
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <Reset_Handler>:
 8000200:	b672      	cpsid	i
 8000202:	4822      	ldr	r0, [pc, #136]	; (800028c <endfiniloop+0x4>)
 8000204:	f380 8809 	msr	PSP, r0
 8000208:	2002      	movs	r0, #2
 800020a:	f380 8814 	msr	CONTROL, r0
 800020e:	f3bf 8f6f 	isb	sy
 8000212:	f00e fde5 	bl	800ede0 <__core_init>
 8000216:	f007 ffa3 	bl	8008160 <__early_init>
 800021a:	481d      	ldr	r0, [pc, #116]	; (8000290 <endfiniloop+0x8>)
 800021c:	491d      	ldr	r1, [pc, #116]	; (8000294 <endfiniloop+0xc>)
 800021e:	4a1e      	ldr	r2, [pc, #120]	; (8000298 <endfiniloop+0x10>)

08000220 <msloop>:
 8000220:	4291      	cmp	r1, r2
 8000222:	bf3c      	itt	cc
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
 8000228:	e7fa      	bcc.n	8000220 <msloop>
 800022a:	491c      	ldr	r1, [pc, #112]	; (800029c <endfiniloop+0x14>)
 800022c:	4a17      	ldr	r2, [pc, #92]	; (800028c <endfiniloop+0x4>)

0800022e <psloop>:
 800022e:	4291      	cmp	r1, r2
 8000230:	bf3c      	itt	cc
 8000232:	f841 0b04 	strcc.w	r0, [r1], #4
 8000236:	e7fa      	bcc.n	800022e <psloop>
 8000238:	4919      	ldr	r1, [pc, #100]	; (80002a0 <endfiniloop+0x18>)
 800023a:	4a1a      	ldr	r2, [pc, #104]	; (80002a4 <endfiniloop+0x1c>)
 800023c:	4b1a      	ldr	r3, [pc, #104]	; (80002a8 <endfiniloop+0x20>)

0800023e <dloop>:
 800023e:	429a      	cmp	r2, r3
 8000240:	bf3e      	ittt	cc
 8000242:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000246:	f842 0b04 	strcc.w	r0, [r2], #4
 800024a:	e7f8      	bcc.n	800023e <dloop>
 800024c:	2000      	movs	r0, #0
 800024e:	4917      	ldr	r1, [pc, #92]	; (80002ac <endfiniloop+0x24>)
 8000250:	4a17      	ldr	r2, [pc, #92]	; (80002b0 <endfiniloop+0x28>)

08000252 <bloop>:
 8000252:	4291      	cmp	r1, r2
 8000254:	bf3c      	itt	cc
 8000256:	f841 0b04 	strcc.w	r0, [r1], #4
 800025a:	e7fa      	bcc.n	8000252 <bloop>
 800025c:	f00e fdd8 	bl	800ee10 <__init_ram_areas>
 8000260:	f00e fdc6 	bl	800edf0 <__late_init>
 8000264:	4c13      	ldr	r4, [pc, #76]	; (80002b4 <endfiniloop+0x2c>)
 8000266:	4d14      	ldr	r5, [pc, #80]	; (80002b8 <endfiniloop+0x30>)

08000268 <initloop>:
 8000268:	42ac      	cmp	r4, r5
 800026a:	da03      	bge.n	8000274 <endinitloop>
 800026c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000270:	4788      	blx	r1
 8000272:	e7f9      	b.n	8000268 <initloop>

08000274 <endinitloop>:
 8000274:	f000 ff84 	bl	8001180 <main>
 8000278:	4c10      	ldr	r4, [pc, #64]	; (80002bc <endfiniloop+0x34>)
 800027a:	4d11      	ldr	r5, [pc, #68]	; (80002c0 <endfiniloop+0x38>)

0800027c <finiloop>:
 800027c:	42ac      	cmp	r4, r5
 800027e:	da03      	bge.n	8000288 <endfiniloop>
 8000280:	f854 1b04 	ldr.w	r1, [r4], #4
 8000284:	4788      	blx	r1
 8000286:	e7f9      	b.n	800027c <finiloop>

08000288 <endfiniloop>:
 8000288:	f00e bdba 	b.w	800ee00 <__default_exit>
 800028c:	20000800 	.word	0x20000800
 8000290:	55555555 	.word	0x55555555
 8000294:	20000000 	.word	0x20000000
 8000298:	20000400 	.word	0x20000400
 800029c:	20000400 	.word	0x20000400
 80002a0:	08012638 	.word	0x08012638
 80002a4:	20000800 	.word	0x20000800
 80002a8:	20000d50 	.word	0x20000d50
 80002ac:	20000d50 	.word	0x20000d50
 80002b0:	20002578 	.word	0x20002578
 80002b4:	08000200 	.word	0x08000200
 80002b8:	08000200 	.word	0x08000200
 80002bc:	08000200 	.word	0x08000200
 80002c0:	08000200 	.word	0x08000200
	...

080002d0 <_port_switch>:
 80002d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002d4:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002d8:	68c3      	ldr	r3, [r0, #12]
 80002da:	469d      	mov	sp, r3
 80002dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002e0 <_port_thread_start>:
 80002e0:	f00f fa1e 	bl	800f720 <_dbg_check_unlock>
 80002e4:	f00d fe54 	bl	800df90 <_stats_stop_measure_crit_thd>
 80002e8:	2300      	movs	r3, #0
 80002ea:	f383 8811 	msr	BASEPRI, r3
 80002ee:	4628      	mov	r0, r5
 80002f0:	47a0      	blx	r4
 80002f2:	2000      	movs	r0, #0
 80002f4:	f00d fbdc 	bl	800dab0 <chThdExit>

080002f8 <_port_switch_from_isr>:
 80002f8:	f00d fe42 	bl	800df80 <_stats_start_measure_crit_thd>
 80002fc:	f00f f9f0 	bl	800f6e0 <_dbg_check_lock>
 8000300:	f010 f80e 	bl	8010320 <chSchDoReschedule>
 8000304:	f00f fa0c 	bl	800f720 <_dbg_check_unlock>
 8000308:	f00d fe42 	bl	800df90 <_stats_stop_measure_crit_thd>

0800030c <_port_exit_from_isr>:
 800030c:	df00      	svc	0
 800030e:	e7fe      	b.n	800030e <_port_exit_from_isr+0x2>

08000310 <memcpy>:
 8000310:	4684      	mov	ip, r0
 8000312:	ea41 0300 	orr.w	r3, r1, r0
 8000316:	f013 0303 	ands.w	r3, r3, #3
 800031a:	d16d      	bne.n	80003f8 <memcpy+0xe8>
 800031c:	3a40      	subs	r2, #64	; 0x40
 800031e:	d341      	bcc.n	80003a4 <memcpy+0x94>
 8000320:	f851 3b04 	ldr.w	r3, [r1], #4
 8000324:	f840 3b04 	str.w	r3, [r0], #4
 8000328:	f851 3b04 	ldr.w	r3, [r1], #4
 800032c:	f840 3b04 	str.w	r3, [r0], #4
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	f851 3b04 	ldr.w	r3, [r1], #4
 800038c:	f840 3b04 	str.w	r3, [r0], #4
 8000390:	f851 3b04 	ldr.w	r3, [r1], #4
 8000394:	f840 3b04 	str.w	r3, [r0], #4
 8000398:	f851 3b04 	ldr.w	r3, [r1], #4
 800039c:	f840 3b04 	str.w	r3, [r0], #4
 80003a0:	3a40      	subs	r2, #64	; 0x40
 80003a2:	d2bd      	bcs.n	8000320 <memcpy+0x10>
 80003a4:	3230      	adds	r2, #48	; 0x30
 80003a6:	d311      	bcc.n	80003cc <memcpy+0xbc>
 80003a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003ac:	f840 3b04 	str.w	r3, [r0], #4
 80003b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b4:	f840 3b04 	str.w	r3, [r0], #4
 80003b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003bc:	f840 3b04 	str.w	r3, [r0], #4
 80003c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c4:	f840 3b04 	str.w	r3, [r0], #4
 80003c8:	3a10      	subs	r2, #16
 80003ca:	d2ed      	bcs.n	80003a8 <memcpy+0x98>
 80003cc:	320c      	adds	r2, #12
 80003ce:	d305      	bcc.n	80003dc <memcpy+0xcc>
 80003d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d4:	f840 3b04 	str.w	r3, [r0], #4
 80003d8:	3a04      	subs	r2, #4
 80003da:	d2f9      	bcs.n	80003d0 <memcpy+0xc0>
 80003dc:	3204      	adds	r2, #4
 80003de:	d008      	beq.n	80003f2 <memcpy+0xe2>
 80003e0:	07d2      	lsls	r2, r2, #31
 80003e2:	bf1c      	itt	ne
 80003e4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003e8:	f800 3b01 	strbne.w	r3, [r0], #1
 80003ec:	d301      	bcc.n	80003f2 <memcpy+0xe2>
 80003ee:	880b      	ldrh	r3, [r1, #0]
 80003f0:	8003      	strh	r3, [r0, #0]
 80003f2:	4660      	mov	r0, ip
 80003f4:	4770      	bx	lr
 80003f6:	bf00      	nop
 80003f8:	2a08      	cmp	r2, #8
 80003fa:	d313      	bcc.n	8000424 <memcpy+0x114>
 80003fc:	078b      	lsls	r3, r1, #30
 80003fe:	d08d      	beq.n	800031c <memcpy+0xc>
 8000400:	f010 0303 	ands.w	r3, r0, #3
 8000404:	d08a      	beq.n	800031c <memcpy+0xc>
 8000406:	f1c3 0304 	rsb	r3, r3, #4
 800040a:	1ad2      	subs	r2, r2, r3
 800040c:	07db      	lsls	r3, r3, #31
 800040e:	bf1c      	itt	ne
 8000410:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000414:	f800 3b01 	strbne.w	r3, [r0], #1
 8000418:	d380      	bcc.n	800031c <memcpy+0xc>
 800041a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800041e:	f820 3b02 	strh.w	r3, [r0], #2
 8000422:	e77b      	b.n	800031c <memcpy+0xc>
 8000424:	3a04      	subs	r2, #4
 8000426:	d3d9      	bcc.n	80003dc <memcpy+0xcc>
 8000428:	3a01      	subs	r2, #1
 800042a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800042e:	f800 3b01 	strb.w	r3, [r0], #1
 8000432:	d2f9      	bcs.n	8000428 <memcpy+0x118>
 8000434:	780b      	ldrb	r3, [r1, #0]
 8000436:	7003      	strb	r3, [r0, #0]
 8000438:	784b      	ldrb	r3, [r1, #1]
 800043a:	7043      	strb	r3, [r0, #1]
 800043c:	788b      	ldrb	r3, [r1, #2]
 800043e:	7083      	strb	r3, [r0, #2]
 8000440:	4660      	mov	r0, ip
 8000442:	4770      	bx	lr
	...

08000450 <strcmp>:
 8000450:	ea40 0c01 	orr.w	ip, r0, r1
 8000454:	f01c 0f07 	tst.w	ip, #7
 8000458:	d123      	bne.n	80004a2 <strcmp+0x52>
 800045a:	f1bd 0d10 	subs.w	sp, sp, #16
 800045e:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8000462:	e9cd 6700 	strd	r6, r7, [sp]
 8000466:	f06f 0600 	mvn.w	r6, #0
 800046a:	f04f 0700 	mov.w	r7, #0
 800046e:	bf00      	nop
 8000470:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 8000474:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 8000478:	42a2      	cmp	r2, r4
 800047a:	fa82 fc46 	uadd8	ip, r2, r6
 800047e:	faa7 fc86 	sel	ip, r7, r6
 8000482:	bf08      	it	eq
 8000484:	f1bc 0f00 	cmpeq.w	ip, #0
 8000488:	f040 80d7 	bne.w	800063a <strcmp+0x1ea>
 800048c:	42ab      	cmp	r3, r5
 800048e:	fa83 fc46 	uadd8	ip, r3, r6
 8000492:	faa7 fc86 	sel	ip, r7, r6
 8000496:	bf08      	it	eq
 8000498:	f1bc 0f00 	cmpeq.w	ip, #0
 800049c:	f040 80ca 	bne.w	8000634 <strcmp+0x1e4>
 80004a0:	e7e6      	b.n	8000470 <strcmp+0x20>
 80004a2:	f010 0c03 	ands.w	ip, r0, #3
 80004a6:	d021      	beq.n	80004ec <strcmp+0x9c>
 80004a8:	f020 0003 	bic.w	r0, r0, #3
 80004ac:	f850 2b04 	ldr.w	r2, [r0], #4
 80004b0:	ea5f 7ccc 	movs.w	ip, ip, lsl #31
 80004b4:	d008      	beq.n	80004c8 <strcmp+0x78>
 80004b6:	d20f      	bcs.n	80004d8 <strcmp+0x88>
 80004b8:	f811 cb01 	ldrb.w	ip, [r1], #1
 80004bc:	fa5f f392 	uxtb.w	r3, r2, ror #8
 80004c0:	ebb3 0c0c 	subs.w	ip, r3, ip
 80004c4:	d110      	bne.n	80004e8 <strcmp+0x98>
 80004c6:	b17b      	cbz	r3, 80004e8 <strcmp+0x98>
 80004c8:	f811 cb01 	ldrb.w	ip, [r1], #1
 80004cc:	fa5f f3a2 	uxtb.w	r3, r2, ror #16
 80004d0:	ebb3 0c0c 	subs.w	ip, r3, ip
 80004d4:	d108      	bne.n	80004e8 <strcmp+0x98>
 80004d6:	b13b      	cbz	r3, 80004e8 <strcmp+0x98>
 80004d8:	f811 cb01 	ldrb.w	ip, [r1], #1
 80004dc:	fa5f f3b2 	uxtb.w	r3, r2, ror #24
 80004e0:	ebb3 0c0c 	subs.w	ip, r3, ip
 80004e4:	d100      	bne.n	80004e8 <strcmp+0x98>
 80004e6:	b90b      	cbnz	r3, 80004ec <strcmp+0x9c>
 80004e8:	4660      	mov	r0, ip
 80004ea:	4770      	bx	lr
 80004ec:	f1bd 0d10 	subs.w	sp, sp, #16
 80004f0:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80004f4:	e9cd 6700 	strd	r6, r7, [sp]
 80004f8:	f06f 0600 	mvn.w	r6, #0
 80004fc:	f04f 0700 	mov.w	r7, #0
 8000500:	f011 0c03 	ands.w	ip, r1, #3
 8000504:	d12d      	bne.n	8000562 <strcmp+0x112>
 8000506:	f010 0f04 	tst.w	r0, #4
 800050a:	d00d      	beq.n	8000528 <strcmp+0xd8>
 800050c:	f850 2b04 	ldr.w	r2, [r0], #4
 8000510:	f851 4b04 	ldr.w	r4, [r1], #4
 8000514:	42a2      	cmp	r2, r4
 8000516:	fa82 fc46 	uadd8	ip, r2, r6
 800051a:	faa7 fc86 	sel	ip, r7, r6
 800051e:	bf08      	it	eq
 8000520:	f1bc 0f00 	cmpeq.w	ip, #0
 8000524:	f040 8089 	bne.w	800063a <strcmp+0x1ea>
 8000528:	f011 0f04 	tst.w	r1, #4
 800052c:	d09f      	beq.n	800046e <strcmp+0x1e>
 800052e:	f851 5b04 	ldr.w	r5, [r1], #4
 8000532:	bf00      	nop
 8000534:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 8000538:	42aa      	cmp	r2, r5
 800053a:	fa82 fc46 	uadd8	ip, r2, r6
 800053e:	faa7 fc86 	sel	ip, r7, r6
 8000542:	bf08      	it	eq
 8000544:	f1bc 0f00 	cmpeq.w	ip, #0
 8000548:	d171      	bne.n	800062e <strcmp+0x1de>
 800054a:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 800054e:	42a3      	cmp	r3, r4
 8000550:	fa83 fc46 	uadd8	ip, r3, r6
 8000554:	faa7 fc86 	sel	ip, r7, r6
 8000558:	bf08      	it	eq
 800055a:	f1bc 0f00 	cmpeq.w	ip, #0
 800055e:	d163      	bne.n	8000628 <strcmp+0x1d8>
 8000560:	e7e8      	b.n	8000534 <strcmp+0xe4>
 8000562:	f021 0103 	bic.w	r1, r1, #3
 8000566:	f1bc 0f02 	cmp.w	ip, #2
 800056a:	d01e      	beq.n	80005aa <strcmp+0x15a>
 800056c:	da3b      	bge.n	80005e6 <strcmp+0x196>
 800056e:	f851 5b04 	ldr.w	r5, [r1], #4
 8000572:	bf00      	nop
 8000574:	f850 3b04 	ldr.w	r3, [r0], #4
 8000578:	ea4f 2515 	mov.w	r5, r5, lsr #8
 800057c:	fa83 fc46 	uadd8	ip, r3, r6
 8000580:	faa7 fc86 	sel	ip, r7, r6
 8000584:	ebb7 2f0c 	cmp.w	r7, ip, lsl #8
 8000588:	ea03 2216 	and.w	r2, r3, r6, lsr #8
 800058c:	bf08      	it	eq
 800058e:	42aa      	cmpeq	r2, r5
 8000590:	d14d      	bne.n	800062e <strcmp+0x1de>
 8000592:	f851 5b04 	ldr.w	r5, [r1], #4
 8000596:	f1bc 0f00 	cmp.w	ip, #0
 800059a:	ea82 0303 	eor.w	r3, r2, r3
 800059e:	ea4f 6205 	mov.w	r2, r5, lsl #24
 80005a2:	bf08      	it	eq
 80005a4:	4293      	cmpeq	r3, r2
 80005a6:	d13c      	bne.n	8000622 <strcmp+0x1d2>
 80005a8:	e7e4      	b.n	8000574 <strcmp+0x124>
 80005aa:	f851 5b04 	ldr.w	r5, [r1], #4
 80005ae:	bf00      	nop
 80005b0:	f850 3b04 	ldr.w	r3, [r0], #4
 80005b4:	ea4f 4515 	mov.w	r5, r5, lsr #16
 80005b8:	fa83 fc46 	uadd8	ip, r3, r6
 80005bc:	faa7 fc86 	sel	ip, r7, r6
 80005c0:	ebb7 4f0c 	cmp.w	r7, ip, lsl #16
 80005c4:	ea03 4216 	and.w	r2, r3, r6, lsr #16
 80005c8:	bf08      	it	eq
 80005ca:	42aa      	cmpeq	r2, r5
 80005cc:	d12f      	bne.n	800062e <strcmp+0x1de>
 80005ce:	f851 5b04 	ldr.w	r5, [r1], #4
 80005d2:	f1bc 0f00 	cmp.w	ip, #0
 80005d6:	ea82 0303 	eor.w	r3, r2, r3
 80005da:	ea4f 4205 	mov.w	r2, r5, lsl #16
 80005de:	bf08      	it	eq
 80005e0:	4293      	cmpeq	r3, r2
 80005e2:	d11e      	bne.n	8000622 <strcmp+0x1d2>
 80005e4:	e7e4      	b.n	80005b0 <strcmp+0x160>
 80005e6:	f851 5b04 	ldr.w	r5, [r1], #4
 80005ea:	bf00      	nop
 80005ec:	f850 3b04 	ldr.w	r3, [r0], #4
 80005f0:	ea4f 6515 	mov.w	r5, r5, lsr #24
 80005f4:	fa83 fc46 	uadd8	ip, r3, r6
 80005f8:	faa7 fc86 	sel	ip, r7, r6
 80005fc:	ebb7 6f0c 	cmp.w	r7, ip, lsl #24
 8000600:	ea03 6216 	and.w	r2, r3, r6, lsr #24
 8000604:	bf08      	it	eq
 8000606:	42aa      	cmpeq	r2, r5
 8000608:	d111      	bne.n	800062e <strcmp+0x1de>
 800060a:	f851 5b04 	ldr.w	r5, [r1], #4
 800060e:	f1bc 0f00 	cmp.w	ip, #0
 8000612:	ea82 0303 	eor.w	r3, r2, r3
 8000616:	ea4f 2205 	mov.w	r2, r5, lsl #8
 800061a:	bf08      	it	eq
 800061c:	4293      	cmpeq	r3, r2
 800061e:	d100      	bne.n	8000622 <strcmp+0x1d2>
 8000620:	e7e4      	b.n	80005ec <strcmp+0x19c>
 8000622:	ba19      	rev	r1, r3
 8000624:	ba12      	rev	r2, r2
 8000626:	e00a      	b.n	800063e <strcmp+0x1ee>
 8000628:	ba19      	rev	r1, r3
 800062a:	ba22      	rev	r2, r4
 800062c:	e007      	b.n	800063e <strcmp+0x1ee>
 800062e:	ba11      	rev	r1, r2
 8000630:	ba2a      	rev	r2, r5
 8000632:	e004      	b.n	800063e <strcmp+0x1ee>
 8000634:	ba19      	rev	r1, r3
 8000636:	ba2a      	rev	r2, r5
 8000638:	e001      	b.n	800063e <strcmp+0x1ee>
 800063a:	ba11      	rev	r1, r2
 800063c:	ba22      	rev	r2, r4
 800063e:	fa9c f08c 	rev.w	r0, ip
 8000642:	e9dd 6700 	ldrd	r6, r7, [sp]
 8000646:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 800064a:	f11d 0d10 	adds.w	sp, sp, #16
 800064e:	b138      	cbz	r0, 8000660 <strcmp+0x210>
 8000650:	fab0 f080 	clz	r0, r0
 8000654:	f1c0 0018 	rsb	r0, r0, #24
 8000658:	fa21 f100 	lsr.w	r1, r1, r0
 800065c:	fa22 f200 	lsr.w	r2, r2, r0
 8000660:	2001      	movs	r0, #1
 8000662:	4291      	cmp	r1, r2
 8000664:	bf98      	it	ls
 8000666:	4180      	sbcls	r0, r0
 8000668:	4770      	bx	lr
 800066a:	bf00      	nop
 800066c:	0000      	movs	r0, r0
	...

08000670 <shellInit.4446>:
/**
 * @brief   Shell manager initialization.
 *
 * @api
 */
void shellInit(void) {
 8000670:	b508      	push	{r3, lr}

  chEvtObjectInit(&shell_terminated);
 8000672:	f641 7054 	movw	r0, #8020	; 0x1f54
 8000676:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800067a:	f001 fef1 	bl	8002460 <chEvtObjectInit.14265>
}
 800067e:	bd08      	pop	{r3, pc}

08000680 <shellExit>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 8000680:	b500      	push	{lr}
 8000682:	b083      	sub	sp, #12
 8000684:	9001      	str	r0, [sp, #4]

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
 8000686:	f001 fe93 	bl	80023b0 <chSysLock.14362>
  chEvtBroadcastI(&shell_terminated);
 800068a:	f641 7054 	movw	r0, #8020	; 0x1f54
 800068e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000692:	f001 feed 	bl	8002470 <chEvtBroadcastI.14368>
  chThdExitS(msg);
 8000696:	9801      	ldr	r0, [sp, #4]
 8000698:	f00d fa1a 	bl	800dad0 <chThdExitS>
}
 800069c:	b003      	add	sp, #12
 800069e:	f85d fb04 	ldr.w	pc, [sp], #4
 80006a2:	bf00      	nop
 80006a4:	f3af 8000 	nop.w
 80006a8:	f3af 8000 	nop.w
 80006ac:	f3af 8000 	nop.w

080006b0 <shellCreate.4438>:
 * @retval NULL         thread creation failed because memory allocation.
 *
 * @api
 */
#if CH_CFG_USE_HEAP && CH_CFG_USE_DYNAMIC
thread_t *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
 80006b0:	b500      	push	{lr}
 80006b2:	b087      	sub	sp, #28
 80006b4:	9005      	str	r0, [sp, #20]
 80006b6:	9104      	str	r1, [sp, #16]
 80006b8:	9203      	str	r2, [sp, #12]

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
 80006ba:	9b05      	ldr	r3, [sp, #20]
 80006bc:	9300      	str	r3, [sp, #0]
 80006be:	2000      	movs	r0, #0
 80006c0:	9904      	ldr	r1, [sp, #16]
 80006c2:	9a03      	ldr	r2, [sp, #12]
 80006c4:	f242 63e1 	movw	r3, #9953	; 0x26e1
 80006c8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80006cc:	f00d fd30 	bl	800e130 <chThdCreateFromHeap>
 80006d0:	4603      	mov	r3, r0
}
 80006d2:	4618      	mov	r0, r3
 80006d4:	b007      	add	sp, #28
 80006d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80006da:	bf00      	nop
 80006dc:	f3af 8000 	nop.w

080006e0 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 80006e0:	b500      	push	{lr}
 80006e2:	b087      	sub	sp, #28
 80006e4:	9003      	str	r0, [sp, #12]
 80006e6:	9102      	str	r1, [sp, #8]
 80006e8:	9201      	str	r2, [sp, #4]
  char *p = line;
 80006ea:	9b02      	ldr	r3, [sp, #8]
 80006ec:	9305      	str	r3, [sp, #20]
 80006ee:	e000      	b.n	80006f2 <shellGetLine+0x12>
        chSequentialStreamPut(chp, c);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, c);
        p--;
      }
      continue;
 80006f0:	bf00      	nop
  char *p = line;

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 80006f2:	9b03      	ldr	r3, [sp, #12]
 80006f4:	681b      	ldr	r3, [r3, #0]
 80006f6:	685b      	ldr	r3, [r3, #4]
 80006f8:	f10d 0213 	add.w	r2, sp, #19
 80006fc:	9803      	ldr	r0, [sp, #12]
 80006fe:	4611      	mov	r1, r2
 8000700:	2201      	movs	r2, #1
 8000702:	4798      	blx	r3
 8000704:	4603      	mov	r3, r0
 8000706:	2b00      	cmp	r3, #0
 8000708:	d101      	bne.n	800070e <shellGetLine+0x2e>
      return true;
 800070a:	2301      	movs	r3, #1
 800070c:	e05e      	b.n	80007cc <shellGetLine+0xec>
    if (c == 4) {
 800070e:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8000712:	2b04      	cmp	r3, #4
 8000714:	d108      	bne.n	8000728 <shellGetLine+0x48>
      chprintf(chp, "^D");
 8000716:	9803      	ldr	r0, [sp, #12]
 8000718:	f640 01f0 	movw	r1, #2288	; 0x8f0
 800071c:	f6c0 0101 	movt	r1, #2049	; 0x801
 8000720:	f000 fae6 	bl	8000cf0 <chprintf>
      return true;
 8000724:	2301      	movs	r3, #1

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
 8000726:	e051      	b.n	80007cc <shellGetLine+0xec>
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
 8000728:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800072c:	2b08      	cmp	r3, #8
 800072e:	d003      	beq.n	8000738 <shellGetLine+0x58>
 8000730:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8000734:	2b7f      	cmp	r3, #127	; 0x7f
 8000736:	d11d      	bne.n	8000774 <shellGetLine+0x94>
      if (p != line) {
 8000738:	9a05      	ldr	r2, [sp, #20]
 800073a:	9b02      	ldr	r3, [sp, #8]
 800073c:	429a      	cmp	r2, r3
 800073e:	d0d7      	beq.n	80006f0 <shellGetLine+0x10>
        chSequentialStreamPut(chp, c);
 8000740:	9b03      	ldr	r3, [sp, #12]
 8000742:	681b      	ldr	r3, [r3, #0]
 8000744:	689b      	ldr	r3, [r3, #8]
 8000746:	f89d 2013 	ldrb.w	r2, [sp, #19]
 800074a:	9803      	ldr	r0, [sp, #12]
 800074c:	4611      	mov	r1, r2
 800074e:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 8000750:	9b03      	ldr	r3, [sp, #12]
 8000752:	681b      	ldr	r3, [r3, #0]
 8000754:	689b      	ldr	r3, [r3, #8]
 8000756:	9803      	ldr	r0, [sp, #12]
 8000758:	2120      	movs	r1, #32
 800075a:	4798      	blx	r3
        chSequentialStreamPut(chp, c);
 800075c:	9b03      	ldr	r3, [sp, #12]
 800075e:	681b      	ldr	r3, [r3, #0]
 8000760:	689b      	ldr	r3, [r3, #8]
 8000762:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8000766:	9803      	ldr	r0, [sp, #12]
 8000768:	4611      	mov	r1, r2
 800076a:	4798      	blx	r3
        p--;
 800076c:	9b05      	ldr	r3, [sp, #20]
 800076e:	3b01      	subs	r3, #1
 8000770:	9305      	str	r3, [sp, #20]
      }
      continue;
 8000772:	e7be      	b.n	80006f2 <shellGetLine+0x12>
    }
    if (c == '\r') {
 8000774:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8000778:	2b0d      	cmp	r3, #13
 800077a:	d10b      	bne.n	8000794 <shellGetLine+0xb4>
      chprintf(chp, "\r\n");
 800077c:	9803      	ldr	r0, [sp, #12]
 800077e:	f640 01f4 	movw	r1, #2292	; 0x8f4
 8000782:	f6c0 0101 	movt	r1, #2049	; 0x801
 8000786:	f000 fab3 	bl	8000cf0 <chprintf>
      *p = 0;
 800078a:	9b05      	ldr	r3, [sp, #20]
 800078c:	2200      	movs	r2, #0
 800078e:	701a      	strb	r2, [r3, #0]
      return false;
 8000790:	2300      	movs	r3, #0

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
 8000792:	e01b      	b.n	80007cc <shellGetLine+0xec>
    if (c == '\r') {
      chprintf(chp, "\r\n");
      *p = 0;
      return false;
    }
    if (c < 0x20)
 8000794:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8000798:	2b1f      	cmp	r3, #31
 800079a:	d801      	bhi.n	80007a0 <shellGetLine+0xc0>
      continue;
 800079c:	bf00      	nop
        chSequentialStreamPut(chp, c);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, c);
        p--;
      }
      continue;
 800079e:	e7a8      	b.n	80006f2 <shellGetLine+0x12>
      *p = 0;
      return false;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 80007a0:	9b01      	ldr	r3, [sp, #4]
 80007a2:	3b01      	subs	r3, #1
 80007a4:	9a02      	ldr	r2, [sp, #8]
 80007a6:	441a      	add	r2, r3
 80007a8:	9b05      	ldr	r3, [sp, #20]
 80007aa:	429a      	cmp	r2, r3
 80007ac:	d9a1      	bls.n	80006f2 <shellGetLine+0x12>
      chSequentialStreamPut(chp, c);
 80007ae:	9b03      	ldr	r3, [sp, #12]
 80007b0:	681b      	ldr	r3, [r3, #0]
 80007b2:	689b      	ldr	r3, [r3, #8]
 80007b4:	f89d 2013 	ldrb.w	r2, [sp, #19]
 80007b8:	9803      	ldr	r0, [sp, #12]
 80007ba:	4611      	mov	r1, r2
 80007bc:	4798      	blx	r3
      *p++ = (char)c;
 80007be:	9b05      	ldr	r3, [sp, #20]
 80007c0:	1c5a      	adds	r2, r3, #1
 80007c2:	9205      	str	r2, [sp, #20]
 80007c4:	f89d 2013 	ldrb.w	r2, [sp, #19]
 80007c8:	701a      	strb	r2, [r3, #0]
        chSequentialStreamPut(chp, c);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, c);
        p--;
      }
      continue;
 80007ca:	e792      	b.n	80006f2 <shellGetLine+0x12>
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 80007cc:	4618      	mov	r0, r3
 80007ce:	b007      	add	sp, #28
 80007d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80007d4:	f3af 8000 	nop.w
 80007d8:	f3af 8000 	nop.w
 80007dc:	f3af 8000 	nop.w

080007e0 <long_to_string_with_divisor.14618.4372>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 80007e0:	b088      	sub	sp, #32
 80007e2:	9003      	str	r0, [sp, #12]
 80007e4:	9102      	str	r1, [sp, #8]
 80007e6:	9201      	str	r2, [sp, #4]
 80007e8:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 80007ea:	9b02      	ldr	r3, [sp, #8]
 80007ec:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 80007ee:	9b00      	ldr	r3, [sp, #0]
 80007f0:	2b00      	cmp	r3, #0
 80007f2:	d102      	bne.n	80007fa <long_to_string_with_divisor.14618.4372+0x1a>
    ll = num;
 80007f4:	9b02      	ldr	r3, [sp, #8]
 80007f6:	9304      	str	r3, [sp, #16]
 80007f8:	e001      	b.n	80007fe <long_to_string_with_divisor.14618.4372+0x1e>
  } else {
    ll = divisor;
 80007fa:	9b00      	ldr	r3, [sp, #0]
 80007fc:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 80007fe:	9b03      	ldr	r3, [sp, #12]
 8000800:	330b      	adds	r3, #11
 8000802:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 8000804:	9b05      	ldr	r3, [sp, #20]
 8000806:	9a01      	ldr	r2, [sp, #4]
 8000808:	fbb3 f2f2 	udiv	r2, r3, r2
 800080c:	9901      	ldr	r1, [sp, #4]
 800080e:	fb01 f202 	mul.w	r2, r1, r2
 8000812:	1a9b      	subs	r3, r3, r2
 8000814:	9307      	str	r3, [sp, #28]
    i += '0';
 8000816:	9b07      	ldr	r3, [sp, #28]
 8000818:	3330      	adds	r3, #48	; 0x30
 800081a:	9307      	str	r3, [sp, #28]
    if (i > '9')
 800081c:	9b07      	ldr	r3, [sp, #28]
 800081e:	2b39      	cmp	r3, #57	; 0x39
 8000820:	dd02      	ble.n	8000828 <long_to_string_with_divisor.14618.4372+0x48>
      i += 'A' - '0' - 10;
 8000822:	9b07      	ldr	r3, [sp, #28]
 8000824:	3307      	adds	r3, #7
 8000826:	9307      	str	r3, [sp, #28]
    *--q = i;
 8000828:	9b06      	ldr	r3, [sp, #24]
 800082a:	3b01      	subs	r3, #1
 800082c:	9306      	str	r3, [sp, #24]
 800082e:	9b07      	ldr	r3, [sp, #28]
 8000830:	b2da      	uxtb	r2, r3
 8000832:	9b06      	ldr	r3, [sp, #24]
 8000834:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8000836:	9a05      	ldr	r2, [sp, #20]
 8000838:	9b01      	ldr	r3, [sp, #4]
 800083a:	fbb2 f3f3 	udiv	r3, r2, r3
 800083e:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8000840:	9a04      	ldr	r2, [sp, #16]
 8000842:	9b01      	ldr	r3, [sp, #4]
 8000844:	fbb2 f3f3 	udiv	r3, r2, r3
 8000848:	9304      	str	r3, [sp, #16]
 800084a:	9b04      	ldr	r3, [sp, #16]
 800084c:	2b00      	cmp	r3, #0
 800084e:	d1d9      	bne.n	8000804 <long_to_string_with_divisor.14618.4372+0x24>

  i = (int)(p + MAX_FILLER - q);
 8000850:	9b03      	ldr	r3, [sp, #12]
 8000852:	330b      	adds	r3, #11
 8000854:	461a      	mov	r2, r3
 8000856:	9b06      	ldr	r3, [sp, #24]
 8000858:	1ad3      	subs	r3, r2, r3
 800085a:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 800085c:	9b03      	ldr	r3, [sp, #12]
 800085e:	1c5a      	adds	r2, r3, #1
 8000860:	9203      	str	r2, [sp, #12]
 8000862:	9a06      	ldr	r2, [sp, #24]
 8000864:	1c51      	adds	r1, r2, #1
 8000866:	9106      	str	r1, [sp, #24]
 8000868:	7812      	ldrb	r2, [r2, #0]
 800086a:	701a      	strb	r2, [r3, #0]
  while (--i);
 800086c:	9b07      	ldr	r3, [sp, #28]
 800086e:	3b01      	subs	r3, #1
 8000870:	9307      	str	r3, [sp, #28]
 8000872:	9b07      	ldr	r3, [sp, #28]
 8000874:	2b00      	cmp	r3, #0
 8000876:	d1f1      	bne.n	800085c <long_to_string_with_divisor.14618.4372+0x7c>

  return p;
 8000878:	9b03      	ldr	r3, [sp, #12]
}
 800087a:	4618      	mov	r0, r3
 800087c:	b008      	add	sp, #32
 800087e:	4770      	bx	lr

08000880 <ch_ltoa.14626.4367>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8000880:	b500      	push	{lr}
 8000882:	b085      	sub	sp, #20
 8000884:	9003      	str	r0, [sp, #12]
 8000886:	9102      	str	r1, [sp, #8]
 8000888:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 800088a:	9803      	ldr	r0, [sp, #12]
 800088c:	9902      	ldr	r1, [sp, #8]
 800088e:	9a01      	ldr	r2, [sp, #4]
 8000890:	2300      	movs	r3, #0
 8000892:	f7ff ffa5 	bl	80007e0 <long_to_string_with_divisor.14618.4372>
 8000896:	4603      	mov	r3, r0
}
 8000898:	4618      	mov	r0, r3
 800089a:	b005      	add	sp, #20
 800089c:	f85d fb04 	ldr.w	pc, [sp], #4

080008a0 <chvprintf.4359>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 80008a0:	b500      	push	{lr}
 80008a2:	b091      	sub	sp, #68	; 0x44
 80008a4:	9003      	str	r0, [sp, #12]
 80008a6:	9102      	str	r1, [sp, #8]
 80008a8:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 80008aa:	2300      	movs	r3, #0
 80008ac:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 80008ae:	9b02      	ldr	r3, [sp, #8]
 80008b0:	1c5a      	adds	r2, r3, #1
 80008b2:	9202      	str	r2, [sp, #8]
 80008b4:	781b      	ldrb	r3, [r3, #0]
 80008b6:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0)
 80008ba:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80008be:	2b00      	cmp	r3, #0
 80008c0:	d101      	bne.n	80008c6 <chvprintf.4359+0x26>
      return n;
 80008c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80008c4:	e210      	b.n	8000ce8 <chvprintf.4359+0x448>
    if (c != '%') {
 80008c6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80008ca:	2b25      	cmp	r3, #37	; 0x25
 80008cc:	d00b      	beq.n	80008e6 <chvprintf.4359+0x46>
      streamPut(chp, (uint8_t)c);
 80008ce:	9b03      	ldr	r3, [sp, #12]
 80008d0:	681b      	ldr	r3, [r3, #0]
 80008d2:	689b      	ldr	r3, [r3, #8]
 80008d4:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 80008d8:	9803      	ldr	r0, [sp, #12]
 80008da:	4611      	mov	r1, r2
 80008dc:	4798      	blx	r3
      n++;
 80008de:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80008e0:	3301      	adds	r3, #1
 80008e2:	9309      	str	r3, [sp, #36]	; 0x24
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80008e4:	e7e3      	b.n	80008ae <chvprintf.4359+0xe>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 80008e6:	ab04      	add	r3, sp, #16
 80008e8:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 80008ea:	ab04      	add	r3, sp, #16
 80008ec:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 80008ee:	2300      	movs	r3, #0
 80008f0:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 80008f4:	9b02      	ldr	r3, [sp, #8]
 80008f6:	781b      	ldrb	r3, [r3, #0]
 80008f8:	2b2d      	cmp	r3, #45	; 0x2d
 80008fa:	d105      	bne.n	8000908 <chvprintf.4359+0x68>
      fmt++;
 80008fc:	9b02      	ldr	r3, [sp, #8]
 80008fe:	3301      	adds	r3, #1
 8000900:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 8000902:	2301      	movs	r3, #1
 8000904:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 8000908:	2320      	movs	r3, #32
 800090a:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 800090e:	9b02      	ldr	r3, [sp, #8]
 8000910:	781b      	ldrb	r3, [r3, #0]
 8000912:	2b30      	cmp	r3, #48	; 0x30
 8000914:	d105      	bne.n	8000922 <chvprintf.4359+0x82>
      fmt++;
 8000916:	9b02      	ldr	r3, [sp, #8]
 8000918:	3301      	adds	r3, #1
 800091a:	9302      	str	r3, [sp, #8]
      filler = '0';
 800091c:	2330      	movs	r3, #48	; 0x30
 800091e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 8000922:	2300      	movs	r3, #0
 8000924:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 8000926:	9b02      	ldr	r3, [sp, #8]
 8000928:	1c5a      	adds	r2, r3, #1
 800092a:	9202      	str	r2, [sp, #8]
 800092c:	781b      	ldrb	r3, [r3, #0]
 800092e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
 8000932:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000936:	2b2f      	cmp	r3, #47	; 0x2f
 8000938:	d909      	bls.n	800094e <chvprintf.4359+0xae>
 800093a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800093e:	2b39      	cmp	r3, #57	; 0x39
 8000940:	d805      	bhi.n	800094e <chvprintf.4359+0xae>
        c -= '0';
 8000942:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000946:	3b30      	subs	r3, #48	; 0x30
 8000948:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800094c:	e009      	b.n	8000962 <chvprintf.4359+0xc2>
      else if (c == '*')
 800094e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000952:	2b2a      	cmp	r3, #42	; 0x2a
 8000954:	d110      	bne.n	8000978 <chvprintf.4359+0xd8>
        c = va_arg(ap, int);
 8000956:	9b01      	ldr	r3, [sp, #4]
 8000958:	1d1a      	adds	r2, r3, #4
 800095a:	9201      	str	r2, [sp, #4]
 800095c:	681b      	ldr	r3, [r3, #0]
 800095e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      else
        break;
      width = width * 10 + c;
 8000962:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8000964:	4613      	mov	r3, r2
 8000966:	009b      	lsls	r3, r3, #2
 8000968:	4413      	add	r3, r2
 800096a:	005b      	lsls	r3, r3, #1
 800096c:	461a      	mov	r2, r3
 800096e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000972:	4413      	add	r3, r2
 8000974:	930a      	str	r3, [sp, #40]	; 0x28
 8000976:	e7d6      	b.n	8000926 <chvprintf.4359+0x86>
    }
    precision = 0;
 8000978:	2300      	movs	r3, #0
 800097a:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 800097c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000980:	2b2e      	cmp	r3, #46	; 0x2e
 8000982:	d129      	bne.n	80009d8 <chvprintf.4359+0x138>
      while (TRUE) {
        c = *fmt++;
 8000984:	9b02      	ldr	r3, [sp, #8]
 8000986:	1c5a      	adds	r2, r3, #1
 8000988:	9202      	str	r2, [sp, #8]
 800098a:	781b      	ldrb	r3, [r3, #0]
 800098c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
 8000990:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000994:	2b2f      	cmp	r3, #47	; 0x2f
 8000996:	d909      	bls.n	80009ac <chvprintf.4359+0x10c>
 8000998:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800099c:	2b39      	cmp	r3, #57	; 0x39
 800099e:	d805      	bhi.n	80009ac <chvprintf.4359+0x10c>
          c -= '0';
 80009a0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80009a4:	3b30      	subs	r3, #48	; 0x30
 80009a6:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80009aa:	e009      	b.n	80009c0 <chvprintf.4359+0x120>
        else if (c == '*')
 80009ac:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80009b0:	2b2a      	cmp	r3, #42	; 0x2a
 80009b2:	d111      	bne.n	80009d8 <chvprintf.4359+0x138>
          c = va_arg(ap, int);
 80009b4:	9b01      	ldr	r3, [sp, #4]
 80009b6:	1d1a      	adds	r2, r3, #4
 80009b8:	9201      	str	r2, [sp, #4]
 80009ba:	681b      	ldr	r3, [r3, #0]
 80009bc:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        else
          break;
        precision *= 10;
 80009c0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80009c2:	4613      	mov	r3, r2
 80009c4:	009b      	lsls	r3, r3, #2
 80009c6:	4413      	add	r3, r2
 80009c8:	005b      	lsls	r3, r3, #1
 80009ca:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 80009cc:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80009d0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80009d2:	4413      	add	r3, r2
 80009d4:	930b      	str	r3, [sp, #44]	; 0x2c
 80009d6:	e7d5      	b.n	8000984 <chvprintf.4359+0xe4>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80009d8:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80009dc:	2b6c      	cmp	r3, #108	; 0x6c
 80009de:	d003      	beq.n	80009e8 <chvprintf.4359+0x148>
 80009e0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80009e4:	2b4c      	cmp	r3, #76	; 0x4c
 80009e6:	d10d      	bne.n	8000a04 <chvprintf.4359+0x164>
      is_long = TRUE;
 80009e8:	2301      	movs	r3, #1
 80009ea:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 80009ee:	9b02      	ldr	r3, [sp, #8]
 80009f0:	781b      	ldrb	r3, [r3, #0]
 80009f2:	2b00      	cmp	r3, #0
 80009f4:	d01a      	beq.n	8000a2c <chvprintf.4359+0x18c>
        c = *fmt++;
 80009f6:	9b02      	ldr	r3, [sp, #8]
 80009f8:	1c5a      	adds	r2, r3, #1
 80009fa:	9202      	str	r2, [sp, #8]
 80009fc:	781b      	ldrb	r3, [r3, #0]
 80009fe:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8000a02:	e014      	b.n	8000a2e <chvprintf.4359+0x18e>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 8000a04:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000a08:	2b40      	cmp	r3, #64	; 0x40
 8000a0a:	d905      	bls.n	8000a18 <chvprintf.4359+0x178>
 8000a0c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000a10:	2b5a      	cmp	r3, #90	; 0x5a
 8000a12:	d801      	bhi.n	8000a18 <chvprintf.4359+0x178>
 8000a14:	2301      	movs	r3, #1
 8000a16:	e000      	b.n	8000a1a <chvprintf.4359+0x17a>
 8000a18:	2300      	movs	r3, #0
 8000a1a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 8000a1e:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8000a22:	f003 0301 	and.w	r3, r3, #1
 8000a26:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 8000a2a:	e000      	b.n	8000a2e <chvprintf.4359+0x18e>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 8000a2c:	bf00      	nop
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8000a2e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000a32:	3b44      	subs	r3, #68	; 0x44
 8000a34:	2b34      	cmp	r3, #52	; 0x34
 8000a36:	f200 80e5 	bhi.w	8000c04 <chvprintf.4359+0x364>
 8000a3a:	a201      	add	r2, pc, #4	; (adr r2, 8000a40 <chvprintf.4359+0x1a0>)
 8000a3c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000a40:	08000b7d 	.word	0x08000b7d
 8000a44:	08000c05 	.word	0x08000c05
 8000a48:	08000c05 	.word	0x08000c05
 8000a4c:	08000c05 	.word	0x08000c05
 8000a50:	08000c05 	.word	0x08000c05
 8000a54:	08000b7d 	.word	0x08000b7d
 8000a58:	08000c05 	.word	0x08000c05
 8000a5c:	08000c05 	.word	0x08000c05
 8000a60:	08000c05 	.word	0x08000c05
 8000a64:	08000c05 	.word	0x08000c05
 8000a68:	08000c05 	.word	0x08000c05
 8000a6c:	08000bcf 	.word	0x08000bcf
 8000a70:	08000c05 	.word	0x08000c05
 8000a74:	08000c05 	.word	0x08000c05
 8000a78:	08000c05 	.word	0x08000c05
 8000a7c:	08000c05 	.word	0x08000c05
 8000a80:	08000c05 	.word	0x08000c05
 8000a84:	08000bc7 	.word	0x08000bc7
 8000a88:	08000c05 	.word	0x08000c05
 8000a8c:	08000c05 	.word	0x08000c05
 8000a90:	08000bbf 	.word	0x08000bbf
 8000a94:	08000c05 	.word	0x08000c05
 8000a98:	08000c05 	.word	0x08000c05
 8000a9c:	08000c05 	.word	0x08000c05
 8000aa0:	08000c05 	.word	0x08000c05
 8000aa4:	08000c05 	.word	0x08000c05
 8000aa8:	08000c05 	.word	0x08000c05
 8000aac:	08000c05 	.word	0x08000c05
 8000ab0:	08000c05 	.word	0x08000c05
 8000ab4:	08000c05 	.word	0x08000c05
 8000ab8:	08000c05 	.word	0x08000c05
 8000abc:	08000b15 	.word	0x08000b15
 8000ac0:	08000b7d 	.word	0x08000b7d
 8000ac4:	08000c05 	.word	0x08000c05
 8000ac8:	08000c05 	.word	0x08000c05
 8000acc:	08000c05 	.word	0x08000c05
 8000ad0:	08000c05 	.word	0x08000c05
 8000ad4:	08000b7d 	.word	0x08000b7d
 8000ad8:	08000c05 	.word	0x08000c05
 8000adc:	08000c05 	.word	0x08000c05
 8000ae0:	08000c05 	.word	0x08000c05
 8000ae4:	08000c05 	.word	0x08000c05
 8000ae8:	08000c05 	.word	0x08000c05
 8000aec:	08000bcf 	.word	0x08000bcf
 8000af0:	08000c05 	.word	0x08000c05
 8000af4:	08000c05 	.word	0x08000c05
 8000af8:	08000c05 	.word	0x08000c05
 8000afc:	08000b2f 	.word	0x08000b2f
 8000b00:	08000c05 	.word	0x08000c05
 8000b04:	08000bc7 	.word	0x08000bc7
 8000b08:	08000c05 	.word	0x08000c05
 8000b0c:	08000c05 	.word	0x08000c05
 8000b10:	08000bbf 	.word	0x08000bbf
    case 'c':
      filler = ' ';
 8000b14:	2320      	movs	r3, #32
 8000b16:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 8000b1a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000b1c:	1c5a      	adds	r2, r3, #1
 8000b1e:	920f      	str	r2, [sp, #60]	; 0x3c
 8000b20:	9a01      	ldr	r2, [sp, #4]
 8000b22:	1d11      	adds	r1, r2, #4
 8000b24:	9101      	str	r1, [sp, #4]
 8000b26:	6812      	ldr	r2, [r2, #0]
 8000b28:	b2d2      	uxtb	r2, r2
 8000b2a:	701a      	strb	r2, [r3, #0]
 8000b2c:	e070      	b.n	8000c10 <chvprintf.4359+0x370>
      break;
    case 's':
      filler = ' ';
 8000b2e:	2320      	movs	r3, #32
 8000b30:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 8000b34:	9b01      	ldr	r3, [sp, #4]
 8000b36:	1d1a      	adds	r2, r3, #4
 8000b38:	9201      	str	r2, [sp, #4]
 8000b3a:	681b      	ldr	r3, [r3, #0]
 8000b3c:	930e      	str	r3, [sp, #56]	; 0x38
 8000b3e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000b40:	2b00      	cmp	r3, #0
 8000b42:	d104      	bne.n	8000b4e <chvprintf.4359+0x2ae>
        s = "(null)";
 8000b44:	f640 03f8 	movw	r3, #2296	; 0x8f8
 8000b48:	f6c0 0301 	movt	r3, #2049	; 0x801
 8000b4c:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 8000b4e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8000b50:	2b00      	cmp	r3, #0
 8000b52:	d102      	bne.n	8000b5a <chvprintf.4359+0x2ba>
        precision = 32767;
 8000b54:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8000b58:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 8000b5a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000b5c:	930f      	str	r3, [sp, #60]	; 0x3c
 8000b5e:	e002      	b.n	8000b66 <chvprintf.4359+0x2c6>
 8000b60:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000b62:	3301      	adds	r3, #1
 8000b64:	930f      	str	r3, [sp, #60]	; 0x3c
 8000b66:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000b68:	781b      	ldrb	r3, [r3, #0]
 8000b6a:	2b00      	cmp	r3, #0
 8000b6c:	d050      	beq.n	8000c10 <chvprintf.4359+0x370>
 8000b6e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8000b70:	3b01      	subs	r3, #1
 8000b72:	930b      	str	r3, [sp, #44]	; 0x2c
 8000b74:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8000b76:	2b00      	cmp	r3, #0
 8000b78:	daf2      	bge.n	8000b60 <chvprintf.4359+0x2c0>
 8000b7a:	e049      	b.n	8000c10 <chvprintf.4359+0x370>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 8000b7c:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8000b80:	2b00      	cmp	r3, #0
 8000b82:	d005      	beq.n	8000b90 <chvprintf.4359+0x2f0>
        l = va_arg(ap, long);
 8000b84:	9b01      	ldr	r3, [sp, #4]
 8000b86:	1d1a      	adds	r2, r3, #4
 8000b88:	9201      	str	r2, [sp, #4]
 8000b8a:	681b      	ldr	r3, [r3, #0]
 8000b8c:	9307      	str	r3, [sp, #28]
 8000b8e:	e004      	b.n	8000b9a <chvprintf.4359+0x2fa>
      else
        l = va_arg(ap, int);
 8000b90:	9b01      	ldr	r3, [sp, #4]
 8000b92:	1d1a      	adds	r2, r3, #4
 8000b94:	9201      	str	r2, [sp, #4]
 8000b96:	681b      	ldr	r3, [r3, #0]
 8000b98:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 8000b9a:	9b07      	ldr	r3, [sp, #28]
 8000b9c:	2b00      	cmp	r3, #0
 8000b9e:	da07      	bge.n	8000bb0 <chvprintf.4359+0x310>
        *p++ = '-';
 8000ba0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000ba2:	1c5a      	adds	r2, r3, #1
 8000ba4:	920f      	str	r2, [sp, #60]	; 0x3c
 8000ba6:	222d      	movs	r2, #45	; 0x2d
 8000ba8:	701a      	strb	r2, [r3, #0]
        l = -l;
 8000baa:	9b07      	ldr	r3, [sp, #28]
 8000bac:	425b      	negs	r3, r3
 8000bae:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 8000bb0:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8000bb2:	9907      	ldr	r1, [sp, #28]
 8000bb4:	220a      	movs	r2, #10
 8000bb6:	f7ff fe63 	bl	8000880 <ch_ltoa.14626.4367>
 8000bba:	900f      	str	r0, [sp, #60]	; 0x3c
 8000bbc:	e028      	b.n	8000c10 <chvprintf.4359+0x370>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8000bbe:	2310      	movs	r3, #16
 8000bc0:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8000bc4:	e006      	b.n	8000bd4 <chvprintf.4359+0x334>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 8000bc6:	230a      	movs	r3, #10
 8000bc8:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8000bcc:	e002      	b.n	8000bd4 <chvprintf.4359+0x334>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 8000bce:	2308      	movs	r3, #8
 8000bd0:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 8000bd4:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8000bd8:	2b00      	cmp	r3, #0
 8000bda:	d005      	beq.n	8000be8 <chvprintf.4359+0x348>
        l = va_arg(ap, unsigned long);
 8000bdc:	9b01      	ldr	r3, [sp, #4]
 8000bde:	1d1a      	adds	r2, r3, #4
 8000be0:	9201      	str	r2, [sp, #4]
 8000be2:	681b      	ldr	r3, [r3, #0]
 8000be4:	9307      	str	r3, [sp, #28]
 8000be6:	e004      	b.n	8000bf2 <chvprintf.4359+0x352>
      else
        l = va_arg(ap, unsigned int);
 8000be8:	9b01      	ldr	r3, [sp, #4]
 8000bea:	1d1a      	adds	r2, r3, #4
 8000bec:	9201      	str	r2, [sp, #4]
 8000bee:	681b      	ldr	r3, [r3, #0]
 8000bf0:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 8000bf2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000bf6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8000bf8:	9907      	ldr	r1, [sp, #28]
 8000bfa:	461a      	mov	r2, r3
 8000bfc:	f7ff fe40 	bl	8000880 <ch_ltoa.14626.4367>
 8000c00:	900f      	str	r0, [sp, #60]	; 0x3c
 8000c02:	e005      	b.n	8000c10 <chvprintf.4359+0x370>
      break;
    default:
      *p++ = c;
 8000c04:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000c06:	1c5a      	adds	r2, r3, #1
 8000c08:	920f      	str	r2, [sp, #60]	; 0x3c
 8000c0a:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8000c0e:	701a      	strb	r2, [r3, #0]
      break;
    }
    i = (int)(p - s);
 8000c10:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8000c12:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000c14:	1ad3      	subs	r3, r2, r3
 8000c16:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 8000c18:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8000c1a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000c1c:	1ad3      	subs	r3, r2, r3
 8000c1e:	930a      	str	r3, [sp, #40]	; 0x28
 8000c20:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000c22:	2b00      	cmp	r3, #0
 8000c24:	da01      	bge.n	8000c2a <chvprintf.4359+0x38a>
      width = 0;
 8000c26:	2300      	movs	r3, #0
 8000c28:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 8000c2a:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 8000c2e:	f083 0301 	eor.w	r3, r3, #1
 8000c32:	b2db      	uxtb	r3, r3
 8000c34:	2b00      	cmp	r3, #0
 8000c36:	d002      	beq.n	8000c3e <chvprintf.4359+0x39e>
      width = -width;
 8000c38:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000c3a:	425b      	negs	r3, r3
 8000c3c:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 8000c3e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000c40:	2b00      	cmp	r3, #0
 8000c42:	da37      	bge.n	8000cb4 <chvprintf.4359+0x414>
      if (*s == '-' && filler == '0') {
 8000c44:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000c46:	781b      	ldrb	r3, [r3, #0]
 8000c48:	2b2d      	cmp	r3, #45	; 0x2d
 8000c4a:	d113      	bne.n	8000c74 <chvprintf.4359+0x3d4>
 8000c4c:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 8000c50:	2b30      	cmp	r3, #48	; 0x30
 8000c52:	d10f      	bne.n	8000c74 <chvprintf.4359+0x3d4>
        streamPut(chp, (uint8_t)*s++);
 8000c54:	9b03      	ldr	r3, [sp, #12]
 8000c56:	681b      	ldr	r3, [r3, #0]
 8000c58:	689a      	ldr	r2, [r3, #8]
 8000c5a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000c5c:	1c59      	adds	r1, r3, #1
 8000c5e:	910e      	str	r1, [sp, #56]	; 0x38
 8000c60:	781b      	ldrb	r3, [r3, #0]
 8000c62:	9803      	ldr	r0, [sp, #12]
 8000c64:	4619      	mov	r1, r3
 8000c66:	4790      	blx	r2
        n++;
 8000c68:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000c6a:	3301      	adds	r3, #1
 8000c6c:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 8000c6e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000c70:	3b01      	subs	r3, #1
 8000c72:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8000c74:	9b03      	ldr	r3, [sp, #12]
 8000c76:	681b      	ldr	r3, [r3, #0]
 8000c78:	689b      	ldr	r3, [r3, #8]
 8000c7a:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 8000c7e:	9803      	ldr	r0, [sp, #12]
 8000c80:	4611      	mov	r1, r2
 8000c82:	4798      	blx	r3
        n++;
 8000c84:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000c86:	3301      	adds	r3, #1
 8000c88:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 8000c8a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000c8c:	3301      	adds	r3, #1
 8000c8e:	930a      	str	r3, [sp, #40]	; 0x28
 8000c90:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000c92:	2b00      	cmp	r3, #0
 8000c94:	d1ee      	bne.n	8000c74 <chvprintf.4359+0x3d4>
 8000c96:	e00d      	b.n	8000cb4 <chvprintf.4359+0x414>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8000c98:	9b03      	ldr	r3, [sp, #12]
 8000c9a:	681b      	ldr	r3, [r3, #0]
 8000c9c:	689a      	ldr	r2, [r3, #8]
 8000c9e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000ca0:	1c59      	adds	r1, r3, #1
 8000ca2:	910e      	str	r1, [sp, #56]	; 0x38
 8000ca4:	781b      	ldrb	r3, [r3, #0]
 8000ca6:	9803      	ldr	r0, [sp, #12]
 8000ca8:	4619      	mov	r1, r3
 8000caa:	4790      	blx	r2
      n++;
 8000cac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000cae:	3301      	adds	r3, #1
 8000cb0:	9309      	str	r3, [sp, #36]	; 0x24
 8000cb2:	e000      	b.n	8000cb6 <chvprintf.4359+0x416>
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
 8000cb4:	bf00      	nop
    }
    while (--i >= 0) {
 8000cb6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000cb8:	3b01      	subs	r3, #1
 8000cba:	930c      	str	r3, [sp, #48]	; 0x30
 8000cbc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000cbe:	2b00      	cmp	r3, #0
 8000cc0:	daea      	bge.n	8000c98 <chvprintf.4359+0x3f8>
 8000cc2:	e00d      	b.n	8000ce0 <chvprintf.4359+0x440>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 8000cc4:	9b03      	ldr	r3, [sp, #12]
 8000cc6:	681b      	ldr	r3, [r3, #0]
 8000cc8:	689b      	ldr	r3, [r3, #8]
 8000cca:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 8000cce:	9803      	ldr	r0, [sp, #12]
 8000cd0:	4611      	mov	r1, r2
 8000cd2:	4798      	blx	r3
      n++;
 8000cd4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000cd6:	3301      	adds	r3, #1
 8000cd8:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 8000cda:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000cdc:	3b01      	subs	r3, #1
 8000cde:	930a      	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8000ce0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000ce2:	2b00      	cmp	r3, #0
 8000ce4:	d1ee      	bne.n	8000cc4 <chvprintf.4359+0x424>
 8000ce6:	e5e2      	b.n	80008ae <chvprintf.4359+0xe>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8000ce8:	4618      	mov	r0, r3
 8000cea:	b011      	add	sp, #68	; 0x44
 8000cec:	f85d fb04 	ldr.w	pc, [sp], #4

08000cf0 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000cf0:	b40e      	push	{r1, r2, r3}
 8000cf2:	b500      	push	{lr}
 8000cf4:	b084      	sub	sp, #16
 8000cf6:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8000cf8:	ab06      	add	r3, sp, #24
 8000cfa:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8000cfc:	9801      	ldr	r0, [sp, #4]
 8000cfe:	9905      	ldr	r1, [sp, #20]
 8000d00:	9a02      	ldr	r2, [sp, #8]
 8000d02:	f7ff fdcd 	bl	80008a0 <chvprintf.4359>
 8000d06:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 8000d08:	9b03      	ldr	r3, [sp, #12]
}
 8000d0a:	4618      	mov	r0, r3
 8000d0c:	b004      	add	sp, #16
 8000d0e:	f85d eb04 	ldr.w	lr, [sp], #4
 8000d12:	b003      	add	sp, #12
 8000d14:	4770      	bx	lr
 8000d16:	bf00      	nop
 8000d18:	f3af 8000 	nop.w
 8000d1c:	f3af 8000 	nop.w

08000d20 <port_lock.14689.4347>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000d20:	b082      	sub	sp, #8
 8000d22:	2320      	movs	r3, #32
 8000d24:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000d26:	9b01      	ldr	r3, [sp, #4]
 8000d28:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000d2c:	b002      	add	sp, #8
 8000d2e:	4770      	bx	lr

08000d30 <port_unlock.14692.4345>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000d30:	b082      	sub	sp, #8
 8000d32:	2300      	movs	r3, #0
 8000d34:	9301      	str	r3, [sp, #4]
 8000d36:	9b01      	ldr	r3, [sp, #4]
 8000d38:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000d3c:	b002      	add	sp, #8
 8000d3e:	4770      	bx	lr

08000d40 <port_lock_from_isr.14694.4343>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000d40:	b508      	push	{r3, lr}

  port_lock();
 8000d42:	f7ff ffed 	bl	8000d20 <port_lock.14689.4347>
}
 8000d46:	bd08      	pop	{r3, pc}
 8000d48:	f3af 8000 	nop.w
 8000d4c:	f3af 8000 	nop.w

08000d50 <port_unlock_from_isr.14696.4341>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000d50:	b508      	push	{r3, lr}

  port_unlock();
 8000d52:	f7ff ffed 	bl	8000d30 <port_unlock.14692.4345>
}
 8000d56:	bd08      	pop	{r3, pc}
 8000d58:	f3af 8000 	nop.w
 8000d5c:	f3af 8000 	nop.w

08000d60 <chSysLockFromISR.14958.4339>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000d60:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000d62:	f7ff ffed 	bl	8000d40 <port_lock_from_isr.14694.4343>
  _stats_start_measure_crit_isr();
 8000d66:	f00d f91b 	bl	800dfa0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8000d6a:	f00e fcf9 	bl	800f760 <_dbg_check_lock_from_isr>
}
 8000d6e:	bd08      	pop	{r3, pc}

08000d70 <chSysUnlockFromISR.14962.4337>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000d70:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8000d72:	f00e fd15 	bl	800f7a0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8000d76:	f00d f91b 	bl	800dfb0 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8000d7a:	f7ff ffe9 	bl	8000d50 <port_unlock_from_isr.14696.4341>
}
 8000d7e:	bd08      	pop	{r3, pc}

08000d80 <osalSysLockFromISR.14960.4335>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8000d80:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8000d82:	f7ff ffed 	bl	8000d60 <chSysLockFromISR.14958.4339>
}
 8000d86:	bd08      	pop	{r3, pc}
 8000d88:	f3af 8000 	nop.w
 8000d8c:	f3af 8000 	nop.w

08000d90 <osalSysUnlockFromISR.14968.4333>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8000d90:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8000d92:	f7ff ffed 	bl	8000d70 <chSysUnlockFromISR.14962.4337>
}
 8000d96:	bd08      	pop	{r3, pc}
 8000d98:	f3af 8000 	nop.w
 8000d9c:	f3af 8000 	nop.w

08000da0 <get_descriptor.14698>:
 * handled here.
 */
static const USBDescriptor *get_descriptor(USBDriver *usbp,
                                           uint8_t dtype,
                                           uint8_t dindex,
                                           uint16_t lang) {
 8000da0:	b082      	sub	sp, #8
 8000da2:	9001      	str	r0, [sp, #4]
 8000da4:	f88d 1003 	strb.w	r1, [sp, #3]
 8000da8:	f88d 2002 	strb.w	r2, [sp, #2]
 8000dac:	f8ad 3000 	strh.w	r3, [sp]

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8000db0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000db4:	2b02      	cmp	r3, #2
 8000db6:	d008      	beq.n	8000dca <get_descriptor.14698+0x2a>
 8000db8:	2b03      	cmp	r3, #3
 8000dba:	d00b      	beq.n	8000dd4 <get_descriptor.14698+0x34>
 8000dbc:	2b01      	cmp	r3, #1
 8000dbe:	d116      	bne.n	8000dee <get_descriptor.14698+0x4e>
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
 8000dc0:	f242 4360 	movw	r3, #9312	; 0x2460
 8000dc4:	f6c0 0301 	movt	r3, #2049	; 0x801
 8000dc8:	e012      	b.n	8000df0 <get_descriptor.14698+0x50>
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
 8000dca:	f242 43c0 	movw	r3, #9408	; 0x24c0
 8000dce:	f6c0 0301 	movt	r3, #2049	; 0x801
 8000dd2:	e00d      	b.n	8000df0 <get_descriptor.14698+0x50>
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8000dd4:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8000dd8:	2b03      	cmp	r3, #3
 8000dda:	d808      	bhi.n	8000dee <get_descriptor.14698+0x4e>
      return &vcom_strings[dindex];
 8000ddc:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8000de0:	00da      	lsls	r2, r3, #3
 8000de2:	f242 5360 	movw	r3, #9568	; 0x2560
 8000de6:	f6c0 0301 	movt	r3, #2049	; 0x801
 8000dea:	4413      	add	r3, r2
 8000dec:	e000      	b.n	8000df0 <get_descriptor.14698+0x50>
  }
  return NULL;
 8000dee:	2300      	movs	r3, #0
}
 8000df0:	4618      	mov	r0, r3
 8000df2:	b002      	add	sp, #8
 8000df4:	4770      	bx	lr
 8000df6:	bf00      	nop
 8000df8:	f3af 8000 	nop.w
 8000dfc:	f3af 8000 	nop.w

08000e00 <usb_event.14964>:
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8000e00:	b500      	push	{lr}
 8000e02:	b083      	sub	sp, #12
 8000e04:	9001      	str	r0, [sp, #4]
 8000e06:	460b      	mov	r3, r1
 8000e08:	f88d 3003 	strb.w	r3, [sp, #3]
  extern SerialUSBDriver SDU1;

  switch (event) {
 8000e0c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000e10:	2b05      	cmp	r3, #5
 8000e12:	d834      	bhi.n	8000e7e <usb_event.14964+0x7e>
 8000e14:	a201      	add	r2, pc, #4	; (adr r2, 8000e1c <usb_event.14964+0x1c>)
 8000e16:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000e1a:	bf00      	nop
 8000e1c:	08000e7f 	.word	0x08000e7f
 8000e20:	08000e7f 	.word	0x08000e7f
 8000e24:	08000e35 	.word	0x08000e35
 8000e28:	08000e6b 	.word	0x08000e6b
 8000e2c:	08000e7f 	.word	0x08000e7f
 8000e30:	08000e7f 	.word	0x08000e7f
  case USB_EVENT_RESET:
    return;
  case USB_EVENT_ADDRESS:
    return;
  case USB_EVENT_CONFIGURED:
    chSysLockFromISR();
 8000e34:	f7ff ff94 	bl	8000d60 <chSysLockFromISR.14958.4339>

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8000e38:	9801      	ldr	r0, [sp, #4]
 8000e3a:	2101      	movs	r1, #1
 8000e3c:	f242 5280 	movw	r2, #9600	; 0x2580
 8000e40:	f6c0 0201 	movt	r2, #2049	; 0x801
 8000e44:	f007 fcfc 	bl	8008840 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 8000e48:	9801      	ldr	r0, [sp, #4]
 8000e4a:	2102      	movs	r1, #2
 8000e4c:	f242 52b0 	movw	r2, #9648	; 0x25b0
 8000e50:	f6c0 0201 	movt	r2, #2049	; 0x801
 8000e54:	f007 fcf4 	bl	8008840 <usbInitEndpointI>

    /* Resetting the state of the CDC subsystem.*/
    sduConfigureHookI(&SDU1);
 8000e58:	f641 7058 	movw	r0, #8024	; 0x1f58
 8000e5c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000e60:	f009 fb7e 	bl	800a560 <sduConfigureHookI>

    chSysUnlockFromISR();
 8000e64:	f7ff ff84 	bl	8000d70 <chSysUnlockFromISR.14962.4337>
 8000e68:	e009      	b.n	8000e7e <usb_event.14964+0x7e>
    return;
  case USB_EVENT_SUSPEND:
    chSysLockFromISR();
 8000e6a:	f7ff ff79 	bl	8000d60 <chSysLockFromISR.14958.4339>

    /* Disconnection event on suspend.*/
    sduDisconnectI(&SDU1);
 8000e6e:	f641 7058 	movw	r0, #8024	; 0x1f58
 8000e72:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000e76:	f009 fb5b 	bl	800a530 <sduDisconnectI>

    chSysUnlockFromISR();
 8000e7a:	f7ff ff79 	bl	8000d70 <chSysUnlockFromISR.14962.4337>
    return;
  case USB_EVENT_STALLED:
    return;
  }
  return;
}
 8000e7e:	b003      	add	sp, #12
 8000e80:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e84:	f3af 8000 	nop.w
 8000e88:	f3af 8000 	nop.w
 8000e8c:	f3af 8000 	nop.w

08000e90 <sof_handler.14970>:

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 8000e90:	b500      	push	{lr}
 8000e92:	b083      	sub	sp, #12
 8000e94:	9001      	str	r0, [sp, #4]

  (void)usbp;

  osalSysLockFromISR();
 8000e96:	f7ff ff73 	bl	8000d80 <osalSysLockFromISR.14960.4335>
  sduSOFHookI(&SDU1);
 8000e9a:	f641 7058 	movw	r0, #8024	; 0x1f58
 8000e9e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000ea2:	f009 fbd5 	bl	800a650 <sduSOFHookI>
  osalSysUnlockFromISR();
 8000ea6:	f7ff ff73 	bl	8000d90 <osalSysUnlockFromISR.14968.4333>
}
 8000eaa:	b003      	add	sp, #12
 8000eac:	f85d fb04 	ldr.w	pc, [sp], #4

08000eb0 <chThdGetSelfX.15075.4149>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8000eb0:	f640 5350 	movw	r3, #3408	; 0xd50
 8000eb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000eb8:	699b      	ldr	r3, [r3, #24]
}
 8000eba:	4618      	mov	r0, r3
 8000ebc:	4770      	bx	lr
 8000ebe:	bf00      	nop

08000ec0 <chThdGetPriorityX.15164.4147>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8000ec0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8000ec2:	f7ff fff5 	bl	8000eb0 <chThdGetSelfX.15075.4149>
 8000ec6:	4603      	mov	r3, r0
 8000ec8:	689b      	ldr	r3, [r3, #8]
}
 8000eca:	4618      	mov	r0, r3
 8000ecc:	bd08      	pop	{r3, pc}
 8000ece:	bf00      	nop

08000ed0 <chThdTerminatedX.15166.4062>:
 * @retval true         thread terminated.
 * @retval false        thread not terminated.
 *
 * @xclass
 */
static inline bool chThdTerminatedX(thread_t *tp) {
 8000ed0:	b082      	sub	sp, #8
 8000ed2:	9001      	str	r0, [sp, #4]

  return (bool)(tp->p_state == CH_STATE_FINAL);
 8000ed4:	9b01      	ldr	r3, [sp, #4]
 8000ed6:	f893 3020 	ldrb.w	r3, [r3, #32]
 8000eda:	2b0f      	cmp	r3, #15
 8000edc:	bf14      	ite	ne
 8000ede:	2300      	movne	r3, #0
 8000ee0:	2301      	moveq	r3, #1
 8000ee2:	b2db      	uxtb	r3, r3
}
 8000ee4:	4618      	mov	r0, r3
 8000ee6:	b002      	add	sp, #8
 8000ee8:	4770      	bx	lr
 8000eea:	bf00      	nop
 8000eec:	f3af 8000 	nop.w

08000ef0 <chRegSetThreadName.15170.4058>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8000ef0:	b082      	sub	sp, #8
 8000ef2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8000ef4:	f640 5350 	movw	r3, #3408	; 0xd50
 8000ef8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000efc:	699b      	ldr	r3, [r3, #24]
 8000efe:	9a01      	ldr	r2, [sp, #4]
 8000f00:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8000f02:	b002      	add	sp, #8
 8000f04:	4770      	bx	lr
 8000f06:	bf00      	nop
 8000f08:	f3af 8000 	nop.w
 8000f0c:	f3af 8000 	nop.w

08000f10 <cmd_mem.15187>:
/*===========================================================================*/

#define SHELL_WA_SIZE   THD_WORKING_AREA_SIZE(2048)
#define TEST_WA_SIZE    THD_WORKING_AREA_SIZE(256)

static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8000f10:	b500      	push	{lr}
 8000f12:	b087      	sub	sp, #28
 8000f14:	9003      	str	r0, [sp, #12]
 8000f16:	9102      	str	r1, [sp, #8]
 8000f18:	9201      	str	r2, [sp, #4]
  size_t n, size;

  (void)argv;
  if (argc > 0) {
 8000f1a:	9b02      	ldr	r3, [sp, #8]
 8000f1c:	2b00      	cmp	r3, #0
 8000f1e:	dd07      	ble.n	8000f30 <cmd_mem.15187+0x20>
    chprintf(chp, "Usage: mem\r\n");
 8000f20:	9803      	ldr	r0, [sp, #12]
 8000f22:	f640 1100 	movw	r1, #2304	; 0x900
 8000f26:	f6c0 0101 	movt	r1, #2049	; 0x801
 8000f2a:	f7ff fee1 	bl	8000cf0 <chprintf>
 8000f2e:	e021      	b.n	8000f74 <cmd_mem.15187+0x64>
    return;
  }
  n = chHeapStatus(NULL, &size);
 8000f30:	ab04      	add	r3, sp, #16
 8000f32:	2000      	movs	r0, #0
 8000f34:	4619      	mov	r1, r3
 8000f36:	f00a fbeb 	bl	800b710 <chHeapStatus>
 8000f3a:	9005      	str	r0, [sp, #20]
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
 8000f3c:	f00a fa90 	bl	800b460 <chCoreGetStatusX>
 8000f40:	4603      	mov	r3, r0
 8000f42:	9803      	ldr	r0, [sp, #12]
 8000f44:	f640 1110 	movw	r1, #2320	; 0x910
 8000f48:	f6c0 0101 	movt	r1, #2049	; 0x801
 8000f4c:	461a      	mov	r2, r3
 8000f4e:	f7ff fecf 	bl	8000cf0 <chprintf>
  chprintf(chp, "heap fragments   : %u\r\n", n);
 8000f52:	9803      	ldr	r0, [sp, #12]
 8000f54:	f640 1130 	movw	r1, #2352	; 0x930
 8000f58:	f6c0 0101 	movt	r1, #2049	; 0x801
 8000f5c:	9a05      	ldr	r2, [sp, #20]
 8000f5e:	f7ff fec7 	bl	8000cf0 <chprintf>
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
 8000f62:	9b04      	ldr	r3, [sp, #16]
 8000f64:	9803      	ldr	r0, [sp, #12]
 8000f66:	f640 1148 	movw	r1, #2376	; 0x948
 8000f6a:	f6c0 0101 	movt	r1, #2049	; 0x801
 8000f6e:	461a      	mov	r2, r3
 8000f70:	f7ff febe 	bl	8000cf0 <chprintf>
}
 8000f74:	b007      	add	sp, #28
 8000f76:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f7a:	bf00      	nop
 8000f7c:	f3af 8000 	nop.w

08000f80 <cmd_threads.15192>:

static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8000f80:	b530      	push	{r4, r5, lr}
 8000f82:	b08b      	sub	sp, #44	; 0x2c
 8000f84:	9007      	str	r0, [sp, #28]
 8000f86:	9106      	str	r1, [sp, #24]
 8000f88:	9205      	str	r2, [sp, #20]
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8000f8a:	9b06      	ldr	r3, [sp, #24]
 8000f8c:	2b00      	cmp	r3, #0
 8000f8e:	dd07      	ble.n	8000fa0 <cmd_threads.15192+0x20>
    chprintf(chp, "Usage: threads\r\n");
 8000f90:	9807      	ldr	r0, [sp, #28]
 8000f92:	f640 1168 	movw	r1, #2408	; 0x968
 8000f96:	f6c0 0101 	movt	r1, #2049	; 0x801
 8000f9a:	f7ff fea9 	bl	8000cf0 <chprintf>
 8000f9e:	e030      	b.n	8001002 <cmd_threads.15192+0x82>
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state time\r\n");
 8000fa0:	9807      	ldr	r0, [sp, #28]
 8000fa2:	f640 117c 	movw	r1, #2428	; 0x97c
 8000fa6:	f6c0 0101 	movt	r1, #2049	; 0x801
 8000faa:	f7ff fea1 	bl	8000cf0 <chprintf>
  tp = chRegFirstThread();
 8000fae:	f00d f98f 	bl	800e2d0 <chRegFirstThread>
 8000fb2:	9009      	str	r0, [sp, #36]	; 0x24
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s\r\n",
 8000fb4:	9a09      	ldr	r2, [sp, #36]	; 0x24
            (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
 8000fb6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000fb8:	68db      	ldr	r3, [r3, #12]
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state time\r\n");
  tp = chRegFirstThread();
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s\r\n",
 8000fba:	461c      	mov	r4, r3
 8000fbc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000fbe:	6898      	ldr	r0, [r3, #8]
            (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
            (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
 8000fc0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000fc2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8000fc6:	3b01      	subs	r3, #1
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state time\r\n");
  tp = chRegFirstThread();
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s\r\n",
 8000fc8:	4619      	mov	r1, r3
            (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
            (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
            states[tp->p_state]);
 8000fca:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000fcc:	f893 3020 	ldrb.w	r3, [r3, #32]
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state time\r\n");
  tp = chRegFirstThread();
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s\r\n",
 8000fd0:	461d      	mov	r5, r3
 8000fd2:	f640 130c 	movw	r3, #2316	; 0x90c
 8000fd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000fda:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 8000fde:	9000      	str	r0, [sp, #0]
 8000fe0:	9101      	str	r1, [sp, #4]
 8000fe2:	9302      	str	r3, [sp, #8]
 8000fe4:	9807      	ldr	r0, [sp, #28]
 8000fe6:	f640 11ac 	movw	r1, #2476	; 0x9ac
 8000fea:	f6c0 0101 	movt	r1, #2049	; 0x801
 8000fee:	4623      	mov	r3, r4
 8000ff0:	f7ff fe7e 	bl	8000cf0 <chprintf>
            (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
            (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
            states[tp->p_state]);
    tp = chRegNextThread(tp);
 8000ff4:	9809      	ldr	r0, [sp, #36]	; 0x24
 8000ff6:	f00d f98b 	bl	800e310 <chRegNextThread>
 8000ffa:	9009      	str	r0, [sp, #36]	; 0x24
  } while (tp != NULL);
 8000ffc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000ffe:	2b00      	cmp	r3, #0
 8001000:	d1d8      	bne.n	8000fb4 <cmd_threads.15192+0x34>
}
 8001002:	b00b      	add	sp, #44	; 0x2c
 8001004:	bd30      	pop	{r4, r5, pc}
 8001006:	bf00      	nop
 8001008:	f3af 8000 	nop.w
 800100c:	f3af 8000 	nop.w

08001010 <cmd_test.15197>:

static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001010:	b500      	push	{lr}
 8001012:	b089      	sub	sp, #36	; 0x24
 8001014:	9005      	str	r0, [sp, #20]
 8001016:	9104      	str	r1, [sp, #16]
 8001018:	9203      	str	r2, [sp, #12]
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 800101a:	9b04      	ldr	r3, [sp, #16]
 800101c:	2b00      	cmp	r3, #0
 800101e:	dd07      	ble.n	8001030 <cmd_test.15197+0x20>
    chprintf(chp, "Usage: test\r\n");
 8001020:	9805      	ldr	r0, [sp, #20]
 8001022:	f640 11c8 	movw	r1, #2504	; 0x9c8
 8001026:	f6c0 0101 	movt	r1, #2049	; 0x801
 800102a:	f7ff fe61 	bl	8000cf0 <chprintf>
 800102e:	e01d      	b.n	800106c <cmd_test.15197+0x5c>
    return;
  }
  tp = chThdCreateFromHeap(NULL, TEST_WA_SIZE, chThdGetPriorityX(),
 8001030:	f7ff ff46 	bl	8000ec0 <chThdGetPriorityX.15164.4147>
 8001034:	4603      	mov	r3, r0
 8001036:	9a05      	ldr	r2, [sp, #20]
 8001038:	9200      	str	r2, [sp, #0]
 800103a:	2000      	movs	r0, #0
 800103c:	f44f 71f4 	mov.w	r1, #488	; 0x1e8
 8001040:	461a      	mov	r2, r3
 8001042:	f645 4331 	movw	r3, #23601	; 0x5c31
 8001046:	f6c0 0300 	movt	r3, #2048	; 0x800
 800104a:	f00d f871 	bl	800e130 <chThdCreateFromHeap>
 800104e:	9007      	str	r0, [sp, #28]
                           TestThread, chp);
  if (tp == NULL) {
 8001050:	9b07      	ldr	r3, [sp, #28]
 8001052:	2b00      	cmp	r3, #0
 8001054:	d107      	bne.n	8001066 <cmd_test.15197+0x56>
    chprintf(chp, "out of memory\r\n");
 8001056:	9805      	ldr	r0, [sp, #20]
 8001058:	f640 11d8 	movw	r1, #2520	; 0x9d8
 800105c:	f6c0 0101 	movt	r1, #2049	; 0x801
 8001060:	f7ff fe46 	bl	8000cf0 <chprintf>
 8001064:	e002      	b.n	800106c <cmd_test.15197+0x5c>
    return;
  }
  chThdWait(tp);
 8001066:	9807      	ldr	r0, [sp, #28]
 8001068:	f00c fd72 	bl	800db50 <chThdWait>
}
 800106c:	b009      	add	sp, #36	; 0x24
 800106e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001072:	bf00      	nop
 8001074:	f3af 8000 	nop.w
 8001078:	f3af 8000 	nop.w
 800107c:	f3af 8000 	nop.w

08001080 <cmd_write.15173>:

/* Can be measured using dd if=/dev/xxxx of=/dev/null bs=512 count=10000.*/
static void cmd_write(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001080:	b500      	push	{lr}
 8001082:	b085      	sub	sp, #20
 8001084:	9003      	str	r0, [sp, #12]
 8001086:	9102      	str	r1, [sp, #8]
 8001088:	9201      	str	r2, [sp, #4]
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";

  (void)argv;
  if (argc > 0) {
 800108a:	9b02      	ldr	r3, [sp, #8]
 800108c:	2b00      	cmp	r3, #0
 800108e:	dd18      	ble.n	80010c2 <cmd_write.15173+0x42>
    chprintf(chp, "Usage: write\r\n");
 8001090:	9803      	ldr	r0, [sp, #12]
 8001092:	f640 11e8 	movw	r1, #2536	; 0x9e8
 8001096:	f6c0 0101 	movt	r1, #2049	; 0x801
 800109a:	f7ff fe29 	bl	8000cf0 <chprintf>
 800109e:	e021      	b.n	80010e4 <cmd_write.15173+0x64>
  }

  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
#if 1
    /* Writing in channel mode.*/
    chnWrite(&SDU1, buf, sizeof buf - 1);
 80010a0:	f641 7358 	movw	r3, #8024	; 0x1f58
 80010a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80010a8:	681b      	ldr	r3, [r3, #0]
 80010aa:	681b      	ldr	r3, [r3, #0]
 80010ac:	f641 7058 	movw	r0, #8024	; 0x1f58
 80010b0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80010b4:	f640 114c 	movw	r1, #2380	; 0x94c
 80010b8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80010bc:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80010c0:	4798      	blx	r3
  if (argc > 0) {
    chprintf(chp, "Usage: write\r\n");
    return;
  }

  while (chnGetTimeout((BaseChannel *)chp, TIME_IMMEDIATE) == Q_TIMEOUT) {
 80010c2:	9b03      	ldr	r3, [sp, #12]
 80010c4:	681b      	ldr	r3, [r3, #0]
 80010c6:	695b      	ldr	r3, [r3, #20]
 80010c8:	9803      	ldr	r0, [sp, #12]
 80010ca:	2100      	movs	r1, #0
 80010cc:	4798      	blx	r3
 80010ce:	4603      	mov	r3, r0
 80010d0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80010d4:	d0e4      	beq.n	80010a0 <cmd_write.15173+0x20>
    (void) obqGetEmptyBufferTimeout(&SDU1.obqueue, TIME_INFINITE);
    memcpy(SDU1.obqueue.ptr, buf, SERIAL_USB_BUFFERS_SIZE);
    obqPostFullBuffer(&SDU1.obqueue, SERIAL_USB_BUFFERS_SIZE);
#endif
  }
  chprintf(chp, "\r\n\nstopped\r\n");
 80010d6:	9803      	ldr	r0, [sp, #12]
 80010d8:	f640 11f8 	movw	r1, #2552	; 0x9f8
 80010dc:	f6c0 0101 	movt	r1, #2049	; 0x801
 80010e0:	f7ff fe06 	bl	8000cf0 <chprintf>
}
 80010e4:	b005      	add	sp, #20
 80010e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80010ea:	bf00      	nop
 80010ec:	f3af 8000 	nop.w

080010f0 <Thread1.15203.4013>:

/*
 * LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 80010f0:	b500      	push	{lr}
 80010f2:	b085      	sub	sp, #20
 80010f4:	9001      	str	r0, [sp, #4]

  (void)arg;
  chRegSetThreadName("blinker");
 80010f6:	f640 2008 	movw	r0, #2568	; 0xa08
 80010fa:	f6c0 0001 	movt	r0, #2049	; 0x801
 80010fe:	f7ff fef7 	bl	8000ef0 <chRegSetThreadName.15170.4058>
  while (true) {
    systime_t time;

    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
 8001102:	f242 53f0 	movw	r3, #9712	; 0x25f0
 8001106:	f6c0 0301 	movt	r3, #2049	; 0x801
 800110a:	681b      	ldr	r3, [r3, #0]
 800110c:	781b      	ldrb	r3, [r3, #0]
 800110e:	2b04      	cmp	r3, #4
 8001110:	d101      	bne.n	8001116 <Thread1.15203.4013+0x26>
 8001112:	23fa      	movs	r3, #250	; 0xfa
 8001114:	e001      	b.n	800111a <Thread1.15203.4013+0x2a>
 8001116:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 800111a:	9303      	str	r3, [sp, #12]
#if defined(BOARD_ST_STM32F4_DISCOVERY)
    palClearPad(GPIOD, GPIOD_LED4);
 800111c:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8001120:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001124:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001128:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(time);
 800112a:	9b03      	ldr	r3, [sp, #12]
 800112c:	f242 7210 	movw	r2, #10000	; 0x2710
 8001130:	fb02 f303 	mul.w	r3, r2, r3
 8001134:	f203 32e7 	addw	r2, r3, #999	; 0x3e7
 8001138:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 800113c:	f2c1 0362 	movt	r3, #4194	; 0x1062
 8001140:	fba3 1302 	umull	r1, r3, r3, r2
 8001144:	099b      	lsrs	r3, r3, #6
 8001146:	4618      	mov	r0, r3
 8001148:	f00c fc82 	bl	800da50 <chThdSleep>
    palSetPad(GPIOD, GPIOD_LED4);
 800114c:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8001150:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001154:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001158:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(time);
 800115a:	9b03      	ldr	r3, [sp, #12]
 800115c:	f242 7210 	movw	r2, #10000	; 0x2710
 8001160:	fb02 f303 	mul.w	r3, r2, r3
 8001164:	f203 32e7 	addw	r2, r3, #999	; 0x3e7
 8001168:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 800116c:	f2c1 0362 	movt	r3, #4194	; 0x1062
 8001170:	fba3 1302 	umull	r1, r3, r3, r2
 8001174:	099b      	lsrs	r3, r3, #6
 8001176:	4618      	mov	r0, r3
 8001178:	f00c fc6a 	bl	800da50 <chThdSleep>
 800117c:	e7c1      	b.n	8001102 <Thread1.15203.4013+0x12>
 800117e:	bf00      	nop

08001180 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8001180:	b500      	push	{lr}
 8001182:	b085      	sub	sp, #20
  thread_t *shelltp = NULL;
 8001184:	2300      	movs	r3, #0
 8001186:	9303      	str	r3, [sp, #12]
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8001188:	f00a fc82 	bl	800ba90 <halInit>
  chSysInit();
 800118c:	f00e f8a0 	bl	800f2d0 <chSysInit>

  /*
   * Initializes a serial-over-USB CDC driver.
   */
  sduObjectInit(&SDU1);
 8001190:	f641 7058 	movw	r0, #8024	; 0x1f58
 8001194:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001198:	f009 f93a 	bl	800a410 <sduObjectInit>
  sduStart(&SDU1, &serusbcfg);
 800119c:	f641 7058 	movw	r0, #8024	; 0x1f58
 80011a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80011a4:	f242 51f0 	movw	r1, #9712	; 0x25f0
 80011a8:	f6c0 0101 	movt	r1, #2049	; 0x801
 80011ac:	f009 f970 	bl	800a490 <sduStart>
  /*
   * Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbDisconnectBus(serusbcfg.usbp);
 80011b0:	f242 53f0 	movw	r3, #9712	; 0x25f0
 80011b4:	f6c0 0301 	movt	r3, #2049	; 0x801
 80011b8:	681b      	ldr	r3, [r3, #0]
 80011ba:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80011bc:	f242 53f0 	movw	r3, #9712	; 0x25f0
 80011c0:	f6c0 0301 	movt	r3, #2049	; 0x801
 80011c4:	681b      	ldr	r3, [r3, #0]
 80011c6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80011c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80011ca:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80011ce:	6393      	str	r3, [r2, #56]	; 0x38
  chThdSleepMilliseconds(1500);
 80011d0:	f643 2098 	movw	r0, #15000	; 0x3a98
 80011d4:	f00c fc3c 	bl	800da50 <chThdSleep>
  usbStart(serusbcfg.usbp, &usbcfg);
 80011d8:	f242 53f0 	movw	r3, #9712	; 0x25f0
 80011dc:	f6c0 0301 	movt	r3, #2049	; 0x801
 80011e0:	681b      	ldr	r3, [r3, #0]
 80011e2:	4618      	mov	r0, r3
 80011e4:	f242 51e0 	movw	r1, #9696	; 0x25e0
 80011e8:	f6c0 0101 	movt	r1, #2049	; 0x801
 80011ec:	f009 fe08 	bl	800ae00 <usbStart>
  usbConnectBus(serusbcfg.usbp);
 80011f0:	f242 53f0 	movw	r3, #9712	; 0x25f0
 80011f4:	f6c0 0301 	movt	r3, #2049	; 0x801
 80011f8:	681b      	ldr	r3, [r3, #0]
 80011fa:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80011fc:	f242 53f0 	movw	r3, #9712	; 0x25f0
 8001200:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001204:	681b      	ldr	r3, [r3, #0]
 8001206:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8001208:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800120a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800120e:	6393      	str	r3, [r2, #56]	; 0x38

  /*
   * Shell manager initialization.
   */
  shellInit();
 8001210:	f7ff fa2e 	bl	8000670 <shellInit.4446>

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8001214:	2300      	movs	r3, #0
 8001216:	9300      	str	r3, [sp, #0]
 8001218:	f242 4010 	movw	r0, #9232	; 0x2410
 800121c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001220:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001224:	2240      	movs	r2, #64	; 0x40
 8001226:	f241 03f1 	movw	r3, #4337	; 0x10f1
 800122a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800122e:	f00f fa97 	bl	8010760 <chThdCreateStatic>
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (!shelltp && (SDU1.config->usbp->state == USB_ACTIVE))
 8001232:	9b03      	ldr	r3, [sp, #12]
 8001234:	2b00      	cmp	r3, #0
 8001236:	d114      	bne.n	8001262 <main+0xe2>
 8001238:	f641 7358 	movw	r3, #8024	; 0x1f58
 800123c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001240:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8001244:	681b      	ldr	r3, [r3, #0]
 8001246:	781b      	ldrb	r3, [r3, #0]
 8001248:	2b04      	cmp	r3, #4
 800124a:	d10a      	bne.n	8001262 <main+0xe2>
      shelltp = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO);
 800124c:	f242 6030 	movw	r0, #9776	; 0x2630
 8001250:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001254:	f640 01e8 	movw	r1, #2280	; 0x8e8
 8001258:	2240      	movs	r2, #64	; 0x40
 800125a:	f7ff fa29 	bl	80006b0 <shellCreate.4438>
 800125e:	9003      	str	r0, [sp, #12]
 8001260:	e00a      	b.n	8001278 <main+0xf8>
    else if (chThdTerminatedX(shelltp)) {
 8001262:	9803      	ldr	r0, [sp, #12]
 8001264:	f7ff fe34 	bl	8000ed0 <chThdTerminatedX.15166.4062>
 8001268:	4603      	mov	r3, r0
 800126a:	2b00      	cmp	r3, #0
 800126c:	d004      	beq.n	8001278 <main+0xf8>
      chThdRelease(shelltp);    /* Recovers memory of the previous shell.   */
 800126e:	9803      	ldr	r0, [sp, #12]
 8001270:	f00c ff06 	bl	800e080 <chThdRelease>
      shelltp = NULL;           /* Triggers spawning of a new shell.        */
 8001274:	2300      	movs	r3, #0
 8001276:	9303      	str	r3, [sp, #12]
    }
    chThdSleepMilliseconds(1000);
 8001278:	f242 7010 	movw	r0, #10000	; 0x2710
 800127c:	f00c fbe8 	bl	800da50 <chThdSleep>
 8001280:	e7d7      	b.n	8001232 <main+0xb2>
 8001282:	bf00      	nop
 8001284:	f3af 8000 	nop.w
 8001288:	f3af 8000 	nop.w
 800128c:	f3af 8000 	nop.w

08001290 <chVTIsArmed.13745.4309>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(virtual_timer_t *vtp) {
 8001290:	b500      	push	{lr}
 8001292:	b085      	sub	sp, #20
 8001294:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 8001296:	f002 fbfb 	bl	8003a90 <chSysLock.13723>
  b = chVTIsArmedI(vtp);
 800129a:	9801      	ldr	r0, [sp, #4]
 800129c:	f002 fc60 	bl	8003b60 <chVTIsArmedI.13727>
 80012a0:	4603      	mov	r3, r0
 80012a2:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 80012a6:	f002 fbfb 	bl	8003aa0 <chSysUnlock.13719>

  return b;
 80012aa:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 80012ae:	4618      	mov	r0, r3
 80012b0:	b005      	add	sp, #20
 80012b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80012b6:	bf00      	nop
 80012b8:	f3af 8000 	nop.w
 80012bc:	f3af 8000 	nop.w

080012c0 <chVTResetI.13730.4306>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 80012c0:	b500      	push	{lr}
 80012c2:	b083      	sub	sp, #12
 80012c4:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 80012c6:	9801      	ldr	r0, [sp, #4]
 80012c8:	f002 fc4a 	bl	8003b60 <chVTIsArmedI.13727>
 80012cc:	4603      	mov	r3, r0
 80012ce:	2b00      	cmp	r3, #0
 80012d0:	d002      	beq.n	80012d8 <chVTResetI.13730.4306+0x18>
    chVTDoResetI(vtp);
 80012d2:	9801      	ldr	r0, [sp, #4]
 80012d4:	f00e fc64 	bl	800fba0 <chVTDoResetI>
  }
}
 80012d8:	b003      	add	sp, #12
 80012da:	f85d fb04 	ldr.w	pc, [sp], #4
 80012de:	bf00      	nop

080012e0 <chVTSetI.13733.4300>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 80012e0:	b500      	push	{lr}
 80012e2:	b085      	sub	sp, #20
 80012e4:	9003      	str	r0, [sp, #12]
 80012e6:	9102      	str	r1, [sp, #8]
 80012e8:	9201      	str	r2, [sp, #4]
 80012ea:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 80012ec:	9803      	ldr	r0, [sp, #12]
 80012ee:	f7ff ffe7 	bl	80012c0 <chVTResetI.13730.4306>
  chVTDoSetI(vtp, delay, vtfunc, par);
 80012f2:	9803      	ldr	r0, [sp, #12]
 80012f4:	9902      	ldr	r1, [sp, #8]
 80012f6:	9a01      	ldr	r2, [sp, #4]
 80012f8:	9b00      	ldr	r3, [sp, #0]
 80012fa:	f00e fba9 	bl	800fa50 <chVTDoSetI>
}
 80012fe:	b005      	add	sp, #20
 8001300:	f85d fb04 	ldr.w	pc, [sp], #4
 8001304:	f3af 8000 	nop.w
 8001308:	f3af 8000 	nop.w
 800130c:	f3af 8000 	nop.w

08001310 <chVTSet.13739.4286>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 8001310:	b500      	push	{lr}
 8001312:	b085      	sub	sp, #20
 8001314:	9003      	str	r0, [sp, #12]
 8001316:	9102      	str	r1, [sp, #8]
 8001318:	9201      	str	r2, [sp, #4]
 800131a:	9300      	str	r3, [sp, #0]

  chSysLock();
 800131c:	f002 fbb8 	bl	8003a90 <chSysLock.13723>
  chVTSetI(vtp, delay, vtfunc, par);
 8001320:	9803      	ldr	r0, [sp, #12]
 8001322:	9902      	ldr	r1, [sp, #8]
 8001324:	9a01      	ldr	r2, [sp, #4]
 8001326:	9b00      	ldr	r3, [sp, #0]
 8001328:	f7ff ffda 	bl	80012e0 <chVTSetI.13733.4300>
  chSysUnlock();
 800132c:	f002 fbb8 	bl	8003aa0 <chSysUnlock.13719>
}
 8001330:	b005      	add	sp, #20
 8001332:	f85d fb04 	ldr.w	pc, [sp], #4
 8001336:	bf00      	nop
 8001338:	f3af 8000 	nop.w
 800133c:	f3af 8000 	nop.w

08001340 <vtcb.13716.4283>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 8001340:	b500      	push	{lr}
 8001342:	b085      	sub	sp, #20
 8001344:	9001      	str	r0, [sp, #4]
  syssts_t sts;

  (void)p;

  /* Testing normal case.*/
  chSysLockFromISR();
 8001346:	f002 fbd3 	bl	8003af0 <chSysLockFromISR.13712>
  chSysUnlockFromISR();
 800134a:	f002 fbd9 	bl	8003b00 <chSysUnlockFromISR.13714>

  /* Reentrant case.*/
  chSysLockFromISR();
 800134e:	f002 fbcf 	bl	8003af0 <chSysLockFromISR.13712>
  sts = chSysGetStatusAndLockX();
 8001352:	f00e f8dd 	bl	800f510 <chSysGetStatusAndLockX>
 8001356:	9003      	str	r0, [sp, #12]
  chSysRestoreStatusX(sts);
 8001358:	9803      	ldr	r0, [sp, #12]
 800135a:	f00e f8f9 	bl	800f550 <chSysRestoreStatusX>
  chSysUnlockFromISR();
 800135e:	f002 fbcf 	bl	8003b00 <chSysUnlockFromISR.13714>
}
 8001362:	b005      	add	sp, #20
 8001364:	f85d fb04 	ldr.w	pc, [sp], #4
 8001368:	f3af 8000 	nop.w
 800136c:	f3af 8000 	nop.w

08001370 <sys1_execute.13748>:

static void sys1_execute(void) {
 8001370:	b500      	push	{lr}
 8001372:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 8001374:	f00e f8cc 	bl	800f510 <chSysGetStatusAndLockX>
 8001378:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 800137a:	9805      	ldr	r0, [sp, #20]
 800137c:	f00e f8e8 	bl	800f550 <chSysRestoreStatusX>

  /* Reentrant case.*/
  chSysLock();
 8001380:	f002 fb86 	bl	8003a90 <chSysLock.13723>
  sts = chSysGetStatusAndLockX();
 8001384:	f00e f8c4 	bl	800f510 <chSysGetStatusAndLockX>
 8001388:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 800138a:	9805      	ldr	r0, [sp, #20]
 800138c:	f00e f8e0 	bl	800f550 <chSysRestoreStatusX>
  chSysUnlock();
 8001390:	f002 fb86 	bl	8003aa0 <chSysUnlock.13719>

  /* Unconditional lock.*/
  chSysUnconditionalLock();
 8001394:	f002 fbbc 	bl	8003b10 <chSysUnconditionalLock.13725>
  chSysUnconditionalLock();
 8001398:	f002 fbba 	bl	8003b10 <chSysUnconditionalLock.13725>
  chSysUnlock();
 800139c:	f002 fb80 	bl	8003aa0 <chSysUnlock.13719>

  /* Unconditional unlock.*/
  chSysLock();
 80013a0:	f002 fb76 	bl	8003a90 <chSysLock.13723>
  chSysUnconditionalUnlock();
 80013a4:	f002 fbc4 	bl	8003b30 <chSysUnconditionalUnlock.13721>
  chSysUnconditionalUnlock();
 80013a8:	f002 fbc2 	bl	8003b30 <chSysUnconditionalUnlock.13721>

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
 80013ac:	466b      	mov	r3, sp
 80013ae:	4618      	mov	r0, r3
 80013b0:	f002 fbce 	bl	8003b50 <chVTObjectInit.13700>
  chVTSet(&vt, 1, vtcb, NULL);
 80013b4:	466b      	mov	r3, sp
 80013b6:	4618      	mov	r0, r3
 80013b8:	2101      	movs	r1, #1
 80013ba:	f241 3241 	movw	r2, #4929	; 0x1341
 80013be:	f6c0 0200 	movt	r2, #2048	; 0x800
 80013c2:	2300      	movs	r3, #0
 80013c4:	f7ff ffa4 	bl	8001310 <chVTSet.13739.4286>
  chThdSleep(10);
 80013c8:	200a      	movs	r0, #10
 80013ca:	f00c fb41 	bl	800da50 <chThdSleep>

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 80013ce:	466b      	mov	r3, sp
 80013d0:	4618      	mov	r0, r3
 80013d2:	f7ff ff5d 	bl	8001290 <chVTIsArmed.13745.4309>
 80013d6:	4603      	mov	r3, r0
 80013d8:	2b00      	cmp	r3, #0
 80013da:	bf0c      	ite	eq
 80013dc:	2300      	moveq	r3, #0
 80013de:	2301      	movne	r3, #1
 80013e0:	b2db      	uxtb	r3, r3
 80013e2:	f083 0301 	eor.w	r3, r3, #1
 80013e6:	b2db      	uxtb	r3, r3
 80013e8:	f003 0301 	and.w	r3, r3, #1
 80013ec:	b2db      	uxtb	r3, r3
 80013ee:	2001      	movs	r0, #1
 80013f0:	4619      	mov	r1, r3
 80013f2:	f007 f8b5 	bl	8008560 <_test_assert>
 80013f6:	4603      	mov	r3, r0
 80013f8:	2b00      	cmp	r3, #0
}
 80013fa:	b007      	add	sp, #28
 80013fc:	f85d fb04 	ldr.w	pc, [sp], #4

08001400 <sys2_execute.13756>:
 *
 * <h2>Description</h2>
 * The interrupts handling API is invoked for coverage.
 */

static void sys2_execute(void) {
 8001400:	b508      	push	{r3, lr}

  chSysSuspend();
 8001402:	f002 fb35 	bl	8003a70 <chSysSuspend.13752>
  chSysDisable();
 8001406:	f002 fb2b 	bl	8003a60 <chSysDisable.13750>
  chSysSuspend();
 800140a:	f002 fb31 	bl	8003a70 <chSysSuspend.13752>
  chSysEnable();
 800140e:	f002 fb37 	bl	8003a80 <chSysEnable.13754>
}
 8001412:	bd08      	pop	{r3, pc}
 8001414:	f3af 8000 	nop.w
 8001418:	f3af 8000 	nop.w
 800141c:	f3af 8000 	nop.w

08001420 <sys3_execute.13758>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 8001420:	b500      	push	{lr}
 8001422:	b083      	sub	sp, #12
  bool result;

  chSysLock();
 8001424:	f002 fb34 	bl	8003a90 <chSysLock.13723>
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8001428:	2001      	movs	r0, #1
 800142a:	f00d ffc1 	bl	800f3b0 <chSysIntegrityCheckI>
 800142e:	4603      	mov	r3, r0
 8001430:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 8001434:	f002 fb34 	bl	8003aa0 <chSysUnlock.13719>
  test_assert(1, result == false, "ready list check failed");
 8001438:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800143c:	2b00      	cmp	r3, #0
 800143e:	bf0c      	ite	eq
 8001440:	2300      	moveq	r3, #0
 8001442:	2301      	movne	r3, #1
 8001444:	b2db      	uxtb	r3, r3
 8001446:	f083 0301 	eor.w	r3, r3, #1
 800144a:	b2db      	uxtb	r3, r3
 800144c:	f003 0301 	and.w	r3, r3, #1
 8001450:	b2db      	uxtb	r3, r3
 8001452:	2001      	movs	r0, #1
 8001454:	4619      	mov	r1, r3
 8001456:	f007 f883 	bl	8008560 <_test_assert>
 800145a:	4603      	mov	r3, r0
 800145c:	2b00      	cmp	r3, #0
 800145e:	d156      	bne.n	800150e <sys3_execute.13758+0xee>

  chSysLock();
 8001460:	f002 fb16 	bl	8003a90 <chSysLock.13723>
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8001464:	2002      	movs	r0, #2
 8001466:	f00d ffa3 	bl	800f3b0 <chSysIntegrityCheckI>
 800146a:	4603      	mov	r3, r0
 800146c:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 8001470:	f002 fb16 	bl	8003aa0 <chSysUnlock.13719>
  test_assert(2, result == false, "virtual timers list check failed");
 8001474:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001478:	2b00      	cmp	r3, #0
 800147a:	bf0c      	ite	eq
 800147c:	2300      	moveq	r3, #0
 800147e:	2301      	movne	r3, #1
 8001480:	b2db      	uxtb	r3, r3
 8001482:	f083 0301 	eor.w	r3, r3, #1
 8001486:	b2db      	uxtb	r3, r3
 8001488:	f003 0301 	and.w	r3, r3, #1
 800148c:	b2db      	uxtb	r3, r3
 800148e:	2002      	movs	r0, #2
 8001490:	4619      	mov	r1, r3
 8001492:	f007 f865 	bl	8008560 <_test_assert>
 8001496:	4603      	mov	r3, r0
 8001498:	2b00      	cmp	r3, #0
 800149a:	d138      	bne.n	800150e <sys3_execute.13758+0xee>

  chSysLock();
 800149c:	f002 faf8 	bl	8003a90 <chSysLock.13723>
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 80014a0:	2004      	movs	r0, #4
 80014a2:	f00d ff85 	bl	800f3b0 <chSysIntegrityCheckI>
 80014a6:	4603      	mov	r3, r0
 80014a8:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 80014ac:	f002 faf8 	bl	8003aa0 <chSysUnlock.13719>
  test_assert(3, result == false, "registry list check failed");
 80014b0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80014b4:	2b00      	cmp	r3, #0
 80014b6:	bf0c      	ite	eq
 80014b8:	2300      	moveq	r3, #0
 80014ba:	2301      	movne	r3, #1
 80014bc:	b2db      	uxtb	r3, r3
 80014be:	f083 0301 	eor.w	r3, r3, #1
 80014c2:	b2db      	uxtb	r3, r3
 80014c4:	f003 0301 	and.w	r3, r3, #1
 80014c8:	b2db      	uxtb	r3, r3
 80014ca:	2003      	movs	r0, #3
 80014cc:	4619      	mov	r1, r3
 80014ce:	f007 f847 	bl	8008560 <_test_assert>
 80014d2:	4603      	mov	r3, r0
 80014d4:	2b00      	cmp	r3, #0
 80014d6:	d11a      	bne.n	800150e <sys3_execute.13758+0xee>

  chSysLock();
 80014d8:	f002 fada 	bl	8003a90 <chSysLock.13723>
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 80014dc:	2008      	movs	r0, #8
 80014de:	f00d ff67 	bl	800f3b0 <chSysIntegrityCheckI>
 80014e2:	4603      	mov	r3, r0
 80014e4:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 80014e8:	f002 fada 	bl	8003aa0 <chSysUnlock.13719>
  test_assert(4, result == false, "port layer check failed");
 80014ec:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80014f0:	2b00      	cmp	r3, #0
 80014f2:	bf0c      	ite	eq
 80014f4:	2300      	moveq	r3, #0
 80014f6:	2301      	movne	r3, #1
 80014f8:	b2db      	uxtb	r3, r3
 80014fa:	f083 0301 	eor.w	r3, r3, #1
 80014fe:	b2db      	uxtb	r3, r3
 8001500:	f003 0301 	and.w	r3, r3, #1
 8001504:	b2db      	uxtb	r3, r3
 8001506:	2004      	movs	r0, #4
 8001508:	4619      	mov	r1, r3
 800150a:	f007 f829 	bl	8008560 <_test_assert>
}
 800150e:	b003      	add	sp, #12
 8001510:	f85d fb04 	ldr.w	pc, [sp], #4
 8001514:	f3af 8000 	nop.w
 8001518:	f3af 8000 	nop.w
 800151c:	f3af 8000 	nop.w

08001520 <port_lock.13940.4274>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001520:	b082      	sub	sp, #8
 8001522:	2320      	movs	r3, #32
 8001524:	9301      	str	r3, [sp, #4]
 8001526:	9b01      	ldr	r3, [sp, #4]
 8001528:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800152c:	b002      	add	sp, #8
 800152e:	4770      	bx	lr

08001530 <port_unlock.13943.4272>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001530:	b082      	sub	sp, #8
 8001532:	2300      	movs	r3, #0
 8001534:	9301      	str	r3, [sp, #4]
 8001536:	9b01      	ldr	r3, [sp, #4]
 8001538:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800153c:	b002      	add	sp, #8
 800153e:	4770      	bx	lr

08001540 <chSysLock.14054.4270>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001540:	b508      	push	{r3, lr}

  port_lock();
 8001542:	f7ff ffed 	bl	8001520 <port_lock.13940.4274>
  _stats_start_measure_crit_thd();
 8001546:	f00c fd1b 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800154a:	f00e f8c9 	bl	800f6e0 <_dbg_check_lock>
}
 800154e:	bd08      	pop	{r3, pc}

08001550 <chSysUnlock.14056.4268>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001550:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8001552:	f00e f8e5 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001556:	f00c fd1b 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800155a:	f640 5350 	movw	r3, #3408	; 0xd50
 800155e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001562:	681a      	ldr	r2, [r3, #0]
 8001564:	f640 5350 	movw	r3, #3408	; 0xd50
 8001568:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800156c:	429a      	cmp	r2, r3
 800156e:	d013      	beq.n	8001598 <chSysUnlock.14056.4268+0x48>
 8001570:	f640 5350 	movw	r3, #3408	; 0xd50
 8001574:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001578:	699b      	ldr	r3, [r3, #24]
 800157a:	689a      	ldr	r2, [r3, #8]
 800157c:	f640 5350 	movw	r3, #3408	; 0xd50
 8001580:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001584:	681b      	ldr	r3, [r3, #0]
 8001586:	689b      	ldr	r3, [r3, #8]
 8001588:	429a      	cmp	r2, r3
 800158a:	d205      	bcs.n	8001598 <chSysUnlock.14056.4268+0x48>
 800158c:	f242 4020 	movw	r0, #9248	; 0x2420
 8001590:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001594:	f00d fefc 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001598:	f7ff ffca 	bl	8001530 <port_unlock.13943.4272>
}
 800159c:	bd08      	pop	{r3, pc}
 800159e:	bf00      	nop

080015a0 <chThdGetSelfX.13945.4266>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80015a0:	f640 5350 	movw	r3, #3408	; 0xd50
 80015a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80015a8:	699b      	ldr	r3, [r3, #24]
}
 80015aa:	4618      	mov	r0, r3
 80015ac:	4770      	bx	lr
 80015ae:	bf00      	nop

080015b0 <chThdGetPriorityX.14033.4264>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 80015b0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 80015b2:	f7ff fff5 	bl	80015a0 <chThdGetSelfX.13945.4266>
 80015b6:	4603      	mov	r3, r0
 80015b8:	689b      	ldr	r3, [r3, #8]
}
 80015ba:	4618      	mov	r0, r3
 80015bc:	bd08      	pop	{r3, pc}
 80015be:	bf00      	nop

080015c0 <chThdShouldTerminateX.14035.4262>:
 * @retval true         termination request pending.
 * @retval false        termination request not pending.
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {
 80015c0:	b508      	push	{r3, lr}

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 80015c2:	f7ff ffed 	bl	80015a0 <chThdGetSelfX.13945.4266>
 80015c6:	4603      	mov	r3, r0
 80015c8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80015cc:	f003 0304 	and.w	r3, r3, #4
 80015d0:	2b00      	cmp	r3, #0
 80015d2:	bf0c      	ite	eq
 80015d4:	2300      	moveq	r3, #0
 80015d6:	2301      	movne	r3, #1
 80015d8:	b2db      	uxtb	r3, r3
}
 80015da:	4618      	mov	r0, r3
 80015dc:	bd08      	pop	{r3, pc}
 80015de:	bf00      	nop

080015e0 <chMsgGet.14038.4259>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 80015e0:	b082      	sub	sp, #8
 80015e2:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 80015e4:	9b01      	ldr	r3, [sp, #4]
 80015e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 80015e8:	4618      	mov	r0, r3
 80015ea:	b002      	add	sp, #8
 80015ec:	4770      	bx	lr
 80015ee:	bf00      	nop

080015f0 <chIQGet.14079.4243>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 80015f0:	b500      	push	{lr}
 80015f2:	b083      	sub	sp, #12
 80015f4:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 80015f6:	9801      	ldr	r0, [sp, #4]
 80015f8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80015fc:	f009 fcc0 	bl	800af80 <chIQGetTimeout>
 8001600:	4603      	mov	r3, r0
}
 8001602:	4618      	mov	r0, r3
 8001604:	b003      	add	sp, #12
 8001606:	f85d fb04 	ldr.w	pc, [sp], #4
 800160a:	bf00      	nop
 800160c:	f3af 8000 	nop.w

08001610 <thread1.14044.4221>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {
 8001610:	b500      	push	{lr}
 8001612:	b083      	sub	sp, #12
 8001614:	9001      	str	r0, [sp, #4]

  chThdExit((msg_t)p);
 8001616:	9b01      	ldr	r3, [sp, #4]
 8001618:	4618      	mov	r0, r3
 800161a:	f00c fa49 	bl	800dab0 <chThdExit>
}
 800161e:	b003      	add	sp, #12
 8001620:	f85d fb04 	ldr.w	pc, [sp], #4
 8001624:	f3af 8000 	nop.w
 8001628:	f3af 8000 	nop.w
 800162c:	f3af 8000 	nop.w

08001630 <thread2.14047.4233>:

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 8001630:	b500      	push	{lr}
 8001632:	b085      	sub	sp, #20
 8001634:	9001      	str	r0, [sp, #4]
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8001636:	f00b fdf3 	bl	800d220 <chMsgWait>
 800163a:	9003      	str	r0, [sp, #12]
    msg = chMsgGet(tp);
 800163c:	9803      	ldr	r0, [sp, #12]
 800163e:	f7ff ffcf 	bl	80015e0 <chMsgGet.14038.4259>
 8001642:	9002      	str	r0, [sp, #8]
    chMsgRelease(tp, msg);
 8001644:	9803      	ldr	r0, [sp, #12]
 8001646:	9902      	ldr	r1, [sp, #8]
 8001648:	f00b fe1a 	bl	800d280 <chMsgRelease>
  } while (msg);
 800164c:	9b02      	ldr	r3, [sp, #8]
 800164e:	2b00      	cmp	r3, #0
 8001650:	d1f1      	bne.n	8001636 <thread2.14047.4233+0x6>
}
 8001652:	b005      	add	sp, #20
 8001654:	f85d fb04 	ldr.w	pc, [sp], #4
 8001658:	f3af 8000 	nop.w
 800165c:	f3af 8000 	nop.w

08001660 <msg_loop_test.14105.4240>:

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 8001660:	b500      	push	{lr}
 8001662:	b085      	sub	sp, #20
 8001664:	9001      	str	r0, [sp, #4]

  uint32_t n = 0;
 8001666:	2300      	movs	r3, #0
 8001668:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 800166a:	f007 f839 	bl	80086e0 <test_wait_tick>
  test_start_timer(1000);
 800166e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001672:	f007 f855 	bl	8008720 <test_start_timer>
  do {
    (void)chMsgSend(tp, 1);
 8001676:	9801      	ldr	r0, [sp, #4]
 8001678:	2101      	movs	r1, #1
 800167a:	f00b fd99 	bl	800d1b0 <chMsgSend>
    n++;
 800167e:	9b03      	ldr	r3, [sp, #12]
 8001680:	3301      	adds	r3, #1
 8001682:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001684:	f641 6378 	movw	r3, #7800	; 0x1e78
 8001688:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800168c:	781b      	ldrb	r3, [r3, #0]
 800168e:	f083 0301 	eor.w	r3, r3, #1
 8001692:	b2db      	uxtb	r3, r3
 8001694:	2b00      	cmp	r3, #0
 8001696:	d1ee      	bne.n	8001676 <msg_loop_test.14105.4240+0x16>
  (void)chMsgSend(tp, 0);
 8001698:	9801      	ldr	r0, [sp, #4]
 800169a:	2100      	movs	r1, #0
 800169c:	f00b fd88 	bl	800d1b0 <chMsgSend>
  return n;
 80016a0:	9b03      	ldr	r3, [sp, #12]
}
 80016a2:	4618      	mov	r0, r3
 80016a4:	b005      	add	sp, #20
 80016a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80016aa:	bf00      	nop
 80016ac:	f3af 8000 	nop.w

080016b0 <bmk1_execute.14108>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 80016b0:	b510      	push	{r4, lr}
 80016b2:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 80016b4:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80016b8:	f6c0 0301 	movt	r3, #2049	; 0x801
 80016bc:	681c      	ldr	r4, [r3, #0]
 80016be:	f7ff ff77 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 80016c2:	4603      	mov	r3, r0
 80016c4:	3b01      	subs	r3, #1
 80016c6:	2200      	movs	r2, #0
 80016c8:	9200      	str	r2, [sp, #0]
 80016ca:	4620      	mov	r0, r4
 80016cc:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80016d0:	461a      	mov	r2, r3
 80016d2:	f241 6331 	movw	r3, #5681	; 0x1631
 80016d6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80016da:	f00f f841 	bl	8010760 <chThdCreateStatic>
 80016de:	4602      	mov	r2, r0
 80016e0:	f641 6360 	movw	r3, #7776	; 0x1e60
 80016e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016e8:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 80016ea:	f641 6360 	movw	r3, #7776	; 0x1e60
 80016ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016f2:	681b      	ldr	r3, [r3, #0]
 80016f4:	4618      	mov	r0, r3
 80016f6:	f7ff ffb3 	bl	8001660 <msg_loop_test.14105.4240>
 80016fa:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 80016fc:	f006 ffc0 	bl	8008680 <test_wait_threads>
  test_print("--- Score : ");
 8001700:	f640 2010 	movw	r0, #2576	; 0xa10
 8001704:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001708:	f006 fe7a 	bl	8008400 <test_print>
  test_printn(n);
 800170c:	9803      	ldr	r0, [sp, #12]
 800170e:	f006 fe1f 	bl	8008350 <test_printn>
  test_print(" msgs/S, ");
 8001712:	f640 2020 	movw	r0, #2592	; 0xa20
 8001716:	f6c0 0001 	movt	r0, #2049	; 0x801
 800171a:	f006 fe71 	bl	8008400 <test_print>
  test_printn(n << 1);
 800171e:	9b03      	ldr	r3, [sp, #12]
 8001720:	005b      	lsls	r3, r3, #1
 8001722:	4618      	mov	r0, r3
 8001724:	f006 fe14 	bl	8008350 <test_printn>
  test_println(" ctxswc/S");
 8001728:	f640 202c 	movw	r0, #2604	; 0xa2c
 800172c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001730:	f006 fe86 	bl	8008440 <test_println>
}
 8001734:	b004      	add	sp, #16
 8001736:	bd10      	pop	{r4, pc}
 8001738:	f3af 8000 	nop.w
 800173c:	f3af 8000 	nop.w

08001740 <bmk2_execute.14110>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8001740:	b510      	push	{r4, lr}
 8001742:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8001744:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001748:	f6c0 0301 	movt	r3, #2049	; 0x801
 800174c:	681c      	ldr	r4, [r3, #0]
 800174e:	f7ff ff2f 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001752:	4603      	mov	r3, r0
 8001754:	3301      	adds	r3, #1
 8001756:	2200      	movs	r2, #0
 8001758:	9200      	str	r2, [sp, #0]
 800175a:	4620      	mov	r0, r4
 800175c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001760:	461a      	mov	r2, r3
 8001762:	f241 6331 	movw	r3, #5681	; 0x1631
 8001766:	f6c0 0300 	movt	r3, #2048	; 0x800
 800176a:	f00e fff9 	bl	8010760 <chThdCreateStatic>
 800176e:	4602      	mov	r2, r0
 8001770:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001774:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001778:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 800177a:	f641 6360 	movw	r3, #7776	; 0x1e60
 800177e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001782:	681b      	ldr	r3, [r3, #0]
 8001784:	4618      	mov	r0, r3
 8001786:	f7ff ff6b 	bl	8001660 <msg_loop_test.14105.4240>
 800178a:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 800178c:	f006 ff78 	bl	8008680 <test_wait_threads>
  test_print("--- Score : ");
 8001790:	f640 2010 	movw	r0, #2576	; 0xa10
 8001794:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001798:	f006 fe32 	bl	8008400 <test_print>
  test_printn(n);
 800179c:	9803      	ldr	r0, [sp, #12]
 800179e:	f006 fdd7 	bl	8008350 <test_printn>
  test_print(" msgs/S, ");
 80017a2:	f640 2020 	movw	r0, #2592	; 0xa20
 80017a6:	f6c0 0001 	movt	r0, #2049	; 0x801
 80017aa:	f006 fe29 	bl	8008400 <test_print>
  test_printn(n << 1);
 80017ae:	9b03      	ldr	r3, [sp, #12]
 80017b0:	005b      	lsls	r3, r3, #1
 80017b2:	4618      	mov	r0, r3
 80017b4:	f006 fdcc 	bl	8008350 <test_printn>
  test_println(" ctxswc/S");
 80017b8:	f640 202c 	movw	r0, #2604	; 0xa2c
 80017bc:	f6c0 0001 	movt	r0, #2049	; 0x801
 80017c0:	f006 fe3e 	bl	8008440 <test_println>
}
 80017c4:	b004      	add	sp, #16
 80017c6:	bd10      	pop	{r4, pc}
 80017c8:	f3af 8000 	nop.w
 80017cc:	f3af 8000 	nop.w

080017d0 <bmk3_execute.14112>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 80017d0:	b510      	push	{r4, lr}
 80017d2:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80017d4:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80017d8:	f6c0 0301 	movt	r3, #2049	; 0x801
 80017dc:	681c      	ldr	r4, [r3, #0]
 80017de:	f7ff fee7 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 80017e2:	4603      	mov	r3, r0
 80017e4:	3301      	adds	r3, #1
 80017e6:	2200      	movs	r2, #0
 80017e8:	9200      	str	r2, [sp, #0]
 80017ea:	4620      	mov	r0, r4
 80017ec:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80017f0:	461a      	mov	r2, r3
 80017f2:	f241 6331 	movw	r3, #5681	; 0x1631
 80017f6:	f6c0 0300 	movt	r3, #2048	; 0x800
 80017fa:	f00e ffb1 	bl	8010760 <chThdCreateStatic>
 80017fe:	4602      	mov	r2, r0
 8001800:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001804:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001808:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 800180a:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 800180e:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001812:	685c      	ldr	r4, [r3, #4]
 8001814:	f7ff fecc 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001818:	4603      	mov	r3, r0
 800181a:	3b02      	subs	r3, #2
 800181c:	2200      	movs	r2, #0
 800181e:	9200      	str	r2, [sp, #0]
 8001820:	4620      	mov	r0, r4
 8001822:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001826:	461a      	mov	r2, r3
 8001828:	f241 6311 	movw	r3, #5649	; 0x1611
 800182c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001830:	f00e ff96 	bl	8010760 <chThdCreateStatic>
 8001834:	4602      	mov	r2, r0
 8001836:	f641 6360 	movw	r3, #7776	; 0x1e60
 800183a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800183e:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8001840:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001844:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001848:	689c      	ldr	r4, [r3, #8]
 800184a:	f7ff feb1 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 800184e:	4603      	mov	r3, r0
 8001850:	3b03      	subs	r3, #3
 8001852:	2200      	movs	r2, #0
 8001854:	9200      	str	r2, [sp, #0]
 8001856:	4620      	mov	r0, r4
 8001858:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800185c:	461a      	mov	r2, r3
 800185e:	f241 6311 	movw	r3, #5649	; 0x1611
 8001862:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001866:	f00e ff7b 	bl	8010760 <chThdCreateStatic>
 800186a:	4602      	mov	r2, r0
 800186c:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001870:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001874:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8001876:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 800187a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800187e:	68dc      	ldr	r4, [r3, #12]
 8001880:	f7ff fe96 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001884:	4603      	mov	r3, r0
 8001886:	3b04      	subs	r3, #4
 8001888:	2200      	movs	r2, #0
 800188a:	9200      	str	r2, [sp, #0]
 800188c:	4620      	mov	r0, r4
 800188e:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001892:	461a      	mov	r2, r3
 8001894:	f241 6311 	movw	r3, #5649	; 0x1611
 8001898:	f6c0 0300 	movt	r3, #2048	; 0x800
 800189c:	f00e ff60 	bl	8010760 <chThdCreateStatic>
 80018a0:	4602      	mov	r2, r0
 80018a2:	f641 6360 	movw	r3, #7776	; 0x1e60
 80018a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018aa:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 80018ac:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80018b0:	f6c0 0301 	movt	r3, #2049	; 0x801
 80018b4:	691c      	ldr	r4, [r3, #16]
 80018b6:	f7ff fe7b 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 80018ba:	4603      	mov	r3, r0
 80018bc:	3b05      	subs	r3, #5
 80018be:	2200      	movs	r2, #0
 80018c0:	9200      	str	r2, [sp, #0]
 80018c2:	4620      	mov	r0, r4
 80018c4:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80018c8:	461a      	mov	r2, r3
 80018ca:	f241 6311 	movw	r3, #5649	; 0x1611
 80018ce:	f6c0 0300 	movt	r3, #2048	; 0x800
 80018d2:	f00e ff45 	bl	8010760 <chThdCreateStatic>
 80018d6:	4602      	mov	r2, r0
 80018d8:	f641 6360 	movw	r3, #7776	; 0x1e60
 80018dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018e0:	611a      	str	r2, [r3, #16]
  n = msg_loop_test(threads[0]);
 80018e2:	f641 6360 	movw	r3, #7776	; 0x1e60
 80018e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018ea:	681b      	ldr	r3, [r3, #0]
 80018ec:	4618      	mov	r0, r3
 80018ee:	f7ff feb7 	bl	8001660 <msg_loop_test.14105.4240>
 80018f2:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 80018f4:	f006 fec4 	bl	8008680 <test_wait_threads>
  test_print("--- Score : ");
 80018f8:	f640 2010 	movw	r0, #2576	; 0xa10
 80018fc:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001900:	f006 fd7e 	bl	8008400 <test_print>
  test_printn(n);
 8001904:	9803      	ldr	r0, [sp, #12]
 8001906:	f006 fd23 	bl	8008350 <test_printn>
  test_print(" msgs/S, ");
 800190a:	f640 2020 	movw	r0, #2592	; 0xa20
 800190e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001912:	f006 fd75 	bl	8008400 <test_print>
  test_printn(n << 1);
 8001916:	9b03      	ldr	r3, [sp, #12]
 8001918:	005b      	lsls	r3, r3, #1
 800191a:	4618      	mov	r0, r3
 800191c:	f006 fd18 	bl	8008350 <test_printn>
  test_println(" ctxswc/S");
 8001920:	f640 202c 	movw	r0, #2604	; 0xa2c
 8001924:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001928:	f006 fd8a 	bl	8008440 <test_println>
}
 800192c:	b004      	add	sp, #16
 800192e:	bd10      	pop	{r4, pc}

08001930 <thread4.14058.4228>:
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 8001930:	b500      	push	{lr}
 8001932:	b085      	sub	sp, #20
 8001934:	9001      	str	r0, [sp, #4]
  msg_t msg;
  thread_t *self = chThdGetSelfX();
 8001936:	f7ff fe33 	bl	80015a0 <chThdGetSelfX.13945.4266>
 800193a:	9003      	str	r0, [sp, #12]

  (void)p;
  chSysLock();
 800193c:	f7ff fe00 	bl	8001540 <chSysLock.14054.4270>
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8001940:	2003      	movs	r0, #3
 8001942:	f00e fad5 	bl	800fef0 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
 8001946:	9b03      	ldr	r3, [sp, #12]
 8001948:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800194a:	9302      	str	r3, [sp, #8]
  } while (msg == MSG_OK);
 800194c:	9b02      	ldr	r3, [sp, #8]
 800194e:	2b00      	cmp	r3, #0
 8001950:	d0f6      	beq.n	8001940 <thread4.14058.4228+0x10>
  chSysUnlock();
 8001952:	f7ff fdfd 	bl	8001550 <chSysUnlock.14056.4268>
}
 8001956:	b005      	add	sp, #20
 8001958:	f85d fb04 	ldr.w	pc, [sp], #4
 800195c:	f3af 8000 	nop.w

08001960 <bmk4_execute.14061>:

static void bmk4_execute(void) {
 8001960:	b510      	push	{r4, lr}
 8001962:	b084      	sub	sp, #16
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8001964:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001968:	f6c0 0301 	movt	r3, #2049	; 0x801
 800196c:	681c      	ldr	r4, [r3, #0]
 800196e:	f7ff fe1f 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001972:	4603      	mov	r3, r0
 8001974:	3301      	adds	r3, #1
 8001976:	2200      	movs	r2, #0
 8001978:	9200      	str	r2, [sp, #0]
 800197a:	4620      	mov	r0, r4
 800197c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001980:	461a      	mov	r2, r3
 8001982:	f641 1331 	movw	r3, #6449	; 0x1931
 8001986:	f6c0 0300 	movt	r3, #2048	; 0x800
 800198a:	f00e fee9 	bl	8010760 <chThdCreateStatic>
 800198e:	4602      	mov	r2, r0
 8001990:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001994:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001998:	601a      	str	r2, [r3, #0]
 800199a:	f641 6360 	movw	r3, #7776	; 0x1e60
 800199e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019a2:	681b      	ldr	r3, [r3, #0]
 80019a4:	9302      	str	r3, [sp, #8]
                                      thread4, NULL);
  n = 0;
 80019a6:	2300      	movs	r3, #0
 80019a8:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 80019aa:	f006 fe99 	bl	80086e0 <test_wait_tick>
  test_start_timer(1000);
 80019ae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80019b2:	f006 feb5 	bl	8008720 <test_start_timer>
  do {
    chSysLock();
 80019b6:	f7ff fdc3 	bl	8001540 <chSysLock.14054.4270>
    chSchWakeupS(tp, MSG_OK);
 80019ba:	9802      	ldr	r0, [sp, #8]
 80019bc:	2100      	movs	r1, #0
 80019be:	f00e fb67 	bl	8010090 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 80019c2:	9802      	ldr	r0, [sp, #8]
 80019c4:	2100      	movs	r1, #0
 80019c6:	f00e fb63 	bl	8010090 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 80019ca:	9802      	ldr	r0, [sp, #8]
 80019cc:	2100      	movs	r1, #0
 80019ce:	f00e fb5f 	bl	8010090 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 80019d2:	9802      	ldr	r0, [sp, #8]
 80019d4:	2100      	movs	r1, #0
 80019d6:	f00e fb5b 	bl	8010090 <chSchWakeupS>
    chSysUnlock();
 80019da:	f7ff fdb9 	bl	8001550 <chSysUnlock.14056.4268>
    n += 4;
 80019de:	9b03      	ldr	r3, [sp, #12]
 80019e0:	3304      	adds	r3, #4
 80019e2:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80019e4:	f641 6378 	movw	r3, #7800	; 0x1e78
 80019e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019ec:	781b      	ldrb	r3, [r3, #0]
 80019ee:	f083 0301 	eor.w	r3, r3, #1
 80019f2:	b2db      	uxtb	r3, r3
 80019f4:	2b00      	cmp	r3, #0
 80019f6:	d1de      	bne.n	80019b6 <bmk4_execute.14061+0x56>
  chSysLock();
 80019f8:	f7ff fda2 	bl	8001540 <chSysLock.14054.4270>
  chSchWakeupS(tp, MSG_TIMEOUT);
 80019fc:	9802      	ldr	r0, [sp, #8]
 80019fe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8001a02:	f00e fb45 	bl	8010090 <chSchWakeupS>
  chSysUnlock();
 8001a06:	f7ff fda3 	bl	8001550 <chSysUnlock.14056.4268>

  test_wait_threads();
 8001a0a:	f006 fe39 	bl	8008680 <test_wait_threads>
  test_print("--- Score : ");
 8001a0e:	f640 2010 	movw	r0, #2576	; 0xa10
 8001a12:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001a16:	f006 fcf3 	bl	8008400 <test_print>
  test_printn(n * 2);
 8001a1a:	9b03      	ldr	r3, [sp, #12]
 8001a1c:	005b      	lsls	r3, r3, #1
 8001a1e:	4618      	mov	r0, r3
 8001a20:	f006 fc96 	bl	8008350 <test_printn>
  test_println(" ctxswc/S");
 8001a24:	f640 202c 	movw	r0, #2604	; 0xa2c
 8001a28:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001a2c:	f006 fd08 	bl	8008440 <test_println>
}
 8001a30:	b004      	add	sp, #16
 8001a32:	bd10      	pop	{r4, pc}
 8001a34:	f3af 8000 	nop.w
 8001a38:	f3af 8000 	nop.w
 8001a3c:	f3af 8000 	nop.w

08001a40 <bmk5_execute.14063>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8001a40:	b500      	push	{lr}
 8001a42:	b087      	sub	sp, #28

  uint32_t n = 0;
 8001a44:	2300      	movs	r3, #0
 8001a46:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 8001a48:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001a4c:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001a50:	681b      	ldr	r3, [r3, #0]
 8001a52:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() - 1;
 8001a54:	f7ff fdac 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001a58:	4603      	mov	r3, r0
 8001a5a:	3b01      	subs	r3, #1
 8001a5c:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001a5e:	f006 fe3f 	bl	80086e0 <test_wait_tick>
  test_start_timer(1000);
 8001a62:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001a66:	f006 fe5b 	bl	8008720 <test_start_timer>
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8001a6a:	2300      	movs	r3, #0
 8001a6c:	9300      	str	r3, [sp, #0]
 8001a6e:	9804      	ldr	r0, [sp, #16]
 8001a70:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001a74:	9a03      	ldr	r2, [sp, #12]
 8001a76:	f241 6311 	movw	r3, #5649	; 0x1611
 8001a7a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001a7e:	f00e fe6f 	bl	8010760 <chThdCreateStatic>
 8001a82:	4603      	mov	r3, r0
 8001a84:	4618      	mov	r0, r3
 8001a86:	f00c f863 	bl	800db50 <chThdWait>
    n++;
 8001a8a:	9b05      	ldr	r3, [sp, #20]
 8001a8c:	3301      	adds	r3, #1
 8001a8e:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001a90:	f641 6378 	movw	r3, #7800	; 0x1e78
 8001a94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a98:	781b      	ldrb	r3, [r3, #0]
 8001a9a:	f083 0301 	eor.w	r3, r3, #1
 8001a9e:	b2db      	uxtb	r3, r3
 8001aa0:	2b00      	cmp	r3, #0
 8001aa2:	d1e2      	bne.n	8001a6a <bmk5_execute.14063+0x2a>
  test_print("--- Score : ");
 8001aa4:	f640 2010 	movw	r0, #2576	; 0xa10
 8001aa8:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001aac:	f006 fca8 	bl	8008400 <test_print>
  test_printn(n);
 8001ab0:	9805      	ldr	r0, [sp, #20]
 8001ab2:	f006 fc4d 	bl	8008350 <test_printn>
  test_println(" threads/S");
 8001ab6:	f640 2038 	movw	r0, #2616	; 0xa38
 8001aba:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001abe:	f006 fcbf 	bl	8008440 <test_println>
}
 8001ac2:	b007      	add	sp, #28
 8001ac4:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ac8:	f3af 8000 	nop.w
 8001acc:	f3af 8000 	nop.w

08001ad0 <bmk6_execute.14050>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 8001ad0:	b500      	push	{lr}
 8001ad2:	b087      	sub	sp, #28

  uint32_t n = 0;
 8001ad4:	2300      	movs	r3, #0
 8001ad6:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 8001ad8:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001adc:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001ae0:	681b      	ldr	r3, [r3, #0]
 8001ae2:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() + 1;
 8001ae4:	f7ff fd64 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001ae8:	4603      	mov	r3, r0
 8001aea:	3301      	adds	r3, #1
 8001aec:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001aee:	f006 fdf7 	bl	80086e0 <test_wait_tick>
  test_start_timer(1000);
 8001af2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001af6:	f006 fe13 	bl	8008720 <test_start_timer>
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 8001afa:	2300      	movs	r3, #0
 8001afc:	9300      	str	r3, [sp, #0]
 8001afe:	9804      	ldr	r0, [sp, #16]
 8001b00:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001b04:	9a03      	ldr	r2, [sp, #12]
 8001b06:	f241 6311 	movw	r3, #5649	; 0x1611
 8001b0a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001b0e:	f00e fe27 	bl	8010760 <chThdCreateStatic>
    n++;
 8001b12:	9b05      	ldr	r3, [sp, #20]
 8001b14:	3301      	adds	r3, #1
 8001b16:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001b18:	f641 6378 	movw	r3, #7800	; 0x1e78
 8001b1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b20:	781b      	ldrb	r3, [r3, #0]
 8001b22:	f083 0301 	eor.w	r3, r3, #1
 8001b26:	b2db      	uxtb	r3, r3
 8001b28:	2b00      	cmp	r3, #0
 8001b2a:	d1e6      	bne.n	8001afa <bmk6_execute.14050+0x2a>
  test_print("--- Score : ");
 8001b2c:	f640 2010 	movw	r0, #2576	; 0xa10
 8001b30:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001b34:	f006 fc64 	bl	8008400 <test_print>
  test_printn(n);
 8001b38:	9805      	ldr	r0, [sp, #20]
 8001b3a:	f006 fc09 	bl	8008350 <test_printn>
  test_println(" threads/S");
 8001b3e:	f640 2038 	movw	r0, #2616	; 0xa38
 8001b42:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001b46:	f006 fc7b 	bl	8008440 <test_println>
}
 8001b4a:	b007      	add	sp, #28
 8001b4c:	f85d fb04 	ldr.w	pc, [sp], #4

08001b50 <thread3.14065.4214>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 8001b50:	b500      	push	{lr}
 8001b52:	b083      	sub	sp, #12
 8001b54:	9001      	str	r0, [sp, #4]
 8001b56:	e005      	b.n	8001b64 <thread3.14065.4214+0x14>

  (void)p;
  while (!chThdShouldTerminateX())
    chSemWait(&sem1);
 8001b58:	f641 60dc 	movw	r0, #7900	; 0x1edc
 8001b5c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001b60:	f00c fd46 	bl	800e5f0 <chSemWait>
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 8001b64:	f7ff fd2c 	bl	80015c0 <chThdShouldTerminateX.14035.4262>
 8001b68:	4603      	mov	r3, r0
 8001b6a:	f083 0301 	eor.w	r3, r3, #1
 8001b6e:	b2db      	uxtb	r3, r3
 8001b70:	2b00      	cmp	r3, #0
 8001b72:	d1f1      	bne.n	8001b58 <thread3.14065.4214+0x8>
    chSemWait(&sem1);
}
 8001b74:	b003      	add	sp, #12
 8001b76:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b7a:	bf00      	nop
 8001b7c:	f3af 8000 	nop.w

08001b80 <bmk7_setup.14068>:

static void bmk7_setup(void) {
 8001b80:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 8001b82:	f641 60dc 	movw	r0, #7900	; 0x1edc
 8001b86:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001b8a:	2100      	movs	r1, #0
 8001b8c:	f00c fca8 	bl	800e4e0 <chSemObjectInit>
}
 8001b90:	bd08      	pop	{r3, pc}
 8001b92:	bf00      	nop
 8001b94:	f3af 8000 	nop.w
 8001b98:	f3af 8000 	nop.w
 8001b9c:	f3af 8000 	nop.w

08001ba0 <bmk7_execute.14072>:

static void bmk7_execute(void) {
 8001ba0:	b510      	push	{r4, lr}
 8001ba2:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8001ba4:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001ba8:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001bac:	681c      	ldr	r4, [r3, #0]
 8001bae:	f7ff fcff 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001bb2:	4603      	mov	r3, r0
 8001bb4:	3305      	adds	r3, #5
 8001bb6:	2200      	movs	r2, #0
 8001bb8:	9200      	str	r2, [sp, #0]
 8001bba:	4620      	mov	r0, r4
 8001bbc:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001bc0:	461a      	mov	r2, r3
 8001bc2:	f641 3351 	movw	r3, #6993	; 0x1b51
 8001bc6:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001bca:	f00e fdc9 	bl	8010760 <chThdCreateStatic>
 8001bce:	4602      	mov	r2, r0
 8001bd0:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001bd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001bd8:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8001bda:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001bde:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001be2:	685c      	ldr	r4, [r3, #4]
 8001be4:	f7ff fce4 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001be8:	4603      	mov	r3, r0
 8001bea:	3304      	adds	r3, #4
 8001bec:	2200      	movs	r2, #0
 8001bee:	9200      	str	r2, [sp, #0]
 8001bf0:	4620      	mov	r0, r4
 8001bf2:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001bf6:	461a      	mov	r2, r3
 8001bf8:	f641 3351 	movw	r3, #6993	; 0x1b51
 8001bfc:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001c00:	f00e fdae 	bl	8010760 <chThdCreateStatic>
 8001c04:	4602      	mov	r2, r0
 8001c06:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001c0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c0e:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8001c10:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001c14:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001c18:	689c      	ldr	r4, [r3, #8]
 8001c1a:	f7ff fcc9 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001c1e:	4603      	mov	r3, r0
 8001c20:	3303      	adds	r3, #3
 8001c22:	2200      	movs	r2, #0
 8001c24:	9200      	str	r2, [sp, #0]
 8001c26:	4620      	mov	r0, r4
 8001c28:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001c2c:	461a      	mov	r2, r3
 8001c2e:	f641 3351 	movw	r3, #6993	; 0x1b51
 8001c32:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001c36:	f00e fd93 	bl	8010760 <chThdCreateStatic>
 8001c3a:	4602      	mov	r2, r0
 8001c3c:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001c40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c44:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8001c46:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001c4a:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001c4e:	68dc      	ldr	r4, [r3, #12]
 8001c50:	f7ff fcae 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001c54:	4603      	mov	r3, r0
 8001c56:	3302      	adds	r3, #2
 8001c58:	2200      	movs	r2, #0
 8001c5a:	9200      	str	r2, [sp, #0]
 8001c5c:	4620      	mov	r0, r4
 8001c5e:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001c62:	461a      	mov	r2, r3
 8001c64:	f641 3351 	movw	r3, #6993	; 0x1b51
 8001c68:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001c6c:	f00e fd78 	bl	8010760 <chThdCreateStatic>
 8001c70:	4602      	mov	r2, r0
 8001c72:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001c76:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c7a:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8001c7c:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001c80:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001c84:	691c      	ldr	r4, [r3, #16]
 8001c86:	f7ff fc93 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001c8a:	4603      	mov	r3, r0
 8001c8c:	3301      	adds	r3, #1
 8001c8e:	2200      	movs	r2, #0
 8001c90:	9200      	str	r2, [sp, #0]
 8001c92:	4620      	mov	r0, r4
 8001c94:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001c98:	461a      	mov	r2, r3
 8001c9a:	f641 3351 	movw	r3, #6993	; 0x1b51
 8001c9e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001ca2:	f00e fd5d 	bl	8010760 <chThdCreateStatic>
 8001ca6:	4602      	mov	r2, r0
 8001ca8:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001cac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001cb0:	611a      	str	r2, [r3, #16]

  n = 0;
 8001cb2:	2300      	movs	r3, #0
 8001cb4:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001cb6:	f006 fd13 	bl	80086e0 <test_wait_tick>
  test_start_timer(1000);
 8001cba:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001cbe:	f006 fd2f 	bl	8008720 <test_start_timer>
  do {
    chSemReset(&sem1, 0);
 8001cc2:	f641 60dc 	movw	r0, #7900	; 0x1edc
 8001cc6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001cca:	2100      	movs	r1, #0
 8001ccc:	f00c fc28 	bl	800e520 <chSemReset>
    n++;
 8001cd0:	9b03      	ldr	r3, [sp, #12]
 8001cd2:	3301      	adds	r3, #1
 8001cd4:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001cd6:	f641 6378 	movw	r3, #7800	; 0x1e78
 8001cda:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001cde:	781b      	ldrb	r3, [r3, #0]
 8001ce0:	f083 0301 	eor.w	r3, r3, #1
 8001ce4:	b2db      	uxtb	r3, r3
 8001ce6:	2b00      	cmp	r3, #0
 8001ce8:	d1eb      	bne.n	8001cc2 <bmk7_execute.14072+0x122>
  test_terminate_threads();
 8001cea:	f006 fca1 	bl	8008630 <test_terminate_threads>
  chSemReset(&sem1, 0);
 8001cee:	f641 60dc 	movw	r0, #7900	; 0x1edc
 8001cf2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001cf6:	2100      	movs	r1, #0
 8001cf8:	f00c fc12 	bl	800e520 <chSemReset>
  test_wait_threads();
 8001cfc:	f006 fcc0 	bl	8008680 <test_wait_threads>

  test_print("--- Score : ");
 8001d00:	f640 2010 	movw	r0, #2576	; 0xa10
 8001d04:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001d08:	f006 fb7a 	bl	8008400 <test_print>
  test_printn(n);
 8001d0c:	9803      	ldr	r0, [sp, #12]
 8001d0e:	f006 fb1f 	bl	8008350 <test_printn>
  test_print(" reschedules/S, ");
 8001d12:	f640 2044 	movw	r0, #2628	; 0xa44
 8001d16:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001d1a:	f006 fb71 	bl	8008400 <test_print>
  test_printn(n * 6);
 8001d1e:	9a03      	ldr	r2, [sp, #12]
 8001d20:	4613      	mov	r3, r2
 8001d22:	005b      	lsls	r3, r3, #1
 8001d24:	4413      	add	r3, r2
 8001d26:	005b      	lsls	r3, r3, #1
 8001d28:	4618      	mov	r0, r3
 8001d2a:	f006 fb11 	bl	8008350 <test_printn>
  test_println(" ctxswc/S");
 8001d2e:	f640 202c 	movw	r0, #2604	; 0xa2c
 8001d32:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001d36:	f006 fb83 	bl	8008440 <test_println>
}
 8001d3a:	b004      	add	sp, #16
 8001d3c:	bd10      	pop	{r4, pc}
 8001d3e:	bf00      	nop

08001d40 <thread8.14074.4209>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 8001d40:	b500      	push	{lr}
 8001d42:	b083      	sub	sp, #12
 8001d44:	9001      	str	r0, [sp, #4]

  do {
    chThdYield();
 8001d46:	f00b feab 	bl	800daa0 <chThdYield>
    chThdYield();
 8001d4a:	f00b fea9 	bl	800daa0 <chThdYield>
    chThdYield();
 8001d4e:	f00b fea7 	bl	800daa0 <chThdYield>
    chThdYield();
 8001d52:	f00b fea5 	bl	800daa0 <chThdYield>
    (*(uint32_t *)p) += 4;
 8001d56:	9b01      	ldr	r3, [sp, #4]
 8001d58:	681b      	ldr	r3, [r3, #0]
 8001d5a:	1d1a      	adds	r2, r3, #4
 8001d5c:	9b01      	ldr	r3, [sp, #4]
 8001d5e:	601a      	str	r2, [r3, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8001d60:	f7ff fc2e 	bl	80015c0 <chThdShouldTerminateX.14035.4262>
 8001d64:	4603      	mov	r3, r0
 8001d66:	f083 0301 	eor.w	r3, r3, #1
 8001d6a:	b2db      	uxtb	r3, r3
 8001d6c:	2b00      	cmp	r3, #0
 8001d6e:	d1ea      	bne.n	8001d46 <thread8.14074.4209+0x6>
}
 8001d70:	b003      	add	sp, #12
 8001d72:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d76:	bf00      	nop
 8001d78:	f3af 8000 	nop.w
 8001d7c:	f3af 8000 	nop.w

08001d80 <bmk8_execute.14077>:

static void bmk8_execute(void) {
 8001d80:	b510      	push	{r4, lr}
 8001d82:	b084      	sub	sp, #16
  uint32_t n;

  n = 0;
 8001d84:	2300      	movs	r3, #0
 8001d86:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001d88:	f006 fcaa 	bl	80086e0 <test_wait_tick>

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001d8c:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001d90:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001d94:	681c      	ldr	r4, [r3, #0]
 8001d96:	f7ff fc0b 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001d9a:	4603      	mov	r3, r0
 8001d9c:	3b01      	subs	r3, #1
 8001d9e:	aa03      	add	r2, sp, #12
 8001da0:	9200      	str	r2, [sp, #0]
 8001da2:	4620      	mov	r0, r4
 8001da4:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001da8:	461a      	mov	r2, r3
 8001daa:	f641 5341 	movw	r3, #7489	; 0x1d41
 8001dae:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001db2:	f00e fcd5 	bl	8010760 <chThdCreateStatic>
 8001db6:	4602      	mov	r2, r0
 8001db8:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001dc0:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001dc2:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001dc6:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001dca:	685c      	ldr	r4, [r3, #4]
 8001dcc:	f7ff fbf0 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001dd0:	4603      	mov	r3, r0
 8001dd2:	3b01      	subs	r3, #1
 8001dd4:	aa03      	add	r2, sp, #12
 8001dd6:	9200      	str	r2, [sp, #0]
 8001dd8:	4620      	mov	r0, r4
 8001dda:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001dde:	461a      	mov	r2, r3
 8001de0:	f641 5341 	movw	r3, #7489	; 0x1d41
 8001de4:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001de8:	f00e fcba 	bl	8010760 <chThdCreateStatic>
 8001dec:	4602      	mov	r2, r0
 8001dee:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001df2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001df6:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001df8:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001dfc:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001e00:	689c      	ldr	r4, [r3, #8]
 8001e02:	f7ff fbd5 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001e06:	4603      	mov	r3, r0
 8001e08:	3b01      	subs	r3, #1
 8001e0a:	aa03      	add	r2, sp, #12
 8001e0c:	9200      	str	r2, [sp, #0]
 8001e0e:	4620      	mov	r0, r4
 8001e10:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001e14:	461a      	mov	r2, r3
 8001e16:	f641 5341 	movw	r3, #7489	; 0x1d41
 8001e1a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001e1e:	f00e fc9f 	bl	8010760 <chThdCreateStatic>
 8001e22:	4602      	mov	r2, r0
 8001e24:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001e28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001e2c:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001e2e:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001e32:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001e36:	68dc      	ldr	r4, [r3, #12]
 8001e38:	f7ff fbba 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001e3c:	4603      	mov	r3, r0
 8001e3e:	3b01      	subs	r3, #1
 8001e40:	aa03      	add	r2, sp, #12
 8001e42:	9200      	str	r2, [sp, #0]
 8001e44:	4620      	mov	r0, r4
 8001e46:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001e4a:	461a      	mov	r2, r3
 8001e4c:	f641 5341 	movw	r3, #7489	; 0x1d41
 8001e50:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001e54:	f00e fc84 	bl	8010760 <chThdCreateStatic>
 8001e58:	4602      	mov	r2, r0
 8001e5a:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001e5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001e62:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001e64:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8001e68:	f6c0 0301 	movt	r3, #2049	; 0x801
 8001e6c:	691c      	ldr	r4, [r3, #16]
 8001e6e:	f7ff fb9f 	bl	80015b0 <chThdGetPriorityX.14033.4264>
 8001e72:	4603      	mov	r3, r0
 8001e74:	3b01      	subs	r3, #1
 8001e76:	aa03      	add	r2, sp, #12
 8001e78:	9200      	str	r2, [sp, #0]
 8001e7a:	4620      	mov	r0, r4
 8001e7c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001e80:	461a      	mov	r2, r3
 8001e82:	f641 5341 	movw	r3, #7489	; 0x1d41
 8001e86:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001e8a:	f00e fc69 	bl	8010760 <chThdCreateStatic>
 8001e8e:	4602      	mov	r2, r0
 8001e90:	f641 6360 	movw	r3, #7776	; 0x1e60
 8001e94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001e98:	611a      	str	r2, [r3, #16]

  chThdSleepSeconds(1);
 8001e9a:	f242 7010 	movw	r0, #10000	; 0x2710
 8001e9e:	f00b fdd7 	bl	800da50 <chThdSleep>
  test_terminate_threads();
 8001ea2:	f006 fbc5 	bl	8008630 <test_terminate_threads>
  test_wait_threads();
 8001ea6:	f006 fbeb 	bl	8008680 <test_wait_threads>

  test_print("--- Score : ");
 8001eaa:	f640 2010 	movw	r0, #2576	; 0xa10
 8001eae:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001eb2:	f006 faa5 	bl	8008400 <test_print>
  test_printn(n);
 8001eb6:	9b03      	ldr	r3, [sp, #12]
 8001eb8:	4618      	mov	r0, r3
 8001eba:	f006 fa49 	bl	8008350 <test_printn>
  test_println(" ctxswc/S");
 8001ebe:	f640 202c 	movw	r0, #2604	; 0xa2c
 8001ec2:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001ec6:	f006 fabb 	bl	8008440 <test_println>
}
 8001eca:	b004      	add	sp, #16
 8001ecc:	bd10      	pop	{r4, pc}
 8001ece:	bf00      	nop

08001ed0 <bmk9_execute.14095>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 8001ed0:	b500      	push	{lr}
 8001ed2:	b085      	sub	sp, #20
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
 8001ed4:	2300      	movs	r3, #0
 8001ed6:	9300      	str	r3, [sp, #0]
 8001ed8:	f641 60f8 	movw	r0, #7928	; 0x1ef8
 8001edc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001ee0:	f641 711c 	movw	r1, #7964	; 0x1f1c
 8001ee4:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8001ee8:	2210      	movs	r2, #16
 8001eea:	2300      	movs	r3, #0
 8001eec:	f008 ffc8 	bl	800ae80 <chIQObjectInit>
  n = 0;
 8001ef0:	2300      	movs	r3, #0
 8001ef2:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001ef4:	f006 fbf4 	bl	80086e0 <test_wait_tick>
  test_start_timer(1000);
 8001ef8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001efc:	f006 fc10 	bl	8008720 <test_start_timer>
  do {
    chSysLock();
 8001f00:	f7ff fb1e 	bl	8001540 <chSysLock.14054.4270>
    chIQPutI(&iq, 0);
 8001f04:	f641 60f8 	movw	r0, #7928	; 0x1ef8
 8001f08:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001f0c:	2100      	movs	r1, #0
 8001f0e:	f008 ffff 	bl	800af10 <chIQPutI>
    chIQPutI(&iq, 1);
 8001f12:	f641 60f8 	movw	r0, #7928	; 0x1ef8
 8001f16:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001f1a:	2101      	movs	r1, #1
 8001f1c:	f008 fff8 	bl	800af10 <chIQPutI>
    chIQPutI(&iq, 2);
 8001f20:	f641 60f8 	movw	r0, #7928	; 0x1ef8
 8001f24:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001f28:	2102      	movs	r1, #2
 8001f2a:	f008 fff1 	bl	800af10 <chIQPutI>
    chIQPutI(&iq, 3);
 8001f2e:	f641 60f8 	movw	r0, #7928	; 0x1ef8
 8001f32:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001f36:	2103      	movs	r1, #3
 8001f38:	f008 ffea 	bl	800af10 <chIQPutI>
    chSysUnlock();
 8001f3c:	f7ff fb08 	bl	8001550 <chSysUnlock.14056.4268>
    (void)chIQGet(&iq);
 8001f40:	f641 60f8 	movw	r0, #7928	; 0x1ef8
 8001f44:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001f48:	f7ff fb52 	bl	80015f0 <chIQGet.14079.4243>
    (void)chIQGet(&iq);
 8001f4c:	f641 60f8 	movw	r0, #7928	; 0x1ef8
 8001f50:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001f54:	f7ff fb4c 	bl	80015f0 <chIQGet.14079.4243>
    (void)chIQGet(&iq);
 8001f58:	f641 60f8 	movw	r0, #7928	; 0x1ef8
 8001f5c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001f60:	f7ff fb46 	bl	80015f0 <chIQGet.14079.4243>
    (void)chIQGet(&iq);
 8001f64:	f641 60f8 	movw	r0, #7928	; 0x1ef8
 8001f68:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001f6c:	f7ff fb40 	bl	80015f0 <chIQGet.14079.4243>
    n++;
 8001f70:	9b03      	ldr	r3, [sp, #12]
 8001f72:	3301      	adds	r3, #1
 8001f74:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001f76:	f641 6378 	movw	r3, #7800	; 0x1e78
 8001f7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f7e:	781b      	ldrb	r3, [r3, #0]
 8001f80:	f083 0301 	eor.w	r3, r3, #1
 8001f84:	b2db      	uxtb	r3, r3
 8001f86:	2b00      	cmp	r3, #0
 8001f88:	d1ba      	bne.n	8001f00 <bmk9_execute.14095+0x30>
  test_print("--- Score : ");
 8001f8a:	f640 2010 	movw	r0, #2576	; 0xa10
 8001f8e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001f92:	f006 fa35 	bl	8008400 <test_print>
  test_printn(n * 4);
 8001f96:	9b03      	ldr	r3, [sp, #12]
 8001f98:	009b      	lsls	r3, r3, #2
 8001f9a:	4618      	mov	r0, r3
 8001f9c:	f006 f9d8 	bl	8008350 <test_printn>
  test_println(" bytes/S");
 8001fa0:	f640 2058 	movw	r0, #2648	; 0xa58
 8001fa4:	f6c0 0001 	movt	r0, #2049	; 0x801
 8001fa8:	f006 fa4a 	bl	8008440 <test_println>
}
 8001fac:	b005      	add	sp, #20
 8001fae:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fb2:	bf00      	nop
 8001fb4:	f3af 8000 	nop.w
 8001fb8:	f3af 8000 	nop.w
 8001fbc:	f3af 8000 	nop.w

08001fc0 <tmo.14041.4202>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 8001fc0:	b082      	sub	sp, #8
 8001fc2:	9001      	str	r0, [sp, #4]
 8001fc4:	b002      	add	sp, #8
 8001fc6:	4770      	bx	lr
 8001fc8:	f3af 8000 	nop.w
 8001fcc:	f3af 8000 	nop.w

08001fd0 <bmk10_execute.14097>:

static void bmk10_execute(void) {
 8001fd0:	b500      	push	{lr}
 8001fd2:	b083      	sub	sp, #12
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 8001fd4:	2300      	movs	r3, #0
 8001fd6:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8001fd8:	f006 fb82 	bl	80086e0 <test_wait_tick>
  test_start_timer(1000);
 8001fdc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001fe0:	f006 fb9e 	bl	8008720 <test_start_timer>
  do {
    chSysLock();
 8001fe4:	f7ff faac 	bl	8001540 <chSysLock.14054.4270>
    chVTDoSetI(&vt1, 1, tmo, NULL);
 8001fe8:	f641 702c 	movw	r0, #7980	; 0x1f2c
 8001fec:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001ff0:	2101      	movs	r1, #1
 8001ff2:	f641 72c1 	movw	r2, #8129	; 0x1fc1
 8001ff6:	f6c0 0200 	movt	r2, #2048	; 0x800
 8001ffa:	2300      	movs	r3, #0
 8001ffc:	f00d fd28 	bl	800fa50 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8002000:	f641 7040 	movw	r0, #8000	; 0x1f40
 8002004:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002008:	f242 7110 	movw	r1, #10000	; 0x2710
 800200c:	f641 72c1 	movw	r2, #8129	; 0x1fc1
 8002010:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002014:	2300      	movs	r3, #0
 8002016:	f00d fd1b 	bl	800fa50 <chVTDoSetI>
    chVTDoResetI(&vt1);
 800201a:	f641 702c 	movw	r0, #7980	; 0x1f2c
 800201e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002022:	f00d fdbd 	bl	800fba0 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8002026:	f641 7040 	movw	r0, #8000	; 0x1f40
 800202a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800202e:	f00d fdb7 	bl	800fba0 <chVTDoResetI>
    chSysUnlock();
 8002032:	f7ff fa8d 	bl	8001550 <chSysUnlock.14056.4268>
    n++;
 8002036:	9b01      	ldr	r3, [sp, #4]
 8002038:	3301      	adds	r3, #1
 800203a:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800203c:	f641 6378 	movw	r3, #7800	; 0x1e78
 8002040:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002044:	781b      	ldrb	r3, [r3, #0]
 8002046:	f083 0301 	eor.w	r3, r3, #1
 800204a:	b2db      	uxtb	r3, r3
 800204c:	2b00      	cmp	r3, #0
 800204e:	d1c9      	bne.n	8001fe4 <bmk10_execute.14097+0x14>
  test_print("--- Score : ");
 8002050:	f640 2010 	movw	r0, #2576	; 0xa10
 8002054:	f6c0 0001 	movt	r0, #2049	; 0x801
 8002058:	f006 f9d2 	bl	8008400 <test_print>
  test_printn(n * 2);
 800205c:	9b01      	ldr	r3, [sp, #4]
 800205e:	005b      	lsls	r3, r3, #1
 8002060:	4618      	mov	r0, r3
 8002062:	f006 f975 	bl	8008350 <test_printn>
  test_println(" timers/S");
 8002066:	f640 2064 	movw	r0, #2660	; 0xa64
 800206a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800206e:	f006 f9e7 	bl	8008440 <test_println>
}
 8002072:	b003      	add	sp, #12
 8002074:	f85d fb04 	ldr.w	pc, [sp], #4
 8002078:	f3af 8000 	nop.w
 800207c:	f3af 8000 	nop.w

08002080 <bmk11_setup.14070>:
 * Switch happens because the counter is always non negative.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk11_setup(void) {
 8002080:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 1);
 8002082:	f641 60dc 	movw	r0, #7900	; 0x1edc
 8002086:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800208a:	2101      	movs	r1, #1
 800208c:	f00c fa28 	bl	800e4e0 <chSemObjectInit>
}
 8002090:	bd08      	pop	{r3, pc}
 8002092:	bf00      	nop
 8002094:	f3af 8000 	nop.w
 8002098:	f3af 8000 	nop.w
 800209c:	f3af 8000 	nop.w

080020a0 <bmk11_execute.14099>:

static void bmk11_execute(void) {
 80020a0:	b500      	push	{lr}
 80020a2:	b083      	sub	sp, #12
  uint32_t n = 0;
 80020a4:	2300      	movs	r3, #0
 80020a6:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 80020a8:	f006 fb1a 	bl	80086e0 <test_wait_tick>
  test_start_timer(1000);
 80020ac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80020b0:	f006 fb36 	bl	8008720 <test_start_timer>
  do {
    chSemWait(&sem1);
 80020b4:	f641 60dc 	movw	r0, #7900	; 0x1edc
 80020b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80020bc:	f00c fa98 	bl	800e5f0 <chSemWait>
    chSemSignal(&sem1);
 80020c0:	f641 60dc 	movw	r0, #7900	; 0x1edc
 80020c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80020c8:	f00c fb82 	bl	800e7d0 <chSemSignal>
    chSemWait(&sem1);
 80020cc:	f641 60dc 	movw	r0, #7900	; 0x1edc
 80020d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80020d4:	f00c fa8c 	bl	800e5f0 <chSemWait>
    chSemSignal(&sem1);
 80020d8:	f641 60dc 	movw	r0, #7900	; 0x1edc
 80020dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80020e0:	f00c fb76 	bl	800e7d0 <chSemSignal>
    chSemWait(&sem1);
 80020e4:	f641 60dc 	movw	r0, #7900	; 0x1edc
 80020e8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80020ec:	f00c fa80 	bl	800e5f0 <chSemWait>
    chSemSignal(&sem1);
 80020f0:	f641 60dc 	movw	r0, #7900	; 0x1edc
 80020f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80020f8:	f00c fb6a 	bl	800e7d0 <chSemSignal>
    chSemWait(&sem1);
 80020fc:	f641 60dc 	movw	r0, #7900	; 0x1edc
 8002100:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002104:	f00c fa74 	bl	800e5f0 <chSemWait>
    chSemSignal(&sem1);
 8002108:	f641 60dc 	movw	r0, #7900	; 0x1edc
 800210c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002110:	f00c fb5e 	bl	800e7d0 <chSemSignal>
    n++;
 8002114:	9b01      	ldr	r3, [sp, #4]
 8002116:	3301      	adds	r3, #1
 8002118:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800211a:	f641 6378 	movw	r3, #7800	; 0x1e78
 800211e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002122:	781b      	ldrb	r3, [r3, #0]
 8002124:	f083 0301 	eor.w	r3, r3, #1
 8002128:	b2db      	uxtb	r3, r3
 800212a:	2b00      	cmp	r3, #0
 800212c:	d1c2      	bne.n	80020b4 <bmk11_execute.14099+0x14>
  test_print("--- Score : ");
 800212e:	f640 2010 	movw	r0, #2576	; 0xa10
 8002132:	f6c0 0001 	movt	r0, #2049	; 0x801
 8002136:	f006 f963 	bl	8008400 <test_print>
  test_printn(n * 4);
 800213a:	9b01      	ldr	r3, [sp, #4]
 800213c:	009b      	lsls	r3, r3, #2
 800213e:	4618      	mov	r0, r3
 8002140:	f006 f906 	bl	8008350 <test_printn>
  test_println(" wait+signal/S");
 8002144:	f640 2070 	movw	r0, #2672	; 0xa70
 8002148:	f6c0 0001 	movt	r0, #2049	; 0x801
 800214c:	f006 f978 	bl	8008440 <test_println>
}
 8002150:	b003      	add	sp, #12
 8002152:	f85d fb04 	ldr.w	pc, [sp], #4
 8002156:	bf00      	nop
 8002158:	f3af 8000 	nop.w
 800215c:	f3af 8000 	nop.w

08002160 <bmk12_setup.14101>:
 * because there are no other threads asking for the mutex.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk12_setup(void) {
 8002160:	b508      	push	{r3, lr}

  chMtxObjectInit(&mtx1);
 8002162:	f641 60e8 	movw	r0, #7912	; 0x1ee8
 8002166:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800216a:	f00c fd71 	bl	800ec50 <chMtxObjectInit>
}
 800216e:	bd08      	pop	{r3, pc}

08002170 <bmk12_execute.14103>:

static void bmk12_execute(void) {
 8002170:	b500      	push	{lr}
 8002172:	b083      	sub	sp, #12
  uint32_t n = 0;
 8002174:	2300      	movs	r3, #0
 8002176:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8002178:	f006 fab2 	bl	80086e0 <test_wait_tick>
  test_start_timer(1000);
 800217c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002180:	f006 face 	bl	8008720 <test_start_timer>
  do {
    chMtxLock(&mtx1);
 8002184:	f641 60e8 	movw	r0, #7912	; 0x1ee8
 8002188:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800218c:	f00c fd78 	bl	800ec80 <chMtxLock>
    chMtxUnlock(&mtx1);
 8002190:	f641 60e8 	movw	r0, #7912	; 0x1ee8
 8002194:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002198:	f00a f912 	bl	800c3c0 <chMtxUnlock>
    chMtxLock(&mtx1);
 800219c:	f641 60e8 	movw	r0, #7912	; 0x1ee8
 80021a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80021a4:	f00c fd6c 	bl	800ec80 <chMtxLock>
    chMtxUnlock(&mtx1);
 80021a8:	f641 60e8 	movw	r0, #7912	; 0x1ee8
 80021ac:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80021b0:	f00a f906 	bl	800c3c0 <chMtxUnlock>
    chMtxLock(&mtx1);
 80021b4:	f641 60e8 	movw	r0, #7912	; 0x1ee8
 80021b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80021bc:	f00c fd60 	bl	800ec80 <chMtxLock>
    chMtxUnlock(&mtx1);
 80021c0:	f641 60e8 	movw	r0, #7912	; 0x1ee8
 80021c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80021c8:	f00a f8fa 	bl	800c3c0 <chMtxUnlock>
    chMtxLock(&mtx1);
 80021cc:	f641 60e8 	movw	r0, #7912	; 0x1ee8
 80021d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80021d4:	f00c fd54 	bl	800ec80 <chMtxLock>
    chMtxUnlock(&mtx1);
 80021d8:	f641 60e8 	movw	r0, #7912	; 0x1ee8
 80021dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80021e0:	f00a f8ee 	bl	800c3c0 <chMtxUnlock>
    n++;
 80021e4:	9b01      	ldr	r3, [sp, #4]
 80021e6:	3301      	adds	r3, #1
 80021e8:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80021ea:	f641 6378 	movw	r3, #7800	; 0x1e78
 80021ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80021f2:	781b      	ldrb	r3, [r3, #0]
 80021f4:	f083 0301 	eor.w	r3, r3, #1
 80021f8:	b2db      	uxtb	r3, r3
 80021fa:	2b00      	cmp	r3, #0
 80021fc:	d1c2      	bne.n	8002184 <bmk12_execute.14103+0x14>
  test_print("--- Score : ");
 80021fe:	f640 2010 	movw	r0, #2576	; 0xa10
 8002202:	f6c0 0001 	movt	r0, #2049	; 0x801
 8002206:	f006 f8fb 	bl	8008400 <test_print>
  test_printn(n * 4);
 800220a:	9b01      	ldr	r3, [sp, #4]
 800220c:	009b      	lsls	r3, r3, #2
 800220e:	4618      	mov	r0, r3
 8002210:	f006 f89e 	bl	8008350 <test_printn>
  test_println(" lock+unlock/S");
 8002214:	f640 2080 	movw	r0, #2688	; 0xa80
 8002218:	f6c0 0001 	movt	r0, #2049	; 0x801
 800221c:	f006 f910 	bl	8008440 <test_println>
}
 8002220:	b003      	add	sp, #12
 8002222:	f85d fb04 	ldr.w	pc, [sp], #4
 8002226:	bf00      	nop
 8002228:	f3af 8000 	nop.w
 800222c:	f3af 8000 	nop.w

08002230 <bmk13_execute.14052>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 8002230:	b508      	push	{r3, lr}

  test_print("--- System: ");
 8002232:	f640 2090 	movw	r0, #2704	; 0xa90
 8002236:	f6c0 0001 	movt	r0, #2049	; 0x801
 800223a:	f006 f8e1 	bl	8008400 <test_print>
  test_printn(sizeof(ch_system_t));
 800223e:	f44f 60bb 	mov.w	r0, #1496	; 0x5d8
 8002242:	f006 f885 	bl	8008350 <test_printn>
  test_println(" bytes");
 8002246:	f640 20a0 	movw	r0, #2720	; 0xaa0
 800224a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800224e:	f006 f8f7 	bl	8008440 <test_println>
  test_print("--- Thread: ");
 8002252:	f640 20a8 	movw	r0, #2728	; 0xaa8
 8002256:	f6c0 0001 	movt	r0, #2049	; 0x801
 800225a:	f006 f8d1 	bl	8008400 <test_print>
  test_printn(sizeof(thread_t));
 800225e:	2060      	movs	r0, #96	; 0x60
 8002260:	f006 f876 	bl	8008350 <test_printn>
  test_println(" bytes");
 8002264:	f640 20a0 	movw	r0, #2720	; 0xaa0
 8002268:	f6c0 0001 	movt	r0, #2049	; 0x801
 800226c:	f006 f8e8 	bl	8008440 <test_println>
  test_print("--- Timer : ");
 8002270:	f640 20b8 	movw	r0, #2744	; 0xab8
 8002274:	f6c0 0001 	movt	r0, #2049	; 0x801
 8002278:	f006 f8c2 	bl	8008400 <test_print>
  test_printn(sizeof(virtual_timer_t));
 800227c:	2014      	movs	r0, #20
 800227e:	f006 f867 	bl	8008350 <test_printn>
  test_println(" bytes");
 8002282:	f640 20a0 	movw	r0, #2720	; 0xaa0
 8002286:	f6c0 0001 	movt	r0, #2049	; 0x801
 800228a:	f006 f8d9 	bl	8008440 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 800228e:	f640 20c8 	movw	r0, #2760	; 0xac8
 8002292:	f6c0 0001 	movt	r0, #2049	; 0x801
 8002296:	f006 f8b3 	bl	8008400 <test_print>
  test_printn(sizeof(semaphore_t));
 800229a:	200c      	movs	r0, #12
 800229c:	f006 f858 	bl	8008350 <test_printn>
  test_println(" bytes");
 80022a0:	f640 20a0 	movw	r0, #2720	; 0xaa0
 80022a4:	f6c0 0001 	movt	r0, #2049	; 0x801
 80022a8:	f006 f8ca 	bl	8008440 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 80022ac:	f640 20d8 	movw	r0, #2776	; 0xad8
 80022b0:	f6c0 0001 	movt	r0, #2049	; 0x801
 80022b4:	f006 f8a4 	bl	8008400 <test_print>
  test_printn(sizeof(event_source_t));
 80022b8:	2004      	movs	r0, #4
 80022ba:	f006 f849 	bl	8008350 <test_printn>
  test_println(" bytes");
 80022be:	f640 20a0 	movw	r0, #2720	; 0xaa0
 80022c2:	f6c0 0001 	movt	r0, #2049	; 0x801
 80022c6:	f006 f8bb 	bl	8008440 <test_println>
  test_print("--- EventL: ");
 80022ca:	f640 20e8 	movw	r0, #2792	; 0xae8
 80022ce:	f6c0 0001 	movt	r0, #2049	; 0x801
 80022d2:	f006 f895 	bl	8008400 <test_print>
  test_printn(sizeof(event_listener_t));
 80022d6:	2014      	movs	r0, #20
 80022d8:	f006 f83a 	bl	8008350 <test_printn>
  test_println(" bytes");
 80022dc:	f640 20a0 	movw	r0, #2720	; 0xaa0
 80022e0:	f6c0 0001 	movt	r0, #2049	; 0x801
 80022e4:	f006 f8ac 	bl	8008440 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 80022e8:	f640 20f8 	movw	r0, #2808	; 0xaf8
 80022ec:	f6c0 0001 	movt	r0, #2049	; 0x801
 80022f0:	f006 f886 	bl	8008400 <test_print>
  test_printn(sizeof(mutex_t));
 80022f4:	2010      	movs	r0, #16
 80022f6:	f006 f82b 	bl	8008350 <test_printn>
  test_println(" bytes");
 80022fa:	f640 20a0 	movw	r0, #2720	; 0xaa0
 80022fe:	f6c0 0001 	movt	r0, #2049	; 0x801
 8002302:	f006 f89d 	bl	8008440 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8002306:	f640 3008 	movw	r0, #2824	; 0xb08
 800230a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800230e:	f006 f877 	bl	8008400 <test_print>
  test_printn(sizeof(condition_variable_t));
 8002312:	2008      	movs	r0, #8
 8002314:	f006 f81c 	bl	8008350 <test_printn>
  test_println(" bytes");
 8002318:	f640 20a0 	movw	r0, #2720	; 0xaa0
 800231c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8002320:	f006 f88e 	bl	8008440 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8002324:	f640 3018 	movw	r0, #2840	; 0xb18
 8002328:	f6c0 0001 	movt	r0, #2049	; 0x801
 800232c:	f006 f868 	bl	8008400 <test_print>
  test_printn(sizeof(io_queue_t));
 8002330:	2024      	movs	r0, #36	; 0x24
 8002332:	f006 f80d 	bl	8008350 <test_printn>
  test_println(" bytes");
 8002336:	f640 20a0 	movw	r0, #2720	; 0xaa0
 800233a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800233e:	f006 f87f 	bl	8008440 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8002342:	f640 3028 	movw	r0, #2856	; 0xb28
 8002346:	f6c0 0001 	movt	r0, #2049	; 0x801
 800234a:	f006 f859 	bl	8008400 <test_print>
  test_printn(sizeof(mailbox_t));
 800234e:	2028      	movs	r0, #40	; 0x28
 8002350:	f005 fffe 	bl	8008350 <test_printn>
  test_println(" bytes");
 8002354:	f640 20a0 	movw	r0, #2720	; 0xaa0
 8002358:	f6c0 0001 	movt	r0, #2049	; 0x801
 800235c:	f006 f870 	bl	8008440 <test_println>
#endif
}
 8002360:	bd08      	pop	{r3, pc}
 8002362:	bf00      	nop
 8002364:	f3af 8000 	nop.w
 8002368:	f3af 8000 	nop.w
 800236c:	f3af 8000 	nop.w

08002370 <port_lock.14247.4187>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002370:	b082      	sub	sp, #8
 8002372:	2320      	movs	r3, #32
 8002374:	9301      	str	r3, [sp, #4]
 8002376:	9b01      	ldr	r3, [sp, #4]
 8002378:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800237c:	b002      	add	sp, #8
 800237e:	4770      	bx	lr

08002380 <port_unlock.14250.4185>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002380:	b082      	sub	sp, #8
 8002382:	2300      	movs	r3, #0
 8002384:	9301      	str	r3, [sp, #4]
 8002386:	9b01      	ldr	r3, [sp, #4]
 8002388:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800238c:	b002      	add	sp, #8
 800238e:	4770      	bx	lr

08002390 <st_lld_get_counter.14252.4183>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8002390:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002394:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8002396:	4618      	mov	r0, r3
 8002398:	4770      	bx	lr
 800239a:	bf00      	nop
 800239c:	f3af 8000 	nop.w

080023a0 <port_timer_get_time.14257.4181>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80023a0:	b508      	push	{r3, lr}

  return stGetCounter();
 80023a2:	f7ff fff5 	bl	8002390 <st_lld_get_counter.14252.4183>
 80023a6:	4603      	mov	r3, r0
}
 80023a8:	4618      	mov	r0, r3
 80023aa:	bd08      	pop	{r3, pc}
 80023ac:	f3af 8000 	nop.w

080023b0 <chSysLock.14362>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80023b0:	b508      	push	{r3, lr}

  port_lock();
 80023b2:	f7ff ffdd 	bl	8002370 <port_lock.14247.4187>
  _stats_start_measure_crit_thd();
 80023b6:	f00b fde3 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80023ba:	f00d f991 	bl	800f6e0 <_dbg_check_lock>
}
 80023be:	bd08      	pop	{r3, pc}

080023c0 <chSysUnlock.14364.4177>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80023c0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80023c2:	f00d f9ad 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80023c6:	f00b fde3 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80023ca:	f640 5350 	movw	r3, #3408	; 0xd50
 80023ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80023d2:	681a      	ldr	r2, [r3, #0]
 80023d4:	f640 5350 	movw	r3, #3408	; 0xd50
 80023d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80023dc:	429a      	cmp	r2, r3
 80023de:	d013      	beq.n	8002408 <chSysUnlock.14364.4177+0x48>
 80023e0:	f640 5350 	movw	r3, #3408	; 0xd50
 80023e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80023e8:	699b      	ldr	r3, [r3, #24]
 80023ea:	689a      	ldr	r2, [r3, #8]
 80023ec:	f640 5350 	movw	r3, #3408	; 0xd50
 80023f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80023f4:	681b      	ldr	r3, [r3, #0]
 80023f6:	689b      	ldr	r3, [r3, #8]
 80023f8:	429a      	cmp	r2, r3
 80023fa:	d205      	bcs.n	8002408 <chSysUnlock.14364.4177+0x48>
 80023fc:	f242 4030 	movw	r0, #9264	; 0x2430
 8002400:	f6c0 0001 	movt	r0, #2049	; 0x801
 8002404:	f00c ffc4 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002408:	f7ff ffba 	bl	8002380 <port_unlock.14250.4185>
}
 800240c:	bd08      	pop	{r3, pc}
 800240e:	bf00      	nop

08002410 <chVTGetSystemTimeX.14259.4175>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002410:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002412:	f7ff ffc5 	bl	80023a0 <port_timer_get_time.14257.4181>
 8002416:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002418:	4618      	mov	r0, r3
 800241a:	bd08      	pop	{r3, pc}
 800241c:	f3af 8000 	nop.w

08002420 <chVTGetSystemTime.14366.4172>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8002420:	b500      	push	{lr}
 8002422:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8002424:	f7ff ffc4 	bl	80023b0 <chSysLock.14362>
  systime = chVTGetSystemTimeX();
 8002428:	f7ff fff2 	bl	8002410 <chVTGetSystemTimeX.14259.4175>
 800242c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800242e:	f7ff ffc7 	bl	80023c0 <chSysUnlock.14364.4177>

  return systime;
 8002432:	9b01      	ldr	r3, [sp, #4]
}
 8002434:	4618      	mov	r0, r3
 8002436:	b003      	add	sp, #12
 8002438:	f85d fb04 	ldr.w	pc, [sp], #4
 800243c:	f3af 8000 	nop.w

08002440 <chRegSetThreadName.14261.4169>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8002440:	b082      	sub	sp, #8
 8002442:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8002444:	f640 5350 	movw	r3, #3408	; 0xd50
 8002448:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800244c:	699b      	ldr	r3, [r3, #24]
 800244e:	9a01      	ldr	r2, [sp, #4]
 8002450:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8002452:	b002      	add	sp, #8
 8002454:	4770      	bx	lr
 8002456:	bf00      	nop
 8002458:	f3af 8000 	nop.w
 800245c:	f3af 8000 	nop.w

08002460 <chEvtObjectInit.14265>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8002460:	b082      	sub	sp, #8
 8002462:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8002464:	9b01      	ldr	r3, [sp, #4]
 8002466:	9a01      	ldr	r2, [sp, #4]
 8002468:	601a      	str	r2, [r3, #0]
}
 800246a:	b002      	add	sp, #8
 800246c:	4770      	bx	lr
 800246e:	bf00      	nop

08002470 <chEvtBroadcastI.14368>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {
 8002470:	b500      	push	{lr}
 8002472:	b083      	sub	sp, #12
 8002474:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8002476:	9801      	ldr	r0, [sp, #4]
 8002478:	2100      	movs	r1, #0
 800247a:	f00a fbc9 	bl	800cc10 <chEvtBroadcastFlagsI>
}
 800247e:	b003      	add	sp, #12
 8002480:	f85d fb04 	ldr.w	pc, [sp], #4
 8002484:	f3af 8000 	nop.w
 8002488:	f3af 8000 	nop.w
 800248c:	f3af 8000 	nop.w

08002490 <_strtok.14371.4065>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 8002490:	b500      	push	{lr}
 8002492:	b087      	sub	sp, #28
 8002494:	9003      	str	r0, [sp, #12]
 8002496:	9102      	str	r1, [sp, #8]
 8002498:	9201      	str	r2, [sp, #4]
  char *token;
  if (str)
 800249a:	9b03      	ldr	r3, [sp, #12]
 800249c:	2b00      	cmp	r3, #0
 800249e:	d002      	beq.n	80024a6 <_strtok.14371.4065+0x16>
    *saveptr = str;
 80024a0:	9b01      	ldr	r3, [sp, #4]
 80024a2:	9a03      	ldr	r2, [sp, #12]
 80024a4:	601a      	str	r2, [r3, #0]
  token = *saveptr;
 80024a6:	9b01      	ldr	r3, [sp, #4]
 80024a8:	681b      	ldr	r3, [r3, #0]
 80024aa:	9305      	str	r3, [sp, #20]

  if (!token)
 80024ac:	9b05      	ldr	r3, [sp, #20]
 80024ae:	2b00      	cmp	r3, #0
 80024b0:	d101      	bne.n	80024b6 <_strtok.14371.4065+0x26>
    return NULL;
 80024b2:	2300      	movs	r3, #0
 80024b4:	e020      	b.n	80024f8 <_strtok.14371.4065+0x68>

  token += strspn(token, delim);
 80024b6:	9805      	ldr	r0, [sp, #20]
 80024b8:	9902      	ldr	r1, [sp, #8]
 80024ba:	f00e f9f9 	bl	80108b0 <strspn>
 80024be:	4603      	mov	r3, r0
 80024c0:	9a05      	ldr	r2, [sp, #20]
 80024c2:	4413      	add	r3, r2
 80024c4:	9305      	str	r3, [sp, #20]
  *saveptr = strpbrk(token, delim);
 80024c6:	9805      	ldr	r0, [sp, #20]
 80024c8:	9902      	ldr	r1, [sp, #8]
 80024ca:	f00e f9c9 	bl	8010860 <strpbrk>
 80024ce:	4602      	mov	r2, r0
 80024d0:	9b01      	ldr	r3, [sp, #4]
 80024d2:	601a      	str	r2, [r3, #0]
  if (*saveptr)
 80024d4:	9b01      	ldr	r3, [sp, #4]
 80024d6:	681b      	ldr	r3, [r3, #0]
 80024d8:	2b00      	cmp	r3, #0
 80024da:	d006      	beq.n	80024ea <_strtok.14371.4065+0x5a>
    *(*saveptr)++ = '\0';
 80024dc:	9b01      	ldr	r3, [sp, #4]
 80024de:	681b      	ldr	r3, [r3, #0]
 80024e0:	1c59      	adds	r1, r3, #1
 80024e2:	9a01      	ldr	r2, [sp, #4]
 80024e4:	6011      	str	r1, [r2, #0]
 80024e6:	2200      	movs	r2, #0
 80024e8:	701a      	strb	r2, [r3, #0]

  return *token ? token : NULL;
 80024ea:	9b05      	ldr	r3, [sp, #20]
 80024ec:	781b      	ldrb	r3, [r3, #0]
 80024ee:	2b00      	cmp	r3, #0
 80024f0:	d001      	beq.n	80024f6 <_strtok.14371.4065+0x66>
 80024f2:	9b05      	ldr	r3, [sp, #20]
 80024f4:	e000      	b.n	80024f8 <_strtok.14371.4065+0x68>
 80024f6:	2300      	movs	r3, #0
}
 80024f8:	4618      	mov	r0, r3
 80024fa:	b007      	add	sp, #28
 80024fc:	f85d fb04 	ldr.w	pc, [sp], #4

08002500 <usage.14376.4061>:

static void usage(BaseSequentialStream *chp, char *p) {
 8002500:	b500      	push	{lr}
 8002502:	b083      	sub	sp, #12
 8002504:	9001      	str	r0, [sp, #4]
 8002506:	9100      	str	r1, [sp, #0]

  chprintf(chp, "Usage: %s\r\n", p);
 8002508:	9801      	ldr	r0, [sp, #4]
 800250a:	f640 3138 	movw	r1, #2872	; 0xb38
 800250e:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002512:	9a00      	ldr	r2, [sp, #0]
 8002514:	f7fe fbec 	bl	8000cf0 <chprintf>
}
 8002518:	b003      	add	sp, #12
 800251a:	f85d fb04 	ldr.w	pc, [sp], #4
 800251e:	bf00      	nop

08002520 <list_commands.14399.4057>:

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {
 8002520:	b500      	push	{lr}
 8002522:	b083      	sub	sp, #12
 8002524:	9001      	str	r0, [sp, #4]
 8002526:	9100      	str	r1, [sp, #0]
 8002528:	e00c      	b.n	8002544 <list_commands.14399.4057+0x24>

  while (scp->sc_name != NULL) {
    chprintf(chp, "%s ", scp->sc_name);
 800252a:	9b00      	ldr	r3, [sp, #0]
 800252c:	681b      	ldr	r3, [r3, #0]
 800252e:	9801      	ldr	r0, [sp, #4]
 8002530:	f640 3144 	movw	r1, #2884	; 0xb44
 8002534:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002538:	461a      	mov	r2, r3
 800253a:	f7fe fbd9 	bl	8000cf0 <chprintf>
    scp++;
 800253e:	9b00      	ldr	r3, [sp, #0]
 8002540:	3308      	adds	r3, #8
 8002542:	9300      	str	r3, [sp, #0]
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8002544:	9b00      	ldr	r3, [sp, #0]
 8002546:	681b      	ldr	r3, [r3, #0]
 8002548:	2b00      	cmp	r3, #0
 800254a:	d1ee      	bne.n	800252a <list_commands.14399.4057+0xa>
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}
 800254c:	b003      	add	sp, #12
 800254e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002552:	bf00      	nop
 8002554:	f3af 8000 	nop.w
 8002558:	f3af 8000 	nop.w
 800255c:	f3af 8000 	nop.w

08002560 <cmd_info.14389>:

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002560:	b500      	push	{lr}
 8002562:	b087      	sub	sp, #28
 8002564:	9005      	str	r0, [sp, #20]
 8002566:	9104      	str	r1, [sp, #16]
 8002568:	9203      	str	r2, [sp, #12]

  (void)argv;
  if (argc > 0) {
 800256a:	9b04      	ldr	r3, [sp, #16]
 800256c:	2b00      	cmp	r3, #0
 800256e:	dd07      	ble.n	8002580 <cmd_info.14389+0x20>
    usage(chp, "info");
 8002570:	9805      	ldr	r0, [sp, #20]
 8002572:	f640 3148 	movw	r1, #2888	; 0xb48
 8002576:	f6c0 0101 	movt	r1, #2049	; 0x801
 800257a:	f7ff ffc1 	bl	8002500 <usage.14376.4061>
 800257e:	e060      	b.n	8002642 <cmd_info.14389+0xe2>
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 8002580:	9805      	ldr	r0, [sp, #20]
 8002582:	f640 3150 	movw	r1, #2896	; 0xb50
 8002586:	f6c0 0101 	movt	r1, #2049	; 0x801
 800258a:	f640 3264 	movw	r2, #2916	; 0xb64
 800258e:	f6c0 0201 	movt	r2, #2049	; 0x801
 8002592:	f7fe fbad 	bl	8000cf0 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 8002596:	9805      	ldr	r0, [sp, #20]
 8002598:	f640 316c 	movw	r1, #2924	; 0xb6c
 800259c:	f6c0 0101 	movt	r1, #2049	; 0x801
 80025a0:	f640 3280 	movw	r2, #2944	; 0xb80
 80025a4:	f6c0 0201 	movt	r2, #2049	; 0x801
 80025a8:	f7fe fba2 	bl	8000cf0 <chprintf>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 80025ac:	9805      	ldr	r0, [sp, #20]
 80025ae:	f640 318c 	movw	r1, #2956	; 0xb8c
 80025b2:	f6c0 0101 	movt	r1, #2049	; 0x801
 80025b6:	f640 32a0 	movw	r2, #2976	; 0xba0
 80025ba:	f6c0 0201 	movt	r2, #2049	; 0x801
 80025be:	f7fe fb97 	bl	8000cf0 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 80025c2:	9805      	ldr	r0, [sp, #20]
 80025c4:	f640 31ac 	movw	r1, #2988	; 0xbac
 80025c8:	f6c0 0101 	movt	r1, #2049	; 0x801
 80025cc:	f640 32c0 	movw	r2, #3008	; 0xbc0
 80025d0:	f6c0 0201 	movt	r2, #2049	; 0x801
 80025d4:	f7fe fb8c 	bl	8000cf0 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 80025d8:	9805      	ldr	r0, [sp, #20]
 80025da:	f640 31cc 	movw	r1, #3020	; 0xbcc
 80025de:	f6c0 0101 	movt	r1, #2049	; 0x801
 80025e2:	f640 32e0 	movw	r2, #3040	; 0xbe0
 80025e6:	f6c0 0201 	movt	r2, #2049	; 0x801
 80025ea:	f7fe fb81 	bl	8000cf0 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 80025ee:	9805      	ldr	r0, [sp, #20]
 80025f0:	f640 31f8 	movw	r1, #3064	; 0xbf8
 80025f4:	f6c0 0101 	movt	r1, #2049	; 0x801
 80025f8:	f640 420c 	movw	r2, #3084	; 0xc0c
 80025fc:	f6c0 0201 	movt	r2, #2049	; 0x801
 8002600:	f7fe fb76 	bl	8000cf0 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 8002604:	9805      	ldr	r0, [sp, #20]
 8002606:	f640 4138 	movw	r1, #3128	; 0xc38
 800260a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800260e:	f640 424c 	movw	r2, #3148	; 0xc4c
 8002612:	f6c0 0201 	movt	r2, #2049	; 0x801
 8002616:	f7fe fb6b 	bl	8000cf0 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 800261a:	f640 439c 	movw	r3, #3228	; 0xc9c
 800261e:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002622:	9300      	str	r3, [sp, #0]
 8002624:	9805      	ldr	r0, [sp, #20]
 8002626:	f640 4174 	movw	r1, #3188	; 0xc74
 800262a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800262e:	f640 428c 	movw	r2, #3212	; 0xc8c
 8002632:	f6c0 0201 	movt	r2, #2049	; 0x801
 8002636:	f640 4398 	movw	r3, #3224	; 0xc98
 800263a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800263e:	f7fe fb57 	bl	8000cf0 <chprintf>
#endif
#endif
}
 8002642:	b007      	add	sp, #28
 8002644:	f85d fb04 	ldr.w	pc, [sp], #4
 8002648:	f3af 8000 	nop.w
 800264c:	f3af 8000 	nop.w

08002650 <cmd_systime.14394>:

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002650:	b500      	push	{lr}
 8002652:	b085      	sub	sp, #20
 8002654:	9003      	str	r0, [sp, #12]
 8002656:	9102      	str	r1, [sp, #8]
 8002658:	9201      	str	r2, [sp, #4]

  (void)argv;
  if (argc > 0) {
 800265a:	9b02      	ldr	r3, [sp, #8]
 800265c:	2b00      	cmp	r3, #0
 800265e:	dd07      	ble.n	8002670 <cmd_systime.14394+0x20>
    usage(chp, "systime");
 8002660:	9803      	ldr	r0, [sp, #12]
 8002662:	f640 41a8 	movw	r1, #3240	; 0xca8
 8002666:	f6c0 0101 	movt	r1, #2049	; 0x801
 800266a:	f7ff ff49 	bl	8002500 <usage.14376.4061>
 800266e:	e00a      	b.n	8002686 <cmd_systime.14394+0x36>
    return;
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 8002670:	f7ff fed6 	bl	8002420 <chVTGetSystemTime.14366.4172>
 8002674:	4603      	mov	r3, r0
 8002676:	9803      	ldr	r0, [sp, #12]
 8002678:	f640 41b0 	movw	r1, #3248	; 0xcb0
 800267c:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002680:	461a      	mov	r2, r3
 8002682:	f7fe fb35 	bl	8000cf0 <chprintf>
}
 8002686:	b005      	add	sp, #20
 8002688:	f85d fb04 	ldr.w	pc, [sp], #4
 800268c:	f3af 8000 	nop.w

08002690 <cmdexec.14408.4014>:
  {"systime", cmd_systime},
  {NULL, NULL}
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {
 8002690:	b500      	push	{lr}
 8002692:	b085      	sub	sp, #20
 8002694:	9003      	str	r0, [sp, #12]
 8002696:	9102      	str	r1, [sp, #8]
 8002698:	9201      	str	r2, [sp, #4]
 800269a:	9300      	str	r3, [sp, #0]
 800269c:	e013      	b.n	80026c6 <cmdexec.14408.4014+0x36>

  while (scp->sc_name != NULL) {
    if (strcmp(scp->sc_name, name) == 0) {
 800269e:	9b03      	ldr	r3, [sp, #12]
 80026a0:	681b      	ldr	r3, [r3, #0]
 80026a2:	4618      	mov	r0, r3
 80026a4:	9901      	ldr	r1, [sp, #4]
 80026a6:	f7fd fed3 	bl	8000450 <strcmp>
 80026aa:	4603      	mov	r3, r0
 80026ac:	2b00      	cmp	r3, #0
 80026ae:	d107      	bne.n	80026c0 <cmdexec.14408.4014+0x30>
      scp->sc_function(chp, argc, argv);
 80026b0:	9b03      	ldr	r3, [sp, #12]
 80026b2:	685b      	ldr	r3, [r3, #4]
 80026b4:	9802      	ldr	r0, [sp, #8]
 80026b6:	9900      	ldr	r1, [sp, #0]
 80026b8:	9a06      	ldr	r2, [sp, #24]
 80026ba:	4798      	blx	r3
      return false;
 80026bc:	2300      	movs	r3, #0
 80026be:	e007      	b.n	80026d0 <cmdexec.14408.4014+0x40>
    }
    scp++;
 80026c0:	9b03      	ldr	r3, [sp, #12]
 80026c2:	3308      	adds	r3, #8
 80026c4:	9303      	str	r3, [sp, #12]
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 80026c6:	9b03      	ldr	r3, [sp, #12]
 80026c8:	681b      	ldr	r3, [r3, #0]
 80026ca:	2b00      	cmp	r3, #0
 80026cc:	d1e7      	bne.n	800269e <cmdexec.14408.4014+0xe>
      scp->sc_function(chp, argc, argv);
      return false;
    }
    scp++;
  }
  return true;
 80026ce:	2301      	movs	r3, #1
}
 80026d0:	4618      	mov	r0, r3
 80026d2:	b005      	add	sp, #20
 80026d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80026d8:	f3af 8000 	nop.w
 80026dc:	f3af 8000 	nop.w

080026e0 <shell_thread.14430>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 80026e0:	b500      	push	{lr}
 80026e2:	b0a1      	sub	sp, #132	; 0x84
 80026e4:	9003      	str	r0, [sp, #12]
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 80026e6:	9b03      	ldr	r3, [sp, #12]
 80026e8:	681b      	ldr	r3, [r3, #0]
 80026ea:	931d      	str	r3, [sp, #116]	; 0x74
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 80026ec:	9b03      	ldr	r3, [sp, #12]
 80026ee:	685b      	ldr	r3, [r3, #4]
 80026f0:	931c      	str	r3, [sp, #112]	; 0x70
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 80026f2:	f640 40b8 	movw	r0, #3256	; 0xcb8
 80026f6:	f6c0 0001 	movt	r0, #2049	; 0x801
 80026fa:	f7ff fea1 	bl	8002440 <chRegSetThreadName.14261.4169>
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 80026fe:	981d      	ldr	r0, [sp, #116]	; 0x74
 8002700:	f640 41c0 	movw	r1, #3264	; 0xcc0
 8002704:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002708:	f7fe faf2 	bl	8000cf0 <chprintf>
  while (true) {
    chprintf(chp, "ch> ");
 800270c:	981d      	ldr	r0, [sp, #116]	; 0x74
 800270e:	f640 41d8 	movw	r1, #3288	; 0xcd8
 8002712:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002716:	f7fe faeb 	bl	8000cf0 <chprintf>
    if (shellGetLine(chp, line, sizeof(line))) {
 800271a:	ab0a      	add	r3, sp, #40	; 0x28
 800271c:	981d      	ldr	r0, [sp, #116]	; 0x74
 800271e:	4619      	mov	r1, r3
 8002720:	2240      	movs	r2, #64	; 0x40
 8002722:	f7fd ffdd 	bl	80006e0 <shellGetLine>
 8002726:	4603      	mov	r3, r0
 8002728:	2b00      	cmp	r3, #0
 800272a:	d007      	beq.n	800273c <shell_thread.14430+0x5c>
      chprintf(chp, "\r\nlogout");
 800272c:	981d      	ldr	r0, [sp, #116]	; 0x74
 800272e:	f640 41e0 	movw	r1, #3296	; 0xce0
 8002732:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002736:	f7fe fadb 	bl	8000cf0 <chprintf>
 800273a:	e0b1      	b.n	80028a0 <shell_thread.14430+0x1c0>
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 800273c:	aa0a      	add	r2, sp, #40	; 0x28
 800273e:	ab1a      	add	r3, sp, #104	; 0x68
 8002740:	4610      	mov	r0, r2
 8002742:	f640 41ec 	movw	r1, #3308	; 0xcec
 8002746:	f6c0 0101 	movt	r1, #2049	; 0x801
 800274a:	461a      	mov	r2, r3
 800274c:	f7ff fea0 	bl	8002490 <_strtok.14371.4065>
 8002750:	901b      	str	r0, [sp, #108]	; 0x6c
    cmd = lp;
 8002752:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8002754:	931e      	str	r3, [sp, #120]	; 0x78
    n = 0;
 8002756:	2300      	movs	r3, #0
 8002758:	931f      	str	r3, [sp, #124]	; 0x7c
 800275a:	e015      	b.n	8002788 <shell_thread.14430+0xa8>
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
      if (n >= SHELL_MAX_ARGUMENTS) {
 800275c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800275e:	2b03      	cmp	r3, #3
 8002760:	dd09      	ble.n	8002776 <shell_thread.14430+0x96>
        chprintf(chp, "too many arguments\r\n");
 8002762:	981d      	ldr	r0, [sp, #116]	; 0x74
 8002764:	f640 41f0 	movw	r1, #3312	; 0xcf0
 8002768:	f6c0 0101 	movt	r1, #2049	; 0x801
 800276c:	f7fe fac0 	bl	8000cf0 <chprintf>
        cmd = NULL;
 8002770:	2300      	movs	r3, #0
 8002772:	931e      	str	r3, [sp, #120]	; 0x78
 8002774:	e015      	b.n	80027a2 <shell_thread.14430+0xc2>
        break;
      }
      args[n++] = lp;
 8002776:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8002778:	1c5a      	adds	r2, r3, #1
 800277a:	921f      	str	r2, [sp, #124]	; 0x7c
 800277c:	009b      	lsls	r3, r3, #2
 800277e:	aa20      	add	r2, sp, #128	; 0x80
 8002780:	4413      	add	r3, r2
 8002782:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8002784:	f843 2c6c 	str.w	r2, [r3, #-108]
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8002788:	ab1a      	add	r3, sp, #104	; 0x68
 800278a:	2000      	movs	r0, #0
 800278c:	f640 41ec 	movw	r1, #3308	; 0xcec
 8002790:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002794:	461a      	mov	r2, r3
 8002796:	f7ff fe7b 	bl	8002490 <_strtok.14371.4065>
 800279a:	901b      	str	r0, [sp, #108]	; 0x6c
 800279c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800279e:	2b00      	cmp	r3, #0
 80027a0:	d1dc      	bne.n	800275c <shell_thread.14430+0x7c>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 80027a2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80027a4:	009b      	lsls	r3, r3, #2
 80027a6:	aa20      	add	r2, sp, #128	; 0x80
 80027a8:	4413      	add	r3, r2
 80027aa:	2200      	movs	r2, #0
 80027ac:	f843 2c6c 	str.w	r2, [r3, #-108]
    if (cmd != NULL) {
 80027b0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 80027b2:	2b00      	cmp	r3, #0
 80027b4:	d0aa      	beq.n	800270c <shell_thread.14430+0x2c>
      if (strcmp(cmd, "exit") == 0) {
 80027b6:	981e      	ldr	r0, [sp, #120]	; 0x78
 80027b8:	f640 5108 	movw	r1, #3336	; 0xd08
 80027bc:	f6c0 0101 	movt	r1, #2049	; 0x801
 80027c0:	f7fd fe46 	bl	8000450 <strcmp>
 80027c4:	4603      	mov	r3, r0
 80027c6:	2b00      	cmp	r3, #0
 80027c8:	d10a      	bne.n	80027e0 <shell_thread.14430+0x100>
        if (n > 0) {
 80027ca:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80027cc:	2b00      	cmp	r3, #0
 80027ce:	dd67      	ble.n	80028a0 <shell_thread.14430+0x1c0>
          usage(chp, "exit");
 80027d0:	981d      	ldr	r0, [sp, #116]	; 0x74
 80027d2:	f640 5108 	movw	r1, #3336	; 0xd08
 80027d6:	f6c0 0101 	movt	r1, #2049	; 0x801
 80027da:	f7ff fe91 	bl	8002500 <usage.14376.4061>
 80027de:	e795      	b.n	800270c <shell_thread.14430+0x2c>
          continue;
        }
        break;
      }
      else if (strcmp(cmd, "help") == 0) {
 80027e0:	981e      	ldr	r0, [sp, #120]	; 0x78
 80027e2:	f640 5110 	movw	r1, #3344	; 0xd10
 80027e6:	f6c0 0101 	movt	r1, #2049	; 0x801
 80027ea:	f7fd fe31 	bl	8000450 <strcmp>
 80027ee:	4603      	mov	r3, r0
 80027f0:	2b00      	cmp	r3, #0
 80027f2:	d127      	bne.n	8002844 <shell_thread.14430+0x164>
        if (n > 0) {
 80027f4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80027f6:	2b00      	cmp	r3, #0
 80027f8:	dd07      	ble.n	800280a <shell_thread.14430+0x12a>
          usage(chp, "help");
 80027fa:	981d      	ldr	r0, [sp, #116]	; 0x74
 80027fc:	f640 5110 	movw	r1, #3344	; 0xd10
 8002800:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002804:	f7ff fe7c 	bl	8002500 <usage.14376.4061>
 8002808:	e780      	b.n	800270c <shell_thread.14430+0x2c>
          continue;
        }
        chprintf(chp, "Commands: help exit ");
 800280a:	981d      	ldr	r0, [sp, #116]	; 0x74
 800280c:	f640 5118 	movw	r1, #3352	; 0xd18
 8002810:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002814:	f7fe fa6c 	bl	8000cf0 <chprintf>
        list_commands(chp, local_commands);
 8002818:	981d      	ldr	r0, [sp, #116]	; 0x74
 800281a:	f640 01f4 	movw	r1, #2292	; 0x8f4
 800281e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8002822:	f7ff fe7d 	bl	8002520 <list_commands.14399.4057>
        if (scp != NULL)
 8002826:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8002828:	2b00      	cmp	r3, #0
 800282a:	d003      	beq.n	8002834 <shell_thread.14430+0x154>
          list_commands(chp, scp);
 800282c:	981d      	ldr	r0, [sp, #116]	; 0x74
 800282e:	991c      	ldr	r1, [sp, #112]	; 0x70
 8002830:	f7ff fe76 	bl	8002520 <list_commands.14399.4057>
        chprintf(chp, "\r\n");
 8002834:	981d      	ldr	r0, [sp, #116]	; 0x74
 8002836:	f640 5130 	movw	r1, #3376	; 0xd30
 800283a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800283e:	f7fe fa57 	bl	8000cf0 <chprintf>
 8002842:	e763      	b.n	800270c <shell_thread.14430+0x2c>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8002844:	ab05      	add	r3, sp, #20
 8002846:	9300      	str	r3, [sp, #0]
 8002848:	f640 00f4 	movw	r0, #2292	; 0x8f4
 800284c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002850:	991d      	ldr	r1, [sp, #116]	; 0x74
 8002852:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8002854:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8002856:	f7ff ff1b 	bl	8002690 <cmdexec.14408.4014>
 800285a:	4603      	mov	r3, r0
 800285c:	2b00      	cmp	r3, #0
 800285e:	f43f af55 	beq.w	800270c <shell_thread.14430+0x2c>
 8002862:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8002864:	2b00      	cmp	r3, #0
 8002866:	d00b      	beq.n	8002880 <shell_thread.14430+0x1a0>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 8002868:	ab05      	add	r3, sp, #20
 800286a:	9300      	str	r3, [sp, #0]
 800286c:	981c      	ldr	r0, [sp, #112]	; 0x70
 800286e:	991d      	ldr	r1, [sp, #116]	; 0x74
 8002870:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8002872:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8002874:	f7ff ff0c 	bl	8002690 <cmdexec.14408.4014>
 8002878:	4603      	mov	r3, r0
 800287a:	2b00      	cmp	r3, #0
 800287c:	f43f af46 	beq.w	800270c <shell_thread.14430+0x2c>
        chprintf(chp, "%s", cmd);
 8002880:	981d      	ldr	r0, [sp, #116]	; 0x74
 8002882:	f640 5134 	movw	r1, #3380	; 0xd34
 8002886:	f6c0 0101 	movt	r1, #2049	; 0x801
 800288a:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 800288c:	f7fe fa30 	bl	8000cf0 <chprintf>
        chprintf(chp, " ?\r\n");
 8002890:	981d      	ldr	r0, [sp, #116]	; 0x74
 8002892:	f640 5138 	movw	r1, #3384	; 0xd38
 8002896:	f6c0 0101 	movt	r1, #2049	; 0x801
 800289a:	f7fe fa29 	bl	8000cf0 <chprintf>
 800289e:	e735      	b.n	800270c <shell_thread.14430+0x2c>
      }
    }
  }
  shellExit(MSG_OK);
 80028a0:	2000      	movs	r0, #0
 80028a2:	f7fd feed 	bl	8000680 <shellExit>
}
 80028a6:	b021      	add	sp, #132	; 0x84
 80028a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80028ac:	f3af 8000 	nop.w

080028b0 <pools1_setup.13131>:

  (void)size;
  return NULL;
}

static void pools1_setup(void) {
 80028b0:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 80028b2:	f640 00a0 	movw	r0, #2208	; 0x8a0
 80028b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80028ba:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80028be:	2200      	movs	r2, #0
 80028c0:	f008 ffb6 	bl	800b830 <chPoolObjectInit>
}
 80028c4:	bd08      	pop	{r3, pc}
 80028c6:	bf00      	nop
 80028c8:	f3af 8000 	nop.w
 80028cc:	f3af 8000 	nop.w

080028d0 <pools1_execute.13133>:

static void pools1_execute(void) {
 80028d0:	b500      	push	{lr}
 80028d2:	b083      	sub	sp, #12
  int i;

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);
 80028d4:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80028d8:	f6c0 0301 	movt	r3, #2049	; 0x801
 80028dc:	681b      	ldr	r3, [r3, #0]
 80028de:	f640 00a0 	movw	r0, #2208	; 0x8a0
 80028e2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80028e6:	4619      	mov	r1, r3
 80028e8:	2205      	movs	r2, #5
 80028ea:	f008 ffc1 	bl	800b870 <chPoolLoadArray>

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 80028ee:	2300      	movs	r3, #0
 80028f0:	9301      	str	r3, [sp, #4]
 80028f2:	e015      	b.n	8002920 <pools1_execute.13133+0x50>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 80028f4:	f640 00a0 	movw	r0, #2208	; 0x8a0
 80028f8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80028fc:	f009 f810 	bl	800b920 <chPoolAlloc>
 8002900:	4603      	mov	r3, r0
 8002902:	2b00      	cmp	r3, #0
 8002904:	bf0c      	ite	eq
 8002906:	2300      	moveq	r3, #0
 8002908:	2301      	movne	r3, #1
 800290a:	b2db      	uxtb	r3, r3
 800290c:	2001      	movs	r0, #1
 800290e:	4619      	mov	r1, r3
 8002910:	f005 fe26 	bl	8008560 <_test_assert>
 8002914:	4603      	mov	r3, r0
 8002916:	2b00      	cmp	r3, #0
 8002918:	d179      	bne.n	8002a0e <pools1_execute.13133+0x13e>

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 800291a:	9b01      	ldr	r3, [sp, #4]
 800291c:	3301      	adds	r3, #1
 800291e:	9301      	str	r3, [sp, #4]
 8002920:	9b01      	ldr	r3, [sp, #4]
 8002922:	2b04      	cmp	r3, #4
 8002924:	dde6      	ble.n	80028f4 <pools1_execute.13133+0x24>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 8002926:	f640 00a0 	movw	r0, #2208	; 0x8a0
 800292a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800292e:	f008 fff7 	bl	800b920 <chPoolAlloc>
 8002932:	4603      	mov	r3, r0
 8002934:	2b00      	cmp	r3, #0
 8002936:	bf14      	ite	ne
 8002938:	2300      	movne	r3, #0
 800293a:	2301      	moveq	r3, #1
 800293c:	b2db      	uxtb	r3, r3
 800293e:	2002      	movs	r0, #2
 8002940:	4619      	mov	r1, r3
 8002942:	f005 fe0d 	bl	8008560 <_test_assert>
 8002946:	4603      	mov	r3, r0
 8002948:	2b00      	cmp	r3, #0
 800294a:	d160      	bne.n	8002a0e <pools1_execute.13133+0x13e>

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800294c:	2300      	movs	r3, #0
 800294e:	9301      	str	r3, [sp, #4]
 8002950:	e010      	b.n	8002974 <pools1_execute.13133+0xa4>
    chPoolFree(&mp1, wa[i]);
 8002952:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8002956:	f6c0 0301 	movt	r3, #2049	; 0x801
 800295a:	9a01      	ldr	r2, [sp, #4]
 800295c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002960:	f640 00a0 	movw	r0, #2208	; 0x8a0
 8002964:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002968:	4619      	mov	r1, r3
 800296a:	f009 f809 	bl	800b980 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800296e:	9b01      	ldr	r3, [sp, #4]
 8002970:	3301      	adds	r3, #1
 8002972:	9301      	str	r3, [sp, #4]
 8002974:	9b01      	ldr	r3, [sp, #4]
 8002976:	2b04      	cmp	r3, #4
 8002978:	ddeb      	ble.n	8002952 <pools1_execute.13133+0x82>
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 800297a:	2300      	movs	r3, #0
 800297c:	9301      	str	r3, [sp, #4]
 800297e:	e015      	b.n	80029ac <pools1_execute.13133+0xdc>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 8002980:	f640 00a0 	movw	r0, #2208	; 0x8a0
 8002984:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002988:	f008 ffca 	bl	800b920 <chPoolAlloc>
 800298c:	4603      	mov	r3, r0
 800298e:	2b00      	cmp	r3, #0
 8002990:	bf0c      	ite	eq
 8002992:	2300      	moveq	r3, #0
 8002994:	2301      	movne	r3, #1
 8002996:	b2db      	uxtb	r3, r3
 8002998:	2003      	movs	r0, #3
 800299a:	4619      	mov	r1, r3
 800299c:	f005 fde0 	bl	8008560 <_test_assert>
 80029a0:	4603      	mov	r3, r0
 80029a2:	2b00      	cmp	r3, #0
 80029a4:	d133      	bne.n	8002a0e <pools1_execute.13133+0x13e>
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 80029a6:	9b01      	ldr	r3, [sp, #4]
 80029a8:	3301      	adds	r3, #1
 80029aa:	9301      	str	r3, [sp, #4]
 80029ac:	9b01      	ldr	r3, [sp, #4]
 80029ae:	2b04      	cmp	r3, #4
 80029b0:	dde6      	ble.n	8002980 <pools1_execute.13133+0xb0>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 80029b2:	f640 00a0 	movw	r0, #2208	; 0x8a0
 80029b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80029ba:	f008 ffb1 	bl	800b920 <chPoolAlloc>
 80029be:	4603      	mov	r3, r0
 80029c0:	2b00      	cmp	r3, #0
 80029c2:	bf14      	ite	ne
 80029c4:	2300      	movne	r3, #0
 80029c6:	2301      	moveq	r3, #1
 80029c8:	b2db      	uxtb	r3, r3
 80029ca:	2004      	movs	r0, #4
 80029cc:	4619      	mov	r1, r3
 80029ce:	f005 fdc7 	bl	8008560 <_test_assert>
 80029d2:	4603      	mov	r3, r0
 80029d4:	2b00      	cmp	r3, #0
 80029d6:	d11a      	bne.n	8002a0e <pools1_execute.13133+0x13e>

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
 80029d8:	f640 00a0 	movw	r0, #2208	; 0x8a0
 80029dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80029e0:	2110      	movs	r1, #16
 80029e2:	f244 62e1 	movw	r2, #18145	; 0x46e1
 80029e6:	f6c0 0200 	movt	r2, #2048	; 0x800
 80029ea:	f008 ff21 	bl	800b830 <chPoolObjectInit>
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 80029ee:	f640 00a0 	movw	r0, #2208	; 0x8a0
 80029f2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80029f6:	f008 ff93 	bl	800b920 <chPoolAlloc>
 80029fa:	4603      	mov	r3, r0
 80029fc:	2b00      	cmp	r3, #0
 80029fe:	bf14      	ite	ne
 8002a00:	2300      	movne	r3, #0
 8002a02:	2301      	moveq	r3, #1
 8002a04:	b2db      	uxtb	r3, r3
 8002a06:	2005      	movs	r0, #5
 8002a08:	4619      	mov	r1, r3
 8002a0a:	f005 fda9 	bl	8008560 <_test_assert>
}
 8002a0e:	b003      	add	sp, #12
 8002a10:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a14:	f3af 8000 	nop.w
 8002a18:	f3af 8000 	nop.w
 8002a1c:	f3af 8000 	nop.w

08002a20 <chThdGetSelfX.13161.4246>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002a20:	f640 5350 	movw	r3, #3408	; 0xd50
 8002a24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002a28:	699b      	ldr	r3, [r3, #24]
}
 8002a2a:	4618      	mov	r0, r3
 8002a2c:	4770      	bx	lr
 8002a2e:	bf00      	nop

08002a30 <chThdGetPriorityX.13250.4244>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8002a30:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8002a32:	f7ff fff5 	bl	8002a20 <chThdGetSelfX.13161.4246>
 8002a36:	4603      	mov	r3, r0
 8002a38:	689b      	ldr	r3, [r3, #8]
}
 8002a3a:	4618      	mov	r0, r3
 8002a3c:	bd08      	pop	{r3, pc}
 8002a3e:	bf00      	nop

08002a40 <thread.13252.4228>:
 * is attempted.<br>
 * The test expects the first two threads to successfully start and the last
 * one to fail.
 */

static THD_FUNCTION(thread, p) {
 8002a40:	b500      	push	{lr}
 8002a42:	b083      	sub	sp, #12
 8002a44:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 8002a46:	9b01      	ldr	r3, [sp, #4]
 8002a48:	781b      	ldrb	r3, [r3, #0]
 8002a4a:	4618      	mov	r0, r3
 8002a4c:	f005 fd50 	bl	80084f0 <test_emit_token>
}
 8002a50:	b003      	add	sp, #12
 8002a52:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a56:	bf00      	nop
 8002a58:	f3af 8000 	nop.w
 8002a5c:	f3af 8000 	nop.w

08002a60 <dyn1_setup.13255>:

#if CH_CFG_USE_HEAP || defined(__DOXYGEN__)
static void dyn1_setup(void) {
 8002a60:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 8002a62:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 8002a66:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002a6a:	f241 7158 	movw	r1, #5976	; 0x1758
 8002a6e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8002a72:	f44f 62e1 	mov.w	r2, #1800	; 0x708
 8002a76:	f008 fd23 	bl	800b4c0 <chHeapObjectInit>
}
 8002a7a:	bd08      	pop	{r3, pc}
 8002a7c:	f3af 8000 	nop.w

08002a80 <dyn1_execute.13259>:

static void dyn1_execute(void) {
 8002a80:	b500      	push	{lr}
 8002a82:	b087      	sub	sp, #28
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();
 8002a84:	f7ff ffd4 	bl	8002a30 <chThdGetPriorityX.13250.4244>
 8002a88:	9005      	str	r0, [sp, #20]

  (void)chHeapStatus(&heap1, &sz);
 8002a8a:	ab02      	add	r3, sp, #8
 8002a8c:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 8002a90:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002a94:	4619      	mov	r1, r3
 8002a96:	f008 fe3b 	bl	800b710 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8002a9a:	9b05      	ldr	r3, [sp, #20]
 8002a9c:	1e5a      	subs	r2, r3, #1
 8002a9e:	f640 5340 	movw	r3, #3392	; 0xd40
 8002aa2:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002aa6:	9300      	str	r3, [sp, #0]
 8002aa8:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 8002aac:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002ab0:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8002ab4:	f642 2341 	movw	r3, #10817	; 0x2a41
 8002ab8:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002abc:	f00b fb38 	bl	800e130 <chThdCreateFromHeap>
 8002ac0:	4602      	mov	r2, r0
 8002ac2:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002ac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002aca:	601a      	str	r2, [r3, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8002acc:	9b05      	ldr	r3, [sp, #20]
 8002ace:	1e9a      	subs	r2, r3, #2
 8002ad0:	f640 5344 	movw	r3, #3396	; 0xd44
 8002ad4:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002ad8:	9300      	str	r3, [sp, #0]
 8002ada:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 8002ade:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002ae2:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8002ae6:	f642 2341 	movw	r3, #10817	; 0x2a41
 8002aea:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002aee:	f00b fb1f 	bl	800e130 <chThdCreateFromHeap>
 8002af2:	4602      	mov	r2, r0
 8002af4:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002af8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002afc:	605a      	str	r2, [r3, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8002afe:	ab03      	add	r3, sp, #12
 8002b00:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 8002b04:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002b08:	4619      	mov	r1, r3
 8002b0a:	f008 fe01 	bl	800b710 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 8002b0e:	9b03      	ldr	r3, [sp, #12]
 8002b10:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 8002b14:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002b18:	4619      	mov	r1, r3
 8002b1a:	f008 fd01 	bl	800b520 <chHeapAlloc>
 8002b1e:	9004      	str	r0, [sp, #16]
  threads[2] = chThdCreateFromHeap(&heap1,
 8002b20:	9b05      	ldr	r3, [sp, #20]
 8002b22:	1eda      	subs	r2, r3, #3
 8002b24:	f640 5348 	movw	r3, #3400	; 0xd48
 8002b28:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002b2c:	9300      	str	r3, [sp, #0]
 8002b2e:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 8002b32:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002b36:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8002b3a:	f642 2341 	movw	r3, #10817	; 0x2a41
 8002b3e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002b42:	f00b faf5 	bl	800e130 <chThdCreateFromHeap>
 8002b46:	4602      	mov	r2, r0
 8002b48:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002b4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002b50:	609a      	str	r2, [r3, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 8002b52:	9804      	ldr	r0, [sp, #16]
 8002b54:	f008 fd5c 	bl	800b610 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 8002b58:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002b5c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002b60:	681b      	ldr	r3, [r3, #0]
 8002b62:	2b00      	cmp	r3, #0
 8002b64:	d01d      	beq.n	8002ba2 <dyn1_execute.13259+0x122>
 8002b66:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002b6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002b6e:	685b      	ldr	r3, [r3, #4]
 8002b70:	2b00      	cmp	r3, #0
 8002b72:	d016      	beq.n	8002ba2 <dyn1_execute.13259+0x122>
 8002b74:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002b78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002b7c:	689b      	ldr	r3, [r3, #8]
 8002b7e:	2b00      	cmp	r3, #0
 8002b80:	d10f      	bne.n	8002ba2 <dyn1_execute.13259+0x122>
 8002b82:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002b86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002b8a:	68db      	ldr	r3, [r3, #12]
 8002b8c:	2b00      	cmp	r3, #0
 8002b8e:	d108      	bne.n	8002ba2 <dyn1_execute.13259+0x122>
 8002b90:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002b94:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002b98:	691b      	ldr	r3, [r3, #16]
 8002b9a:	2b00      	cmp	r3, #0
 8002b9c:	d101      	bne.n	8002ba2 <dyn1_execute.13259+0x122>
 8002b9e:	2301      	movs	r3, #1
 8002ba0:	e000      	b.n	8002ba4 <dyn1_execute.13259+0x124>
 8002ba2:	2300      	movs	r3, #0
 8002ba4:	f003 0301 	and.w	r3, r3, #1
 8002ba8:	b2db      	uxtb	r3, r3
 8002baa:	2001      	movs	r0, #1
 8002bac:	4619      	mov	r1, r3
 8002bae:	f005 fcd7 	bl	8008560 <_test_assert>
 8002bb2:	4603      	mov	r3, r0
 8002bb4:	2b00      	cmp	r3, #0
 8002bb6:	d12d      	bne.n	8002c14 <dyn1_execute.13259+0x194>
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8002bb8:	f005 fd62 	bl	8008680 <test_wait_threads>
  test_assert_sequence(2, "AB");
 8002bbc:	2002      	movs	r0, #2
 8002bbe:	f640 514c 	movw	r1, #3404	; 0xd4c
 8002bc2:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002bc6:	f005 fce3 	bl	8008590 <_test_assert_sequence>
 8002bca:	4603      	mov	r3, r0
 8002bcc:	2b00      	cmp	r3, #0
 8002bce:	d121      	bne.n	8002c14 <dyn1_execute.13259+0x194>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 8002bd0:	ab03      	add	r3, sp, #12
 8002bd2:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 8002bd6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002bda:	4619      	mov	r1, r3
 8002bdc:	f008 fd98 	bl	800b710 <chHeapStatus>
 8002be0:	4603      	mov	r3, r0
 8002be2:	2b01      	cmp	r3, #1
 8002be4:	bf14      	ite	ne
 8002be6:	2300      	movne	r3, #0
 8002be8:	2301      	moveq	r3, #1
 8002bea:	b2db      	uxtb	r3, r3
 8002bec:	2003      	movs	r0, #3
 8002bee:	4619      	mov	r1, r3
 8002bf0:	f005 fcb6 	bl	8008560 <_test_assert>
 8002bf4:	4603      	mov	r3, r0
 8002bf6:	2b00      	cmp	r3, #0
 8002bf8:	d10c      	bne.n	8002c14 <dyn1_execute.13259+0x194>
  test_assert(4, n == sz, "heap size changed");
 8002bfa:	9a03      	ldr	r2, [sp, #12]
 8002bfc:	9b02      	ldr	r3, [sp, #8]
 8002bfe:	429a      	cmp	r2, r3
 8002c00:	bf14      	ite	ne
 8002c02:	2300      	movne	r3, #0
 8002c04:	2301      	moveq	r3, #1
 8002c06:	b2db      	uxtb	r3, r3
 8002c08:	2004      	movs	r0, #4
 8002c0a:	4619      	mov	r1, r3
 8002c0c:	f005 fca8 	bl	8008560 <_test_assert>
 8002c10:	4603      	mov	r3, r0
 8002c12:	2b00      	cmp	r3, #0
}
 8002c14:	b007      	add	sp, #28
 8002c16:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c1a:	bf00      	nop
 8002c1c:	f3af 8000 	nop.w

08002c20 <dyn2_setup.13261>:
 * elements.<br>
 * The test expects the first four threads to successfully start and the last
 * one to fail.
 */

static void dyn2_setup(void) {
 8002c20:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 8002c22:	f641 60d0 	movw	r0, #7888	; 0x1ed0
 8002c26:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002c2a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8002c2e:	2200      	movs	r2, #0
 8002c30:	f008 fdfe 	bl	800b830 <chPoolObjectInit>
}
 8002c34:	bd08      	pop	{r3, pc}
 8002c36:	bf00      	nop
 8002c38:	f3af 8000 	nop.w
 8002c3c:	f3af 8000 	nop.w

08002c40 <dyn2_execute.13263>:

static void dyn2_execute(void) {
 8002c40:	b500      	push	{lr}
 8002c42:	b083      	sub	sp, #12
  int i;
  tprio_t prio = chThdGetPriorityX();
 8002c44:	f7ff fef4 	bl	8002a30 <chThdGetPriorityX.13250.4244>
 8002c48:	9000      	str	r0, [sp, #0]

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 8002c4a:	2300      	movs	r3, #0
 8002c4c:	9301      	str	r3, [sp, #4]
 8002c4e:	e010      	b.n	8002c72 <dyn2_execute.13263+0x32>
    chPoolFree(&mp1, wa[i]);
 8002c50:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8002c54:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002c58:	9a01      	ldr	r2, [sp, #4]
 8002c5a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8002c5e:	f641 60d0 	movw	r0, #7888	; 0x1ed0
 8002c62:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002c66:	4619      	mov	r1, r3
 8002c68:	f008 fe8a 	bl	800b980 <chPoolFree>
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 8002c6c:	9b01      	ldr	r3, [sp, #4]
 8002c6e:	3301      	adds	r3, #1
 8002c70:	9301      	str	r3, [sp, #4]
 8002c72:	9b01      	ldr	r3, [sp, #4]
 8002c74:	2b03      	cmp	r3, #3
 8002c76:	ddeb      	ble.n	8002c50 <dyn2_execute.13263+0x10>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8002c78:	9b00      	ldr	r3, [sp, #0]
 8002c7a:	3b01      	subs	r3, #1
 8002c7c:	f641 60d0 	movw	r0, #7888	; 0x1ed0
 8002c80:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002c84:	4619      	mov	r1, r3
 8002c86:	f642 2241 	movw	r2, #10817	; 0x2a41
 8002c8a:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002c8e:	f640 5340 	movw	r3, #3392	; 0xd40
 8002c92:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002c96:	f00b fa8b 	bl	800e1b0 <chThdCreateFromMemoryPool>
 8002c9a:	4602      	mov	r2, r0
 8002c9c:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002ca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002ca4:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8002ca6:	9b00      	ldr	r3, [sp, #0]
 8002ca8:	3b02      	subs	r3, #2
 8002caa:	f641 60d0 	movw	r0, #7888	; 0x1ed0
 8002cae:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002cb2:	4619      	mov	r1, r3
 8002cb4:	f642 2241 	movw	r2, #10817	; 0x2a41
 8002cb8:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002cbc:	f640 5344 	movw	r3, #3396	; 0xd44
 8002cc0:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002cc4:	f00b fa74 	bl	800e1b0 <chThdCreateFromMemoryPool>
 8002cc8:	4602      	mov	r2, r0
 8002cca:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002cce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002cd2:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8002cd4:	9b00      	ldr	r3, [sp, #0]
 8002cd6:	3b03      	subs	r3, #3
 8002cd8:	f641 60d0 	movw	r0, #7888	; 0x1ed0
 8002cdc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002ce0:	4619      	mov	r1, r3
 8002ce2:	f642 2241 	movw	r2, #10817	; 0x2a41
 8002ce6:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002cea:	f640 5348 	movw	r3, #3400	; 0xd48
 8002cee:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002cf2:	f00b fa5d 	bl	800e1b0 <chThdCreateFromMemoryPool>
 8002cf6:	4602      	mov	r2, r0
 8002cf8:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002cfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d00:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8002d02:	9b00      	ldr	r3, [sp, #0]
 8002d04:	3b04      	subs	r3, #4
 8002d06:	f641 60d0 	movw	r0, #7888	; 0x1ed0
 8002d0a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002d0e:	4619      	mov	r1, r3
 8002d10:	f642 2241 	movw	r2, #10817	; 0x2a41
 8002d14:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002d18:	f640 5350 	movw	r3, #3408	; 0xd50
 8002d1c:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002d20:	f00b fa46 	bl	800e1b0 <chThdCreateFromMemoryPool>
 8002d24:	4602      	mov	r2, r0
 8002d26:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002d2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d2e:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8002d30:	9b00      	ldr	r3, [sp, #0]
 8002d32:	3b05      	subs	r3, #5
 8002d34:	f641 60d0 	movw	r0, #7888	; 0x1ed0
 8002d38:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002d3c:	4619      	mov	r1, r3
 8002d3e:	f642 2241 	movw	r2, #10817	; 0x2a41
 8002d42:	f6c0 0200 	movt	r2, #2048	; 0x800
 8002d46:	f640 5354 	movw	r3, #3412	; 0xd54
 8002d4a:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002d4e:	f00b fa2f 	bl	800e1b0 <chThdCreateFromMemoryPool>
 8002d52:	4602      	mov	r2, r0
 8002d54:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002d58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d5c:	611a      	str	r2, [r3, #16]

  test_assert(1, (threads[0] != NULL) &&
 8002d5e:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002d62:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d66:	681b      	ldr	r3, [r3, #0]
 8002d68:	2b00      	cmp	r3, #0
 8002d6a:	d01d      	beq.n	8002da8 <dyn2_execute.13263+0x168>
 8002d6c:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002d70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d74:	685b      	ldr	r3, [r3, #4]
 8002d76:	2b00      	cmp	r3, #0
 8002d78:	d016      	beq.n	8002da8 <dyn2_execute.13263+0x168>
 8002d7a:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002d7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d82:	689b      	ldr	r3, [r3, #8]
 8002d84:	2b00      	cmp	r3, #0
 8002d86:	d00f      	beq.n	8002da8 <dyn2_execute.13263+0x168>
 8002d88:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002d8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d90:	68db      	ldr	r3, [r3, #12]
 8002d92:	2b00      	cmp	r3, #0
 8002d94:	d008      	beq.n	8002da8 <dyn2_execute.13263+0x168>
 8002d96:	f641 6360 	movw	r3, #7776	; 0x1e60
 8002d9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d9e:	691b      	ldr	r3, [r3, #16]
 8002da0:	2b00      	cmp	r3, #0
 8002da2:	d101      	bne.n	8002da8 <dyn2_execute.13263+0x168>
 8002da4:	2301      	movs	r3, #1
 8002da6:	e000      	b.n	8002daa <dyn2_execute.13263+0x16a>
 8002da8:	2300      	movs	r3, #0
 8002daa:	f003 0301 	and.w	r3, r3, #1
 8002dae:	b2db      	uxtb	r3, r3
 8002db0:	2001      	movs	r0, #1
 8002db2:	4619      	mov	r1, r3
 8002db4:	f005 fbd4 	bl	8008560 <_test_assert>
 8002db8:	4603      	mov	r3, r0
 8002dba:	2b00      	cmp	r3, #0
 8002dbc:	d137      	bne.n	8002e2e <dyn2_execute.13263+0x1ee>
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8002dbe:	f005 fc5f 	bl	8008680 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 8002dc2:	2002      	movs	r0, #2
 8002dc4:	f640 5158 	movw	r1, #3416	; 0xd58
 8002dc8:	f6c0 0101 	movt	r1, #2049	; 0x801
 8002dcc:	f005 fbe0 	bl	8008590 <_test_assert_sequence>
 8002dd0:	4603      	mov	r3, r0
 8002dd2:	2b00      	cmp	r3, #0
 8002dd4:	d12b      	bne.n	8002e2e <dyn2_execute.13263+0x1ee>

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 8002dd6:	2300      	movs	r3, #0
 8002dd8:	9301      	str	r3, [sp, #4]
 8002dda:	e015      	b.n	8002e08 <dyn2_execute.13263+0x1c8>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 8002ddc:	f641 60d0 	movw	r0, #7888	; 0x1ed0
 8002de0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002de4:	f008 fd9c 	bl	800b920 <chPoolAlloc>
 8002de8:	4603      	mov	r3, r0
 8002dea:	2b00      	cmp	r3, #0
 8002dec:	bf0c      	ite	eq
 8002dee:	2300      	moveq	r3, #0
 8002df0:	2301      	movne	r3, #1
 8002df2:	b2db      	uxtb	r3, r3
 8002df4:	2003      	movs	r0, #3
 8002df6:	4619      	mov	r1, r3
 8002df8:	f005 fbb2 	bl	8008560 <_test_assert>
 8002dfc:	4603      	mov	r3, r0
 8002dfe:	2b00      	cmp	r3, #0
 8002e00:	d115      	bne.n	8002e2e <dyn2_execute.13263+0x1ee>
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 8002e02:	9b01      	ldr	r3, [sp, #4]
 8002e04:	3301      	adds	r3, #1
 8002e06:	9301      	str	r3, [sp, #4]
 8002e08:	9b01      	ldr	r3, [sp, #4]
 8002e0a:	2b03      	cmp	r3, #3
 8002e0c:	dde6      	ble.n	8002ddc <dyn2_execute.13263+0x19c>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8002e0e:	f641 60d0 	movw	r0, #7888	; 0x1ed0
 8002e12:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002e16:	f008 fd83 	bl	800b920 <chPoolAlloc>
 8002e1a:	4603      	mov	r3, r0
 8002e1c:	2b00      	cmp	r3, #0
 8002e1e:	bf14      	ite	ne
 8002e20:	2300      	movne	r3, #0
 8002e22:	2301      	moveq	r3, #1
 8002e24:	b2db      	uxtb	r3, r3
 8002e26:	2004      	movs	r0, #4
 8002e28:	4619      	mov	r1, r3
 8002e2a:	f005 fb99 	bl	8008560 <_test_assert>
}
 8002e2e:	b003      	add	sp, #12
 8002e30:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e34:	f3af 8000 	nop.w
 8002e38:	f3af 8000 	nop.w
 8002e3c:	f3af 8000 	nop.w

08002e40 <regfind.13265.4233>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 8002e40:	b500      	push	{lr}
 8002e42:	b085      	sub	sp, #20
 8002e44:	9001      	str	r0, [sp, #4]
  thread_t *ftp;
  bool found = false;
 8002e46:	2300      	movs	r3, #0
 8002e48:	f88d 300b 	strb.w	r3, [sp, #11]

  ftp = chRegFirstThread();
 8002e4c:	f00b fa40 	bl	800e2d0 <chRegFirstThread>
 8002e50:	9003      	str	r0, [sp, #12]
  do {
    found |= ftp == tp;
 8002e52:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8002e56:	9903      	ldr	r1, [sp, #12]
 8002e58:	9b01      	ldr	r3, [sp, #4]
 8002e5a:	4299      	cmp	r1, r3
 8002e5c:	bf14      	ite	ne
 8002e5e:	2300      	movne	r3, #0
 8002e60:	2301      	moveq	r3, #1
 8002e62:	b2db      	uxtb	r3, r3
 8002e64:	4313      	orrs	r3, r2
 8002e66:	2b00      	cmp	r3, #0
 8002e68:	bf0c      	ite	eq
 8002e6a:	2300      	moveq	r3, #0
 8002e6c:	2301      	movne	r3, #1
 8002e6e:	f88d 300b 	strb.w	r3, [sp, #11]
    ftp = chRegNextThread(ftp);
 8002e72:	9803      	ldr	r0, [sp, #12]
 8002e74:	f00b fa4c 	bl	800e310 <chRegNextThread>
 8002e78:	9003      	str	r0, [sp, #12]
  } while (ftp != NULL);
 8002e7a:	9b03      	ldr	r3, [sp, #12]
 8002e7c:	2b00      	cmp	r3, #0
 8002e7e:	d1e8      	bne.n	8002e52 <regfind.13265.4233+0x12>
  return found;
 8002e80:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 8002e84:	4618      	mov	r0, r3
 8002e86:	b005      	add	sp, #20
 8002e88:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e8c:	f3af 8000 	nop.w

08002e90 <dyn3_setup.13257>:

static void dyn3_setup(void) {
 8002e90:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 8002e92:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 8002e96:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002e9a:	f241 7158 	movw	r1, #5976	; 0x1758
 8002e9e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8002ea2:	f44f 62e1 	mov.w	r2, #1800	; 0x708
 8002ea6:	f008 fb0b 	bl	800b4c0 <chHeapObjectInit>
}
 8002eaa:	bd08      	pop	{r3, pc}
 8002eac:	f3af 8000 	nop.w

08002eb0 <dyn3_execute.13269>:

static void dyn3_execute(void) {
 8002eb0:	b500      	push	{lr}
 8002eb2:	b085      	sub	sp, #20
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();
 8002eb4:	f7ff fdbc 	bl	8002a30 <chThdGetPriorityX.13250.4244>
 8002eb8:	9003      	str	r0, [sp, #12]

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8002eba:	9b03      	ldr	r3, [sp, #12]
 8002ebc:	1e5a      	subs	r2, r3, #1
 8002ebe:	f640 5340 	movw	r3, #3392	; 0xd40
 8002ec2:	f6c0 0301 	movt	r3, #2049	; 0x801
 8002ec6:	9300      	str	r3, [sp, #0]
 8002ec8:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 8002ecc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8002ed0:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8002ed4:	f642 2341 	movw	r3, #10817	; 0x2a41
 8002ed8:	f6c0 0300 	movt	r3, #2048	; 0x800
 8002edc:	f00b f928 	bl	800e130 <chThdCreateFromHeap>
 8002ee0:	9002      	str	r0, [sp, #8]
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 8002ee2:	9b02      	ldr	r3, [sp, #8]
 8002ee4:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8002ee8:	2b01      	cmp	r3, #1
 8002eea:	bf14      	ite	ne
 8002eec:	2300      	movne	r3, #0
 8002eee:	2301      	moveq	r3, #1
 8002ef0:	b2db      	uxtb	r3, r3
 8002ef2:	2001      	movs	r0, #1
 8002ef4:	4619      	mov	r1, r3
 8002ef6:	f005 fb33 	bl	8008560 <_test_assert>
 8002efa:	4603      	mov	r3, r0
 8002efc:	2b00      	cmp	r3, #0
 8002efe:	f040 80a3 	bne.w	8003048 <dyn3_execute.13269+0x198>
  chThdAddRef(tp);
 8002f02:	9802      	ldr	r0, [sp, #8]
 8002f04:	f00b f89c 	bl	800e040 <chThdAddRef>
  test_assert(2, tp->p_refs == 2, "references increase failure");
 8002f08:	9b02      	ldr	r3, [sp, #8]
 8002f0a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8002f0e:	2b02      	cmp	r3, #2
 8002f10:	bf14      	ite	ne
 8002f12:	2300      	movne	r3, #0
 8002f14:	2301      	moveq	r3, #1
 8002f16:	b2db      	uxtb	r3, r3
 8002f18:	2002      	movs	r0, #2
 8002f1a:	4619      	mov	r1, r3
 8002f1c:	f005 fb20 	bl	8008560 <_test_assert>
 8002f20:	4603      	mov	r3, r0
 8002f22:	2b00      	cmp	r3, #0
 8002f24:	f040 8090 	bne.w	8003048 <dyn3_execute.13269+0x198>
  chThdRelease(tp);
 8002f28:	9802      	ldr	r0, [sp, #8]
 8002f2a:	f00b f8a9 	bl	800e080 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 8002f2e:	9b02      	ldr	r3, [sp, #8]
 8002f30:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8002f34:	2b01      	cmp	r3, #1
 8002f36:	bf14      	ite	ne
 8002f38:	2300      	movne	r3, #0
 8002f3a:	2301      	moveq	r3, #1
 8002f3c:	b2db      	uxtb	r3, r3
 8002f3e:	2003      	movs	r0, #3
 8002f40:	4619      	mov	r1, r3
 8002f42:	f005 fb0d 	bl	8008560 <_test_assert>
 8002f46:	4603      	mov	r3, r0
 8002f48:	2b00      	cmp	r3, #0
 8002f4a:	d17d      	bne.n	8003048 <dyn3_execute.13269+0x198>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 8002f4c:	9802      	ldr	r0, [sp, #8]
 8002f4e:	f7ff ff77 	bl	8002e40 <regfind.13265.4233>
 8002f52:	4603      	mov	r3, r0
 8002f54:	2004      	movs	r0, #4
 8002f56:	4619      	mov	r1, r3
 8002f58:	f005 fb02 	bl	8008560 <_test_assert>
 8002f5c:	4603      	mov	r3, r0
 8002f5e:	2b00      	cmp	r3, #0
 8002f60:	d172      	bne.n	8003048 <dyn3_execute.13269+0x198>
  test_assert(5, regfind(tp), "thread disappeared");
 8002f62:	9802      	ldr	r0, [sp, #8]
 8002f64:	f7ff ff6c 	bl	8002e40 <regfind.13265.4233>
 8002f68:	4603      	mov	r3, r0
 8002f6a:	2005      	movs	r0, #5
 8002f6c:	4619      	mov	r1, r3
 8002f6e:	f005 faf7 	bl	8008560 <_test_assert>
 8002f72:	4603      	mov	r3, r0
 8002f74:	2b00      	cmp	r3, #0
 8002f76:	d167      	bne.n	8003048 <dyn3_execute.13269+0x198>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 8002f78:	9802      	ldr	r0, [sp, #8]
 8002f7a:	f00b f881 	bl	800e080 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 8002f7e:	9b02      	ldr	r3, [sp, #8]
 8002f80:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8002f84:	2b00      	cmp	r3, #0
 8002f86:	bf14      	ite	ne
 8002f88:	2300      	movne	r3, #0
 8002f8a:	2301      	moveq	r3, #1
 8002f8c:	b2db      	uxtb	r3, r3
 8002f8e:	2006      	movs	r0, #6
 8002f90:	4619      	mov	r1, r3
 8002f92:	f005 fae5 	bl	8008560 <_test_assert>
 8002f96:	4603      	mov	r3, r0
 8002f98:	2b00      	cmp	r3, #0
 8002f9a:	d155      	bne.n	8003048 <dyn3_execute.13269+0x198>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 8002f9c:	9b02      	ldr	r3, [sp, #8]
 8002f9e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8002fa2:	2b00      	cmp	r3, #0
 8002fa4:	bf14      	ite	ne
 8002fa6:	2300      	movne	r3, #0
 8002fa8:	2301      	moveq	r3, #1
 8002faa:	b2db      	uxtb	r3, r3
 8002fac:	2007      	movs	r0, #7
 8002fae:	4619      	mov	r1, r3
 8002fb0:	f005 fad6 	bl	8008560 <_test_assert>
 8002fb4:	4603      	mov	r3, r0
 8002fb6:	2b00      	cmp	r3, #0
 8002fb8:	d146      	bne.n	8003048 <dyn3_execute.13269+0x198>
  test_assert(8, regfind(tp), "thread disappeared");
 8002fba:	9802      	ldr	r0, [sp, #8]
 8002fbc:	f7ff ff40 	bl	8002e40 <regfind.13265.4233>
 8002fc0:	4603      	mov	r3, r0
 8002fc2:	2008      	movs	r0, #8
 8002fc4:	4619      	mov	r1, r3
 8002fc6:	f005 facb 	bl	8008560 <_test_assert>
 8002fca:	4603      	mov	r3, r0
 8002fcc:	2b00      	cmp	r3, #0
 8002fce:	d13b      	bne.n	8003048 <dyn3_execute.13269+0x198>
  test_assert(9, regfind(tp), "thread disappeared");
 8002fd0:	9802      	ldr	r0, [sp, #8]
 8002fd2:	f7ff ff35 	bl	8002e40 <regfind.13265.4233>
 8002fd6:	4603      	mov	r3, r0
 8002fd8:	2009      	movs	r0, #9
 8002fda:	4619      	mov	r1, r3
 8002fdc:	f005 fac0 	bl	8008560 <_test_assert>
 8002fe0:	4603      	mov	r3, r0
 8002fe2:	2b00      	cmp	r3, #0
 8002fe4:	d130      	bne.n	8003048 <dyn3_execute.13269+0x198>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 8002fe6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002fea:	f00a fd31 	bl	800da50 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 8002fee:	9b02      	ldr	r3, [sp, #8]
 8002ff0:	f893 3020 	ldrb.w	r3, [r3, #32]
 8002ff4:	2b0f      	cmp	r3, #15
 8002ff6:	bf14      	ite	ne
 8002ff8:	2300      	movne	r3, #0
 8002ffa:	2301      	moveq	r3, #1
 8002ffc:	b2db      	uxtb	r3, r3
 8002ffe:	200a      	movs	r0, #10
 8003000:	4619      	mov	r1, r3
 8003002:	f005 faad 	bl	8008560 <_test_assert>
 8003006:	4603      	mov	r3, r0
 8003008:	2b00      	cmp	r3, #0
 800300a:	d11d      	bne.n	8003048 <dyn3_execute.13269+0x198>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 800300c:	9802      	ldr	r0, [sp, #8]
 800300e:	f7ff ff17 	bl	8002e40 <regfind.13265.4233>
 8003012:	4603      	mov	r3, r0
 8003014:	200b      	movs	r0, #11
 8003016:	4619      	mov	r1, r3
 8003018:	f005 faa2 	bl	8008560 <_test_assert>
 800301c:	4603      	mov	r3, r0
 800301e:	2b00      	cmp	r3, #0
 8003020:	d112      	bne.n	8003048 <dyn3_execute.13269+0x198>
  test_assert(12, !regfind(tp), "thread still in registry");
 8003022:	9802      	ldr	r0, [sp, #8]
 8003024:	f7ff ff0c 	bl	8002e40 <regfind.13265.4233>
 8003028:	4603      	mov	r3, r0
 800302a:	2b00      	cmp	r3, #0
 800302c:	bf0c      	ite	eq
 800302e:	2300      	moveq	r3, #0
 8003030:	2301      	movne	r3, #1
 8003032:	b2db      	uxtb	r3, r3
 8003034:	f083 0301 	eor.w	r3, r3, #1
 8003038:	b2db      	uxtb	r3, r3
 800303a:	f003 0301 	and.w	r3, r3, #1
 800303e:	b2db      	uxtb	r3, r3
 8003040:	200c      	movs	r0, #12
 8003042:	4619      	mov	r1, r3
 8003044:	f005 fa8c 	bl	8008560 <_test_assert>
}
 8003048:	b005      	add	sp, #20
 800304a:	f85d fb04 	ldr.w	pc, [sp], #4
 800304e:	bf00      	nop

08003050 <port_lock.13401.4223>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003050:	b082      	sub	sp, #8
 8003052:	2320      	movs	r3, #32
 8003054:	9301      	str	r3, [sp, #4]
 8003056:	9b01      	ldr	r3, [sp, #4]
 8003058:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800305c:	b002      	add	sp, #8
 800305e:	4770      	bx	lr

08003060 <port_unlock.13404.4221>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003060:	b082      	sub	sp, #8
 8003062:	2300      	movs	r3, #0
 8003064:	9301      	str	r3, [sp, #4]
 8003066:	9b01      	ldr	r3, [sp, #4]
 8003068:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800306c:	b002      	add	sp, #8
 800306e:	4770      	bx	lr

08003070 <chSysLock.13540.4219>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003070:	b508      	push	{r3, lr}

  port_lock();
 8003072:	f7ff ffed 	bl	8003050 <port_lock.13401.4223>
  _stats_start_measure_crit_thd();
 8003076:	f00a ff83 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800307a:	f00c fb31 	bl	800f6e0 <_dbg_check_lock>
}
 800307e:	bd08      	pop	{r3, pc}

08003080 <chSysUnlock.13542.4217>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003080:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8003082:	f00c fb4d 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8003086:	f00a ff83 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800308a:	f640 5350 	movw	r3, #3408	; 0xd50
 800308e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003092:	681a      	ldr	r2, [r3, #0]
 8003094:	f640 5350 	movw	r3, #3408	; 0xd50
 8003098:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800309c:	429a      	cmp	r2, r3
 800309e:	d013      	beq.n	80030c8 <chSysUnlock.13542.4217+0x48>
 80030a0:	f640 5350 	movw	r3, #3408	; 0xd50
 80030a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80030a8:	699b      	ldr	r3, [r3, #24]
 80030aa:	689a      	ldr	r2, [r3, #8]
 80030ac:	f640 5350 	movw	r3, #3408	; 0xd50
 80030b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80030b4:	681b      	ldr	r3, [r3, #0]
 80030b6:	689b      	ldr	r3, [r3, #8]
 80030b8:	429a      	cmp	r2, r3
 80030ba:	d205      	bcs.n	80030c8 <chSysUnlock.13542.4217+0x48>
 80030bc:	f242 20b0 	movw	r0, #8880	; 0x22b0
 80030c0:	f6c0 0001 	movt	r0, #2049	; 0x801
 80030c4:	f00c f964 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80030c8:	f7ff ffca 	bl	8003060 <port_unlock.13404.4221>
}
 80030cc:	bd08      	pop	{r3, pc}
 80030ce:	bf00      	nop

080030d0 <chThdGetSelfX.13406.4215>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80030d0:	f640 5350 	movw	r3, #3408	; 0xd50
 80030d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80030d8:	699b      	ldr	r3, [r3, #24]
}
 80030da:	4618      	mov	r0, r3
 80030dc:	4770      	bx	lr
 80030de:	bf00      	nop

080030e0 <chThdGetPriorityX.13494.4213>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 80030e0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 80030e2:	f7ff fff5 	bl	80030d0 <chThdGetSelfX.13406.4215>
 80030e6:	4603      	mov	r3, r0
 80030e8:	689b      	ldr	r3, [r3, #8]
}
 80030ea:	4618      	mov	r0, r3
 80030ec:	bd08      	pop	{r3, pc}
 80030ee:	bf00      	nop

080030f0 <chIQGetFullI.13527.4210>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {
 80030f0:	b500      	push	{lr}
 80030f2:	b083      	sub	sp, #12
 80030f4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80030f6:	f00c fbc3 	bl	800f880 <chDbgCheckClassI>

  return (size_t)chQSpaceI(iqp);
 80030fa:	9b01      	ldr	r3, [sp, #4]
 80030fc:	689b      	ldr	r3, [r3, #8]
}
 80030fe:	4618      	mov	r0, r3
 8003100:	b003      	add	sp, #12
 8003102:	f85d fb04 	ldr.w	pc, [sp], #4
 8003106:	bf00      	nop
 8003108:	f3af 8000 	nop.w
 800310c:	f3af 8000 	nop.w

08003110 <chIQIsEmptyI.13524.4207>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8003110:	b500      	push	{lr}
 8003112:	b083      	sub	sp, #12
 8003114:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003116:	f00c fbb3 	bl	800f880 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 800311a:	9b01      	ldr	r3, [sp, #4]
 800311c:	689b      	ldr	r3, [r3, #8]
 800311e:	2b00      	cmp	r3, #0
 8003120:	bf14      	ite	ne
 8003122:	2300      	movne	r3, #0
 8003124:	2301      	moveq	r3, #1
 8003126:	b2db      	uxtb	r3, r3
}
 8003128:	4618      	mov	r0, r3
 800312a:	b003      	add	sp, #12
 800312c:	f85d fb04 	ldr.w	pc, [sp], #4

08003130 <chIQIsFullI.13520.4204>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 8003130:	b500      	push	{lr}
 8003132:	b083      	sub	sp, #12
 8003134:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003136:	f00c fba3 	bl	800f880 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 800313a:	9b01      	ldr	r3, [sp, #4]
 800313c:	695a      	ldr	r2, [r3, #20]
 800313e:	9b01      	ldr	r3, [sp, #4]
 8003140:	699b      	ldr	r3, [r3, #24]
 8003142:	429a      	cmp	r2, r3
 8003144:	d105      	bne.n	8003152 <chIQIsFullI.13520.4204+0x22>
 8003146:	9b01      	ldr	r3, [sp, #4]
 8003148:	689b      	ldr	r3, [r3, #8]
 800314a:	2b00      	cmp	r3, #0
 800314c:	d001      	beq.n	8003152 <chIQIsFullI.13520.4204+0x22>
 800314e:	2301      	movs	r3, #1
 8003150:	e000      	b.n	8003154 <chIQIsFullI.13520.4204+0x24>
 8003152:	2300      	movs	r3, #0
 8003154:	f003 0301 	and.w	r3, r3, #1
 8003158:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800315a:	4618      	mov	r0, r3
 800315c:	b003      	add	sp, #12
 800315e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003162:	bf00      	nop
 8003164:	f3af 8000 	nop.w
 8003168:	f3af 8000 	nop.w
 800316c:	f3af 8000 	nop.w

08003170 <chIQGet.13516.4200>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 8003170:	b500      	push	{lr}
 8003172:	b083      	sub	sp, #12
 8003174:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8003176:	9801      	ldr	r0, [sp, #4]
 8003178:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800317c:	f007 ff00 	bl	800af80 <chIQGetTimeout>
 8003180:	4603      	mov	r3, r0
}
 8003182:	4618      	mov	r0, r3
 8003184:	b003      	add	sp, #12
 8003186:	f85d fb04 	ldr.w	pc, [sp], #4
 800318a:	bf00      	nop
 800318c:	f3af 8000 	nop.w

08003190 <chOQGetFullI.13534.4197>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {
 8003190:	b500      	push	{lr}
 8003192:	b083      	sub	sp, #12
 8003194:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003196:	f00c fb73 	bl	800f880 <chDbgCheckClassI>

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800319a:	9b01      	ldr	r3, [sp, #4]
 800319c:	691b      	ldr	r3, [r3, #16]
 800319e:	461a      	mov	r2, r3
 80031a0:	9b01      	ldr	r3, [sp, #4]
 80031a2:	68db      	ldr	r3, [r3, #12]
 80031a4:	1ad3      	subs	r3, r2, r3
 80031a6:	461a      	mov	r2, r3
 80031a8:	9b01      	ldr	r3, [sp, #4]
 80031aa:	689b      	ldr	r3, [r3, #8]
 80031ac:	1ad3      	subs	r3, r2, r3
}
 80031ae:	4618      	mov	r0, r3
 80031b0:	b003      	add	sp, #12
 80031b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80031b6:	bf00      	nop
 80031b8:	f3af 8000 	nop.w
 80031bc:	f3af 8000 	nop.w

080031c0 <chOQIsEmptyI.13530.4194>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 80031c0:	b500      	push	{lr}
 80031c2:	b083      	sub	sp, #12
 80031c4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80031c6:	f00c fb5b 	bl	800f880 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80031ca:	9b01      	ldr	r3, [sp, #4]
 80031cc:	695a      	ldr	r2, [r3, #20]
 80031ce:	9b01      	ldr	r3, [sp, #4]
 80031d0:	699b      	ldr	r3, [r3, #24]
 80031d2:	429a      	cmp	r2, r3
 80031d4:	d105      	bne.n	80031e2 <chOQIsEmptyI.13530.4194+0x22>
 80031d6:	9b01      	ldr	r3, [sp, #4]
 80031d8:	689b      	ldr	r3, [r3, #8]
 80031da:	2b00      	cmp	r3, #0
 80031dc:	d001      	beq.n	80031e2 <chOQIsEmptyI.13530.4194+0x22>
 80031de:	2301      	movs	r3, #1
 80031e0:	e000      	b.n	80031e4 <chOQIsEmptyI.13530.4194+0x24>
 80031e2:	2300      	movs	r3, #0
 80031e4:	f003 0301 	and.w	r3, r3, #1
 80031e8:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 80031ea:	4618      	mov	r0, r3
 80031ec:	b003      	add	sp, #12
 80031ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80031f2:	bf00      	nop
 80031f4:	f3af 8000 	nop.w
 80031f8:	f3af 8000 	nop.w
 80031fc:	f3af 8000 	nop.w

08003200 <chOQIsFullI.13537.4191>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8003200:	b500      	push	{lr}
 8003202:	b083      	sub	sp, #12
 8003204:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003206:	f00c fb3b 	bl	800f880 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 800320a:	9b01      	ldr	r3, [sp, #4]
 800320c:	689b      	ldr	r3, [r3, #8]
 800320e:	2b00      	cmp	r3, #0
 8003210:	bf14      	ite	ne
 8003212:	2300      	movne	r3, #0
 8003214:	2301      	moveq	r3, #1
 8003216:	b2db      	uxtb	r3, r3
}
 8003218:	4618      	mov	r0, r3
 800321a:	b003      	add	sp, #12
 800321c:	f85d fb04 	ldr.w	pc, [sp], #4

08003220 <chOQPut.13551.4186>:
 * @retval Q_OK         if the operation succeeded.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {
 8003220:	b500      	push	{lr}
 8003222:	b083      	sub	sp, #12
 8003224:	9001      	str	r0, [sp, #4]
 8003226:	460b      	mov	r3, r1
 8003228:	f88d 3003 	strb.w	r3, [sp, #3]

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 800322c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8003230:	9801      	ldr	r0, [sp, #4]
 8003232:	4619      	mov	r1, r3
 8003234:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003238:	f007 ff92 	bl	800b160 <chOQPutTimeout>
 800323c:	4603      	mov	r3, r0
}
 800323e:	4618      	mov	r0, r3
 8003240:	b003      	add	sp, #12
 8003242:	f85d fb04 	ldr.w	pc, [sp], #4
 8003246:	bf00      	nop
 8003248:	f3af 8000 	nop.w
 800324c:	f3af 8000 	nop.w

08003250 <notify.13496>:

#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
 8003250:	b082      	sub	sp, #8
 8003252:	9001      	str	r0, [sp, #4]
  (void)qp;
}
 8003254:	b002      	add	sp, #8
 8003256:	4770      	bx	lr
 8003258:	f3af 8000 	nop.w
 800325c:	f3af 8000 	nop.w

08003260 <queues1_setup.13511>:
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 8003260:	b500      	push	{lr}
 8003262:	b083      	sub	sp, #12

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 8003264:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8003268:	f6c0 0301 	movt	r3, #2049	; 0x801
 800326c:	681b      	ldr	r3, [r3, #0]
 800326e:	2200      	movs	r2, #0
 8003270:	9200      	str	r2, [sp, #0]
 8003272:	f640 00ac 	movw	r0, #2220	; 0x8ac
 8003276:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800327a:	4619      	mov	r1, r3
 800327c:	2204      	movs	r2, #4
 800327e:	f243 2351 	movw	r3, #12881	; 0x3251
 8003282:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003286:	f007 fdfb 	bl	800ae80 <chIQObjectInit>
}
 800328a:	b003      	add	sp, #12
 800328c:	f85d fb04 	ldr.w	pc, [sp], #4

08003290 <thread1.13513.4181>:

static THD_FUNCTION(thread1, p) {
 8003290:	b500      	push	{lr}
 8003292:	b083      	sub	sp, #12
 8003294:	9001      	str	r0, [sp, #4]

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 8003296:	f640 00ac 	movw	r0, #2220	; 0x8ac
 800329a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800329e:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80032a2:	f007 fe6d 	bl	800af80 <chIQGetTimeout>
}
 80032a6:	b003      	add	sp, #12
 80032a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80032ac:	f3af 8000 	nop.w

080032b0 <queues1_execute.13544>:

static void queues1_execute(void) {
 80032b0:	b510      	push	{r4, lr}
 80032b2:	b084      	sub	sp, #16
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 80032b4:	f7ff fedc 	bl	8003070 <chSysLock.13540.4219>
 80032b8:	f640 00ac 	movw	r0, #2220	; 0x8ac
 80032bc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80032c0:	f7ff ff26 	bl	8003110 <chIQIsEmptyI.13524.4207>
 80032c4:	4603      	mov	r3, r0
 80032c6:	2001      	movs	r0, #1
 80032c8:	4619      	mov	r1, r3
 80032ca:	f005 f949 	bl	8008560 <_test_assert>
 80032ce:	4603      	mov	r3, r0
 80032d0:	2b00      	cmp	r3, #0
 80032d2:	d002      	beq.n	80032da <queues1_execute.13544+0x2a>
 80032d4:	f7ff fed4 	bl	8003080 <chSysUnlock.13542.4217>
 80032d8:	e1a3      	b.n	8003622 <queues1_execute.13544+0x372>
 80032da:	f7ff fed1 	bl	8003080 <chSysUnlock.13542.4217>

  /* Queue filling */
  chSysLock();
 80032de:	f7ff fec7 	bl	8003070 <chSysLock.13540.4219>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80032e2:	2300      	movs	r3, #0
 80032e4:	9303      	str	r3, [sp, #12]
 80032e6:	e00d      	b.n	8003304 <queues1_execute.13544+0x54>
    chIQPutI(&iq, 'A' + i);
 80032e8:	9b03      	ldr	r3, [sp, #12]
 80032ea:	b2db      	uxtb	r3, r3
 80032ec:	3341      	adds	r3, #65	; 0x41
 80032ee:	b2db      	uxtb	r3, r3
 80032f0:	f640 00ac 	movw	r0, #2220	; 0x8ac
 80032f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80032f8:	4619      	mov	r1, r3
 80032fa:	f007 fe09 	bl	800af10 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80032fe:	9b03      	ldr	r3, [sp, #12]
 8003300:	3301      	adds	r3, #1
 8003302:	9303      	str	r3, [sp, #12]
 8003304:	9b03      	ldr	r3, [sp, #12]
 8003306:	2b03      	cmp	r3, #3
 8003308:	d9ee      	bls.n	80032e8 <queues1_execute.13544+0x38>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800330a:	f7ff feb9 	bl	8003080 <chSysUnlock.13542.4217>
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 800330e:	f7ff feaf 	bl	8003070 <chSysLock.13540.4219>
 8003312:	f640 00ac 	movw	r0, #2220	; 0x8ac
 8003316:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800331a:	f7ff ff09 	bl	8003130 <chIQIsFullI.13520.4204>
 800331e:	4603      	mov	r3, r0
 8003320:	2002      	movs	r0, #2
 8003322:	4619      	mov	r1, r3
 8003324:	f005 f91c 	bl	8008560 <_test_assert>
 8003328:	4603      	mov	r3, r0
 800332a:	2b00      	cmp	r3, #0
 800332c:	d002      	beq.n	8003334 <queues1_execute.13544+0x84>
 800332e:	f7ff fea7 	bl	8003080 <chSysUnlock.13542.4217>
 8003332:	e176      	b.n	8003622 <queues1_execute.13544+0x372>
 8003334:	f7ff fea4 	bl	8003080 <chSysUnlock.13542.4217>
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 8003338:	f7ff fe9a 	bl	8003070 <chSysLock.13540.4219>
 800333c:	f640 00ac 	movw	r0, #2220	; 0x8ac
 8003340:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003344:	2100      	movs	r1, #0
 8003346:	f007 fde3 	bl	800af10 <chIQPutI>
 800334a:	4603      	mov	r3, r0
 800334c:	f113 0f04 	cmn.w	r3, #4
 8003350:	bf14      	ite	ne
 8003352:	2300      	movne	r3, #0
 8003354:	2301      	moveq	r3, #1
 8003356:	b2db      	uxtb	r3, r3
 8003358:	2003      	movs	r0, #3
 800335a:	4619      	mov	r1, r3
 800335c:	f005 f900 	bl	8008560 <_test_assert>
 8003360:	4603      	mov	r3, r0
 8003362:	2b00      	cmp	r3, #0
 8003364:	d002      	beq.n	800336c <queues1_execute.13544+0xbc>
 8003366:	f7ff fe8b 	bl	8003080 <chSysUnlock.13542.4217>
 800336a:	e15a      	b.n	8003622 <queues1_execute.13544+0x372>
 800336c:	f7ff fe88 	bl	8003080 <chSysUnlock.13542.4217>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8003370:	2300      	movs	r3, #0
 8003372:	9303      	str	r3, [sp, #12]
 8003374:	e00d      	b.n	8003392 <queues1_execute.13544+0xe2>
    test_emit_token(chIQGet(&iq));
 8003376:	f640 00ac 	movw	r0, #2220	; 0x8ac
 800337a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800337e:	f7ff fef7 	bl	8003170 <chIQGet.13516.4200>
 8003382:	4603      	mov	r3, r0
 8003384:	b2db      	uxtb	r3, r3
 8003386:	4618      	mov	r0, r3
 8003388:	f005 f8b2 	bl	80084f0 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800338c:	9b03      	ldr	r3, [sp, #12]
 800338e:	3301      	adds	r3, #1
 8003390:	9303      	str	r3, [sp, #12]
 8003392:	9b03      	ldr	r3, [sp, #12]
 8003394:	2b03      	cmp	r3, #3
 8003396:	d9ee      	bls.n	8003376 <queues1_execute.13544+0xc6>
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 8003398:	f7ff fe6a 	bl	8003070 <chSysLock.13540.4219>
 800339c:	f640 00ac 	movw	r0, #2220	; 0x8ac
 80033a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80033a4:	f7ff feb4 	bl	8003110 <chIQIsEmptyI.13524.4207>
 80033a8:	4603      	mov	r3, r0
 80033aa:	2004      	movs	r0, #4
 80033ac:	4619      	mov	r1, r3
 80033ae:	f005 f8d7 	bl	8008560 <_test_assert>
 80033b2:	4603      	mov	r3, r0
 80033b4:	2b00      	cmp	r3, #0
 80033b6:	d002      	beq.n	80033be <queues1_execute.13544+0x10e>
 80033b8:	f7ff fe62 	bl	8003080 <chSysUnlock.13542.4217>
 80033bc:	e131      	b.n	8003622 <queues1_execute.13544+0x372>
 80033be:	f7ff fe5f 	bl	8003080 <chSysUnlock.13542.4217>
  test_assert_sequence(5, "ABCD");
 80033c2:	2005      	movs	r0, #5
 80033c4:	f640 5158 	movw	r1, #3416	; 0xd58
 80033c8:	f6c0 0101 	movt	r1, #2049	; 0x801
 80033cc:	f005 f8e0 	bl	8008590 <_test_assert_sequence>
 80033d0:	4603      	mov	r3, r0
 80033d2:	2b00      	cmp	r3, #0
 80033d4:	f040 8125 	bne.w	8003622 <queues1_execute.13544+0x372>

  /* Queue filling again */
  chSysLock();
 80033d8:	f7ff fe4a 	bl	8003070 <chSysLock.13540.4219>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80033dc:	2300      	movs	r3, #0
 80033de:	9303      	str	r3, [sp, #12]
 80033e0:	e00d      	b.n	80033fe <queues1_execute.13544+0x14e>
    chIQPutI(&iq, 'A' + i);
 80033e2:	9b03      	ldr	r3, [sp, #12]
 80033e4:	b2db      	uxtb	r3, r3
 80033e6:	3341      	adds	r3, #65	; 0x41
 80033e8:	b2db      	uxtb	r3, r3
 80033ea:	f640 00ac 	movw	r0, #2220	; 0x8ac
 80033ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80033f2:	4619      	mov	r1, r3
 80033f4:	f007 fd8c 	bl	800af10 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80033f8:	9b03      	ldr	r3, [sp, #12]
 80033fa:	3301      	adds	r3, #1
 80033fc:	9303      	str	r3, [sp, #12]
 80033fe:	9b03      	ldr	r3, [sp, #12]
 8003400:	2b03      	cmp	r3, #3
 8003402:	d9ee      	bls.n	80033e2 <queues1_execute.13544+0x132>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 8003404:	f7ff fe3c 	bl	8003080 <chSysUnlock.13542.4217>

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 8003408:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 800340c:	f6c0 0301 	movt	r3, #2049	; 0x801
 8003410:	685b      	ldr	r3, [r3, #4]
 8003412:	f640 00ac 	movw	r0, #2220	; 0x8ac
 8003416:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800341a:	4619      	mov	r1, r3
 800341c:	2208      	movs	r2, #8
 800341e:	2300      	movs	r3, #0
 8003420:	f007 fdf6 	bl	800b010 <chIQReadTimeout>
 8003424:	9002      	str	r0, [sp, #8]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 8003426:	9b02      	ldr	r3, [sp, #8]
 8003428:	2b04      	cmp	r3, #4
 800342a:	bf14      	ite	ne
 800342c:	2300      	movne	r3, #0
 800342e:	2301      	moveq	r3, #1
 8003430:	b2db      	uxtb	r3, r3
 8003432:	2006      	movs	r0, #6
 8003434:	4619      	mov	r1, r3
 8003436:	f005 f893 	bl	8008560 <_test_assert>
 800343a:	4603      	mov	r3, r0
 800343c:	2b00      	cmp	r3, #0
 800343e:	f040 80f0 	bne.w	8003622 <queues1_execute.13544+0x372>
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 8003442:	f7ff fe15 	bl	8003070 <chSysLock.13540.4219>
 8003446:	f640 00ac 	movw	r0, #2220	; 0x8ac
 800344a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800344e:	f7ff fe5f 	bl	8003110 <chIQIsEmptyI.13524.4207>
 8003452:	4603      	mov	r3, r0
 8003454:	2007      	movs	r0, #7
 8003456:	4619      	mov	r1, r3
 8003458:	f005 f882 	bl	8008560 <_test_assert>
 800345c:	4603      	mov	r3, r0
 800345e:	2b00      	cmp	r3, #0
 8003460:	d002      	beq.n	8003468 <queues1_execute.13544+0x1b8>
 8003462:	f7ff fe0d 	bl	8003080 <chSysUnlock.13542.4217>
 8003466:	e0dc      	b.n	8003622 <queues1_execute.13544+0x372>
 8003468:	f7ff fe0a 	bl	8003080 <chSysUnlock.13542.4217>

  /* Queue filling again */
  chSysLock();
 800346c:	f7ff fe00 	bl	8003070 <chSysLock.13540.4219>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8003470:	2300      	movs	r3, #0
 8003472:	9303      	str	r3, [sp, #12]
 8003474:	e00d      	b.n	8003492 <queues1_execute.13544+0x1e2>
    chIQPutI(&iq, 'A' + i);
 8003476:	9b03      	ldr	r3, [sp, #12]
 8003478:	b2db      	uxtb	r3, r3
 800347a:	3341      	adds	r3, #65	; 0x41
 800347c:	b2db      	uxtb	r3, r3
 800347e:	f640 00ac 	movw	r0, #2220	; 0x8ac
 8003482:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003486:	4619      	mov	r1, r3
 8003488:	f007 fd42 	bl	800af10 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800348c:	9b03      	ldr	r3, [sp, #12]
 800348e:	3301      	adds	r3, #1
 8003490:	9303      	str	r3, [sp, #12]
 8003492:	9b03      	ldr	r3, [sp, #12]
 8003494:	2b03      	cmp	r3, #3
 8003496:	d9ee      	bls.n	8003476 <queues1_execute.13544+0x1c6>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 8003498:	f7ff fdf2 	bl	8003080 <chSysUnlock.13542.4217>

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800349c:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80034a0:	f6c0 0301 	movt	r3, #2049	; 0x801
 80034a4:	685b      	ldr	r3, [r3, #4]
 80034a6:	f640 00ac 	movw	r0, #2220	; 0x8ac
 80034aa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80034ae:	4619      	mov	r1, r3
 80034b0:	2202      	movs	r2, #2
 80034b2:	2300      	movs	r3, #0
 80034b4:	f007 fdac 	bl	800b010 <chIQReadTimeout>
 80034b8:	9002      	str	r0, [sp, #8]
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 80034ba:	9b02      	ldr	r3, [sp, #8]
 80034bc:	2b02      	cmp	r3, #2
 80034be:	bf14      	ite	ne
 80034c0:	2300      	movne	r3, #0
 80034c2:	2301      	moveq	r3, #1
 80034c4:	b2db      	uxtb	r3, r3
 80034c6:	2008      	movs	r0, #8
 80034c8:	4619      	mov	r1, r3
 80034ca:	f005 f849 	bl	8008560 <_test_assert>
 80034ce:	4603      	mov	r3, r0
 80034d0:	2b00      	cmp	r3, #0
 80034d2:	f040 80a6 	bne.w	8003622 <queues1_execute.13544+0x372>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 80034d6:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80034da:	f6c0 0301 	movt	r3, #2049	; 0x801
 80034de:	685b      	ldr	r3, [r3, #4]
 80034e0:	f640 00ac 	movw	r0, #2220	; 0x8ac
 80034e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80034e8:	4619      	mov	r1, r3
 80034ea:	2202      	movs	r2, #2
 80034ec:	2300      	movs	r3, #0
 80034ee:	f007 fd8f 	bl	800b010 <chIQReadTimeout>
 80034f2:	9002      	str	r0, [sp, #8]
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 80034f4:	9b02      	ldr	r3, [sp, #8]
 80034f6:	2b02      	cmp	r3, #2
 80034f8:	bf14      	ite	ne
 80034fa:	2300      	movne	r3, #0
 80034fc:	2301      	moveq	r3, #1
 80034fe:	b2db      	uxtb	r3, r3
 8003500:	2009      	movs	r0, #9
 8003502:	4619      	mov	r1, r3
 8003504:	f005 f82c 	bl	8008560 <_test_assert>
 8003508:	4603      	mov	r3, r0
 800350a:	2b00      	cmp	r3, #0
 800350c:	f040 8089 	bne.w	8003622 <queues1_execute.13544+0x372>
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 8003510:	f7ff fdae 	bl	8003070 <chSysLock.13540.4219>
 8003514:	f640 00ac 	movw	r0, #2220	; 0x8ac
 8003518:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800351c:	f7ff fdf8 	bl	8003110 <chIQIsEmptyI.13524.4207>
 8003520:	4603      	mov	r3, r0
 8003522:	200a      	movs	r0, #10
 8003524:	4619      	mov	r1, r3
 8003526:	f005 f81b 	bl	8008560 <_test_assert>
 800352a:	4603      	mov	r3, r0
 800352c:	2b00      	cmp	r3, #0
 800352e:	d002      	beq.n	8003536 <queues1_execute.13544+0x286>
 8003530:	f7ff fda6 	bl	8003080 <chSysUnlock.13542.4217>
 8003534:	e075      	b.n	8003622 <queues1_execute.13544+0x372>
 8003536:	f7ff fda3 	bl	8003080 <chSysUnlock.13542.4217>

  /* Testing reset */
  chSysLock();
 800353a:	f7ff fd99 	bl	8003070 <chSysLock.13540.4219>
  chIQPutI(&iq, 0);
 800353e:	f640 00ac 	movw	r0, #2220	; 0x8ac
 8003542:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003546:	2100      	movs	r1, #0
 8003548:	f007 fce2 	bl	800af10 <chIQPutI>
  chIQResetI(&iq);
 800354c:	f640 00ac 	movw	r0, #2220	; 0x8ac
 8003550:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003554:	f007 fcbc 	bl	800aed0 <chIQResetI>
  chSysUnlock();
 8003558:	f7ff fd92 	bl	8003080 <chSysUnlock.13542.4217>
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 800355c:	f7ff fd88 	bl	8003070 <chSysLock.13540.4219>
 8003560:	f640 00ac 	movw	r0, #2220	; 0x8ac
 8003564:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003568:	f7ff fdc2 	bl	80030f0 <chIQGetFullI.13527.4210>
 800356c:	4603      	mov	r3, r0
 800356e:	2b00      	cmp	r3, #0
 8003570:	bf14      	ite	ne
 8003572:	2300      	movne	r3, #0
 8003574:	2301      	moveq	r3, #1
 8003576:	b2db      	uxtb	r3, r3
 8003578:	200b      	movs	r0, #11
 800357a:	4619      	mov	r1, r3
 800357c:	f004 fff0 	bl	8008560 <_test_assert>
 8003580:	4603      	mov	r3, r0
 8003582:	2b00      	cmp	r3, #0
 8003584:	d002      	beq.n	800358c <queues1_execute.13544+0x2dc>
 8003586:	f7ff fd7b 	bl	8003080 <chSysUnlock.13542.4217>
 800358a:	e04a      	b.n	8003622 <queues1_execute.13544+0x372>
 800358c:	f7ff fd78 	bl	8003080 <chSysUnlock.13542.4217>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 8003590:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8003594:	f6c0 0301 	movt	r3, #2049	; 0x801
 8003598:	681c      	ldr	r4, [r3, #0]
 800359a:	f7ff fda1 	bl	80030e0 <chThdGetPriorityX.13494.4213>
 800359e:	4603      	mov	r3, r0
 80035a0:	3301      	adds	r3, #1
 80035a2:	2200      	movs	r2, #0
 80035a4:	9200      	str	r2, [sp, #0]
 80035a6:	4620      	mov	r0, r4
 80035a8:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80035ac:	461a      	mov	r2, r3
 80035ae:	f243 2391 	movw	r3, #12945	; 0x3291
 80035b2:	f6c0 0300 	movt	r3, #2048	; 0x800
 80035b6:	f00d f8d3 	bl	8010760 <chThdCreateStatic>
 80035ba:	4602      	mov	r2, r0
 80035bc:	f641 6360 	movw	r3, #7776	; 0x1e60
 80035c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035c4:	601a      	str	r2, [r3, #0]
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 80035c6:	f7ff fd53 	bl	8003070 <chSysLock.13540.4219>
 80035ca:	f640 00ac 	movw	r0, #2220	; 0x8ac
 80035ce:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80035d2:	f7ff fd8d 	bl	80030f0 <chIQGetFullI.13527.4210>
 80035d6:	4603      	mov	r3, r0
 80035d8:	2b00      	cmp	r3, #0
 80035da:	bf14      	ite	ne
 80035dc:	2300      	movne	r3, #0
 80035de:	2301      	moveq	r3, #1
 80035e0:	b2db      	uxtb	r3, r3
 80035e2:	200c      	movs	r0, #12
 80035e4:	4619      	mov	r1, r3
 80035e6:	f004 ffbb 	bl	8008560 <_test_assert>
 80035ea:	4603      	mov	r3, r0
 80035ec:	2b00      	cmp	r3, #0
 80035ee:	d002      	beq.n	80035f6 <queues1_execute.13544+0x346>
 80035f0:	f7ff fd46 	bl	8003080 <chSysUnlock.13542.4217>
 80035f4:	e015      	b.n	8003622 <queues1_execute.13544+0x372>
 80035f6:	f7ff fd43 	bl	8003080 <chSysUnlock.13542.4217>
  test_wait_threads();
 80035fa:	f005 f841 	bl	8008680 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 80035fe:	f640 00ac 	movw	r0, #2220	; 0x8ac
 8003602:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003606:	210a      	movs	r1, #10
 8003608:	f007 fcba 	bl	800af80 <chIQGetTimeout>
 800360c:	4603      	mov	r3, r0
 800360e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8003612:	bf14      	ite	ne
 8003614:	2300      	movne	r3, #0
 8003616:	2301      	moveq	r3, #1
 8003618:	b2db      	uxtb	r3, r3
 800361a:	200d      	movs	r0, #13
 800361c:	4619      	mov	r1, r3
 800361e:	f004 ff9f 	bl	8008560 <_test_assert>
}
 8003622:	b004      	add	sp, #16
 8003624:	bd10      	pop	{r4, pc}
 8003626:	bf00      	nop
 8003628:	f3af 8000 	nop.w
 800362c:	f3af 8000 	nop.w

08003630 <queues2_setup.13546>:
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 8003630:	b500      	push	{lr}
 8003632:	b083      	sub	sp, #12

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 8003634:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8003638:	f6c0 0301 	movt	r3, #2049	; 0x801
 800363c:	681b      	ldr	r3, [r3, #0]
 800363e:	2200      	movs	r2, #0
 8003640:	9200      	str	r2, [sp, #0]
 8003642:	f640 00d0 	movw	r0, #2256	; 0x8d0
 8003646:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800364a:	4619      	mov	r1, r3
 800364c:	2204      	movs	r2, #4
 800364e:	f243 2351 	movw	r3, #12881	; 0x3251
 8003652:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003656:	f007 fd3b 	bl	800b0d0 <chOQObjectInit>
}
 800365a:	b003      	add	sp, #12
 800365c:	f85d fb04 	ldr.w	pc, [sp], #4

08003660 <thread2.13548.4072>:

static THD_FUNCTION(thread2, p) {
 8003660:	b500      	push	{lr}
 8003662:	b083      	sub	sp, #12
 8003664:	9001      	str	r0, [sp, #4]

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 8003666:	f640 00d0 	movw	r0, #2256	; 0x8d0
 800366a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800366e:	2100      	movs	r1, #0
 8003670:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8003674:	f007 fd74 	bl	800b160 <chOQPutTimeout>
}
 8003678:	b003      	add	sp, #12
 800367a:	f85d fb04 	ldr.w	pc, [sp], #4
 800367e:	bf00      	nop

08003680 <queues2_execute.13555>:

static void queues2_execute(void) {
 8003680:	b510      	push	{r4, lr}
 8003682:	b086      	sub	sp, #24
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 8003684:	f7ff fcf4 	bl	8003070 <chSysLock.13540.4219>
 8003688:	f640 00d0 	movw	r0, #2256	; 0x8d0
 800368c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003690:	f7ff fd96 	bl	80031c0 <chOQIsEmptyI.13530.4194>
 8003694:	4603      	mov	r3, r0
 8003696:	2001      	movs	r0, #1
 8003698:	4619      	mov	r1, r3
 800369a:	f004 ff61 	bl	8008560 <_test_assert>
 800369e:	4603      	mov	r3, r0
 80036a0:	2b00      	cmp	r3, #0
 80036a2:	d002      	beq.n	80036aa <queues2_execute.13555+0x2a>
 80036a4:	f7ff fcec 	bl	8003080 <chSysUnlock.13542.4217>
 80036a8:	e16d      	b.n	8003986 <queues2_execute.13555+0x306>
 80036aa:	f7ff fce9 	bl	8003080 <chSysUnlock.13542.4217>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80036ae:	2300      	movs	r3, #0
 80036b0:	9305      	str	r3, [sp, #20]
 80036b2:	e00d      	b.n	80036d0 <queues2_execute.13555+0x50>
    chOQPut(&oq, 'A' + i);
 80036b4:	9b05      	ldr	r3, [sp, #20]
 80036b6:	b2db      	uxtb	r3, r3
 80036b8:	3341      	adds	r3, #65	; 0x41
 80036ba:	b2db      	uxtb	r3, r3
 80036bc:	f640 00d0 	movw	r0, #2256	; 0x8d0
 80036c0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80036c4:	4619      	mov	r1, r3
 80036c6:	f7ff fdab 	bl	8003220 <chOQPut.13551.4186>

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80036ca:	9b05      	ldr	r3, [sp, #20]
 80036cc:	3301      	adds	r3, #1
 80036ce:	9305      	str	r3, [sp, #20]
 80036d0:	9b05      	ldr	r3, [sp, #20]
 80036d2:	2b03      	cmp	r3, #3
 80036d4:	d9ee      	bls.n	80036b4 <queues2_execute.13555+0x34>
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 80036d6:	f7ff fccb 	bl	8003070 <chSysLock.13540.4219>
 80036da:	f640 00d0 	movw	r0, #2256	; 0x8d0
 80036de:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80036e2:	f7ff fd8d 	bl	8003200 <chOQIsFullI.13537.4191>
 80036e6:	4603      	mov	r3, r0
 80036e8:	2002      	movs	r0, #2
 80036ea:	4619      	mov	r1, r3
 80036ec:	f004 ff38 	bl	8008560 <_test_assert>
 80036f0:	4603      	mov	r3, r0
 80036f2:	2b00      	cmp	r3, #0
 80036f4:	d002      	beq.n	80036fc <queues2_execute.13555+0x7c>
 80036f6:	f7ff fcc3 	bl	8003080 <chSysUnlock.13542.4217>
 80036fa:	e144      	b.n	8003986 <queues2_execute.13555+0x306>
 80036fc:	f7ff fcc0 	bl	8003080 <chSysUnlock.13542.4217>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 8003700:	2300      	movs	r3, #0
 8003702:	9305      	str	r3, [sp, #20]
 8003704:	e014      	b.n	8003730 <queues2_execute.13555+0xb0>
    char c;

    chSysLock();
 8003706:	f7ff fcb3 	bl	8003070 <chSysLock.13540.4219>
    c = chOQGetI(&oq);
 800370a:	f640 00d0 	movw	r0, #2256	; 0x8d0
 800370e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003712:	f007 fd6d 	bl	800b1f0 <chOQGetI>
 8003716:	4603      	mov	r3, r0
 8003718:	f88d 3013 	strb.w	r3, [sp, #19]
    chSysUnlock();
 800371c:	f7ff fcb0 	bl	8003080 <chSysUnlock.13542.4217>
    test_emit_token(c);
 8003720:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8003724:	4618      	mov	r0, r3
 8003726:	f004 fee3 	bl	80084f0 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 800372a:	9b05      	ldr	r3, [sp, #20]
 800372c:	3301      	adds	r3, #1
 800372e:	9305      	str	r3, [sp, #20]
 8003730:	9b05      	ldr	r3, [sp, #20]
 8003732:	2b03      	cmp	r3, #3
 8003734:	d9e7      	bls.n	8003706 <queues2_execute.13555+0x86>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 8003736:	f7ff fc9b 	bl	8003070 <chSysLock.13540.4219>
 800373a:	f640 00d0 	movw	r0, #2256	; 0x8d0
 800373e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003742:	f7ff fd3d 	bl	80031c0 <chOQIsEmptyI.13530.4194>
 8003746:	4603      	mov	r3, r0
 8003748:	2003      	movs	r0, #3
 800374a:	4619      	mov	r1, r3
 800374c:	f004 ff08 	bl	8008560 <_test_assert>
 8003750:	4603      	mov	r3, r0
 8003752:	2b00      	cmp	r3, #0
 8003754:	d002      	beq.n	800375c <queues2_execute.13555+0xdc>
 8003756:	f7ff fc93 	bl	8003080 <chSysUnlock.13542.4217>
 800375a:	e114      	b.n	8003986 <queues2_execute.13555+0x306>
 800375c:	f7ff fc90 	bl	8003080 <chSysUnlock.13542.4217>
  test_assert_sequence(4, "ABCD");
 8003760:	2004      	movs	r0, #4
 8003762:	f640 5158 	movw	r1, #3416	; 0xd58
 8003766:	f6c0 0101 	movt	r1, #2049	; 0x801
 800376a:	f004 ff11 	bl	8008590 <_test_assert_sequence>
 800376e:	4603      	mov	r3, r0
 8003770:	2b00      	cmp	r3, #0
 8003772:	f040 8108 	bne.w	8003986 <queues2_execute.13555+0x306>
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 8003776:	f7ff fc7b 	bl	8003070 <chSysLock.13540.4219>
 800377a:	f640 00d0 	movw	r0, #2256	; 0x8d0
 800377e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003782:	f007 fd35 	bl	800b1f0 <chOQGetI>
 8003786:	4603      	mov	r3, r0
 8003788:	f113 0f03 	cmn.w	r3, #3
 800378c:	bf14      	ite	ne
 800378e:	2300      	movne	r3, #0
 8003790:	2301      	moveq	r3, #1
 8003792:	b2db      	uxtb	r3, r3
 8003794:	2005      	movs	r0, #5
 8003796:	4619      	mov	r1, r3
 8003798:	f004 fee2 	bl	8008560 <_test_assert>
 800379c:	4603      	mov	r3, r0
 800379e:	2b00      	cmp	r3, #0
 80037a0:	d002      	beq.n	80037a8 <queues2_execute.13555+0x128>
 80037a2:	f7ff fc6d 	bl	8003080 <chSysUnlock.13542.4217>
 80037a6:	e0ee      	b.n	8003986 <queues2_execute.13555+0x306>
 80037a8:	f7ff fc6a 	bl	8003080 <chSysUnlock.13542.4217>

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 80037ac:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80037b0:	f6c0 0301 	movt	r3, #2049	; 0x801
 80037b4:	685b      	ldr	r3, [r3, #4]
 80037b6:	f640 00d0 	movw	r0, #2256	; 0x8d0
 80037ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80037be:	4619      	mov	r1, r3
 80037c0:	2208      	movs	r2, #8
 80037c2:	2300      	movs	r3, #0
 80037c4:	f007 fd44 	bl	800b250 <chOQWriteTimeout>
 80037c8:	9003      	str	r0, [sp, #12]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 80037ca:	9b03      	ldr	r3, [sp, #12]
 80037cc:	2b04      	cmp	r3, #4
 80037ce:	bf14      	ite	ne
 80037d0:	2300      	movne	r3, #0
 80037d2:	2301      	moveq	r3, #1
 80037d4:	b2db      	uxtb	r3, r3
 80037d6:	2006      	movs	r0, #6
 80037d8:	4619      	mov	r1, r3
 80037da:	f004 fec1 	bl	8008560 <_test_assert>
 80037de:	4603      	mov	r3, r0
 80037e0:	2b00      	cmp	r3, #0
 80037e2:	f040 80d0 	bne.w	8003986 <queues2_execute.13555+0x306>
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 80037e6:	f7ff fc43 	bl	8003070 <chSysLock.13540.4219>
 80037ea:	f640 00d0 	movw	r0, #2256	; 0x8d0
 80037ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80037f2:	f7ff fd05 	bl	8003200 <chOQIsFullI.13537.4191>
 80037f6:	4603      	mov	r3, r0
 80037f8:	2007      	movs	r0, #7
 80037fa:	4619      	mov	r1, r3
 80037fc:	f004 feb0 	bl	8008560 <_test_assert>
 8003800:	4603      	mov	r3, r0
 8003802:	2b00      	cmp	r3, #0
 8003804:	d002      	beq.n	800380c <queues2_execute.13555+0x18c>
 8003806:	f7ff fc3b 	bl	8003080 <chSysUnlock.13542.4217>
 800380a:	e0bc      	b.n	8003986 <queues2_execute.13555+0x306>
 800380c:	f7ff fc38 	bl	8003080 <chSysUnlock.13542.4217>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8003810:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8003814:	f6c0 0301 	movt	r3, #2049	; 0x801
 8003818:	681c      	ldr	r4, [r3, #0]
 800381a:	f7ff fc61 	bl	80030e0 <chThdGetPriorityX.13494.4213>
 800381e:	4603      	mov	r3, r0
 8003820:	3301      	adds	r3, #1
 8003822:	2200      	movs	r2, #0
 8003824:	9200      	str	r2, [sp, #0]
 8003826:	4620      	mov	r0, r4
 8003828:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800382c:	461a      	mov	r2, r3
 800382e:	f243 6361 	movw	r3, #13921	; 0x3661
 8003832:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003836:	f00c ff93 	bl	8010760 <chThdCreateStatic>
 800383a:	4602      	mov	r2, r0
 800383c:	f641 6360 	movw	r3, #7776	; 0x1e60
 8003840:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003844:	601a      	str	r2, [r3, #0]
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 8003846:	f7ff fc13 	bl	8003070 <chSysLock.13540.4219>
 800384a:	f640 00d0 	movw	r0, #2256	; 0x8d0
 800384e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003852:	f7ff fc9d 	bl	8003190 <chOQGetFullI.13534.4197>
 8003856:	4603      	mov	r3, r0
 8003858:	2b04      	cmp	r3, #4
 800385a:	bf14      	ite	ne
 800385c:	2300      	movne	r3, #0
 800385e:	2301      	moveq	r3, #1
 8003860:	b2db      	uxtb	r3, r3
 8003862:	2008      	movs	r0, #8
 8003864:	4619      	mov	r1, r3
 8003866:	f004 fe7b 	bl	8008560 <_test_assert>
 800386a:	4603      	mov	r3, r0
 800386c:	2b00      	cmp	r3, #0
 800386e:	d002      	beq.n	8003876 <queues2_execute.13555+0x1f6>
 8003870:	f7ff fc06 	bl	8003080 <chSysUnlock.13542.4217>
 8003874:	e087      	b.n	8003986 <queues2_execute.13555+0x306>
 8003876:	f7ff fc03 	bl	8003080 <chSysUnlock.13542.4217>
  test_wait_threads();
 800387a:	f004 ff01 	bl	8008680 <test_wait_threads>

  /* Testing reset */
  chSysLock();
 800387e:	f7ff fbf7 	bl	8003070 <chSysLock.13540.4219>
  chOQResetI(&oq);
 8003882:	f640 00d0 	movw	r0, #2256	; 0x8d0
 8003886:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800388a:	f007 fc49 	bl	800b120 <chOQResetI>
  chSysUnlock();
 800388e:	f7ff fbf7 	bl	8003080 <chSysUnlock.13542.4217>
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 8003892:	f7ff fbed 	bl	8003070 <chSysLock.13540.4219>
 8003896:	f640 00d0 	movw	r0, #2256	; 0x8d0
 800389a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800389e:	f7ff fc77 	bl	8003190 <chOQGetFullI.13534.4197>
 80038a2:	4603      	mov	r3, r0
 80038a4:	2b00      	cmp	r3, #0
 80038a6:	bf14      	ite	ne
 80038a8:	2300      	movne	r3, #0
 80038aa:	2301      	moveq	r3, #1
 80038ac:	b2db      	uxtb	r3, r3
 80038ae:	2009      	movs	r0, #9
 80038b0:	4619      	mov	r1, r3
 80038b2:	f004 fe55 	bl	8008560 <_test_assert>
 80038b6:	4603      	mov	r3, r0
 80038b8:	2b00      	cmp	r3, #0
 80038ba:	d002      	beq.n	80038c2 <queues2_execute.13555+0x242>
 80038bc:	f7ff fbe0 	bl	8003080 <chSysUnlock.13542.4217>
 80038c0:	e061      	b.n	8003986 <queues2_execute.13555+0x306>
 80038c2:	f7ff fbdd 	bl	8003080 <chSysUnlock.13542.4217>

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 80038c6:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80038ca:	f6c0 0301 	movt	r3, #2049	; 0x801
 80038ce:	685b      	ldr	r3, [r3, #4]
 80038d0:	f640 00d0 	movw	r0, #2256	; 0x8d0
 80038d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80038d8:	4619      	mov	r1, r3
 80038da:	2202      	movs	r2, #2
 80038dc:	2300      	movs	r3, #0
 80038de:	f007 fcb7 	bl	800b250 <chOQWriteTimeout>
 80038e2:	9003      	str	r0, [sp, #12]
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 80038e4:	9b03      	ldr	r3, [sp, #12]
 80038e6:	2b02      	cmp	r3, #2
 80038e8:	bf14      	ite	ne
 80038ea:	2300      	movne	r3, #0
 80038ec:	2301      	moveq	r3, #1
 80038ee:	b2db      	uxtb	r3, r3
 80038f0:	200a      	movs	r0, #10
 80038f2:	4619      	mov	r1, r3
 80038f4:	f004 fe34 	bl	8008560 <_test_assert>
 80038f8:	4603      	mov	r3, r0
 80038fa:	2b00      	cmp	r3, #0
 80038fc:	d143      	bne.n	8003986 <queues2_execute.13555+0x306>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 80038fe:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8003902:	f6c0 0301 	movt	r3, #2049	; 0x801
 8003906:	685b      	ldr	r3, [r3, #4]
 8003908:	f640 00d0 	movw	r0, #2256	; 0x8d0
 800390c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003910:	4619      	mov	r1, r3
 8003912:	2202      	movs	r2, #2
 8003914:	2300      	movs	r3, #0
 8003916:	f007 fc9b 	bl	800b250 <chOQWriteTimeout>
 800391a:	9003      	str	r0, [sp, #12]
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800391c:	9b03      	ldr	r3, [sp, #12]
 800391e:	2b02      	cmp	r3, #2
 8003920:	bf14      	ite	ne
 8003922:	2300      	movne	r3, #0
 8003924:	2301      	moveq	r3, #1
 8003926:	b2db      	uxtb	r3, r3
 8003928:	200b      	movs	r0, #11
 800392a:	4619      	mov	r1, r3
 800392c:	f004 fe18 	bl	8008560 <_test_assert>
 8003930:	4603      	mov	r3, r0
 8003932:	2b00      	cmp	r3, #0
 8003934:	d127      	bne.n	8003986 <queues2_execute.13555+0x306>
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 8003936:	f7ff fb9b 	bl	8003070 <chSysLock.13540.4219>
 800393a:	f640 00d0 	movw	r0, #2256	; 0x8d0
 800393e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003942:	f7ff fc5d 	bl	8003200 <chOQIsFullI.13537.4191>
 8003946:	4603      	mov	r3, r0
 8003948:	200c      	movs	r0, #12
 800394a:	4619      	mov	r1, r3
 800394c:	f004 fe08 	bl	8008560 <_test_assert>
 8003950:	4603      	mov	r3, r0
 8003952:	2b00      	cmp	r3, #0
 8003954:	d002      	beq.n	800395c <queues2_execute.13555+0x2dc>
 8003956:	f7ff fb93 	bl	8003080 <chSysUnlock.13542.4217>
 800395a:	e014      	b.n	8003986 <queues2_execute.13555+0x306>
 800395c:	f7ff fb90 	bl	8003080 <chSysUnlock.13542.4217>

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 8003960:	f640 00d0 	movw	r0, #2256	; 0x8d0
 8003964:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003968:	2100      	movs	r1, #0
 800396a:	220a      	movs	r2, #10
 800396c:	f007 fbf8 	bl	800b160 <chOQPutTimeout>
 8003970:	4603      	mov	r3, r0
 8003972:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8003976:	bf14      	ite	ne
 8003978:	2300      	movne	r3, #0
 800397a:	2301      	moveq	r3, #1
 800397c:	b2db      	uxtb	r3, r3
 800397e:	200d      	movs	r0, #13
 8003980:	4619      	mov	r1, r3
 8003982:	f004 fded 	bl	8008560 <_test_assert>
}
 8003986:	b006      	add	sp, #24
 8003988:	bd10      	pop	{r4, pc}
 800398a:	bf00      	nop
 800398c:	f3af 8000 	nop.w

08003990 <port_get_irq_status.13676.4067>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 8003990:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003992:	f3ef 8311 	mrs	r3, BASEPRI
 8003996:	9300      	str	r3, [sp, #0]
  return(result);
 8003998:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 800399a:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 800399c:	9b01      	ldr	r3, [sp, #4]
}
 800399e:	4618      	mov	r0, r3
 80039a0:	b002      	add	sp, #8
 80039a2:	4770      	bx	lr
 80039a4:	f3af 8000 	nop.w
 80039a8:	f3af 8000 	nop.w
 80039ac:	f3af 8000 	nop.w

080039b0 <port_irq_enabled.13682.4063>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 80039b0:	b082      	sub	sp, #8
 80039b2:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 80039b4:	9b01      	ldr	r3, [sp, #4]
 80039b6:	2b00      	cmp	r3, #0
 80039b8:	bf14      	ite	ne
 80039ba:	2300      	movne	r3, #0
 80039bc:	2301      	moveq	r3, #1
 80039be:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80039c0:	4618      	mov	r0, r3
 80039c2:	b002      	add	sp, #8
 80039c4:	4770      	bx	lr
 80039c6:	bf00      	nop
 80039c8:	f3af 8000 	nop.w
 80039cc:	f3af 8000 	nop.w

080039d0 <port_lock.13686.4061>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80039d0:	b082      	sub	sp, #8
 80039d2:	2320      	movs	r3, #32
 80039d4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80039d6:	9b01      	ldr	r3, [sp, #4]
 80039d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80039dc:	b002      	add	sp, #8
 80039de:	4770      	bx	lr

080039e0 <port_unlock.13688.4059>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80039e0:	b082      	sub	sp, #8
 80039e2:	2300      	movs	r3, #0
 80039e4:	9301      	str	r3, [sp, #4]
 80039e6:	9b01      	ldr	r3, [sp, #4]
 80039e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80039ec:	b002      	add	sp, #8
 80039ee:	4770      	bx	lr

080039f0 <port_lock_from_isr.13690.4057>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80039f0:	b508      	push	{r3, lr}

  port_lock();
 80039f2:	f7ff ffed 	bl	80039d0 <port_lock.13686.4061>
}
 80039f6:	bd08      	pop	{r3, pc}
 80039f8:	f3af 8000 	nop.w
 80039fc:	f3af 8000 	nop.w

08003a00 <port_unlock_from_isr.13692.4055>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8003a00:	b508      	push	{r3, lr}

  port_unlock();
 8003a02:	f7ff ffed 	bl	80039e0 <port_unlock.13688.4059>
}
 8003a06:	bd08      	pop	{r3, pc}
 8003a08:	f3af 8000 	nop.w
 8003a0c:	f3af 8000 	nop.w

08003a10 <port_disable.13694.4053>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003a10:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8003a12:	4770      	bx	lr
 8003a14:	f3af 8000 	nop.w
 8003a18:	f3af 8000 	nop.w
 8003a1c:	f3af 8000 	nop.w

08003a20 <port_suspend.13696.4051>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 * @note    Interrupt sources above kernel level remains enabled.
 * @note    In this port it raises/lowers the base priority to kernel level.
 */
static inline void port_suspend(void) {
 8003a20:	b082      	sub	sp, #8
 8003a22:	2320      	movs	r3, #32
 8003a24:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003a26:	9b01      	ldr	r3, [sp, #4]
 8003a28:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003a2c:	b662      	cpsie	i
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
  __enable_irq();
#else
  __disable_irq();
#endif
}
 8003a2e:	b002      	add	sp, #8
 8003a30:	4770      	bx	lr
 8003a32:	bf00      	nop
 8003a34:	f3af 8000 	nop.w
 8003a38:	f3af 8000 	nop.w
 8003a3c:	f3af 8000 	nop.w

08003a40 <port_enable.13698.4049>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8003a40:	b082      	sub	sp, #8
 8003a42:	2300      	movs	r3, #0
 8003a44:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003a46:	9b01      	ldr	r3, [sp, #4]
 8003a48:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003a4c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 8003a4e:	b002      	add	sp, #8
 8003a50:	4770      	bx	lr
 8003a52:	bf00      	nop
 8003a54:	f3af 8000 	nop.w
 8003a58:	f3af 8000 	nop.w
 8003a5c:	f3af 8000 	nop.w

08003a60 <chSysDisable.13750>:
 *          hardware priority.
 * @note    Do not invoke this API from within a kernel lock.
 *
 * @special
 */
static inline void chSysDisable(void) {
 8003a60:	b508      	push	{r3, lr}

  port_disable();
 8003a62:	f7ff ffd5 	bl	8003a10 <port_disable.13694.4053>
  _dbg_check_disable();
 8003a66:	f00b fdf3 	bl	800f650 <_dbg_check_disable>
}
 8003a6a:	bd08      	pop	{r3, pc}
 8003a6c:	f3af 8000 	nop.w

08003a70 <chSysSuspend.13752>:
 * @note    This API is no replacement for @p chSysLock(), the @p chSysLock()
 *          could do more than just disable the interrupts.
 *
 * @special
 */
static inline void chSysSuspend(void) {
 8003a70:	b508      	push	{r3, lr}

  port_suspend();
 8003a72:	f7ff ffd5 	bl	8003a20 <port_suspend.13696.4051>
  _dbg_check_suspend();
 8003a76:	f00b fe03 	bl	800f680 <_dbg_check_suspend>
}
 8003a7a:	bd08      	pop	{r3, pc}
 8003a7c:	f3af 8000 	nop.w

08003a80 <chSysEnable.13754>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8003a80:	b508      	push	{r3, lr}

  _dbg_check_enable();
 8003a82:	f00b fe15 	bl	800f6b0 <_dbg_check_enable>
  port_enable();
 8003a86:	f7ff ffdb 	bl	8003a40 <port_enable.13698.4049>
}
 8003a8a:	bd08      	pop	{r3, pc}
 8003a8c:	f3af 8000 	nop.w

08003a90 <chSysLock.13723>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003a90:	b508      	push	{r3, lr}

  port_lock();
 8003a92:	f7ff ff9d 	bl	80039d0 <port_lock.13686.4061>
  _stats_start_measure_crit_thd();
 8003a96:	f00a fa73 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8003a9a:	f00b fe21 	bl	800f6e0 <_dbg_check_lock>
}
 8003a9e:	bd08      	pop	{r3, pc}

08003aa0 <chSysUnlock.13719>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003aa0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8003aa2:	f00b fe3d 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8003aa6:	f00a fa73 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003aaa:	f640 5350 	movw	r3, #3408	; 0xd50
 8003aae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ab2:	681a      	ldr	r2, [r3, #0]
 8003ab4:	f640 5350 	movw	r3, #3408	; 0xd50
 8003ab8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003abc:	429a      	cmp	r2, r3
 8003abe:	d013      	beq.n	8003ae8 <chSysUnlock.13719+0x48>
 8003ac0:	f640 5350 	movw	r3, #3408	; 0xd50
 8003ac4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ac8:	699b      	ldr	r3, [r3, #24]
 8003aca:	689a      	ldr	r2, [r3, #8]
 8003acc:	f640 5350 	movw	r3, #3408	; 0xd50
 8003ad0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ad4:	681b      	ldr	r3, [r3, #0]
 8003ad6:	689b      	ldr	r3, [r3, #8]
 8003ad8:	429a      	cmp	r2, r3
 8003ada:	d205      	bcs.n	8003ae8 <chSysUnlock.13719+0x48>
 8003adc:	f242 3000 	movw	r0, #8960	; 0x2300
 8003ae0:	f6c0 0001 	movt	r0, #2049	; 0x801
 8003ae4:	f00b fc54 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003ae8:	f7ff ff7a 	bl	80039e0 <port_unlock.13688.4059>
}
 8003aec:	bd08      	pop	{r3, pc}
 8003aee:	bf00      	nop

08003af0 <chSysLockFromISR.13712>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8003af0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8003af2:	f7ff ff7d 	bl	80039f0 <port_lock_from_isr.13690.4057>
  _stats_start_measure_crit_isr();
 8003af6:	f00a fa53 	bl	800dfa0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8003afa:	f00b fe31 	bl	800f760 <_dbg_check_lock_from_isr>
}
 8003afe:	bd08      	pop	{r3, pc}

08003b00 <chSysUnlockFromISR.13714>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8003b00:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8003b02:	f00b fe4d 	bl	800f7a0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8003b06:	f00a fa53 	bl	800dfb0 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8003b0a:	f7ff ff79 	bl	8003a00 <port_unlock_from_isr.13692.4055>
}
 8003b0e:	bd08      	pop	{r3, pc}

08003b10 <chSysUnconditionalLock.13725>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "s-locked".
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {
 8003b10:	b508      	push	{r3, lr}

  if (port_irq_enabled(port_get_irq_status())) {
 8003b12:	f7ff ff3d 	bl	8003990 <port_get_irq_status.13676.4067>
 8003b16:	4603      	mov	r3, r0
 8003b18:	4618      	mov	r0, r3
 8003b1a:	f7ff ff49 	bl	80039b0 <port_irq_enabled.13682.4063>
 8003b1e:	4603      	mov	r3, r0
 8003b20:	2b00      	cmp	r3, #0
 8003b22:	d001      	beq.n	8003b28 <chSysUnconditionalLock.13725+0x18>
    chSysLock();
 8003b24:	f7ff ffb4 	bl	8003a90 <chSysLock.13723>
  }
}
 8003b28:	bd08      	pop	{r3, pc}
 8003b2a:	bf00      	nop
 8003b2c:	f3af 8000 	nop.w

08003b30 <chSysUnconditionalUnlock.13721>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "normal".
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {
 8003b30:	b508      	push	{r3, lr}

  if (!port_irq_enabled(port_get_irq_status())) {
 8003b32:	f7ff ff2d 	bl	8003990 <port_get_irq_status.13676.4067>
 8003b36:	4603      	mov	r3, r0
 8003b38:	4618      	mov	r0, r3
 8003b3a:	f7ff ff39 	bl	80039b0 <port_irq_enabled.13682.4063>
 8003b3e:	4603      	mov	r3, r0
 8003b40:	f083 0301 	eor.w	r3, r3, #1
 8003b44:	b2db      	uxtb	r3, r3
 8003b46:	2b00      	cmp	r3, #0
 8003b48:	d001      	beq.n	8003b4e <chSysUnconditionalUnlock.13721+0x1e>
    chSysUnlock();
 8003b4a:	f7ff ffa9 	bl	8003aa0 <chSysUnlock.13719>
  }
}
 8003b4e:	bd08      	pop	{r3, pc}

08003b50 <chVTObjectInit.13700>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 8003b50:	b082      	sub	sp, #8
 8003b52:	9001      	str	r0, [sp, #4]

  vtp->vt_func = NULL;
 8003b54:	9b01      	ldr	r3, [sp, #4]
 8003b56:	2200      	movs	r2, #0
 8003b58:	60da      	str	r2, [r3, #12]
}
 8003b5a:	b002      	add	sp, #8
 8003b5c:	4770      	bx	lr
 8003b5e:	bf00      	nop

08003b60 <chVTIsArmedI.13727>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8003b60:	b500      	push	{lr}
 8003b62:	b083      	sub	sp, #12
 8003b64:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003b66:	f00b fe8b 	bl	800f880 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
 8003b6a:	9b01      	ldr	r3, [sp, #4]
 8003b6c:	68db      	ldr	r3, [r3, #12]
 8003b6e:	2b00      	cmp	r3, #0
 8003b70:	bf0c      	ite	eq
 8003b72:	2300      	moveq	r3, #0
 8003b74:	2301      	movne	r3, #1
 8003b76:	b2db      	uxtb	r3, r3
}
 8003b78:	4618      	mov	r0, r3
 8003b7a:	b003      	add	sp, #12
 8003b7c:	f85d fb04 	ldr.w	pc, [sp], #4

08003b80 <port_lock.12694.4184>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003b80:	b082      	sub	sp, #8
 8003b82:	2320      	movs	r3, #32
 8003b84:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003b86:	9b01      	ldr	r3, [sp, #4]
 8003b88:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003b8c:	b002      	add	sp, #8
 8003b8e:	4770      	bx	lr

08003b90 <port_unlock.12697.4182>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003b90:	b082      	sub	sp, #8
 8003b92:	2300      	movs	r3, #0
 8003b94:	9301      	str	r3, [sp, #4]
 8003b96:	9b01      	ldr	r3, [sp, #4]
 8003b98:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003b9c:	b002      	add	sp, #8
 8003b9e:	4770      	bx	lr

08003ba0 <st_lld_get_counter.12699.4180>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003ba0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003ba4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8003ba6:	4618      	mov	r0, r3
 8003ba8:	4770      	bx	lr
 8003baa:	bf00      	nop
 8003bac:	f3af 8000 	nop.w

08003bb0 <port_timer_get_time.12704.4178>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8003bb0:	b508      	push	{r3, lr}

  return stGetCounter();
 8003bb2:	f7ff fff5 	bl	8003ba0 <st_lld_get_counter.12699.4180>
 8003bb6:	4603      	mov	r3, r0
}
 8003bb8:	4618      	mov	r0, r3
 8003bba:	bd08      	pop	{r3, pc}
 8003bbc:	f3af 8000 	nop.w

08003bc0 <chSysLock.12846.4176>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003bc0:	b508      	push	{r3, lr}

  port_lock();
 8003bc2:	f7ff ffdd 	bl	8003b80 <port_lock.12694.4184>
  _stats_start_measure_crit_thd();
 8003bc6:	f00a f9db 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8003bca:	f00b fd89 	bl	800f6e0 <_dbg_check_lock>
}
 8003bce:	bd08      	pop	{r3, pc}

08003bd0 <chSysUnlock.12848.4174>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003bd0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8003bd2:	f00b fda5 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8003bd6:	f00a f9db 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003bda:	f640 5350 	movw	r3, #3408	; 0xd50
 8003bde:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003be2:	681a      	ldr	r2, [r3, #0]
 8003be4:	f640 5350 	movw	r3, #3408	; 0xd50
 8003be8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003bec:	429a      	cmp	r2, r3
 8003bee:	d013      	beq.n	8003c18 <chSysUnlock.12848.4174+0x48>
 8003bf0:	f640 5350 	movw	r3, #3408	; 0xd50
 8003bf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003bf8:	699b      	ldr	r3, [r3, #24]
 8003bfa:	689a      	ldr	r2, [r3, #8]
 8003bfc:	f640 5350 	movw	r3, #3408	; 0xd50
 8003c00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c04:	681b      	ldr	r3, [r3, #0]
 8003c06:	689b      	ldr	r3, [r3, #8]
 8003c08:	429a      	cmp	r2, r3
 8003c0a:	d205      	bcs.n	8003c18 <chSysUnlock.12848.4174+0x48>
 8003c0c:	f242 10f0 	movw	r0, #8688	; 0x21f0
 8003c10:	f6c0 0001 	movt	r0, #2049	; 0x801
 8003c14:	f00b fbbc 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003c18:	f7ff ffba 	bl	8003b90 <port_unlock.12697.4182>
}
 8003c1c:	bd08      	pop	{r3, pc}
 8003c1e:	bf00      	nop

08003c20 <chVTGetSystemTimeX.12706.4172>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8003c20:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8003c22:	f7ff ffc5 	bl	8003bb0 <port_timer_get_time.12704.4178>
 8003c26:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003c28:	4618      	mov	r0, r3
 8003c2a:	bd08      	pop	{r3, pc}
 8003c2c:	f3af 8000 	nop.w

08003c30 <chVTGetSystemTime.12850.4169>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8003c30:	b500      	push	{lr}
 8003c32:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8003c34:	f7ff ffc4 	bl	8003bc0 <chSysLock.12846.4176>
  systime = chVTGetSystemTimeX();
 8003c38:	f7ff fff2 	bl	8003c20 <chVTGetSystemTimeX.12706.4172>
 8003c3c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8003c3e:	f7ff ffc7 	bl	8003bd0 <chSysUnlock.12848.4174>

  return systime;
 8003c42:	9b01      	ldr	r3, [sp, #4]
}
 8003c44:	4618      	mov	r0, r3
 8003c46:	b003      	add	sp, #12
 8003c48:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c4c:	f3af 8000 	nop.w

08003c50 <chThdGetSelfX.12708.4167>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003c50:	f640 5350 	movw	r3, #3408	; 0xd50
 8003c54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003c58:	699b      	ldr	r3, [r3, #24]
}
 8003c5a:	4618      	mov	r0, r3
 8003c5c:	4770      	bx	lr
 8003c5e:	bf00      	nop

08003c60 <chThdGetPriorityX.12794.4165>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8003c60:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8003c62:	f7ff fff5 	bl	8003c50 <chThdGetSelfX.12708.4167>
 8003c66:	4603      	mov	r3, r0
 8003c68:	689b      	ldr	r3, [r3, #8]
}
 8003c6a:	4618      	mov	r0, r3
 8003c6c:	bd08      	pop	{r3, pc}
 8003c6e:	bf00      	nop

08003c70 <chEvtObjectInit.12796.4162>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8003c70:	b082      	sub	sp, #8
 8003c72:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8003c74:	9b01      	ldr	r3, [sp, #4]
 8003c76:	9a01      	ldr	r2, [sp, #4]
 8003c78:	601a      	str	r2, [r3, #0]
}
 8003c7a:	b002      	add	sp, #8
 8003c7c:	4770      	bx	lr
 8003c7e:	bf00      	nop

08003c80 <chEvtRegisterMask.12830.4157>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 8003c80:	b500      	push	{lr}
 8003c82:	b085      	sub	sp, #20
 8003c84:	9003      	str	r0, [sp, #12]
 8003c86:	9102      	str	r1, [sp, #8]
 8003c88:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8003c8a:	9803      	ldr	r0, [sp, #12]
 8003c8c:	9902      	ldr	r1, [sp, #8]
 8003c8e:	9a01      	ldr	r2, [sp, #4]
 8003c90:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8003c94:	f008 ff0c 	bl	800cab0 <chEvtRegisterMaskWithFlags>
}
 8003c98:	b005      	add	sp, #20
 8003c9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c9e:	bf00      	nop

08003ca0 <chEvtIsListeningI.12810.4153>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @return              The event source status.
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {
 8003ca0:	b082      	sub	sp, #8
 8003ca2:	9001      	str	r0, [sp, #4]

  return (bool)(esp != (event_source_t *)esp->es_next);
 8003ca4:	9b01      	ldr	r3, [sp, #4]
 8003ca6:	681a      	ldr	r2, [r3, #0]
 8003ca8:	9b01      	ldr	r3, [sp, #4]
 8003caa:	429a      	cmp	r2, r3
 8003cac:	bf0c      	ite	eq
 8003cae:	2300      	moveq	r3, #0
 8003cb0:	2301      	movne	r3, #1
 8003cb2:	b2db      	uxtb	r3, r3
}
 8003cb4:	4618      	mov	r0, r3
 8003cb6:	b002      	add	sp, #8
 8003cb8:	4770      	bx	lr
 8003cba:	bf00      	nop
 8003cbc:	f3af 8000 	nop.w

08003cc0 <chEvtBroadcast.12840.4053>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {
 8003cc0:	b500      	push	{lr}
 8003cc2:	b083      	sub	sp, #12
 8003cc4:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 8003cc6:	9801      	ldr	r0, [sp, #4]
 8003cc8:	2100      	movs	r1, #0
 8003cca:	f009 f831 	bl	800cd30 <chEvtBroadcastFlags>
}
 8003cce:	b003      	add	sp, #12
 8003cd0:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cd4:	f3af 8000 	nop.w
 8003cd8:	f3af 8000 	nop.w
 8003cdc:	f3af 8000 	nop.w

08003ce0 <evt1_setup.12814>:
 * the test expects no more listeners.<br>
 * In the second part the test dispatches three event flags and verifies that
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {
 8003ce0:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 8003ce2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003ce6:	f008 ff43 	bl	800cb70 <chEvtGetAndClearEvents>
}
 8003cea:	bd08      	pop	{r3, pc}
 8003cec:	f3af 8000 	nop.w

08003cf0 <h1.12820>:

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8003cf0:	b500      	push	{lr}
 8003cf2:	b083      	sub	sp, #12
 8003cf4:	9001      	str	r0, [sp, #4]
 8003cf6:	2041      	movs	r0, #65	; 0x41
 8003cf8:	f004 fbfa 	bl	80084f0 <test_emit_token>
 8003cfc:	b003      	add	sp, #12
 8003cfe:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d02:	bf00      	nop
 8003d04:	f3af 8000 	nop.w
 8003d08:	f3af 8000 	nop.w
 8003d0c:	f3af 8000 	nop.w

08003d10 <h2.12824>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8003d10:	b500      	push	{lr}
 8003d12:	b083      	sub	sp, #12
 8003d14:	9001      	str	r0, [sp, #4]
 8003d16:	2042      	movs	r0, #66	; 0x42
 8003d18:	f004 fbea 	bl	80084f0 <test_emit_token>
 8003d1c:	b003      	add	sp, #12
 8003d1e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d22:	bf00      	nop
 8003d24:	f3af 8000 	nop.w
 8003d28:	f3af 8000 	nop.w
 8003d2c:	f3af 8000 	nop.w

08003d30 <h3.12827>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8003d30:	b500      	push	{lr}
 8003d32:	b083      	sub	sp, #12
 8003d34:	9001      	str	r0, [sp, #4]
 8003d36:	2043      	movs	r0, #67	; 0x43
 8003d38:	f004 fbda 	bl	80084f0 <test_emit_token>
 8003d3c:	b003      	add	sp, #12
 8003d3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d42:	bf00      	nop
 8003d44:	f3af 8000 	nop.w
 8003d48:	f3af 8000 	nop.w
 8003d4c:	f3af 8000 	nop.w

08003d50 <evt1_execute.12835>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 8003d50:	b500      	push	{lr}
 8003d52:	b08b      	sub	sp, #44	; 0x2c
  event_listener_t el1, el2;

  /*
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
 8003d54:	f640 0098 	movw	r0, #2200	; 0x898
 8003d58:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003d5c:	f7ff ff88 	bl	8003c70 <chEvtObjectInit.12796.4162>
  chEvtRegisterMask(&es1, &el1, 1);
 8003d60:	ab05      	add	r3, sp, #20
 8003d62:	f640 0098 	movw	r0, #2200	; 0x898
 8003d66:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003d6a:	4619      	mov	r1, r3
 8003d6c:	2201      	movs	r2, #1
 8003d6e:	f7ff ff87 	bl	8003c80 <chEvtRegisterMask.12830.4157>
  chEvtRegisterMask(&es1, &el2, 2);
 8003d72:	466b      	mov	r3, sp
 8003d74:	f640 0098 	movw	r0, #2200	; 0x898
 8003d78:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003d7c:	4619      	mov	r1, r3
 8003d7e:	2202      	movs	r2, #2
 8003d80:	f7ff ff7e 	bl	8003c80 <chEvtRegisterMask.12830.4157>
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 8003d84:	f640 0098 	movw	r0, #2200	; 0x898
 8003d88:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003d8c:	f7ff ff88 	bl	8003ca0 <chEvtIsListeningI.12810.4153>
 8003d90:	4603      	mov	r3, r0
 8003d92:	2001      	movs	r0, #1
 8003d94:	4619      	mov	r1, r3
 8003d96:	f004 fbe3 	bl	8008560 <_test_assert>
 8003d9a:	4603      	mov	r3, r0
 8003d9c:	2b00      	cmp	r3, #0
 8003d9e:	d146      	bne.n	8003e2e <evt1_execute.12835+0xde>
  chEvtUnregister(&es1, &el1);
 8003da0:	ab05      	add	r3, sp, #20
 8003da2:	f640 0098 	movw	r0, #2200	; 0x898
 8003da6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003daa:	4619      	mov	r1, r3
 8003dac:	f008 feb0 	bl	800cb10 <chEvtUnregister>
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 8003db0:	f640 0098 	movw	r0, #2200	; 0x898
 8003db4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003db8:	f7ff ff72 	bl	8003ca0 <chEvtIsListeningI.12810.4153>
 8003dbc:	4603      	mov	r3, r0
 8003dbe:	2002      	movs	r0, #2
 8003dc0:	4619      	mov	r1, r3
 8003dc2:	f004 fbcd 	bl	8008560 <_test_assert>
 8003dc6:	4603      	mov	r3, r0
 8003dc8:	2b00      	cmp	r3, #0
 8003dca:	d130      	bne.n	8003e2e <evt1_execute.12835+0xde>
  chEvtUnregister(&es1, &el2);
 8003dcc:	466b      	mov	r3, sp
 8003dce:	f640 0098 	movw	r0, #2200	; 0x898
 8003dd2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003dd6:	4619      	mov	r1, r3
 8003dd8:	f008 fe9a 	bl	800cb10 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 8003ddc:	f640 0098 	movw	r0, #2200	; 0x898
 8003de0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003de4:	f7ff ff5c 	bl	8003ca0 <chEvtIsListeningI.12810.4153>
 8003de8:	4603      	mov	r3, r0
 8003dea:	2b00      	cmp	r3, #0
 8003dec:	bf0c      	ite	eq
 8003dee:	2300      	moveq	r3, #0
 8003df0:	2301      	movne	r3, #1
 8003df2:	b2db      	uxtb	r3, r3
 8003df4:	f083 0301 	eor.w	r3, r3, #1
 8003df8:	b2db      	uxtb	r3, r3
 8003dfa:	f003 0301 	and.w	r3, r3, #1
 8003dfe:	b2db      	uxtb	r3, r3
 8003e00:	2003      	movs	r0, #3
 8003e02:	4619      	mov	r1, r3
 8003e04:	f004 fbac 	bl	8008560 <_test_assert>
 8003e08:	4603      	mov	r3, r0
 8003e0a:	2b00      	cmp	r3, #0
 8003e0c:	d10f      	bne.n	8003e2e <evt1_execute.12835+0xde>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
 8003e0e:	f242 10a0 	movw	r0, #8608	; 0x21a0
 8003e12:	f6c0 0001 	movt	r0, #2049	; 0x801
 8003e16:	2107      	movs	r1, #7
 8003e18:	f008 ffa2 	bl	800cd60 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
 8003e1c:	2004      	movs	r0, #4
 8003e1e:	f640 5160 	movw	r1, #3424	; 0xd60
 8003e22:	f6c0 0101 	movt	r1, #2049	; 0x801
 8003e26:	f004 fbb3 	bl	8008590 <_test_assert_sequence>
 8003e2a:	4603      	mov	r3, r0
 8003e2c:	2b00      	cmp	r3, #0
}
 8003e2e:	b00b      	add	sp, #44	; 0x2c
 8003e30:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e34:	f3af 8000 	nop.w
 8003e38:	f3af 8000 	nop.w
 8003e3c:	f3af 8000 	nop.w

08003e40 <evt2_setup.12816>:
 * .
 * After each test phase the test verifies that the events have been served at
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {
 8003e40:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 8003e42:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003e46:	f008 fe93 	bl	800cb70 <chEvtGetAndClearEvents>
}
 8003e4a:	bd08      	pop	{r3, pc}
 8003e4c:	f3af 8000 	nop.w

08003e50 <thread1.12837.4028>:

static THD_FUNCTION(thread1, p) {
 8003e50:	b500      	push	{lr}
 8003e52:	b083      	sub	sp, #12
 8003e54:	9001      	str	r0, [sp, #4]

  chThdSleepMilliseconds(50);
 8003e56:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8003e5a:	f009 fdf9 	bl	800da50 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 8003e5e:	9801      	ldr	r0, [sp, #4]
 8003e60:	2101      	movs	r1, #1
 8003e62:	f008 ff0d 	bl	800cc80 <chEvtSignal>
}
 8003e66:	b003      	add	sp, #12
 8003e68:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e6c:	f3af 8000 	nop.w

08003e70 <thread2.12843.4031>:

static THD_FUNCTION(thread2, p) {
 8003e70:	b500      	push	{lr}
 8003e72:	b083      	sub	sp, #12
 8003e74:	9001      	str	r0, [sp, #4]

  (void)p;
  chEvtBroadcast(&es1);
 8003e76:	f640 0098 	movw	r0, #2200	; 0x898
 8003e7a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003e7e:	f7ff ff1f 	bl	8003cc0 <chEvtBroadcast.12840.4053>
  chThdSleepMilliseconds(50);
 8003e82:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8003e86:	f009 fde3 	bl	800da50 <chThdSleep>
  chEvtBroadcast(&es2);
 8003e8a:	f640 009c 	movw	r0, #2204	; 0x89c
 8003e8e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8003e92:	f7ff ff15 	bl	8003cc0 <chEvtBroadcast.12840.4053>
}
 8003e96:	b003      	add	sp, #12
 8003e98:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e9c:	f3af 8000 	nop.w

08003ea0 <evt2_execute.12852>:

static void evt2_execute(void) {
 8003ea0:	b530      	push	{r4, r5, lr}
 8003ea2:	b08f      	sub	sp, #60	; 0x3c
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 8003ea4:	2007      	movs	r0, #7
 8003ea6:	f008 fe8b 	bl	800cbc0 <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
 8003eaa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003eae:	f008 ff97 	bl	800cde0 <chEvtWaitOne>
 8003eb2:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(1, m == 1, "single event error");
 8003eb4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003eb6:	2b01      	cmp	r3, #1
 8003eb8:	bf14      	ite	ne
 8003eba:	2300      	movne	r3, #0
 8003ebc:	2301      	moveq	r3, #1
 8003ebe:	b2db      	uxtb	r3, r3
 8003ec0:	2001      	movs	r0, #1
 8003ec2:	4619      	mov	r1, r3
 8003ec4:	f004 fb4c 	bl	8008560 <_test_assert>
 8003ec8:	4603      	mov	r3, r0
 8003eca:	2b00      	cmp	r3, #0
 8003ecc:	f040 81b8 	bne.w	8004240 <evt2_execute.12852+0x3a0>
  m = chEvtWaitOne(ALL_EVENTS);
 8003ed0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003ed4:	f008 ff84 	bl	800cde0 <chEvtWaitOne>
 8003ed8:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(2, m == 2, "single event error");
 8003eda:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003edc:	2b02      	cmp	r3, #2
 8003ede:	bf14      	ite	ne
 8003ee0:	2300      	movne	r3, #0
 8003ee2:	2301      	moveq	r3, #1
 8003ee4:	b2db      	uxtb	r3, r3
 8003ee6:	2002      	movs	r0, #2
 8003ee8:	4619      	mov	r1, r3
 8003eea:	f004 fb39 	bl	8008560 <_test_assert>
 8003eee:	4603      	mov	r3, r0
 8003ef0:	2b00      	cmp	r3, #0
 8003ef2:	f040 81a5 	bne.w	8004240 <evt2_execute.12852+0x3a0>
  m = chEvtWaitOne(ALL_EVENTS);
 8003ef6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003efa:	f008 ff71 	bl	800cde0 <chEvtWaitOne>
 8003efe:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(3, m == 4, "single event error");
 8003f00:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003f02:	2b04      	cmp	r3, #4
 8003f04:	bf14      	ite	ne
 8003f06:	2300      	movne	r3, #0
 8003f08:	2301      	moveq	r3, #1
 8003f0a:	b2db      	uxtb	r3, r3
 8003f0c:	2003      	movs	r0, #3
 8003f0e:	4619      	mov	r1, r3
 8003f10:	f004 fb26 	bl	8008560 <_test_assert>
 8003f14:	4603      	mov	r3, r0
 8003f16:	2b00      	cmp	r3, #0
 8003f18:	f040 8192 	bne.w	8004240 <evt2_execute.12852+0x3a0>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003f1c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003f20:	f008 fe26 	bl	800cb70 <chEvtGetAndClearEvents>
 8003f24:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(4, m == 0, "stuck event");
 8003f26:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003f28:	2b00      	cmp	r3, #0
 8003f2a:	bf14      	ite	ne
 8003f2c:	2300      	movne	r3, #0
 8003f2e:	2301      	moveq	r3, #1
 8003f30:	b2db      	uxtb	r3, r3
 8003f32:	2004      	movs	r0, #4
 8003f34:	4619      	mov	r1, r3
 8003f36:	f004 fb13 	bl	8008560 <_test_assert>
 8003f3a:	4603      	mov	r3, r0
 8003f3c:	2b00      	cmp	r3, #0
 8003f3e:	f040 817f 	bne.w	8004240 <evt2_execute.12852+0x3a0>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 8003f42:	f004 fbcd 	bl	80086e0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 8003f46:	f7ff fe73 	bl	8003c30 <chVTGetSystemTime.12850.4169>
 8003f4a:	4603      	mov	r3, r0
 8003f4c:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8003f50:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003f52:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8003f56:	f6c0 0301 	movt	r3, #2049	; 0x801
 8003f5a:	681d      	ldr	r5, [r3, #0]
 8003f5c:	f7ff fe80 	bl	8003c60 <chThdGetPriorityX.12794.4165>
 8003f60:	4603      	mov	r3, r0
 8003f62:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 8003f64:	f7ff fe74 	bl	8003c50 <chThdGetSelfX.12708.4167>
 8003f68:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003f6a:	9300      	str	r3, [sp, #0]
 8003f6c:	4628      	mov	r0, r5
 8003f6e:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8003f72:	4622      	mov	r2, r4
 8003f74:	f643 6351 	movw	r3, #15953	; 0x3e51
 8003f78:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003f7c:	f00c fbf0 	bl	8010760 <chThdCreateStatic>
 8003f80:	4602      	mov	r2, r0
 8003f82:	f641 6360 	movw	r3, #7776	; 0x1e60
 8003f86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003f8a:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 8003f8c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003f90:	f008 ff26 	bl	800cde0 <chEvtWaitOne>
 8003f94:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 8003f96:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003f98:	3332      	adds	r3, #50	; 0x32
 8003f9a:	2005      	movs	r0, #5
 8003f9c:	990c      	ldr	r1, [sp, #48]	; 0x30
 8003f9e:	461a      	mov	r2, r3
 8003fa0:	f004 fb2e 	bl	8008600 <_test_assert_time_window>
 8003fa4:	4603      	mov	r3, r0
 8003fa6:	2b00      	cmp	r3, #0
 8003fa8:	f040 814a 	bne.w	8004240 <evt2_execute.12852+0x3a0>
  test_assert(6, m == 1, "single event error");
 8003fac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003fae:	2b01      	cmp	r3, #1
 8003fb0:	bf14      	ite	ne
 8003fb2:	2300      	movne	r3, #0
 8003fb4:	2301      	moveq	r3, #1
 8003fb6:	b2db      	uxtb	r3, r3
 8003fb8:	2006      	movs	r0, #6
 8003fba:	4619      	mov	r1, r3
 8003fbc:	f004 fad0 	bl	8008560 <_test_assert>
 8003fc0:	4603      	mov	r3, r0
 8003fc2:	2b00      	cmp	r3, #0
 8003fc4:	f040 813c 	bne.w	8004240 <evt2_execute.12852+0x3a0>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003fc8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003fcc:	f008 fdd0 	bl	800cb70 <chEvtGetAndClearEvents>
 8003fd0:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(7, m == 0, "stuck event");
 8003fd2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003fd4:	2b00      	cmp	r3, #0
 8003fd6:	bf14      	ite	ne
 8003fd8:	2300      	movne	r3, #0
 8003fda:	2301      	moveq	r3, #1
 8003fdc:	b2db      	uxtb	r3, r3
 8003fde:	2007      	movs	r0, #7
 8003fe0:	4619      	mov	r1, r3
 8003fe2:	f004 fabd 	bl	8008560 <_test_assert>
 8003fe6:	4603      	mov	r3, r0
 8003fe8:	2b00      	cmp	r3, #0
 8003fea:	f040 8129 	bne.w	8004240 <evt2_execute.12852+0x3a0>
  test_wait_threads();
 8003fee:	f004 fb47 	bl	8008680 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
 8003ff2:	2005      	movs	r0, #5
 8003ff4:	f008 fde4 	bl	800cbc0 <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
 8003ff8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003ffc:	f008 ff28 	bl	800ce50 <chEvtWaitAny>
 8004000:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(8, m == 5, "unexpected pending bit");
 8004002:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8004004:	2b05      	cmp	r3, #5
 8004006:	bf14      	ite	ne
 8004008:	2300      	movne	r3, #0
 800400a:	2301      	moveq	r3, #1
 800400c:	b2db      	uxtb	r3, r3
 800400e:	2008      	movs	r0, #8
 8004010:	4619      	mov	r1, r3
 8004012:	f004 faa5 	bl	8008560 <_test_assert>
 8004016:	4603      	mov	r3, r0
 8004018:	2b00      	cmp	r3, #0
 800401a:	f040 8111 	bne.w	8004240 <evt2_execute.12852+0x3a0>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800401e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004022:	f008 fda5 	bl	800cb70 <chEvtGetAndClearEvents>
 8004026:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(9, m == 0, "stuck event");
 8004028:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800402a:	2b00      	cmp	r3, #0
 800402c:	bf14      	ite	ne
 800402e:	2300      	movne	r3, #0
 8004030:	2301      	moveq	r3, #1
 8004032:	b2db      	uxtb	r3, r3
 8004034:	2009      	movs	r0, #9
 8004036:	4619      	mov	r1, r3
 8004038:	f004 fa92 	bl	8008560 <_test_assert>
 800403c:	4603      	mov	r3, r0
 800403e:	2b00      	cmp	r3, #0
 8004040:	f040 80fe 	bne.w	8004240 <evt2_execute.12852+0x3a0>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 8004044:	f004 fb4c 	bl	80086e0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 8004048:	f7ff fdf2 	bl	8003c30 <chVTGetSystemTime.12850.4169>
 800404c:	4603      	mov	r3, r0
 800404e:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8004052:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004054:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004058:	f6c0 0301 	movt	r3, #2049	; 0x801
 800405c:	681d      	ldr	r5, [r3, #0]
 800405e:	f7ff fdff 	bl	8003c60 <chThdGetPriorityX.12794.4165>
 8004062:	4603      	mov	r3, r0
 8004064:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 8004066:	f7ff fdf3 	bl	8003c50 <chThdGetSelfX.12708.4167>
 800406a:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800406c:	9300      	str	r3, [sp, #0]
 800406e:	4628      	mov	r0, r5
 8004070:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004074:	4622      	mov	r2, r4
 8004076:	f643 6351 	movw	r3, #15953	; 0x3e51
 800407a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800407e:	f00c fb6f 	bl	8010760 <chThdCreateStatic>
 8004082:	4602      	mov	r2, r0
 8004084:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004088:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800408c:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 800408e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004092:	f008 fedd 	bl	800ce50 <chEvtWaitAny>
 8004096:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 8004098:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800409a:	3332      	adds	r3, #50	; 0x32
 800409c:	200a      	movs	r0, #10
 800409e:	990c      	ldr	r1, [sp, #48]	; 0x30
 80040a0:	461a      	mov	r2, r3
 80040a2:	f004 faad 	bl	8008600 <_test_assert_time_window>
 80040a6:	4603      	mov	r3, r0
 80040a8:	2b00      	cmp	r3, #0
 80040aa:	f040 80c9 	bne.w	8004240 <evt2_execute.12852+0x3a0>
  test_assert(11, m == 1, "single event error");
 80040ae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80040b0:	2b01      	cmp	r3, #1
 80040b2:	bf14      	ite	ne
 80040b4:	2300      	movne	r3, #0
 80040b6:	2301      	moveq	r3, #1
 80040b8:	b2db      	uxtb	r3, r3
 80040ba:	200b      	movs	r0, #11
 80040bc:	4619      	mov	r1, r3
 80040be:	f004 fa4f 	bl	8008560 <_test_assert>
 80040c2:	4603      	mov	r3, r0
 80040c4:	2b00      	cmp	r3, #0
 80040c6:	f040 80bb 	bne.w	8004240 <evt2_execute.12852+0x3a0>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80040ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80040ce:	f008 fd4f 	bl	800cb70 <chEvtGetAndClearEvents>
 80040d2:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(12, m == 0, "stuck event");
 80040d4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80040d6:	2b00      	cmp	r3, #0
 80040d8:	bf14      	ite	ne
 80040da:	2300      	movne	r3, #0
 80040dc:	2301      	moveq	r3, #1
 80040de:	b2db      	uxtb	r3, r3
 80040e0:	200c      	movs	r0, #12
 80040e2:	4619      	mov	r1, r3
 80040e4:	f004 fa3c 	bl	8008560 <_test_assert>
 80040e8:	4603      	mov	r3, r0
 80040ea:	2b00      	cmp	r3, #0
 80040ec:	f040 80a8 	bne.w	8004240 <evt2_execute.12852+0x3a0>
  test_wait_threads();
 80040f0:	f004 fac6 	bl	8008680 <test_wait_threads>

  /*
   * Test on chEvtWaitAll().
   */
  chEvtObjectInit(&es1);
 80040f4:	f640 0098 	movw	r0, #2200	; 0x898
 80040f8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80040fc:	f7ff fdb8 	bl	8003c70 <chEvtObjectInit.12796.4162>
  chEvtObjectInit(&es2);
 8004100:	f640 009c 	movw	r0, #2204	; 0x89c
 8004104:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004108:	f7ff fdb2 	bl	8003c70 <chEvtObjectInit.12796.4162>
  chEvtRegisterMask(&es1, &el1, 1);
 800410c:	ab07      	add	r3, sp, #28
 800410e:	f640 0098 	movw	r0, #2200	; 0x898
 8004112:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004116:	4619      	mov	r1, r3
 8004118:	2201      	movs	r2, #1
 800411a:	f7ff fdb1 	bl	8003c80 <chEvtRegisterMask.12830.4157>
  chEvtRegisterMask(&es2, &el2, 4);
 800411e:	ab02      	add	r3, sp, #8
 8004120:	f640 009c 	movw	r0, #2204	; 0x89c
 8004124:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004128:	4619      	mov	r1, r3
 800412a:	2204      	movs	r2, #4
 800412c:	f7ff fda8 	bl	8003c80 <chEvtRegisterMask.12830.4157>
  test_wait_tick();
 8004130:	f004 fad6 	bl	80086e0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 8004134:	f7ff fd7c 	bl	8003c30 <chVTGetSystemTime.12850.4169>
 8004138:	4603      	mov	r3, r0
 800413a:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 800413e:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004140:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004144:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004148:	681c      	ldr	r4, [r3, #0]
 800414a:	f7ff fd89 	bl	8003c60 <chThdGetPriorityX.12794.4165>
 800414e:	4603      	mov	r3, r0
 8004150:	1e5a      	subs	r2, r3, #1
 8004152:	f640 5364 	movw	r3, #3428	; 0xd64
 8004156:	f6c0 0301 	movt	r3, #2049	; 0x801
 800415a:	9300      	str	r3, [sp, #0]
 800415c:	4620      	mov	r0, r4
 800415e:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004162:	f643 6371 	movw	r3, #15985	; 0x3e71
 8004166:	f6c0 0300 	movt	r3, #2048	; 0x800
 800416a:	f00c faf9 	bl	8010760 <chThdCreateStatic>
 800416e:	4602      	mov	r2, r0
 8004170:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004174:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004178:	601a      	str	r2, [r3, #0]
                                 thread2, "A");
  m = chEvtWaitAll(5);
 800417a:	2005      	movs	r0, #5
 800417c:	f008 fe98 	bl	800ceb0 <chEvtWaitAll>
 8004180:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 8004182:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8004184:	3332      	adds	r3, #50	; 0x32
 8004186:	200d      	movs	r0, #13
 8004188:	990c      	ldr	r1, [sp, #48]	; 0x30
 800418a:	461a      	mov	r2, r3
 800418c:	f004 fa38 	bl	8008600 <_test_assert_time_window>
 8004190:	4603      	mov	r3, r0
 8004192:	2b00      	cmp	r3, #0
 8004194:	d154      	bne.n	8004240 <evt2_execute.12852+0x3a0>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004196:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800419a:	f008 fce9 	bl	800cb70 <chEvtGetAndClearEvents>
 800419e:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(14, m == 0, "stuck event");
 80041a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80041a2:	2b00      	cmp	r3, #0
 80041a4:	bf14      	ite	ne
 80041a6:	2300      	movne	r3, #0
 80041a8:	2301      	moveq	r3, #1
 80041aa:	b2db      	uxtb	r3, r3
 80041ac:	200e      	movs	r0, #14
 80041ae:	4619      	mov	r1, r3
 80041b0:	f004 f9d6 	bl	8008560 <_test_assert>
 80041b4:	4603      	mov	r3, r0
 80041b6:	2b00      	cmp	r3, #0
 80041b8:	d142      	bne.n	8004240 <evt2_execute.12852+0x3a0>
  test_wait_threads();
 80041ba:	f004 fa61 	bl	8008680 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 80041be:	ab07      	add	r3, sp, #28
 80041c0:	f640 0098 	movw	r0, #2200	; 0x898
 80041c4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80041c8:	4619      	mov	r1, r3
 80041ca:	f008 fca1 	bl	800cb10 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 80041ce:	ab02      	add	r3, sp, #8
 80041d0:	f640 009c 	movw	r0, #2204	; 0x89c
 80041d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80041d8:	4619      	mov	r1, r3
 80041da:	f008 fc99 	bl	800cb10 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 80041de:	f640 0098 	movw	r0, #2200	; 0x898
 80041e2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80041e6:	f7ff fd5b 	bl	8003ca0 <chEvtIsListeningI.12810.4153>
 80041ea:	4603      	mov	r3, r0
 80041ec:	2b00      	cmp	r3, #0
 80041ee:	bf0c      	ite	eq
 80041f0:	2300      	moveq	r3, #0
 80041f2:	2301      	movne	r3, #1
 80041f4:	b2db      	uxtb	r3, r3
 80041f6:	f083 0301 	eor.w	r3, r3, #1
 80041fa:	b2db      	uxtb	r3, r3
 80041fc:	f003 0301 	and.w	r3, r3, #1
 8004200:	b2db      	uxtb	r3, r3
 8004202:	200f      	movs	r0, #15
 8004204:	4619      	mov	r1, r3
 8004206:	f004 f9ab 	bl	8008560 <_test_assert>
 800420a:	4603      	mov	r3, r0
 800420c:	2b00      	cmp	r3, #0
 800420e:	d117      	bne.n	8004240 <evt2_execute.12852+0x3a0>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 8004210:	f640 009c 	movw	r0, #2204	; 0x89c
 8004214:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004218:	f7ff fd42 	bl	8003ca0 <chEvtIsListeningI.12810.4153>
 800421c:	4603      	mov	r3, r0
 800421e:	2b00      	cmp	r3, #0
 8004220:	bf0c      	ite	eq
 8004222:	2300      	moveq	r3, #0
 8004224:	2301      	movne	r3, #1
 8004226:	b2db      	uxtb	r3, r3
 8004228:	f083 0301 	eor.w	r3, r3, #1
 800422c:	b2db      	uxtb	r3, r3
 800422e:	f003 0301 	and.w	r3, r3, #1
 8004232:	b2db      	uxtb	r3, r3
 8004234:	2010      	movs	r0, #16
 8004236:	4619      	mov	r1, r3
 8004238:	f004 f992 	bl	8008560 <_test_assert>
 800423c:	4603      	mov	r3, r0
 800423e:	2b00      	cmp	r3, #0
}
 8004240:	b00f      	add	sp, #60	; 0x3c
 8004242:	bd30      	pop	{r4, r5, pc}
 8004244:	f3af 8000 	nop.w
 8004248:	f3af 8000 	nop.w
 800424c:	f3af 8000 	nop.w

08004250 <evt3_setup.12818>:
 * - @p chEvtWaitAllTimeout()
 * .
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {
 8004250:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 8004252:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004256:	f008 fc8b 	bl	800cb70 <chEvtGetAndClearEvents>
}
 800425a:	bd08      	pop	{r3, pc}
 800425c:	f3af 8000 	nop.w

08004260 <evt3_execute.12854>:

static void evt3_execute(void) {
 8004260:	b500      	push	{lr}
 8004262:	b083      	sub	sp, #12
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8004264:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004268:	2100      	movs	r1, #0
 800426a:	f008 fe49 	bl	800cf00 <chEvtWaitOneTimeout>
 800426e:	9001      	str	r0, [sp, #4]
  test_assert(1, m == 0, "spurious event");
 8004270:	9b01      	ldr	r3, [sp, #4]
 8004272:	2b00      	cmp	r3, #0
 8004274:	bf14      	ite	ne
 8004276:	2300      	movne	r3, #0
 8004278:	2301      	moveq	r3, #1
 800427a:	b2db      	uxtb	r3, r3
 800427c:	2001      	movs	r0, #1
 800427e:	4619      	mov	r1, r3
 8004280:	f004 f96e 	bl	8008560 <_test_assert>
 8004284:	4603      	mov	r3, r0
 8004286:	2b00      	cmp	r3, #0
 8004288:	d15b      	bne.n	8004342 <evt3_execute.12854+0xe2>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800428a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800428e:	2100      	movs	r1, #0
 8004290:	f008 fe7e 	bl	800cf90 <chEvtWaitAnyTimeout>
 8004294:	9001      	str	r0, [sp, #4]
  test_assert(2, m == 0, "spurious event");
 8004296:	9b01      	ldr	r3, [sp, #4]
 8004298:	2b00      	cmp	r3, #0
 800429a:	bf14      	ite	ne
 800429c:	2300      	movne	r3, #0
 800429e:	2301      	moveq	r3, #1
 80042a0:	b2db      	uxtb	r3, r3
 80042a2:	2002      	movs	r0, #2
 80042a4:	4619      	mov	r1, r3
 80042a6:	f004 f95b 	bl	8008560 <_test_assert>
 80042aa:	4603      	mov	r3, r0
 80042ac:	2b00      	cmp	r3, #0
 80042ae:	d148      	bne.n	8004342 <evt3_execute.12854+0xe2>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 80042b0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80042b4:	2100      	movs	r1, #0
 80042b6:	f008 feab 	bl	800d010 <chEvtWaitAllTimeout>
 80042ba:	9001      	str	r0, [sp, #4]
  test_assert(3, m == 0, "spurious event");
 80042bc:	9b01      	ldr	r3, [sp, #4]
 80042be:	2b00      	cmp	r3, #0
 80042c0:	bf14      	ite	ne
 80042c2:	2300      	movne	r3, #0
 80042c4:	2301      	moveq	r3, #1
 80042c6:	b2db      	uxtb	r3, r3
 80042c8:	2003      	movs	r0, #3
 80042ca:	4619      	mov	r1, r3
 80042cc:	f004 f948 	bl	8008560 <_test_assert>
 80042d0:	4603      	mov	r3, r0
 80042d2:	2b00      	cmp	r3, #0
 80042d4:	d135      	bne.n	8004342 <evt3_execute.12854+0xe2>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
 80042d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80042da:	210a      	movs	r1, #10
 80042dc:	f008 fe10 	bl	800cf00 <chEvtWaitOneTimeout>
 80042e0:	9001      	str	r0, [sp, #4]
  test_assert(4, m == 0, "spurious event");
 80042e2:	9b01      	ldr	r3, [sp, #4]
 80042e4:	2b00      	cmp	r3, #0
 80042e6:	bf14      	ite	ne
 80042e8:	2300      	movne	r3, #0
 80042ea:	2301      	moveq	r3, #1
 80042ec:	b2db      	uxtb	r3, r3
 80042ee:	2004      	movs	r0, #4
 80042f0:	4619      	mov	r1, r3
 80042f2:	f004 f935 	bl	8008560 <_test_assert>
 80042f6:	4603      	mov	r3, r0
 80042f8:	2b00      	cmp	r3, #0
 80042fa:	d122      	bne.n	8004342 <evt3_execute.12854+0xe2>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
 80042fc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004300:	210a      	movs	r1, #10
 8004302:	f008 fe45 	bl	800cf90 <chEvtWaitAnyTimeout>
 8004306:	9001      	str	r0, [sp, #4]
  test_assert(5, m == 0, "spurious event");
 8004308:	9b01      	ldr	r3, [sp, #4]
 800430a:	2b00      	cmp	r3, #0
 800430c:	bf14      	ite	ne
 800430e:	2300      	movne	r3, #0
 8004310:	2301      	moveq	r3, #1
 8004312:	b2db      	uxtb	r3, r3
 8004314:	2005      	movs	r0, #5
 8004316:	4619      	mov	r1, r3
 8004318:	f004 f922 	bl	8008560 <_test_assert>
 800431c:	4603      	mov	r3, r0
 800431e:	2b00      	cmp	r3, #0
 8004320:	d10f      	bne.n	8004342 <evt3_execute.12854+0xe2>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
 8004322:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8004326:	210a      	movs	r1, #10
 8004328:	f008 fe72 	bl	800d010 <chEvtWaitAllTimeout>
 800432c:	9001      	str	r0, [sp, #4]
  test_assert(6, m == 0, "spurious event");
 800432e:	9b01      	ldr	r3, [sp, #4]
 8004330:	2b00      	cmp	r3, #0
 8004332:	bf14      	ite	ne
 8004334:	2300      	movne	r3, #0
 8004336:	2301      	moveq	r3, #1
 8004338:	b2db      	uxtb	r3, r3
 800433a:	2006      	movs	r0, #6
 800433c:	4619      	mov	r1, r3
 800433e:	f004 f90f 	bl	8008560 <_test_assert>
}
 8004342:	b003      	add	sp, #12
 8004344:	f85d fb04 	ldr.w	pc, [sp], #4
 8004348:	f3af 8000 	nop.w
 800434c:	f3af 8000 	nop.w

08004350 <heap1_setup.12993>:
 * allocator.<br>
 * The test expects to find the heap back to the initial status after each
 * sequence.
 */

static void heap1_setup(void) {
 8004350:	b508      	push	{r3, lr}

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
 8004352:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004356:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800435a:	f241 7158 	movw	r1, #5976	; 0x1758
 800435e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8004362:	f44f 62e1 	mov.w	r2, #1800	; 0x708
 8004366:	f007 f8ab 	bl	800b4c0 <chHeapObjectInit>
}
 800436a:	bd08      	pop	{r3, pc}
 800436c:	f3af 8000 	nop.w

08004370 <heap1_execute.12996>:

static void heap1_execute(void) {
 8004370:	b500      	push	{lr}
 8004372:	b087      	sub	sp, #28
  void *p1, *p2, *p3;
  size_t n, sz;

  /* Unrelated, for coverage only.*/
  (void)chCoreGetStatusX();
 8004374:	f007 f874 	bl	800b460 <chCoreGetStatusX>

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 8004378:	ab01      	add	r3, sp, #4
 800437a:	2000      	movs	r0, #0
 800437c:	4619      	mov	r1, r3
 800437e:	f007 f9c7 	bl	800b710 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 8004382:	2000      	movs	r0, #0
 8004384:	2110      	movs	r1, #16
 8004386:	f007 f8cb 	bl	800b520 <chHeapAlloc>
 800438a:	9005      	str	r0, [sp, #20]
  test_assert(1, p1 != NULL, "allocation failed");
 800438c:	9b05      	ldr	r3, [sp, #20]
 800438e:	2b00      	cmp	r3, #0
 8004390:	bf0c      	ite	eq
 8004392:	2300      	moveq	r3, #0
 8004394:	2301      	movne	r3, #1
 8004396:	b2db      	uxtb	r3, r3
 8004398:	2001      	movs	r0, #1
 800439a:	4619      	mov	r1, r3
 800439c:	f004 f8e0 	bl	8008560 <_test_assert>
 80043a0:	4603      	mov	r3, r0
 80043a2:	2b00      	cmp	r3, #0
 80043a4:	f040 8194 	bne.w	80046d0 <heap1_execute.12996+0x360>
  chHeapFree(p1);
 80043a8:	9805      	ldr	r0, [sp, #20]
 80043aa:	f007 f931 	bl	800b610 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 80043ae:	2000      	movs	r0, #0
 80043b0:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 80043b4:	f007 f8b4 	bl	800b520 <chHeapAlloc>
 80043b8:	9005      	str	r0, [sp, #20]
  test_assert(2, p1 == NULL, "allocation not failed");
 80043ba:	9b05      	ldr	r3, [sp, #20]
 80043bc:	2b00      	cmp	r3, #0
 80043be:	bf14      	ite	ne
 80043c0:	2300      	movne	r3, #0
 80043c2:	2301      	moveq	r3, #1
 80043c4:	b2db      	uxtb	r3, r3
 80043c6:	2002      	movs	r0, #2
 80043c8:	4619      	mov	r1, r3
 80043ca:	f004 f8c9 	bl	8008560 <_test_assert>
 80043ce:	4603      	mov	r3, r0
 80043d0:	2b00      	cmp	r3, #0
 80043d2:	f040 817d 	bne.w	80046d0 <heap1_execute.12996+0x360>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 80043d6:	ab01      	add	r3, sp, #4
 80043d8:	f641 6090 	movw	r0, #7824	; 0x1e90
 80043dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80043e0:	4619      	mov	r1, r3
 80043e2:	f007 f995 	bl	800b710 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 80043e6:	f641 6090 	movw	r0, #7824	; 0x1e90
 80043ea:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80043ee:	2110      	movs	r1, #16
 80043f0:	f007 f896 	bl	800b520 <chHeapAlloc>
 80043f4:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 80043f6:	f641 6090 	movw	r0, #7824	; 0x1e90
 80043fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80043fe:	2110      	movs	r1, #16
 8004400:	f007 f88e 	bl	800b520 <chHeapAlloc>
 8004404:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 8004406:	f641 6090 	movw	r0, #7824	; 0x1e90
 800440a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800440e:	2110      	movs	r1, #16
 8004410:	f007 f886 	bl	800b520 <chHeapAlloc>
 8004414:	9003      	str	r0, [sp, #12]
  chHeapFree(p1);                               /* Does not merge.*/
 8004416:	9805      	ldr	r0, [sp, #20]
 8004418:	f007 f8fa 	bl	800b610 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 800441c:	9804      	ldr	r0, [sp, #16]
 800441e:	f007 f8f7 	bl	800b610 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 8004422:	9803      	ldr	r0, [sp, #12]
 8004424:	f007 f8f4 	bl	800b610 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004428:	ab02      	add	r3, sp, #8
 800442a:	f641 6090 	movw	r0, #7824	; 0x1e90
 800442e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004432:	4619      	mov	r1, r3
 8004434:	f007 f96c 	bl	800b710 <chHeapStatus>
 8004438:	4603      	mov	r3, r0
 800443a:	2b01      	cmp	r3, #1
 800443c:	bf14      	ite	ne
 800443e:	2300      	movne	r3, #0
 8004440:	2301      	moveq	r3, #1
 8004442:	b2db      	uxtb	r3, r3
 8004444:	2003      	movs	r0, #3
 8004446:	4619      	mov	r1, r3
 8004448:	f004 f88a 	bl	8008560 <_test_assert>
 800444c:	4603      	mov	r3, r0
 800444e:	2b00      	cmp	r3, #0
 8004450:	f040 813e 	bne.w	80046d0 <heap1_execute.12996+0x360>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004454:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004458:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800445c:	2110      	movs	r1, #16
 800445e:	f007 f85f 	bl	800b520 <chHeapAlloc>
 8004462:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004464:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004468:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800446c:	2110      	movs	r1, #16
 800446e:	f007 f857 	bl	800b520 <chHeapAlloc>
 8004472:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 8004474:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004478:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800447c:	2110      	movs	r1, #16
 800447e:	f007 f84f 	bl	800b520 <chHeapAlloc>
 8004482:	9003      	str	r0, [sp, #12]
  chHeapFree(p3);                               /* Merges forward.*/
 8004484:	9803      	ldr	r0, [sp, #12]
 8004486:	f007 f8c3 	bl	800b610 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 800448a:	9804      	ldr	r0, [sp, #16]
 800448c:	f007 f8c0 	bl	800b610 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 8004490:	9805      	ldr	r0, [sp, #20]
 8004492:	f007 f8bd 	bl	800b610 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004496:	ab02      	add	r3, sp, #8
 8004498:	f641 6090 	movw	r0, #7824	; 0x1e90
 800449c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80044a0:	4619      	mov	r1, r3
 80044a2:	f007 f935 	bl	800b710 <chHeapStatus>
 80044a6:	4603      	mov	r3, r0
 80044a8:	2b01      	cmp	r3, #1
 80044aa:	bf14      	ite	ne
 80044ac:	2300      	movne	r3, #0
 80044ae:	2301      	moveq	r3, #1
 80044b0:	b2db      	uxtb	r3, r3
 80044b2:	2004      	movs	r0, #4
 80044b4:	4619      	mov	r1, r3
 80044b6:	f004 f853 	bl	8008560 <_test_assert>
 80044ba:	4603      	mov	r3, r0
 80044bc:	2b00      	cmp	r3, #0
 80044be:	f040 8107 	bne.w	80046d0 <heap1_execute.12996+0x360>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 80044c2:	f641 6090 	movw	r0, #7824	; 0x1e90
 80044c6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80044ca:	2111      	movs	r1, #17
 80044cc:	f007 f828 	bl	800b520 <chHeapAlloc>
 80044d0:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 80044d2:	f641 6090 	movw	r0, #7824	; 0x1e90
 80044d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80044da:	2110      	movs	r1, #16
 80044dc:	f007 f820 	bl	800b520 <chHeapAlloc>
 80044e0:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 80044e2:	9805      	ldr	r0, [sp, #20]
 80044e4:	f007 f894 	bl	800b610 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 80044e8:	ab02      	add	r3, sp, #8
 80044ea:	f641 6090 	movw	r0, #7824	; 0x1e90
 80044ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80044f2:	4619      	mov	r1, r3
 80044f4:	f007 f90c 	bl	800b710 <chHeapStatus>
 80044f8:	4603      	mov	r3, r0
 80044fa:	2b02      	cmp	r3, #2
 80044fc:	bf14      	ite	ne
 80044fe:	2300      	movne	r3, #0
 8004500:	2301      	moveq	r3, #1
 8004502:	b2db      	uxtb	r3, r3
 8004504:	2005      	movs	r0, #5
 8004506:	4619      	mov	r1, r3
 8004508:	f004 f82a 	bl	8008560 <_test_assert>
 800450c:	4603      	mov	r3, r0
 800450e:	2b00      	cmp	r3, #0
 8004510:	f040 80de 	bne.w	80046d0 <heap1_execute.12996+0x360>
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004514:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004518:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800451c:	2110      	movs	r1, #16
 800451e:	f006 ffff 	bl	800b520 <chHeapAlloc>
 8004522:	9005      	str	r0, [sp, #20]
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8004524:	ab02      	add	r3, sp, #8
 8004526:	f641 6090 	movw	r0, #7824	; 0x1e90
 800452a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800452e:	4619      	mov	r1, r3
 8004530:	f007 f8ee 	bl	800b710 <chHeapStatus>
 8004534:	4603      	mov	r3, r0
 8004536:	2b01      	cmp	r3, #1
 8004538:	d00a      	beq.n	8004550 <heap1_execute.12996+0x1e0>
 800453a:	ab02      	add	r3, sp, #8
 800453c:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004540:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004544:	4619      	mov	r1, r3
 8004546:	f007 f8e3 	bl	800b710 <chHeapStatus>
 800454a:	4603      	mov	r3, r0
 800454c:	2b02      	cmp	r3, #2
 800454e:	d101      	bne.n	8004554 <heap1_execute.12996+0x1e4>
 8004550:	2301      	movs	r3, #1
 8004552:	e000      	b.n	8004556 <heap1_execute.12996+0x1e6>
 8004554:	2300      	movs	r3, #0
 8004556:	f003 0301 	and.w	r3, r3, #1
 800455a:	b2db      	uxtb	r3, r3
 800455c:	2006      	movs	r0, #6
 800455e:	4619      	mov	r1, r3
 8004560:	f003 fffe 	bl	8008560 <_test_assert>
 8004564:	4603      	mov	r3, r0
 8004566:	2b00      	cmp	r3, #0
 8004568:	f040 80b2 	bne.w	80046d0 <heap1_execute.12996+0x360>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 800456c:	9804      	ldr	r0, [sp, #16]
 800456e:	f007 f84f 	bl	800b610 <chHeapFree>
  chHeapFree(p1);
 8004572:	9805      	ldr	r0, [sp, #20]
 8004574:	f007 f84c 	bl	800b610 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004578:	ab02      	add	r3, sp, #8
 800457a:	f641 6090 	movw	r0, #7824	; 0x1e90
 800457e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004582:	4619      	mov	r1, r3
 8004584:	f007 f8c4 	bl	800b710 <chHeapStatus>
 8004588:	4603      	mov	r3, r0
 800458a:	2b01      	cmp	r3, #1
 800458c:	bf14      	ite	ne
 800458e:	2300      	movne	r3, #0
 8004590:	2301      	moveq	r3, #1
 8004592:	b2db      	uxtb	r3, r3
 8004594:	2007      	movs	r0, #7
 8004596:	4619      	mov	r1, r3
 8004598:	f003 ffe2 	bl	8008560 <_test_assert>
 800459c:	4603      	mov	r3, r0
 800459e:	2b00      	cmp	r3, #0
 80045a0:	f040 8096 	bne.w	80046d0 <heap1_execute.12996+0x360>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 80045a4:	f641 6090 	movw	r0, #7824	; 0x1e90
 80045a8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80045ac:	2110      	movs	r1, #16
 80045ae:	f006 ffb7 	bl	800b520 <chHeapAlloc>
 80045b2:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 80045b4:	f641 6090 	movw	r0, #7824	; 0x1e90
 80045b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80045bc:	2110      	movs	r1, #16
 80045be:	f006 ffaf 	bl	800b520 <chHeapAlloc>
 80045c2:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 80045c4:	9805      	ldr	r0, [sp, #20]
 80045c6:	f007 f823 	bl	800b610 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 80045ca:	ab02      	add	r3, sp, #8
 80045cc:	f641 6090 	movw	r0, #7824	; 0x1e90
 80045d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80045d4:	4619      	mov	r1, r3
 80045d6:	f007 f89b 	bl	800b710 <chHeapStatus>
 80045da:	4603      	mov	r3, r0
 80045dc:	2b02      	cmp	r3, #2
 80045de:	bf14      	ite	ne
 80045e0:	2300      	movne	r3, #0
 80045e2:	2301      	moveq	r3, #1
 80045e4:	b2db      	uxtb	r3, r3
 80045e6:	2008      	movs	r0, #8
 80045e8:	4619      	mov	r1, r3
 80045ea:	f003 ffb9 	bl	8008560 <_test_assert>
 80045ee:	4603      	mov	r3, r0
 80045f0:	2b00      	cmp	r3, #0
 80045f2:	d16d      	bne.n	80046d0 <heap1_execute.12996+0x360>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 80045f4:	f641 6090 	movw	r0, #7824	; 0x1e90
 80045f8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80045fc:	2120      	movs	r1, #32
 80045fe:	f006 ff8f 	bl	800b520 <chHeapAlloc>
 8004602:	9005      	str	r0, [sp, #20]
  chHeapFree(p1);
 8004604:	9805      	ldr	r0, [sp, #20]
 8004606:	f007 f803 	bl	800b610 <chHeapFree>
  chHeapFree(p2);
 800460a:	9804      	ldr	r0, [sp, #16]
 800460c:	f007 f800 	bl	800b610 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8004610:	ab02      	add	r3, sp, #8
 8004612:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004616:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800461a:	4619      	mov	r1, r3
 800461c:	f007 f878 	bl	800b710 <chHeapStatus>
 8004620:	4603      	mov	r3, r0
 8004622:	2b01      	cmp	r3, #1
 8004624:	bf14      	ite	ne
 8004626:	2300      	movne	r3, #0
 8004628:	2301      	moveq	r3, #1
 800462a:	b2db      	uxtb	r3, r3
 800462c:	2009      	movs	r0, #9
 800462e:	4619      	mov	r1, r3
 8004630:	f003 ff96 	bl	8008560 <_test_assert>
 8004634:	4603      	mov	r3, r0
 8004636:	2b00      	cmp	r3, #0
 8004638:	d14a      	bne.n	80046d0 <heap1_execute.12996+0x360>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 800463a:	ab02      	add	r3, sp, #8
 800463c:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004640:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004644:	4619      	mov	r1, r3
 8004646:	f007 f863 	bl	800b710 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 800464a:	9b02      	ldr	r3, [sp, #8]
 800464c:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004650:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004654:	4619      	mov	r1, r3
 8004656:	f006 ff63 	bl	800b520 <chHeapAlloc>
 800465a:	9005      	str	r0, [sp, #20]
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 800465c:	ab02      	add	r3, sp, #8
 800465e:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004662:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004666:	4619      	mov	r1, r3
 8004668:	f007 f852 	bl	800b710 <chHeapStatus>
 800466c:	4603      	mov	r3, r0
 800466e:	2b00      	cmp	r3, #0
 8004670:	bf14      	ite	ne
 8004672:	2300      	movne	r3, #0
 8004674:	2301      	moveq	r3, #1
 8004676:	b2db      	uxtb	r3, r3
 8004678:	200a      	movs	r0, #10
 800467a:	4619      	mov	r1, r3
 800467c:	f003 ff70 	bl	8008560 <_test_assert>
 8004680:	4603      	mov	r3, r0
 8004682:	2b00      	cmp	r3, #0
 8004684:	d124      	bne.n	80046d0 <heap1_execute.12996+0x360>
  chHeapFree(p1);
 8004686:	9805      	ldr	r0, [sp, #20]
 8004688:	f006 ffc2 	bl	800b610 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800468c:	ab02      	add	r3, sp, #8
 800468e:	f641 6090 	movw	r0, #7824	; 0x1e90
 8004692:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004696:	4619      	mov	r1, r3
 8004698:	f007 f83a 	bl	800b710 <chHeapStatus>
 800469c:	4603      	mov	r3, r0
 800469e:	2b01      	cmp	r3, #1
 80046a0:	bf14      	ite	ne
 80046a2:	2300      	movne	r3, #0
 80046a4:	2301      	moveq	r3, #1
 80046a6:	b2db      	uxtb	r3, r3
 80046a8:	200b      	movs	r0, #11
 80046aa:	4619      	mov	r1, r3
 80046ac:	f003 ff58 	bl	8008560 <_test_assert>
 80046b0:	4603      	mov	r3, r0
 80046b2:	2b00      	cmp	r3, #0
 80046b4:	d10c      	bne.n	80046d0 <heap1_execute.12996+0x360>
  test_assert(12, n == sz, "size changed");
 80046b6:	9a02      	ldr	r2, [sp, #8]
 80046b8:	9b01      	ldr	r3, [sp, #4]
 80046ba:	429a      	cmp	r2, r3
 80046bc:	bf14      	ite	ne
 80046be:	2300      	movne	r3, #0
 80046c0:	2301      	moveq	r3, #1
 80046c2:	b2db      	uxtb	r3, r3
 80046c4:	200c      	movs	r0, #12
 80046c6:	4619      	mov	r1, r3
 80046c8:	f003 ff4a 	bl	8008560 <_test_assert>
 80046cc:	4603      	mov	r3, r0
 80046ce:	2b00      	cmp	r3, #0
}
 80046d0:	b007      	add	sp, #28
 80046d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80046d6:	bf00      	nop
 80046d8:	f3af 8000 	nop.w
 80046dc:	f3af 8000 	nop.w

080046e0 <null_provider.13126>:
 * Five memory blocks are added to a memory pool then removed.<br>
 * The test expects to find the pool queue in the proper status after each
 * operation.
 */

static void *null_provider(size_t size) {
 80046e0:	b082      	sub	sp, #8
 80046e2:	9001      	str	r0, [sp, #4]

  (void)size;
  return NULL;
 80046e4:	2300      	movs	r3, #0
}
 80046e6:	4618      	mov	r0, r3
 80046e8:	b002      	add	sp, #8
 80046ea:	4770      	bx	lr
 80046ec:	f3af 8000 	nop.w

080046f0 <thread4a.12144.4174>:

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread4a, p) {
 80046f0:	b500      	push	{lr}
 80046f2:	b083      	sub	sp, #12
 80046f4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 80046f6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80046fa:	f009 f9a9 	bl	800da50 <chThdSleep>
  chMtxLock(&m2);
 80046fe:	f640 0058 	movw	r0, #2136	; 0x858
 8004702:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004706:	f00a fabb 	bl	800ec80 <chMtxLock>
  chMtxUnlock(&m2);
 800470a:	f640 0058 	movw	r0, #2136	; 0x858
 800470e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004712:	f007 fe55 	bl	800c3c0 <chMtxUnlock>
}
 8004716:	b003      	add	sp, #12
 8004718:	f85d fb04 	ldr.w	pc, [sp], #4
 800471c:	f3af 8000 	nop.w

08004720 <thread4b.12147.4177>:

static THD_FUNCTION(thread4b, p) {
 8004720:	b500      	push	{lr}
 8004722:	b083      	sub	sp, #12
 8004724:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(150);
 8004726:	f240 50dc 	movw	r0, #1500	; 0x5dc
 800472a:	f009 f991 	bl	800da50 <chThdSleep>
  chMtxLock(&m1);
 800472e:	f640 0048 	movw	r0, #2120	; 0x848
 8004732:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004736:	f00a faa3 	bl	800ec80 <chMtxLock>
  chMtxUnlock(&m1);
 800473a:	f640 0048 	movw	r0, #2120	; 0x848
 800473e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004742:	f007 fe3d 	bl	800c3c0 <chMtxUnlock>
}
 8004746:	b003      	add	sp, #12
 8004748:	f85d fb04 	ldr.w	pc, [sp], #4
 800474c:	f3af 8000 	nop.w

08004750 <mtx4_execute.12154>:

static void mtx4_execute(void) {
 8004750:	b500      	push	{lr}
 8004752:	b087      	sub	sp, #28
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
 8004754:	f002 fbf4 	bl	8006f40 <chThdGetPriorityX.12128>
 8004758:	9005      	str	r0, [sp, #20]
  p1 = p + 1;
 800475a:	9b05      	ldr	r3, [sp, #20]
 800475c:	3301      	adds	r3, #1
 800475e:	9304      	str	r3, [sp, #16]
  p2 = p + 2;
 8004760:	9b05      	ldr	r3, [sp, #20]
 8004762:	3302      	adds	r3, #2
 8004764:	9303      	str	r3, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8004766:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 800476a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800476e:	681a      	ldr	r2, [r3, #0]
 8004770:	f640 5370 	movw	r3, #3440	; 0xd70
 8004774:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004778:	9300      	str	r3, [sp, #0]
 800477a:	4610      	mov	r0, r2
 800477c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004780:	9a04      	ldr	r2, [sp, #16]
 8004782:	f244 63f1 	movw	r3, #18161	; 0x46f1
 8004786:	f6c0 0300 	movt	r3, #2048	; 0x800
 800478a:	f00b ffe9 	bl	8010760 <chThdCreateStatic>
 800478e:	4602      	mov	r2, r0
 8004790:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004794:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004798:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 800479a:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 800479e:	f6c0 0301 	movt	r3, #2049	; 0x801
 80047a2:	685a      	ldr	r2, [r3, #4]
 80047a4:	f640 5374 	movw	r3, #3444	; 0xd74
 80047a8:	f6c0 0301 	movt	r3, #2049	; 0x801
 80047ac:	9300      	str	r3, [sp, #0]
 80047ae:	4610      	mov	r0, r2
 80047b0:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80047b4:	9a03      	ldr	r2, [sp, #12]
 80047b6:	f244 7321 	movw	r3, #18209	; 0x4721
 80047ba:	f6c0 0300 	movt	r3, #2048	; 0x800
 80047be:	f00b ffcf 	bl	8010760 <chThdCreateStatic>
 80047c2:	4602      	mov	r2, r0
 80047c4:	f641 6360 	movw	r3, #7776	; 0x1e60
 80047c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80047cc:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 80047ce:	f640 0058 	movw	r0, #2136	; 0x858
 80047d2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80047d6:	f00a fa53 	bl	800ec80 <chMtxLock>
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 80047da:	f002 fbb1 	bl	8006f40 <chThdGetPriorityX.12128>
 80047de:	4602      	mov	r2, r0
 80047e0:	9b05      	ldr	r3, [sp, #20]
 80047e2:	429a      	cmp	r2, r3
 80047e4:	bf14      	ite	ne
 80047e6:	2300      	movne	r3, #0
 80047e8:	2301      	moveq	r3, #1
 80047ea:	b2db      	uxtb	r3, r3
 80047ec:	2001      	movs	r0, #1
 80047ee:	4619      	mov	r1, r3
 80047f0:	f003 feb6 	bl	8008560 <_test_assert>
 80047f4:	4603      	mov	r3, r0
 80047f6:	2b00      	cmp	r3, #0
 80047f8:	f040 814f 	bne.w	8004a9a <mtx4_execute.12154+0x34a>
  chThdSleepMilliseconds(100);
 80047fc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004800:	f009 f926 	bl	800da50 <chThdSleep>
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 8004804:	f002 fb9c 	bl	8006f40 <chThdGetPriorityX.12128>
 8004808:	4602      	mov	r2, r0
 800480a:	9b04      	ldr	r3, [sp, #16]
 800480c:	429a      	cmp	r2, r3
 800480e:	bf14      	ite	ne
 8004810:	2300      	movne	r3, #0
 8004812:	2301      	moveq	r3, #1
 8004814:	b2db      	uxtb	r3, r3
 8004816:	2002      	movs	r0, #2
 8004818:	4619      	mov	r1, r3
 800481a:	f003 fea1 	bl	8008560 <_test_assert>
 800481e:	4603      	mov	r3, r0
 8004820:	2b00      	cmp	r3, #0
 8004822:	f040 813a 	bne.w	8004a9a <mtx4_execute.12154+0x34a>
  chMtxLock(&m1);
 8004826:	f640 0048 	movw	r0, #2120	; 0x848
 800482a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800482e:	f00a fa27 	bl	800ec80 <chMtxLock>
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 8004832:	f002 fb85 	bl	8006f40 <chThdGetPriorityX.12128>
 8004836:	4602      	mov	r2, r0
 8004838:	9b04      	ldr	r3, [sp, #16]
 800483a:	429a      	cmp	r2, r3
 800483c:	bf14      	ite	ne
 800483e:	2300      	movne	r3, #0
 8004840:	2301      	moveq	r3, #1
 8004842:	b2db      	uxtb	r3, r3
 8004844:	2003      	movs	r0, #3
 8004846:	4619      	mov	r1, r3
 8004848:	f003 fe8a 	bl	8008560 <_test_assert>
 800484c:	4603      	mov	r3, r0
 800484e:	2b00      	cmp	r3, #0
 8004850:	f040 8123 	bne.w	8004a9a <mtx4_execute.12154+0x34a>
  chThdSleepMilliseconds(100);
 8004854:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004858:	f009 f8fa 	bl	800da50 <chThdSleep>
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 800485c:	f002 fb70 	bl	8006f40 <chThdGetPriorityX.12128>
 8004860:	4602      	mov	r2, r0
 8004862:	9b03      	ldr	r3, [sp, #12]
 8004864:	429a      	cmp	r2, r3
 8004866:	bf14      	ite	ne
 8004868:	2300      	movne	r3, #0
 800486a:	2301      	moveq	r3, #1
 800486c:	b2db      	uxtb	r3, r3
 800486e:	2004      	movs	r0, #4
 8004870:	4619      	mov	r1, r3
 8004872:	f003 fe75 	bl	8008560 <_test_assert>
 8004876:	4603      	mov	r3, r0
 8004878:	2b00      	cmp	r3, #0
 800487a:	f040 810e 	bne.w	8004a9a <mtx4_execute.12154+0x34a>
  chMtxUnlock(&m1);
 800487e:	f640 0048 	movw	r0, #2120	; 0x848
 8004882:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004886:	f007 fd9b 	bl	800c3c0 <chMtxUnlock>
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 800488a:	f002 fb59 	bl	8006f40 <chThdGetPriorityX.12128>
 800488e:	4602      	mov	r2, r0
 8004890:	9b04      	ldr	r3, [sp, #16]
 8004892:	429a      	cmp	r2, r3
 8004894:	bf14      	ite	ne
 8004896:	2300      	movne	r3, #0
 8004898:	2301      	moveq	r3, #1
 800489a:	b2db      	uxtb	r3, r3
 800489c:	2005      	movs	r0, #5
 800489e:	4619      	mov	r1, r3
 80048a0:	f003 fe5e 	bl	8008560 <_test_assert>
 80048a4:	4603      	mov	r3, r0
 80048a6:	2b00      	cmp	r3, #0
 80048a8:	f040 80f7 	bne.w	8004a9a <mtx4_execute.12154+0x34a>
  chThdSleepMilliseconds(100);
 80048ac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80048b0:	f009 f8ce 	bl	800da50 <chThdSleep>
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 80048b4:	f002 fb44 	bl	8006f40 <chThdGetPriorityX.12128>
 80048b8:	4602      	mov	r2, r0
 80048ba:	9b04      	ldr	r3, [sp, #16]
 80048bc:	429a      	cmp	r2, r3
 80048be:	bf14      	ite	ne
 80048c0:	2300      	movne	r3, #0
 80048c2:	2301      	moveq	r3, #1
 80048c4:	b2db      	uxtb	r3, r3
 80048c6:	2006      	movs	r0, #6
 80048c8:	4619      	mov	r1, r3
 80048ca:	f003 fe49 	bl	8008560 <_test_assert>
 80048ce:	4603      	mov	r3, r0
 80048d0:	2b00      	cmp	r3, #0
 80048d2:	f040 80e2 	bne.w	8004a9a <mtx4_execute.12154+0x34a>
  chMtxUnlockAll();
 80048d6:	f007 fe6b 	bl	800c5b0 <chMtxUnlockAll>
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 80048da:	f002 fb31 	bl	8006f40 <chThdGetPriorityX.12128>
 80048de:	4602      	mov	r2, r0
 80048e0:	9b05      	ldr	r3, [sp, #20]
 80048e2:	429a      	cmp	r2, r3
 80048e4:	bf14      	ite	ne
 80048e6:	2300      	movne	r3, #0
 80048e8:	2301      	moveq	r3, #1
 80048ea:	b2db      	uxtb	r3, r3
 80048ec:	2007      	movs	r0, #7
 80048ee:	4619      	mov	r1, r3
 80048f0:	f003 fe36 	bl	8008560 <_test_assert>
 80048f4:	4603      	mov	r3, r0
 80048f6:	2b00      	cmp	r3, #0
 80048f8:	f040 80cf 	bne.w	8004a9a <mtx4_execute.12154+0x34a>
  test_wait_threads();
 80048fc:	f003 fec0 	bl	8008680 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8004900:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004904:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004908:	681a      	ldr	r2, [r3, #0]
 800490a:	f640 5378 	movw	r3, #3448	; 0xd78
 800490e:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004912:	9300      	str	r3, [sp, #0]
 8004914:	4610      	mov	r0, r2
 8004916:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800491a:	9a04      	ldr	r2, [sp, #16]
 800491c:	f244 63f1 	movw	r3, #18161	; 0x46f1
 8004920:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004924:	f00b ff1c 	bl	8010760 <chThdCreateStatic>
 8004928:	4602      	mov	r2, r0
 800492a:	f641 6360 	movw	r3, #7776	; 0x1e60
 800492e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004932:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8004934:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004938:	f6c0 0301 	movt	r3, #2049	; 0x801
 800493c:	685a      	ldr	r2, [r3, #4]
 800493e:	f640 537c 	movw	r3, #3452	; 0xd7c
 8004942:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004946:	9300      	str	r3, [sp, #0]
 8004948:	4610      	mov	r0, r2
 800494a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800494e:	9a03      	ldr	r2, [sp, #12]
 8004950:	f244 7321 	movw	r3, #18209	; 0x4721
 8004954:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004958:	f00b ff02 	bl	8010760 <chThdCreateStatic>
 800495c:	4602      	mov	r2, r0
 800495e:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004962:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004966:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 8004968:	f640 0058 	movw	r0, #2136	; 0x858
 800496c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004970:	f00a f986 	bl	800ec80 <chMtxLock>
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 8004974:	f002 fae4 	bl	8006f40 <chThdGetPriorityX.12128>
 8004978:	4602      	mov	r2, r0
 800497a:	9b05      	ldr	r3, [sp, #20]
 800497c:	429a      	cmp	r2, r3
 800497e:	bf14      	ite	ne
 8004980:	2300      	movne	r3, #0
 8004982:	2301      	moveq	r3, #1
 8004984:	b2db      	uxtb	r3, r3
 8004986:	2008      	movs	r0, #8
 8004988:	4619      	mov	r1, r3
 800498a:	f003 fde9 	bl	8008560 <_test_assert>
 800498e:	4603      	mov	r3, r0
 8004990:	2b00      	cmp	r3, #0
 8004992:	f040 8082 	bne.w	8004a9a <mtx4_execute.12154+0x34a>
  chThdSleepMilliseconds(100);
 8004996:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800499a:	f009 f859 	bl	800da50 <chThdSleep>
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 800499e:	f002 facf 	bl	8006f40 <chThdGetPriorityX.12128>
 80049a2:	4602      	mov	r2, r0
 80049a4:	9b04      	ldr	r3, [sp, #16]
 80049a6:	429a      	cmp	r2, r3
 80049a8:	bf14      	ite	ne
 80049aa:	2300      	movne	r3, #0
 80049ac:	2301      	moveq	r3, #1
 80049ae:	b2db      	uxtb	r3, r3
 80049b0:	2009      	movs	r0, #9
 80049b2:	4619      	mov	r1, r3
 80049b4:	f003 fdd4 	bl	8008560 <_test_assert>
 80049b8:	4603      	mov	r3, r0
 80049ba:	2b00      	cmp	r3, #0
 80049bc:	d16d      	bne.n	8004a9a <mtx4_execute.12154+0x34a>
  chMtxLock(&m1);
 80049be:	f640 0048 	movw	r0, #2120	; 0x848
 80049c2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80049c6:	f00a f95b 	bl	800ec80 <chMtxLock>
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 80049ca:	f002 fab9 	bl	8006f40 <chThdGetPriorityX.12128>
 80049ce:	4602      	mov	r2, r0
 80049d0:	9b04      	ldr	r3, [sp, #16]
 80049d2:	429a      	cmp	r2, r3
 80049d4:	bf14      	ite	ne
 80049d6:	2300      	movne	r3, #0
 80049d8:	2301      	moveq	r3, #1
 80049da:	b2db      	uxtb	r3, r3
 80049dc:	200a      	movs	r0, #10
 80049de:	4619      	mov	r1, r3
 80049e0:	f003 fdbe 	bl	8008560 <_test_assert>
 80049e4:	4603      	mov	r3, r0
 80049e6:	2b00      	cmp	r3, #0
 80049e8:	d157      	bne.n	8004a9a <mtx4_execute.12154+0x34a>
  chThdSleepMilliseconds(100);
 80049ea:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80049ee:	f009 f82f 	bl	800da50 <chThdSleep>
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 80049f2:	f002 faa5 	bl	8006f40 <chThdGetPriorityX.12128>
 80049f6:	4602      	mov	r2, r0
 80049f8:	9b03      	ldr	r3, [sp, #12]
 80049fa:	429a      	cmp	r2, r3
 80049fc:	bf14      	ite	ne
 80049fe:	2300      	movne	r3, #0
 8004a00:	2301      	moveq	r3, #1
 8004a02:	b2db      	uxtb	r3, r3
 8004a04:	200b      	movs	r0, #11
 8004a06:	4619      	mov	r1, r3
 8004a08:	f003 fdaa 	bl	8008560 <_test_assert>
 8004a0c:	4603      	mov	r3, r0
 8004a0e:	2b00      	cmp	r3, #0
 8004a10:	d143      	bne.n	8004a9a <mtx4_execute.12154+0x34a>
  chSysLock();
 8004a12:	f002 fa5d 	bl	8006ed0 <chSysLock.12150>
  chMtxUnlockS(&m1);
 8004a16:	f640 0048 	movw	r0, #2120	; 0x848
 8004a1a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004a1e:	f007 fd4f 	bl	800c4c0 <chMtxUnlockS>
  chSchRescheduleS();
 8004a22:	f00b fb9d 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 8004a26:	f002 fa5b 	bl	8006ee0 <chSysUnlock.12152>
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 8004a2a:	f002 fa89 	bl	8006f40 <chThdGetPriorityX.12128>
 8004a2e:	4602      	mov	r2, r0
 8004a30:	9b04      	ldr	r3, [sp, #16]
 8004a32:	429a      	cmp	r2, r3
 8004a34:	bf14      	ite	ne
 8004a36:	2300      	movne	r3, #0
 8004a38:	2301      	moveq	r3, #1
 8004a3a:	b2db      	uxtb	r3, r3
 8004a3c:	200c      	movs	r0, #12
 8004a3e:	4619      	mov	r1, r3
 8004a40:	f003 fd8e 	bl	8008560 <_test_assert>
 8004a44:	4603      	mov	r3, r0
 8004a46:	2b00      	cmp	r3, #0
 8004a48:	d127      	bne.n	8004a9a <mtx4_execute.12154+0x34a>
  chThdSleepMilliseconds(100);
 8004a4a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004a4e:	f008 ffff 	bl	800da50 <chThdSleep>
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 8004a52:	f002 fa75 	bl	8006f40 <chThdGetPriorityX.12128>
 8004a56:	4602      	mov	r2, r0
 8004a58:	9b04      	ldr	r3, [sp, #16]
 8004a5a:	429a      	cmp	r2, r3
 8004a5c:	bf14      	ite	ne
 8004a5e:	2300      	movne	r3, #0
 8004a60:	2301      	moveq	r3, #1
 8004a62:	b2db      	uxtb	r3, r3
 8004a64:	200d      	movs	r0, #13
 8004a66:	4619      	mov	r1, r3
 8004a68:	f003 fd7a 	bl	8008560 <_test_assert>
 8004a6c:	4603      	mov	r3, r0
 8004a6e:	2b00      	cmp	r3, #0
 8004a70:	d113      	bne.n	8004a9a <mtx4_execute.12154+0x34a>
  chMtxUnlockAll();
 8004a72:	f007 fd9d 	bl	800c5b0 <chMtxUnlockAll>
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 8004a76:	f002 fa63 	bl	8006f40 <chThdGetPriorityX.12128>
 8004a7a:	4602      	mov	r2, r0
 8004a7c:	9b05      	ldr	r3, [sp, #20]
 8004a7e:	429a      	cmp	r2, r3
 8004a80:	bf14      	ite	ne
 8004a82:	2300      	movne	r3, #0
 8004a84:	2301      	moveq	r3, #1
 8004a86:	b2db      	uxtb	r3, r3
 8004a88:	200e      	movs	r0, #14
 8004a8a:	4619      	mov	r1, r3
 8004a8c:	f003 fd68 	bl	8008560 <_test_assert>
 8004a90:	4603      	mov	r3, r0
 8004a92:	2b00      	cmp	r3, #0
 8004a94:	d101      	bne.n	8004a9a <mtx4_execute.12154+0x34a>
  test_wait_threads();
 8004a96:	f003 fdf3 	bl	8008680 <test_wait_threads>
}
 8004a9a:	b007      	add	sp, #28
 8004a9c:	f85d fb04 	ldr.w	pc, [sp], #4

08004aa0 <mtx5_setup.12134>:
 * unlock operations.<br>
 * The test expects that the internal mutex status is consistent after each
 * operation.
 */

static void mtx5_setup(void) {
 8004aa0:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 8004aa2:	f640 0048 	movw	r0, #2120	; 0x848
 8004aa6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004aaa:	f00a f8d1 	bl	800ec50 <chMtxObjectInit>
}
 8004aae:	bd08      	pop	{r3, pc}

08004ab0 <mtx5_execute.12156>:

static void mtx5_execute(void) {
 8004ab0:	b500      	push	{lr}
 8004ab2:	b083      	sub	sp, #12

#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();
 8004ab4:	f002 fa44 	bl	8006f40 <chThdGetPriorityX.12128>
 8004ab8:	9001      	str	r0, [sp, #4]

  b = chMtxTryLock(&m1);
 8004aba:	f640 0048 	movw	r0, #2120	; 0x848
 8004abe:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004ac2:	f00a f975 	bl	800edb0 <chMtxTryLock>
 8004ac6:	4603      	mov	r3, r0
 8004ac8:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(1, b, "already locked");
 8004acc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004ad0:	2001      	movs	r0, #1
 8004ad2:	4619      	mov	r1, r3
 8004ad4:	f003 fd44 	bl	8008560 <_test_assert>
 8004ad8:	4603      	mov	r3, r0
 8004ada:	2b00      	cmp	r3, #0
 8004adc:	d179      	bne.n	8004bd2 <mtx5_execute.12156+0x122>

  b = chMtxTryLock(&m1);
 8004ade:	f640 0048 	movw	r0, #2120	; 0x848
 8004ae2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004ae6:	f00a f963 	bl	800edb0 <chMtxTryLock>
 8004aea:	4603      	mov	r3, r0
 8004aec:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(2, !b, "not locked");
 8004af0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004af4:	2b00      	cmp	r3, #0
 8004af6:	bf0c      	ite	eq
 8004af8:	2300      	moveq	r3, #0
 8004afa:	2301      	movne	r3, #1
 8004afc:	b2db      	uxtb	r3, r3
 8004afe:	f083 0301 	eor.w	r3, r3, #1
 8004b02:	b2db      	uxtb	r3, r3
 8004b04:	f003 0301 	and.w	r3, r3, #1
 8004b08:	b2db      	uxtb	r3, r3
 8004b0a:	2002      	movs	r0, #2
 8004b0c:	4619      	mov	r1, r3
 8004b0e:	f003 fd27 	bl	8008560 <_test_assert>
 8004b12:	4603      	mov	r3, r0
 8004b14:	2b00      	cmp	r3, #0
 8004b16:	d15c      	bne.n	8004bd2 <mtx5_execute.12156+0x122>

  chSysLock();
 8004b18:	f002 f9da 	bl	8006ed0 <chSysLock.12150>
  chMtxUnlockS(&m1);
 8004b1c:	f640 0048 	movw	r0, #2120	; 0x848
 8004b20:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004b24:	f007 fccc 	bl	800c4c0 <chMtxUnlockS>
  chSysUnlock();
 8004b28:	f002 f9da 	bl	8006ee0 <chSysUnlock.12152>

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 8004b2c:	f640 0048 	movw	r0, #2120	; 0x848
 8004b30:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004b34:	f002 f9bc 	bl	8006eb0 <queue_isempty.12036>
 8004b38:	4603      	mov	r3, r0
 8004b3a:	2003      	movs	r0, #3
 8004b3c:	4619      	mov	r1, r3
 8004b3e:	f003 fd0f 	bl	8008560 <_test_assert>
 8004b42:	4603      	mov	r3, r0
 8004b44:	2b00      	cmp	r3, #0
 8004b46:	d144      	bne.n	8004bd2 <mtx5_execute.12156+0x122>
  test_assert(4, m1.m_owner == NULL, "still owned");
 8004b48:	f640 0348 	movw	r3, #2120	; 0x848
 8004b4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004b50:	689b      	ldr	r3, [r3, #8]
 8004b52:	2b00      	cmp	r3, #0
 8004b54:	bf14      	ite	ne
 8004b56:	2300      	movne	r3, #0
 8004b58:	2301      	moveq	r3, #1
 8004b5a:	b2db      	uxtb	r3, r3
 8004b5c:	2004      	movs	r0, #4
 8004b5e:	4619      	mov	r1, r3
 8004b60:	f003 fcfe 	bl	8008560 <_test_assert>
 8004b64:	4603      	mov	r3, r0
 8004b66:	2b00      	cmp	r3, #0
 8004b68:	d133      	bne.n	8004bd2 <mtx5_execute.12156+0x122>
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 8004b6a:	f002 f9e9 	bl	8006f40 <chThdGetPriorityX.12128>
 8004b6e:	4602      	mov	r2, r0
 8004b70:	9b01      	ldr	r3, [sp, #4]
 8004b72:	429a      	cmp	r2, r3
 8004b74:	bf14      	ite	ne
 8004b76:	2300      	movne	r3, #0
 8004b78:	2301      	moveq	r3, #1
 8004b7a:	b2db      	uxtb	r3, r3
 8004b7c:	2005      	movs	r0, #5
 8004b7e:	4619      	mov	r1, r3
 8004b80:	f003 fcee 	bl	8008560 <_test_assert>
 8004b84:	4603      	mov	r3, r0
 8004b86:	2b00      	cmp	r3, #0
 8004b88:	d123      	bne.n	8004bd2 <mtx5_execute.12156+0x122>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 8004b8a:	f640 0048 	movw	r0, #2120	; 0x848
 8004b8e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004b92:	f00a f875 	bl	800ec80 <chMtxLock>
  chMtxUnlockAll();
 8004b96:	f007 fd0b 	bl	800c5b0 <chMtxUnlockAll>
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 8004b9a:	f640 0048 	movw	r0, #2120	; 0x848
 8004b9e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004ba2:	f002 f985 	bl	8006eb0 <queue_isempty.12036>
 8004ba6:	4603      	mov	r3, r0
 8004ba8:	2006      	movs	r0, #6
 8004baa:	4619      	mov	r1, r3
 8004bac:	f003 fcd8 	bl	8008560 <_test_assert>
 8004bb0:	4603      	mov	r3, r0
 8004bb2:	2b00      	cmp	r3, #0
 8004bb4:	d10d      	bne.n	8004bd2 <mtx5_execute.12156+0x122>
  test_assert(7, m1.m_owner == NULL, "still owned");
 8004bb6:	f640 0348 	movw	r3, #2120	; 0x848
 8004bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004bbe:	689b      	ldr	r3, [r3, #8]
 8004bc0:	2b00      	cmp	r3, #0
 8004bc2:	bf14      	ite	ne
 8004bc4:	2300      	movne	r3, #0
 8004bc6:	2301      	moveq	r3, #1
 8004bc8:	b2db      	uxtb	r3, r3
 8004bca:	2007      	movs	r0, #7
 8004bcc:	4619      	mov	r1, r3
 8004bce:	f003 fcc7 	bl	8008560 <_test_assert>
}
 8004bd2:	b003      	add	sp, #12
 8004bd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8004bd8:	f3af 8000 	nop.w
 8004bdc:	f3af 8000 	nop.w

08004be0 <mtx6_setup.12158>:
 * atomically.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx6_setup(void) {
 8004be0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8004be2:	f640 0068 	movw	r0, #2152	; 0x868
 8004be6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004bea:	f007 fdd1 	bl	800c790 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8004bee:	f640 0048 	movw	r0, #2120	; 0x848
 8004bf2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004bf6:	f00a f82b 	bl	800ec50 <chMtxObjectInit>
}
 8004bfa:	bd08      	pop	{r3, pc}
 8004bfc:	f3af 8000 	nop.w

08004c00 <thread10.12164.4152>:

static THD_FUNCTION(thread10, p) {
 8004c00:	b500      	push	{lr}
 8004c02:	b083      	sub	sp, #12
 8004c04:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 8004c06:	f640 0048 	movw	r0, #2120	; 0x848
 8004c0a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004c0e:	f00a f837 	bl	800ec80 <chMtxLock>
  chCondWait(&c1);
 8004c12:	f640 0068 	movw	r0, #2152	; 0x868
 8004c16:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004c1a:	f007 fe59 	bl	800c8d0 <chCondWait>
  test_emit_token(*(char *)p);
 8004c1e:	9b01      	ldr	r3, [sp, #4]
 8004c20:	781b      	ldrb	r3, [r3, #0]
 8004c22:	4618      	mov	r0, r3
 8004c24:	f003 fc64 	bl	80084f0 <test_emit_token>
  chMtxUnlock(&m1);
 8004c28:	f640 0048 	movw	r0, #2120	; 0x848
 8004c2c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004c30:	f007 fbc6 	bl	800c3c0 <chMtxUnlock>
}
 8004c34:	b003      	add	sp, #12
 8004c36:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c3a:	bf00      	nop
 8004c3c:	f3af 8000 	nop.w

08004c40 <mtx6_execute.12167>:

static void mtx6_execute(void) {
 8004c40:	b500      	push	{lr}
 8004c42:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 8004c44:	f002 f97c 	bl	8006f40 <chThdGetPriorityX.12128>
 8004c48:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8004c4a:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004c4e:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004c52:	6819      	ldr	r1, [r3, #0]
 8004c54:	9b03      	ldr	r3, [sp, #12]
 8004c56:	1c5a      	adds	r2, r3, #1
 8004c58:	f640 5380 	movw	r3, #3456	; 0xd80
 8004c5c:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004c60:	9300      	str	r3, [sp, #0]
 8004c62:	4608      	mov	r0, r1
 8004c64:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004c68:	f644 4301 	movw	r3, #19457	; 0x4c01
 8004c6c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004c70:	f00b fd76 	bl	8010760 <chThdCreateStatic>
 8004c74:	4602      	mov	r2, r0
 8004c76:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004c7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004c7e:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8004c80:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004c84:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004c88:	6859      	ldr	r1, [r3, #4]
 8004c8a:	9b03      	ldr	r3, [sp, #12]
 8004c8c:	1c9a      	adds	r2, r3, #2
 8004c8e:	f640 5378 	movw	r3, #3448	; 0xd78
 8004c92:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004c96:	9300      	str	r3, [sp, #0]
 8004c98:	4608      	mov	r0, r1
 8004c9a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004c9e:	f644 4301 	movw	r3, #19457	; 0x4c01
 8004ca2:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004ca6:	f00b fd5b 	bl	8010760 <chThdCreateStatic>
 8004caa:	4602      	mov	r2, r0
 8004cac:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004cb0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cb4:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8004cb6:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004cba:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004cbe:	6899      	ldr	r1, [r3, #8]
 8004cc0:	9b03      	ldr	r3, [sp, #12]
 8004cc2:	1cda      	adds	r2, r3, #3
 8004cc4:	f640 537c 	movw	r3, #3452	; 0xd7c
 8004cc8:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004ccc:	9300      	str	r3, [sp, #0]
 8004cce:	4608      	mov	r0, r1
 8004cd0:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004cd4:	f644 4301 	movw	r3, #19457	; 0x4c01
 8004cd8:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004cdc:	f00b fd40 	bl	8010760 <chThdCreateStatic>
 8004ce0:	4602      	mov	r2, r0
 8004ce2:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004ce6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004cea:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8004cec:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004cf0:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004cf4:	68d9      	ldr	r1, [r3, #12]
 8004cf6:	9b03      	ldr	r3, [sp, #12]
 8004cf8:	1d1a      	adds	r2, r3, #4
 8004cfa:	f640 5370 	movw	r3, #3440	; 0xd70
 8004cfe:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004d02:	9300      	str	r3, [sp, #0]
 8004d04:	4608      	mov	r0, r1
 8004d06:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004d0a:	f644 4301 	movw	r3, #19457	; 0x4c01
 8004d0e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004d12:	f00b fd25 	bl	8010760 <chThdCreateStatic>
 8004d16:	4602      	mov	r2, r0
 8004d18:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004d1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d20:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8004d22:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004d26:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004d2a:	6919      	ldr	r1, [r3, #16]
 8004d2c:	9b03      	ldr	r3, [sp, #12]
 8004d2e:	1d5a      	adds	r2, r3, #5
 8004d30:	f640 5374 	movw	r3, #3444	; 0xd74
 8004d34:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004d38:	9300      	str	r3, [sp, #0]
 8004d3a:	4608      	mov	r0, r1
 8004d3c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004d40:	f644 4301 	movw	r3, #19457	; 0x4c01
 8004d44:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004d48:	f00b fd0a 	bl	8010760 <chThdCreateStatic>
 8004d4c:	4602      	mov	r2, r0
 8004d4e:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004d52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004d56:	611a      	str	r2, [r3, #16]
  chSysLock();
 8004d58:	f002 f8ba 	bl	8006ed0 <chSysLock.12150>
  chCondSignalI(&c1);
 8004d5c:	f640 0068 	movw	r0, #2152	; 0x868
 8004d60:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004d64:	f007 fd54 	bl	800c810 <chCondSignalI>
  chCondSignalI(&c1);
 8004d68:	f640 0068 	movw	r0, #2152	; 0x868
 8004d6c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004d70:	f007 fd4e 	bl	800c810 <chCondSignalI>
  chCondSignalI(&c1);
 8004d74:	f640 0068 	movw	r0, #2152	; 0x868
 8004d78:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004d7c:	f007 fd48 	bl	800c810 <chCondSignalI>
  chCondSignalI(&c1);
 8004d80:	f640 0068 	movw	r0, #2152	; 0x868
 8004d84:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004d88:	f007 fd42 	bl	800c810 <chCondSignalI>
  chCondSignalI(&c1);
 8004d8c:	f640 0068 	movw	r0, #2152	; 0x868
 8004d90:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004d94:	f007 fd3c 	bl	800c810 <chCondSignalI>
  chSchRescheduleS();
 8004d98:	f00b f9e2 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 8004d9c:	f002 f8a0 	bl	8006ee0 <chSysUnlock.12152>
  test_wait_threads();
 8004da0:	f003 fc6e 	bl	8008680 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8004da4:	2001      	movs	r0, #1
 8004da6:	f640 5184 	movw	r1, #3460	; 0xd84
 8004daa:	f6c0 0101 	movt	r1, #2049	; 0x801
 8004dae:	f003 fbef 	bl	8008590 <_test_assert_sequence>
}
 8004db2:	b005      	add	sp, #20
 8004db4:	f85d fb04 	ldr.w	pc, [sp], #4
 8004db8:	f3af 8000 	nop.w
 8004dbc:	f3af 8000 	nop.w

08004dc0 <mtx7_setup.12160>:
 * tester thread then proceeds to broadcast the conditional variable.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {
 8004dc0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8004dc2:	f640 0068 	movw	r0, #2152	; 0x868
 8004dc6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004dca:	f007 fce1 	bl	800c790 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8004dce:	f640 0048 	movw	r0, #2120	; 0x848
 8004dd2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004dd6:	f009 ff3b 	bl	800ec50 <chMtxObjectInit>
}
 8004dda:	bd08      	pop	{r3, pc}
 8004ddc:	f3af 8000 	nop.w

08004de0 <mtx7_execute.12169>:

static void mtx7_execute(void) {
 8004de0:	b500      	push	{lr}
 8004de2:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 8004de4:	f002 f8ac 	bl	8006f40 <chThdGetPriorityX.12128>
 8004de8:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8004dea:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004dee:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004df2:	6819      	ldr	r1, [r3, #0]
 8004df4:	9b03      	ldr	r3, [sp, #12]
 8004df6:	1c5a      	adds	r2, r3, #1
 8004df8:	f640 5380 	movw	r3, #3456	; 0xd80
 8004dfc:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004e00:	9300      	str	r3, [sp, #0]
 8004e02:	4608      	mov	r0, r1
 8004e04:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004e08:	f644 4301 	movw	r3, #19457	; 0x4c01
 8004e0c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004e10:	f00b fca6 	bl	8010760 <chThdCreateStatic>
 8004e14:	4602      	mov	r2, r0
 8004e16:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004e1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e1e:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8004e20:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004e24:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004e28:	6859      	ldr	r1, [r3, #4]
 8004e2a:	9b03      	ldr	r3, [sp, #12]
 8004e2c:	1c9a      	adds	r2, r3, #2
 8004e2e:	f640 5378 	movw	r3, #3448	; 0xd78
 8004e32:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004e36:	9300      	str	r3, [sp, #0]
 8004e38:	4608      	mov	r0, r1
 8004e3a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004e3e:	f644 4301 	movw	r3, #19457	; 0x4c01
 8004e42:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004e46:	f00b fc8b 	bl	8010760 <chThdCreateStatic>
 8004e4a:	4602      	mov	r2, r0
 8004e4c:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004e50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e54:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8004e56:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004e5a:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004e5e:	6899      	ldr	r1, [r3, #8]
 8004e60:	9b03      	ldr	r3, [sp, #12]
 8004e62:	1cda      	adds	r2, r3, #3
 8004e64:	f640 537c 	movw	r3, #3452	; 0xd7c
 8004e68:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004e6c:	9300      	str	r3, [sp, #0]
 8004e6e:	4608      	mov	r0, r1
 8004e70:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004e74:	f644 4301 	movw	r3, #19457	; 0x4c01
 8004e78:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004e7c:	f00b fc70 	bl	8010760 <chThdCreateStatic>
 8004e80:	4602      	mov	r2, r0
 8004e82:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004e86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004e8a:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8004e8c:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004e90:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004e94:	68d9      	ldr	r1, [r3, #12]
 8004e96:	9b03      	ldr	r3, [sp, #12]
 8004e98:	1d1a      	adds	r2, r3, #4
 8004e9a:	f640 5370 	movw	r3, #3440	; 0xd70
 8004e9e:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004ea2:	9300      	str	r3, [sp, #0]
 8004ea4:	4608      	mov	r0, r1
 8004ea6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004eaa:	f644 4301 	movw	r3, #19457	; 0x4c01
 8004eae:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004eb2:	f00b fc55 	bl	8010760 <chThdCreateStatic>
 8004eb6:	4602      	mov	r2, r0
 8004eb8:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004ebc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ec0:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8004ec2:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004ec6:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004eca:	6919      	ldr	r1, [r3, #16]
 8004ecc:	9b03      	ldr	r3, [sp, #12]
 8004ece:	1d5a      	adds	r2, r3, #5
 8004ed0:	f640 5374 	movw	r3, #3444	; 0xd74
 8004ed4:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004ed8:	9300      	str	r3, [sp, #0]
 8004eda:	4608      	mov	r0, r1
 8004edc:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004ee0:	f644 4301 	movw	r3, #19457	; 0x4c01
 8004ee4:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004ee8:	f00b fc3a 	bl	8010760 <chThdCreateStatic>
 8004eec:	4602      	mov	r2, r0
 8004eee:	f641 6360 	movw	r3, #7776	; 0x1e60
 8004ef2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004ef6:	611a      	str	r2, [r3, #16]
  chCondBroadcast(&c1);
 8004ef8:	f640 0068 	movw	r0, #2152	; 0x868
 8004efc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f00:	f007 fcae 	bl	800c860 <chCondBroadcast>
  test_wait_threads();
 8004f04:	f003 fbbc 	bl	8008680 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8004f08:	2001      	movs	r0, #1
 8004f0a:	f640 5184 	movw	r1, #3460	; 0xd84
 8004f0e:	f6c0 0101 	movt	r1, #2049	; 0x801
 8004f12:	f003 fb3d 	bl	8008590 <_test_assert_sequence>
}
 8004f16:	b005      	add	sp, #20
 8004f18:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f1c:	f3af 8000 	nop.w

08004f20 <mtx8_setup.12162>:
 * This test case verifies the priority boost of a thread waiting on a
 * conditional variable queue. It tests this very specific situation in order
 * to complete the code coverage.
 */

static void mtx8_setup(void) {
 8004f20:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8004f22:	f640 0068 	movw	r0, #2152	; 0x868
 8004f26:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f2a:	f007 fc31 	bl	800c790 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8004f2e:	f640 0048 	movw	r0, #2120	; 0x848
 8004f32:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f36:	f009 fe8b 	bl	800ec50 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 8004f3a:	f640 0058 	movw	r0, #2136	; 0x858
 8004f3e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f42:	f009 fe85 	bl	800ec50 <chMtxObjectInit>
}
 8004f46:	bd08      	pop	{r3, pc}
 8004f48:	f3af 8000 	nop.w
 8004f4c:	f3af 8000 	nop.w

08004f50 <thread11.12171.4149>:

static THD_FUNCTION(thread11, p) {
 8004f50:	b500      	push	{lr}
 8004f52:	b083      	sub	sp, #12
 8004f54:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 8004f56:	f640 0058 	movw	r0, #2136	; 0x858
 8004f5a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f5e:	f009 fe8f 	bl	800ec80 <chMtxLock>
  chMtxLock(&m1);
 8004f62:	f640 0048 	movw	r0, #2120	; 0x848
 8004f66:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f6a:	f009 fe89 	bl	800ec80 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 8004f6e:	f640 0068 	movw	r0, #2152	; 0x868
 8004f72:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f76:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8004f7a:	f007 fcf9 	bl	800c970 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 8004f7e:	9b01      	ldr	r3, [sp, #4]
 8004f80:	781b      	ldrb	r3, [r3, #0]
 8004f82:	4618      	mov	r0, r3
 8004f84:	f003 fab4 	bl	80084f0 <test_emit_token>
  chMtxUnlock(&m1);
 8004f88:	f640 0048 	movw	r0, #2120	; 0x848
 8004f8c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f90:	f007 fa16 	bl	800c3c0 <chMtxUnlock>
  chMtxUnlock(&m2);
 8004f94:	f640 0058 	movw	r0, #2136	; 0x858
 8004f98:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004f9c:	f007 fa10 	bl	800c3c0 <chMtxUnlock>
}
 8004fa0:	b003      	add	sp, #12
 8004fa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fa6:	bf00      	nop
 8004fa8:	f3af 8000 	nop.w
 8004fac:	f3af 8000 	nop.w

08004fb0 <thread12.12139.4155>:

static THD_FUNCTION(thread12, p) {
 8004fb0:	b500      	push	{lr}
 8004fb2:	b083      	sub	sp, #12
 8004fb4:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 8004fb6:	f640 0058 	movw	r0, #2136	; 0x858
 8004fba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004fbe:	f009 fe5f 	bl	800ec80 <chMtxLock>
  test_emit_token(*(char *)p);
 8004fc2:	9b01      	ldr	r3, [sp, #4]
 8004fc4:	781b      	ldrb	r3, [r3, #0]
 8004fc6:	4618      	mov	r0, r3
 8004fc8:	f003 fa92 	bl	80084f0 <test_emit_token>
  chMtxUnlock(&m2);
 8004fcc:	f640 0058 	movw	r0, #2136	; 0x858
 8004fd0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8004fd4:	f007 f9f4 	bl	800c3c0 <chMtxUnlock>
}
 8004fd8:	b003      	add	sp, #12
 8004fda:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fde:	bf00      	nop

08004fe0 <mtx8_execute.12174>:

static void mtx8_execute(void) {
 8004fe0:	b500      	push	{lr}
 8004fe2:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 8004fe4:	f001 ffac 	bl	8006f40 <chThdGetPriorityX.12128>
 8004fe8:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8004fea:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8004fee:	f6c0 0301 	movt	r3, #2049	; 0x801
 8004ff2:	6819      	ldr	r1, [r3, #0]
 8004ff4:	9b03      	ldr	r3, [sp, #12]
 8004ff6:	1c5a      	adds	r2, r3, #1
 8004ff8:	f640 5374 	movw	r3, #3444	; 0xd74
 8004ffc:	f6c0 0301 	movt	r3, #2049	; 0x801
 8005000:	9300      	str	r3, [sp, #0]
 8005002:	4608      	mov	r0, r1
 8005004:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005008:	f644 7351 	movw	r3, #20305	; 0x4f51
 800500c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005010:	f00b fba6 	bl	8010760 <chThdCreateStatic>
 8005014:	4602      	mov	r2, r0
 8005016:	f641 6360 	movw	r3, #7776	; 0x1e60
 800501a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800501e:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8005020:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8005024:	f6c0 0301 	movt	r3, #2049	; 0x801
 8005028:	6859      	ldr	r1, [r3, #4]
 800502a:	9b03      	ldr	r3, [sp, #12]
 800502c:	1c9a      	adds	r2, r3, #2
 800502e:	f640 537c 	movw	r3, #3452	; 0xd7c
 8005032:	f6c0 0301 	movt	r3, #2049	; 0x801
 8005036:	9300      	str	r3, [sp, #0]
 8005038:	4608      	mov	r0, r1
 800503a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800503e:	f644 4301 	movw	r3, #19457	; 0x4c01
 8005042:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005046:	f00b fb8b 	bl	8010760 <chThdCreateStatic>
 800504a:	4602      	mov	r2, r0
 800504c:	f641 6360 	movw	r3, #7776	; 0x1e60
 8005050:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005054:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 8005056:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 800505a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800505e:	6899      	ldr	r1, [r3, #8]
 8005060:	9b03      	ldr	r3, [sp, #12]
 8005062:	1cda      	adds	r2, r3, #3
 8005064:	f640 5370 	movw	r3, #3440	; 0xd70
 8005068:	f6c0 0301 	movt	r3, #2049	; 0x801
 800506c:	9300      	str	r3, [sp, #0]
 800506e:	4608      	mov	r0, r1
 8005070:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005074:	f644 73b1 	movw	r3, #20401	; 0x4fb1
 8005078:	f6c0 0300 	movt	r3, #2048	; 0x800
 800507c:	f00b fb70 	bl	8010760 <chThdCreateStatic>
 8005080:	4602      	mov	r2, r0
 8005082:	f641 6360 	movw	r3, #7776	; 0x1e60
 8005086:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800508a:	609a      	str	r2, [r3, #8]
  chCondSignal(&c1);
 800508c:	f640 0068 	movw	r0, #2152	; 0x868
 8005090:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005094:	f007 fb94 	bl	800c7c0 <chCondSignal>
  chCondSignal(&c1);
 8005098:	f640 0068 	movw	r0, #2152	; 0x868
 800509c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80050a0:	f007 fb8e 	bl	800c7c0 <chCondSignal>
  test_wait_threads();
 80050a4:	f003 faec 	bl	8008680 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 80050a8:	2001      	movs	r0, #1
 80050aa:	f640 518c 	movw	r1, #3468	; 0xd8c
 80050ae:	f6c0 0101 	movt	r1, #2049	; 0x801
 80050b2:	f003 fa6d 	bl	8008590 <_test_assert_sequence>
}
 80050b6:	b005      	add	sp, #20
 80050b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80050bc:	f3af 8000 	nop.w

080050c0 <chThdGetSelfX.12294.4144>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80050c0:	f640 5350 	movw	r3, #3408	; 0xd50
 80050c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80050c8:	699b      	ldr	r3, [r3, #24]
}
 80050ca:	4618      	mov	r0, r3
 80050cc:	4770      	bx	lr
 80050ce:	bf00      	nop

080050d0 <chThdGetPriorityX.12383.4142>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 80050d0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 80050d2:	f7ff fff5 	bl	80050c0 <chThdGetSelfX.12294.4144>
 80050d6:	4603      	mov	r3, r0
 80050d8:	689b      	ldr	r3, [r3, #8]
}
 80050da:	4618      	mov	r0, r3
 80050dc:	bd08      	pop	{r3, pc}
 80050de:	bf00      	nop

080050e0 <chMsgGet.12385.4139>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 80050e0:	b082      	sub	sp, #8
 80050e2:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 80050e4:	9b01      	ldr	r3, [sp, #4]
 80050e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 80050e8:	4618      	mov	r0, r3
 80050ea:	b002      	add	sp, #8
 80050ec:	4770      	bx	lr
 80050ee:	bf00      	nop

080050f0 <thread.12388.4136>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 80050f0:	b500      	push	{lr}
 80050f2:	b083      	sub	sp, #12
 80050f4:	9001      	str	r0, [sp, #4]

  chMsgSend(p, 'A');
 80050f6:	9801      	ldr	r0, [sp, #4]
 80050f8:	2141      	movs	r1, #65	; 0x41
 80050fa:	f008 f859 	bl	800d1b0 <chMsgSend>
  chMsgSend(p, 'B');
 80050fe:	9801      	ldr	r0, [sp, #4]
 8005100:	2142      	movs	r1, #66	; 0x42
 8005102:	f008 f855 	bl	800d1b0 <chMsgSend>
  chMsgSend(p, 'C');
 8005106:	9801      	ldr	r0, [sp, #4]
 8005108:	2143      	movs	r1, #67	; 0x43
 800510a:	f008 f851 	bl	800d1b0 <chMsgSend>
}
 800510e:	b003      	add	sp, #12
 8005110:	f85d fb04 	ldr.w	pc, [sp], #4
 8005114:	f3af 8000 	nop.w
 8005118:	f3af 8000 	nop.w
 800511c:	f3af 8000 	nop.w

08005120 <msg1_execute.12391>:

static void msg1_execute(void) {
 8005120:	b530      	push	{r4, r5, lr}
 8005122:	b085      	sub	sp, #20
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8005124:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8005128:	f6c0 0301 	movt	r3, #2049	; 0x801
 800512c:	681d      	ldr	r5, [r3, #0]
 800512e:	f7ff ffcf 	bl	80050d0 <chThdGetPriorityX.12383.4142>
 8005132:	4603      	mov	r3, r0
 8005134:	1c5c      	adds	r4, r3, #1
                                 thread, chThdGetSelfX());
 8005136:	f7ff ffc3 	bl	80050c0 <chThdGetSelfX.12294.4144>
 800513a:	4603      	mov	r3, r0
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800513c:	9300      	str	r3, [sp, #0]
 800513e:	4628      	mov	r0, r5
 8005140:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005144:	4622      	mov	r2, r4
 8005146:	f245 03f1 	movw	r3, #20721	; 0x50f1
 800514a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800514e:	f00b fb07 	bl	8010760 <chThdCreateStatic>
 8005152:	4602      	mov	r2, r0
 8005154:	f641 6360 	movw	r3, #7776	; 0x1e60
 8005158:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800515c:	601a      	str	r2, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 800515e:	f008 f85f 	bl	800d220 <chMsgWait>
 8005162:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 8005164:	9803      	ldr	r0, [sp, #12]
 8005166:	f7ff ffbb 	bl	80050e0 <chMsgGet.12385.4139>
 800516a:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800516c:	9803      	ldr	r0, [sp, #12]
 800516e:	9902      	ldr	r1, [sp, #8]
 8005170:	f008 f886 	bl	800d280 <chMsgRelease>
  test_emit_token(msg);
 8005174:	9b02      	ldr	r3, [sp, #8]
 8005176:	b2db      	uxtb	r3, r3
 8005178:	4618      	mov	r0, r3
 800517a:	f003 f9b9 	bl	80084f0 <test_emit_token>
  tp = chMsgWait();
 800517e:	f008 f84f 	bl	800d220 <chMsgWait>
 8005182:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 8005184:	9803      	ldr	r0, [sp, #12]
 8005186:	f7ff ffab 	bl	80050e0 <chMsgGet.12385.4139>
 800518a:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800518c:	9803      	ldr	r0, [sp, #12]
 800518e:	9902      	ldr	r1, [sp, #8]
 8005190:	f008 f876 	bl	800d280 <chMsgRelease>
  test_emit_token(msg);
 8005194:	9b02      	ldr	r3, [sp, #8]
 8005196:	b2db      	uxtb	r3, r3
 8005198:	4618      	mov	r0, r3
 800519a:	f003 f9a9 	bl	80084f0 <test_emit_token>
  tp = chMsgWait();
 800519e:	f008 f83f 	bl	800d220 <chMsgWait>
 80051a2:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 80051a4:	9803      	ldr	r0, [sp, #12]
 80051a6:	f7ff ff9b 	bl	80050e0 <chMsgGet.12385.4139>
 80051aa:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 80051ac:	9803      	ldr	r0, [sp, #12]
 80051ae:	9902      	ldr	r1, [sp, #8]
 80051b0:	f008 f866 	bl	800d280 <chMsgRelease>
  test_emit_token(msg);
 80051b4:	9b02      	ldr	r3, [sp, #8]
 80051b6:	b2db      	uxtb	r3, r3
 80051b8:	4618      	mov	r0, r3
 80051ba:	f003 f999 	bl	80084f0 <test_emit_token>
  test_assert_sequence(1, "ABC");
 80051be:	2001      	movs	r0, #1
 80051c0:	f640 518c 	movw	r1, #3468	; 0xd8c
 80051c4:	f6c0 0101 	movt	r1, #2049	; 0x801
 80051c8:	f003 f9e2 	bl	8008590 <_test_assert_sequence>
}
 80051cc:	b005      	add	sp, #20
 80051ce:	bd30      	pop	{r4, r5, pc}

080051d0 <port_lock.12474.4131>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80051d0:	b082      	sub	sp, #8
 80051d2:	2320      	movs	r3, #32
 80051d4:	9301      	str	r3, [sp, #4]
 80051d6:	9b01      	ldr	r3, [sp, #4]
 80051d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80051dc:	b002      	add	sp, #8
 80051de:	4770      	bx	lr

080051e0 <port_unlock.12477.4129>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80051e0:	b082      	sub	sp, #8
 80051e2:	2300      	movs	r3, #0
 80051e4:	9301      	str	r3, [sp, #4]
 80051e6:	9b01      	ldr	r3, [sp, #4]
 80051e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80051ec:	b002      	add	sp, #8
 80051ee:	4770      	bx	lr

080051f0 <chSysLock.12585.4127>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80051f0:	b508      	push	{r3, lr}

  port_lock();
 80051f2:	f7ff ffed 	bl	80051d0 <port_lock.12474.4131>
  _stats_start_measure_crit_thd();
 80051f6:	f008 fec3 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80051fa:	f00a fa71 	bl	800f6e0 <_dbg_check_lock>
}
 80051fe:	bd08      	pop	{r3, pc}

08005200 <chSysUnlock.12587.4125>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005200:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8005202:	f00a fa8d 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8005206:	f008 fec3 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800520a:	f640 5350 	movw	r3, #3408	; 0xd50
 800520e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005212:	681a      	ldr	r2, [r3, #0]
 8005214:	f640 5350 	movw	r3, #3408	; 0xd50
 8005218:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800521c:	429a      	cmp	r2, r3
 800521e:	d013      	beq.n	8005248 <chSysUnlock.12587.4125+0x48>
 8005220:	f640 5350 	movw	r3, #3408	; 0xd50
 8005224:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005228:	699b      	ldr	r3, [r3, #24]
 800522a:	689a      	ldr	r2, [r3, #8]
 800522c:	f640 5350 	movw	r3, #3408	; 0xd50
 8005230:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005234:	681b      	ldr	r3, [r3, #0]
 8005236:	689b      	ldr	r3, [r3, #8]
 8005238:	429a      	cmp	r2, r3
 800523a:	d205      	bcs.n	8005248 <chSysUnlock.12587.4125+0x48>
 800523c:	f242 1090 	movw	r0, #8592	; 0x2190
 8005240:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005244:	f00a f8a4 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005248:	f7ff ffca 	bl	80051e0 <port_unlock.12477.4129>
}
 800524c:	bd08      	pop	{r3, pc}
 800524e:	bf00      	nop

08005250 <chSemGetCounterI.12481.4122>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 8005250:	b500      	push	{lr}
 8005252:	b083      	sub	sp, #12
 8005254:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005256:	f00a fb13 	bl	800f880 <chDbgCheckClassI>

  return sp->s_cnt;
 800525a:	9b01      	ldr	r3, [sp, #4]
 800525c:	689b      	ldr	r3, [r3, #8]
}
 800525e:	4618      	mov	r0, r3
 8005260:	b003      	add	sp, #12
 8005262:	f85d fb04 	ldr.w	pc, [sp], #4
 8005266:	bf00      	nop
 8005268:	f3af 8000 	nop.w
 800526c:	f3af 8000 	nop.w

08005270 <chMBGetFreeCountI.12571.4119>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {
 8005270:	b500      	push	{lr}
 8005272:	b083      	sub	sp, #12
 8005274:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005276:	f00a fb03 	bl	800f880 <chDbgCheckClassI>

  return chSemGetCounterI(&mbp->mb_emptysem);
 800527a:	9b01      	ldr	r3, [sp, #4]
 800527c:	331c      	adds	r3, #28
 800527e:	4618      	mov	r0, r3
 8005280:	f7ff ffe6 	bl	8005250 <chSemGetCounterI.12481.4122>
 8005284:	4603      	mov	r3, r0
}
 8005286:	4618      	mov	r0, r3
 8005288:	b003      	add	sp, #12
 800528a:	f85d fb04 	ldr.w	pc, [sp], #4
 800528e:	bf00      	nop

08005290 <chMBGetUsedCountI.12582.4015>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of queued messages.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {
 8005290:	b500      	push	{lr}
 8005292:	b083      	sub	sp, #12
 8005294:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005296:	f00a faf3 	bl	800f880 <chDbgCheckClassI>

  return chSemGetCounterI(&mbp->mb_fullsem);
 800529a:	9b01      	ldr	r3, [sp, #4]
 800529c:	3310      	adds	r3, #16
 800529e:	4618      	mov	r0, r3
 80052a0:	f7ff ffd6 	bl	8005250 <chSemGetCounterI.12481.4122>
 80052a4:	4603      	mov	r3, r0
}
 80052a6:	4618      	mov	r0, r3
 80052a8:	b003      	add	sp, #12
 80052aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80052ae:	bf00      	nop

080052b0 <mbox1_setup.12479>:
 * Messages are posted/fetched from a mailbox in carefully designed sequences
 * in order to stimulate all the possible code paths inside the mailbox.<br>
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {
 80052b0:	b508      	push	{r3, lr}

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
 80052b2:	f640 0070 	movw	r0, #2160	; 0x870
 80052b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80052ba:	f241 7158 	movw	r1, #5976	; 0x1758
 80052be:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80052c2:	2205      	movs	r2, #5
 80052c4:	f008 f85c 	bl	800d380 <chMBObjectInit>
}
 80052c8:	bd08      	pop	{r3, pc}
 80052ca:	bf00      	nop
 80052cc:	f3af 8000 	nop.w

080052d0 <mbox1_execute.12589>:

static void mbox1_execute(void) {
 80052d0:	b500      	push	{lr}
 80052d2:	b085      	sub	sp, #20
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 80052d4:	f7ff ff8c 	bl	80051f0 <chSysLock.12585.4127>
 80052d8:	f640 0070 	movw	r0, #2160	; 0x870
 80052dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80052e0:	f7ff ffc6 	bl	8005270 <chMBGetFreeCountI.12571.4119>
 80052e4:	4603      	mov	r3, r0
 80052e6:	2b05      	cmp	r3, #5
 80052e8:	bf14      	ite	ne
 80052ea:	2300      	movne	r3, #0
 80052ec:	2301      	moveq	r3, #1
 80052ee:	b2db      	uxtb	r3, r3
 80052f0:	2001      	movs	r0, #1
 80052f2:	4619      	mov	r1, r3
 80052f4:	f003 f934 	bl	8008560 <_test_assert>
 80052f8:	4603      	mov	r3, r0
 80052fa:	2b00      	cmp	r3, #0
 80052fc:	d003      	beq.n	8005306 <mbox1_execute.12589+0x36>
 80052fe:	f7ff ff7f 	bl	8005200 <chSysUnlock.12587.4125>
 8005302:	f000 bc90 	b.w	8005c26 <mbox1_execute.12589+0x956>
 8005306:	f7ff ff7b 	bl	8005200 <chSysUnlock.12587.4125>

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800530a:	2300      	movs	r3, #0
 800530c:	9303      	str	r3, [sp, #12]
 800530e:	e01c      	b.n	800534a <mbox1_execute.12589+0x7a>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8005310:	9b03      	ldr	r3, [sp, #12]
 8005312:	3342      	adds	r3, #66	; 0x42
 8005314:	f640 0070 	movw	r0, #2160	; 0x870
 8005318:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800531c:	4619      	mov	r1, r3
 800531e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005322:	f008 f8a5 	bl	800d470 <chMBPost>
 8005326:	9002      	str	r0, [sp, #8]
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 8005328:	9b02      	ldr	r3, [sp, #8]
 800532a:	2b00      	cmp	r3, #0
 800532c:	bf14      	ite	ne
 800532e:	2300      	movne	r3, #0
 8005330:	2301      	moveq	r3, #1
 8005332:	b2db      	uxtb	r3, r3
 8005334:	2002      	movs	r0, #2
 8005336:	4619      	mov	r1, r3
 8005338:	f003 f912 	bl	8008560 <_test_assert>
 800533c:	4603      	mov	r3, r0
 800533e:	2b00      	cmp	r3, #0
 8005340:	f040 8471 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 8005344:	9b03      	ldr	r3, [sp, #12]
 8005346:	3301      	adds	r3, #1
 8005348:	9303      	str	r3, [sp, #12]
 800534a:	9b03      	ldr	r3, [sp, #12]
 800534c:	2b03      	cmp	r3, #3
 800534e:	d9df      	bls.n	8005310 <mbox1_execute.12589+0x40>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 8005350:	f640 0070 	movw	r0, #2160	; 0x870
 8005354:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005358:	2141      	movs	r1, #65	; 0x41
 800535a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800535e:	f008 f917 	bl	800d590 <chMBPostAhead>
 8005362:	9002      	str	r0, [sp, #8]
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 8005364:	9b02      	ldr	r3, [sp, #8]
 8005366:	2b00      	cmp	r3, #0
 8005368:	bf14      	ite	ne
 800536a:	2300      	movne	r3, #0
 800536c:	2301      	moveq	r3, #1
 800536e:	b2db      	uxtb	r3, r3
 8005370:	2003      	movs	r0, #3
 8005372:	4619      	mov	r1, r3
 8005374:	f003 f8f4 	bl	8008560 <_test_assert>
 8005378:	4603      	mov	r3, r0
 800537a:	2b00      	cmp	r3, #0
 800537c:	f040 8453 	bne.w	8005c26 <mbox1_execute.12589+0x956>

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 8005380:	f640 0070 	movw	r0, #2160	; 0x870
 8005384:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005388:	2158      	movs	r1, #88	; 0x58
 800538a:	2201      	movs	r2, #1
 800538c:	f008 f870 	bl	800d470 <chMBPost>
 8005390:	9002      	str	r0, [sp, #8]
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005392:	9b02      	ldr	r3, [sp, #8]
 8005394:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8005398:	bf14      	ite	ne
 800539a:	2300      	movne	r3, #0
 800539c:	2301      	moveq	r3, #1
 800539e:	b2db      	uxtb	r3, r3
 80053a0:	2004      	movs	r0, #4
 80053a2:	4619      	mov	r1, r3
 80053a4:	f003 f8dc 	bl	8008560 <_test_assert>
 80053a8:	4603      	mov	r3, r0
 80053aa:	2b00      	cmp	r3, #0
 80053ac:	f040 843b 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  chSysLock();
 80053b0:	f7ff ff1e 	bl	80051f0 <chSysLock.12585.4127>
  msg1 = chMBPostI(&mb1, 'X');
 80053b4:	f640 0070 	movw	r0, #2160	; 0x870
 80053b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80053bc:	2158      	movs	r1, #88	; 0x58
 80053be:	f008 f8a7 	bl	800d510 <chMBPostI>
 80053c2:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 80053c4:	f7ff ff1c 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80053c8:	9b02      	ldr	r3, [sp, #8]
 80053ca:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80053ce:	bf14      	ite	ne
 80053d0:	2300      	movne	r3, #0
 80053d2:	2301      	moveq	r3, #1
 80053d4:	b2db      	uxtb	r3, r3
 80053d6:	2005      	movs	r0, #5
 80053d8:	4619      	mov	r1, r3
 80053da:	f003 f8c1 	bl	8008560 <_test_assert>
 80053de:	4603      	mov	r3, r0
 80053e0:	2b00      	cmp	r3, #0
 80053e2:	f040 8420 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 80053e6:	f640 0070 	movw	r0, #2160	; 0x870
 80053ea:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80053ee:	2158      	movs	r1, #88	; 0x58
 80053f0:	2201      	movs	r2, #1
 80053f2:	f008 f8cd 	bl	800d590 <chMBPostAhead>
 80053f6:	9002      	str	r0, [sp, #8]
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80053f8:	9b02      	ldr	r3, [sp, #8]
 80053fa:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80053fe:	bf14      	ite	ne
 8005400:	2300      	movne	r3, #0
 8005402:	2301      	moveq	r3, #1
 8005404:	b2db      	uxtb	r3, r3
 8005406:	2006      	movs	r0, #6
 8005408:	4619      	mov	r1, r3
 800540a:	f003 f8a9 	bl	8008560 <_test_assert>
 800540e:	4603      	mov	r3, r0
 8005410:	2b00      	cmp	r3, #0
 8005412:	f040 8408 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  chSysLock();
 8005416:	f7ff feeb 	bl	80051f0 <chSysLock.12585.4127>
  msg1 = chMBPostAheadI(&mb1, 'X');
 800541a:	f640 0070 	movw	r0, #2160	; 0x870
 800541e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005422:	2158      	movs	r1, #88	; 0x58
 8005424:	f008 f90c 	bl	800d640 <chMBPostAheadI>
 8005428:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800542a:	f7ff fee9 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800542e:	9b02      	ldr	r3, [sp, #8]
 8005430:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8005434:	bf14      	ite	ne
 8005436:	2300      	movne	r3, #0
 8005438:	2301      	moveq	r3, #1
 800543a:	b2db      	uxtb	r3, r3
 800543c:	2007      	movs	r0, #7
 800543e:	4619      	mov	r1, r3
 8005440:	f003 f88e 	bl	8008560 <_test_assert>
 8005444:	4603      	mov	r3, r0
 8005446:	2b00      	cmp	r3, #0
 8005448:	f040 83ed 	bne.w	8005c26 <mbox1_execute.12589+0x956>

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 800544c:	f7ff fed0 	bl	80051f0 <chSysLock.12585.4127>
 8005450:	f640 0070 	movw	r0, #2160	; 0x870
 8005454:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005458:	f7ff ff0a 	bl	8005270 <chMBGetFreeCountI.12571.4119>
 800545c:	4603      	mov	r3, r0
 800545e:	2b00      	cmp	r3, #0
 8005460:	bf14      	ite	ne
 8005462:	2300      	movne	r3, #0
 8005464:	2301      	moveq	r3, #1
 8005466:	b2db      	uxtb	r3, r3
 8005468:	2008      	movs	r0, #8
 800546a:	4619      	mov	r1, r3
 800546c:	f003 f878 	bl	8008560 <_test_assert>
 8005470:	4603      	mov	r3, r0
 8005472:	2b00      	cmp	r3, #0
 8005474:	d002      	beq.n	800547c <mbox1_execute.12589+0x1ac>
 8005476:	f7ff fec3 	bl	8005200 <chSysUnlock.12587.4125>
 800547a:	e3d4      	b.n	8005c26 <mbox1_execute.12589+0x956>
 800547c:	f7ff fec0 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8005480:	f7ff feb6 	bl	80051f0 <chSysLock.12585.4127>
 8005484:	f640 0070 	movw	r0, #2160	; 0x870
 8005488:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800548c:	f7ff ff00 	bl	8005290 <chMBGetUsedCountI.12582.4015>
 8005490:	4603      	mov	r3, r0
 8005492:	2b05      	cmp	r3, #5
 8005494:	bf14      	ite	ne
 8005496:	2300      	movne	r3, #0
 8005498:	2301      	moveq	r3, #1
 800549a:	b2db      	uxtb	r3, r3
 800549c:	2009      	movs	r0, #9
 800549e:	4619      	mov	r1, r3
 80054a0:	f003 f85e 	bl	8008560 <_test_assert>
 80054a4:	4603      	mov	r3, r0
 80054a6:	2b00      	cmp	r3, #0
 80054a8:	d002      	beq.n	80054b0 <mbox1_execute.12589+0x1e0>
 80054aa:	f7ff fea9 	bl	8005200 <chSysUnlock.12587.4125>
 80054ae:	e3ba      	b.n	8005c26 <mbox1_execute.12589+0x956>
 80054b0:	f7ff fea6 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80054b4:	f7ff fe9c 	bl	80051f0 <chSysLock.12585.4127>
 80054b8:	f640 0370 	movw	r3, #2160	; 0x870
 80054bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80054c0:	68da      	ldr	r2, [r3, #12]
 80054c2:	f640 0370 	movw	r3, #2160	; 0x870
 80054c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80054ca:	689b      	ldr	r3, [r3, #8]
 80054cc:	429a      	cmp	r2, r3
 80054ce:	bf14      	ite	ne
 80054d0:	2300      	movne	r3, #0
 80054d2:	2301      	moveq	r3, #1
 80054d4:	b2db      	uxtb	r3, r3
 80054d6:	200a      	movs	r0, #10
 80054d8:	4619      	mov	r1, r3
 80054da:	f003 f841 	bl	8008560 <_test_assert>
 80054de:	4603      	mov	r3, r0
 80054e0:	2b00      	cmp	r3, #0
 80054e2:	d002      	beq.n	80054ea <mbox1_execute.12589+0x21a>
 80054e4:	f7ff fe8c 	bl	8005200 <chSysUnlock.12587.4125>
 80054e8:	e39d      	b.n	8005c26 <mbox1_execute.12589+0x956>
 80054ea:	f7ff fe89 	bl	8005200 <chSysUnlock.12587.4125>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 80054ee:	2300      	movs	r3, #0
 80054f0:	9303      	str	r3, [sp, #12]
 80054f2:	e020      	b.n	8005536 <mbox1_execute.12589+0x266>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80054f4:	ab01      	add	r3, sp, #4
 80054f6:	f640 0070 	movw	r0, #2160	; 0x870
 80054fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80054fe:	4619      	mov	r1, r3
 8005500:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005504:	f008 f8dc 	bl	800d6c0 <chMBFetch>
 8005508:	9002      	str	r0, [sp, #8]
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 800550a:	9b02      	ldr	r3, [sp, #8]
 800550c:	2b00      	cmp	r3, #0
 800550e:	bf14      	ite	ne
 8005510:	2300      	movne	r3, #0
 8005512:	2301      	moveq	r3, #1
 8005514:	b2db      	uxtb	r3, r3
 8005516:	200b      	movs	r0, #11
 8005518:	4619      	mov	r1, r3
 800551a:	f003 f821 	bl	8008560 <_test_assert>
 800551e:	4603      	mov	r3, r0
 8005520:	2b00      	cmp	r3, #0
 8005522:	f040 8380 	bne.w	8005c26 <mbox1_execute.12589+0x956>
    test_emit_token(msg2);
 8005526:	9b01      	ldr	r3, [sp, #4]
 8005528:	b2db      	uxtb	r3, r3
 800552a:	4618      	mov	r0, r3
 800552c:	f002 ffe0 	bl	80084f0 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 8005530:	9b03      	ldr	r3, [sp, #12]
 8005532:	3301      	adds	r3, #1
 8005534:	9303      	str	r3, [sp, #12]
 8005536:	9b03      	ldr	r3, [sp, #12]
 8005538:	2b04      	cmp	r3, #4
 800553a:	d9db      	bls.n	80054f4 <mbox1_execute.12589+0x224>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 800553c:	200c      	movs	r0, #12
 800553e:	f640 5184 	movw	r1, #3460	; 0xd84
 8005542:	f6c0 0101 	movt	r1, #2049	; 0x801
 8005546:	f003 f823 	bl	8008590 <_test_assert_sequence>
 800554a:	4603      	mov	r3, r0
 800554c:	2b00      	cmp	r3, #0
 800554e:	f040 836a 	bne.w	8005c26 <mbox1_execute.12589+0x956>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8005552:	9b03      	ldr	r3, [sp, #12]
 8005554:	3342      	adds	r3, #66	; 0x42
 8005556:	f640 0070 	movw	r0, #2160	; 0x870
 800555a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800555e:	4619      	mov	r1, r3
 8005560:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005564:	f007 ff84 	bl	800d470 <chMBPost>
 8005568:	9002      	str	r0, [sp, #8]
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 800556a:	9b02      	ldr	r3, [sp, #8]
 800556c:	2b00      	cmp	r3, #0
 800556e:	bf14      	ite	ne
 8005570:	2300      	movne	r3, #0
 8005572:	2301      	moveq	r3, #1
 8005574:	b2db      	uxtb	r3, r3
 8005576:	200d      	movs	r0, #13
 8005578:	4619      	mov	r1, r3
 800557a:	f002 fff1 	bl	8008560 <_test_assert>
 800557e:	4603      	mov	r3, r0
 8005580:	2b00      	cmp	r3, #0
 8005582:	f040 8350 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8005586:	ab01      	add	r3, sp, #4
 8005588:	f640 0070 	movw	r0, #2160	; 0x870
 800558c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005590:	4619      	mov	r1, r3
 8005592:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005596:	f008 f893 	bl	800d6c0 <chMBFetch>
 800559a:	9002      	str	r0, [sp, #8]
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 800559c:	9b02      	ldr	r3, [sp, #8]
 800559e:	2b00      	cmp	r3, #0
 80055a0:	bf14      	ite	ne
 80055a2:	2300      	movne	r3, #0
 80055a4:	2301      	moveq	r3, #1
 80055a6:	b2db      	uxtb	r3, r3
 80055a8:	200e      	movs	r0, #14
 80055aa:	4619      	mov	r1, r3
 80055ac:	f002 ffd8 	bl	8008560 <_test_assert>
 80055b0:	4603      	mov	r3, r0
 80055b2:	2b00      	cmp	r3, #0
 80055b4:	f040 8337 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 80055b8:	f640 0370 	movw	r3, #2160	; 0x870
 80055bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055c0:	681a      	ldr	r2, [r3, #0]
 80055c2:	f640 0370 	movw	r3, #2160	; 0x870
 80055c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055ca:	689b      	ldr	r3, [r3, #8]
 80055cc:	429a      	cmp	r2, r3
 80055ce:	bf14      	ite	ne
 80055d0:	2300      	movne	r3, #0
 80055d2:	2301      	moveq	r3, #1
 80055d4:	b2db      	uxtb	r3, r3
 80055d6:	200f      	movs	r0, #15
 80055d8:	4619      	mov	r1, r3
 80055da:	f002 ffc1 	bl	8008560 <_test_assert>
 80055de:	4603      	mov	r3, r0
 80055e0:	2b00      	cmp	r3, #0
 80055e2:	f040 8320 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 80055e6:	f640 0370 	movw	r3, #2160	; 0x870
 80055ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055ee:	681a      	ldr	r2, [r3, #0]
 80055f0:	f640 0370 	movw	r3, #2160	; 0x870
 80055f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055f8:	68db      	ldr	r3, [r3, #12]
 80055fa:	429a      	cmp	r2, r3
 80055fc:	bf14      	ite	ne
 80055fe:	2300      	movne	r3, #0
 8005600:	2301      	moveq	r3, #1
 8005602:	b2db      	uxtb	r3, r3
 8005604:	2010      	movs	r0, #16
 8005606:	4619      	mov	r1, r3
 8005608:	f002 ffaa 	bl	8008560 <_test_assert>
 800560c:	4603      	mov	r3, r0
 800560e:	2b00      	cmp	r3, #0
 8005610:	f040 8309 	bne.w	8005c26 <mbox1_execute.12589+0x956>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 8005614:	ab01      	add	r3, sp, #4
 8005616:	f640 0070 	movw	r0, #2160	; 0x870
 800561a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800561e:	4619      	mov	r1, r3
 8005620:	2201      	movs	r2, #1
 8005622:	f008 f84d 	bl	800d6c0 <chMBFetch>
 8005626:	9002      	str	r0, [sp, #8]
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005628:	9b02      	ldr	r3, [sp, #8]
 800562a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800562e:	bf14      	ite	ne
 8005630:	2300      	movne	r3, #0
 8005632:	2301      	moveq	r3, #1
 8005634:	b2db      	uxtb	r3, r3
 8005636:	2011      	movs	r0, #17
 8005638:	4619      	mov	r1, r3
 800563a:	f002 ff91 	bl	8008560 <_test_assert>
 800563e:	4603      	mov	r3, r0
 8005640:	2b00      	cmp	r3, #0
 8005642:	f040 82f0 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  chSysLock();
 8005646:	f7ff fdd3 	bl	80051f0 <chSysLock.12585.4127>
  msg1 = chMBFetchI(&mb1, &msg2);
 800564a:	ab01      	add	r3, sp, #4
 800564c:	f640 0070 	movw	r0, #2160	; 0x870
 8005650:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005654:	4619      	mov	r1, r3
 8005656:	f008 f88b 	bl	800d770 <chMBFetchI>
 800565a:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800565c:	f7ff fdd0 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005660:	9b02      	ldr	r3, [sp, #8]
 8005662:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8005666:	bf14      	ite	ne
 8005668:	2300      	movne	r3, #0
 800566a:	2301      	moveq	r3, #1
 800566c:	b2db      	uxtb	r3, r3
 800566e:	2012      	movs	r0, #18
 8005670:	4619      	mov	r1, r3
 8005672:	f002 ff75 	bl	8008560 <_test_assert>
 8005676:	4603      	mov	r3, r0
 8005678:	2b00      	cmp	r3, #0
 800567a:	f040 82d4 	bne.w	8005c26 <mbox1_execute.12589+0x956>

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800567e:	f7ff fdb7 	bl	80051f0 <chSysLock.12585.4127>
 8005682:	f640 0070 	movw	r0, #2160	; 0x870
 8005686:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800568a:	f7ff fdf1 	bl	8005270 <chMBGetFreeCountI.12571.4119>
 800568e:	4603      	mov	r3, r0
 8005690:	2b05      	cmp	r3, #5
 8005692:	bf14      	ite	ne
 8005694:	2300      	movne	r3, #0
 8005696:	2301      	moveq	r3, #1
 8005698:	b2db      	uxtb	r3, r3
 800569a:	2013      	movs	r0, #19
 800569c:	4619      	mov	r1, r3
 800569e:	f002 ff5f 	bl	8008560 <_test_assert>
 80056a2:	4603      	mov	r3, r0
 80056a4:	2b00      	cmp	r3, #0
 80056a6:	d002      	beq.n	80056ae <mbox1_execute.12589+0x3de>
 80056a8:	f7ff fdaa 	bl	8005200 <chSysUnlock.12587.4125>
 80056ac:	e2bb      	b.n	8005c26 <mbox1_execute.12589+0x956>
 80056ae:	f7ff fda7 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 80056b2:	f7ff fd9d 	bl	80051f0 <chSysLock.12585.4127>
 80056b6:	f640 0070 	movw	r0, #2160	; 0x870
 80056ba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80056be:	f7ff fde7 	bl	8005290 <chMBGetUsedCountI.12582.4015>
 80056c2:	4603      	mov	r3, r0
 80056c4:	2b00      	cmp	r3, #0
 80056c6:	bf14      	ite	ne
 80056c8:	2300      	movne	r3, #0
 80056ca:	2301      	moveq	r3, #1
 80056cc:	b2db      	uxtb	r3, r3
 80056ce:	2014      	movs	r0, #20
 80056d0:	4619      	mov	r1, r3
 80056d2:	f002 ff45 	bl	8008560 <_test_assert>
 80056d6:	4603      	mov	r3, r0
 80056d8:	2b00      	cmp	r3, #0
 80056da:	d002      	beq.n	80056e2 <mbox1_execute.12589+0x412>
 80056dc:	f7ff fd90 	bl	8005200 <chSysUnlock.12587.4125>
 80056e0:	e2a1      	b.n	8005c26 <mbox1_execute.12589+0x956>
 80056e2:	f7ff fd8d 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80056e6:	f7ff fd83 	bl	80051f0 <chSysLock.12585.4127>
 80056ea:	f640 0370 	movw	r3, #2160	; 0x870
 80056ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056f2:	68da      	ldr	r2, [r3, #12]
 80056f4:	f640 0370 	movw	r3, #2160	; 0x870
 80056f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056fc:	689b      	ldr	r3, [r3, #8]
 80056fe:	429a      	cmp	r2, r3
 8005700:	bf14      	ite	ne
 8005702:	2300      	movne	r3, #0
 8005704:	2301      	moveq	r3, #1
 8005706:	b2db      	uxtb	r3, r3
 8005708:	2015      	movs	r0, #21
 800570a:	4619      	mov	r1, r3
 800570c:	f002 ff28 	bl	8008560 <_test_assert>
 8005710:	4603      	mov	r3, r0
 8005712:	2b00      	cmp	r3, #0
 8005714:	d002      	beq.n	800571c <mbox1_execute.12589+0x44c>
 8005716:	f7ff fd73 	bl	8005200 <chSysUnlock.12587.4125>
 800571a:	e284      	b.n	8005c26 <mbox1_execute.12589+0x956>
 800571c:	f7ff fd70 	bl	8005200 <chSysUnlock.12587.4125>

  /*
   * Testing I-Class.
   */
  chSysLock();
 8005720:	f7ff fd66 	bl	80051f0 <chSysLock.12585.4127>
  msg1 = chMBPostI(&mb1, 'A');
 8005724:	f640 0070 	movw	r0, #2160	; 0x870
 8005728:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800572c:	2141      	movs	r1, #65	; 0x41
 800572e:	f007 feef 	bl	800d510 <chMBPostI>
 8005732:	9002      	str	r0, [sp, #8]
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 8005734:	9b02      	ldr	r3, [sp, #8]
 8005736:	2b00      	cmp	r3, #0
 8005738:	bf14      	ite	ne
 800573a:	2300      	movne	r3, #0
 800573c:	2301      	moveq	r3, #1
 800573e:	b2db      	uxtb	r3, r3
 8005740:	2016      	movs	r0, #22
 8005742:	4619      	mov	r1, r3
 8005744:	f002 ff0c 	bl	8008560 <_test_assert>
 8005748:	4603      	mov	r3, r0
 800574a:	2b00      	cmp	r3, #0
 800574c:	f040 826b 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  msg1 = chMBPostI(&mb1, 'B');
 8005750:	f640 0070 	movw	r0, #2160	; 0x870
 8005754:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005758:	2142      	movs	r1, #66	; 0x42
 800575a:	f007 fed9 	bl	800d510 <chMBPostI>
 800575e:	9002      	str	r0, [sp, #8]
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 8005760:	9b02      	ldr	r3, [sp, #8]
 8005762:	2b00      	cmp	r3, #0
 8005764:	bf14      	ite	ne
 8005766:	2300      	movne	r3, #0
 8005768:	2301      	moveq	r3, #1
 800576a:	b2db      	uxtb	r3, r3
 800576c:	2017      	movs	r0, #23
 800576e:	4619      	mov	r1, r3
 8005770:	f002 fef6 	bl	8008560 <_test_assert>
 8005774:	4603      	mov	r3, r0
 8005776:	2b00      	cmp	r3, #0
 8005778:	f040 8255 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  msg1 = chMBPostI(&mb1, 'C');
 800577c:	f640 0070 	movw	r0, #2160	; 0x870
 8005780:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005784:	2143      	movs	r1, #67	; 0x43
 8005786:	f007 fec3 	bl	800d510 <chMBPostI>
 800578a:	9002      	str	r0, [sp, #8]
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 800578c:	9b02      	ldr	r3, [sp, #8]
 800578e:	2b00      	cmp	r3, #0
 8005790:	bf14      	ite	ne
 8005792:	2300      	movne	r3, #0
 8005794:	2301      	moveq	r3, #1
 8005796:	b2db      	uxtb	r3, r3
 8005798:	2018      	movs	r0, #24
 800579a:	4619      	mov	r1, r3
 800579c:	f002 fee0 	bl	8008560 <_test_assert>
 80057a0:	4603      	mov	r3, r0
 80057a2:	2b00      	cmp	r3, #0
 80057a4:	f040 823f 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  msg1 = chMBPostI(&mb1, 'D');
 80057a8:	f640 0070 	movw	r0, #2160	; 0x870
 80057ac:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80057b0:	2144      	movs	r1, #68	; 0x44
 80057b2:	f007 fead 	bl	800d510 <chMBPostI>
 80057b6:	9002      	str	r0, [sp, #8]
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 80057b8:	9b02      	ldr	r3, [sp, #8]
 80057ba:	2b00      	cmp	r3, #0
 80057bc:	bf14      	ite	ne
 80057be:	2300      	movne	r3, #0
 80057c0:	2301      	moveq	r3, #1
 80057c2:	b2db      	uxtb	r3, r3
 80057c4:	2019      	movs	r0, #25
 80057c6:	4619      	mov	r1, r3
 80057c8:	f002 feca 	bl	8008560 <_test_assert>
 80057cc:	4603      	mov	r3, r0
 80057ce:	2b00      	cmp	r3, #0
 80057d0:	f040 8229 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  msg1 = chMBPostI(&mb1, 'E');
 80057d4:	f640 0070 	movw	r0, #2160	; 0x870
 80057d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80057dc:	2145      	movs	r1, #69	; 0x45
 80057de:	f007 fe97 	bl	800d510 <chMBPostI>
 80057e2:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 80057e4:	f7ff fd0c 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 80057e8:	9b02      	ldr	r3, [sp, #8]
 80057ea:	2b00      	cmp	r3, #0
 80057ec:	bf14      	ite	ne
 80057ee:	2300      	movne	r3, #0
 80057f0:	2301      	moveq	r3, #1
 80057f2:	b2db      	uxtb	r3, r3
 80057f4:	201a      	movs	r0, #26
 80057f6:	4619      	mov	r1, r3
 80057f8:	f002 feb2 	bl	8008560 <_test_assert>
 80057fc:	4603      	mov	r3, r0
 80057fe:	2b00      	cmp	r3, #0
 8005800:	f040 8211 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8005804:	f640 0370 	movw	r3, #2160	; 0x870
 8005808:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800580c:	68da      	ldr	r2, [r3, #12]
 800580e:	f640 0370 	movw	r3, #2160	; 0x870
 8005812:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005816:	689b      	ldr	r3, [r3, #8]
 8005818:	429a      	cmp	r2, r3
 800581a:	bf14      	ite	ne
 800581c:	2300      	movne	r3, #0
 800581e:	2301      	moveq	r3, #1
 8005820:	b2db      	uxtb	r3, r3
 8005822:	201b      	movs	r0, #27
 8005824:	4619      	mov	r1, r3
 8005826:	f002 fe9b 	bl	8008560 <_test_assert>
 800582a:	4603      	mov	r3, r0
 800582c:	2b00      	cmp	r3, #0
 800582e:	f040 81fa 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  for (i = 0; i < MB_SIZE; i++) {
 8005832:	2300      	movs	r3, #0
 8005834:	9303      	str	r3, [sp, #12]
 8005836:	e022      	b.n	800587e <mbox1_execute.12589+0x5ae>
    chSysLock();
 8005838:	f7ff fcda 	bl	80051f0 <chSysLock.12585.4127>
    msg1 = chMBFetchI(&mb1, &msg2);
 800583c:	ab01      	add	r3, sp, #4
 800583e:	f640 0070 	movw	r0, #2160	; 0x870
 8005842:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005846:	4619      	mov	r1, r3
 8005848:	f007 ff92 	bl	800d770 <chMBFetchI>
 800584c:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800584e:	f7ff fcd7 	bl	8005200 <chSysUnlock.12587.4125>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 8005852:	9b02      	ldr	r3, [sp, #8]
 8005854:	2b00      	cmp	r3, #0
 8005856:	bf14      	ite	ne
 8005858:	2300      	movne	r3, #0
 800585a:	2301      	moveq	r3, #1
 800585c:	b2db      	uxtb	r3, r3
 800585e:	201c      	movs	r0, #28
 8005860:	4619      	mov	r1, r3
 8005862:	f002 fe7d 	bl	8008560 <_test_assert>
 8005866:	4603      	mov	r3, r0
 8005868:	2b00      	cmp	r3, #0
 800586a:	f040 81dc 	bne.w	8005c26 <mbox1_execute.12589+0x956>
    test_emit_token(msg2);
 800586e:	9b01      	ldr	r3, [sp, #4]
 8005870:	b2db      	uxtb	r3, r3
 8005872:	4618      	mov	r0, r3
 8005874:	f002 fe3c 	bl	80084f0 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 8005878:	9b03      	ldr	r3, [sp, #12]
 800587a:	3301      	adds	r3, #1
 800587c:	9303      	str	r3, [sp, #12]
 800587e:	9b03      	ldr	r3, [sp, #12]
 8005880:	2b04      	cmp	r3, #4
 8005882:	d9d9      	bls.n	8005838 <mbox1_execute.12589+0x568>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 8005884:	201d      	movs	r0, #29
 8005886:	f640 5184 	movw	r1, #3460	; 0xd84
 800588a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800588e:	f002 fe7f 	bl	8008590 <_test_assert_sequence>
 8005892:	4603      	mov	r3, r0
 8005894:	2b00      	cmp	r3, #0
 8005896:	f040 81c6 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800589a:	f7ff fca9 	bl	80051f0 <chSysLock.12585.4127>
 800589e:	f640 0070 	movw	r0, #2160	; 0x870
 80058a2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80058a6:	f7ff fce3 	bl	8005270 <chMBGetFreeCountI.12571.4119>
 80058aa:	4603      	mov	r3, r0
 80058ac:	2b05      	cmp	r3, #5
 80058ae:	bf14      	ite	ne
 80058b0:	2300      	movne	r3, #0
 80058b2:	2301      	moveq	r3, #1
 80058b4:	b2db      	uxtb	r3, r3
 80058b6:	201e      	movs	r0, #30
 80058b8:	4619      	mov	r1, r3
 80058ba:	f002 fe51 	bl	8008560 <_test_assert>
 80058be:	4603      	mov	r3, r0
 80058c0:	2b00      	cmp	r3, #0
 80058c2:	d002      	beq.n	80058ca <mbox1_execute.12589+0x5fa>
 80058c4:	f7ff fc9c 	bl	8005200 <chSysUnlock.12587.4125>
 80058c8:	e1ad      	b.n	8005c26 <mbox1_execute.12589+0x956>
 80058ca:	f7ff fc99 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 80058ce:	f7ff fc8f 	bl	80051f0 <chSysLock.12585.4127>
 80058d2:	f640 0070 	movw	r0, #2160	; 0x870
 80058d6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80058da:	f7ff fcd9 	bl	8005290 <chMBGetUsedCountI.12582.4015>
 80058de:	4603      	mov	r3, r0
 80058e0:	2b00      	cmp	r3, #0
 80058e2:	bf14      	ite	ne
 80058e4:	2300      	movne	r3, #0
 80058e6:	2301      	moveq	r3, #1
 80058e8:	b2db      	uxtb	r3, r3
 80058ea:	201f      	movs	r0, #31
 80058ec:	4619      	mov	r1, r3
 80058ee:	f002 fe37 	bl	8008560 <_test_assert>
 80058f2:	4603      	mov	r3, r0
 80058f4:	2b00      	cmp	r3, #0
 80058f6:	d002      	beq.n	80058fe <mbox1_execute.12589+0x62e>
 80058f8:	f7ff fc82 	bl	8005200 <chSysUnlock.12587.4125>
 80058fc:	e193      	b.n	8005c26 <mbox1_execute.12589+0x956>
 80058fe:	f7ff fc7f 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8005902:	f640 0370 	movw	r3, #2160	; 0x870
 8005906:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800590a:	68da      	ldr	r2, [r3, #12]
 800590c:	f640 0370 	movw	r3, #2160	; 0x870
 8005910:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005914:	689b      	ldr	r3, [r3, #8]
 8005916:	429a      	cmp	r2, r3
 8005918:	bf14      	ite	ne
 800591a:	2300      	movne	r3, #0
 800591c:	2301      	moveq	r3, #1
 800591e:	b2db      	uxtb	r3, r3
 8005920:	2020      	movs	r0, #32
 8005922:	4619      	mov	r1, r3
 8005924:	f002 fe1c 	bl	8008560 <_test_assert>
 8005928:	4603      	mov	r3, r0
 800592a:	2b00      	cmp	r3, #0
 800592c:	f040 817b 	bne.w	8005c26 <mbox1_execute.12589+0x956>

  chSysLock();
 8005930:	f7ff fc5e 	bl	80051f0 <chSysLock.12585.4127>
  msg1 = chMBPostAheadI(&mb1, 'E');
 8005934:	f640 0070 	movw	r0, #2160	; 0x870
 8005938:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800593c:	2145      	movs	r1, #69	; 0x45
 800593e:	f007 fe7f 	bl	800d640 <chMBPostAheadI>
 8005942:	9002      	str	r0, [sp, #8]
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 8005944:	9b02      	ldr	r3, [sp, #8]
 8005946:	2b00      	cmp	r3, #0
 8005948:	bf14      	ite	ne
 800594a:	2300      	movne	r3, #0
 800594c:	2301      	moveq	r3, #1
 800594e:	b2db      	uxtb	r3, r3
 8005950:	2021      	movs	r0, #33	; 0x21
 8005952:	4619      	mov	r1, r3
 8005954:	f002 fe04 	bl	8008560 <_test_assert>
 8005958:	4603      	mov	r3, r0
 800595a:	2b00      	cmp	r3, #0
 800595c:	f040 8163 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  msg1 = chMBPostAheadI(&mb1, 'D');
 8005960:	f640 0070 	movw	r0, #2160	; 0x870
 8005964:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005968:	2144      	movs	r1, #68	; 0x44
 800596a:	f007 fe69 	bl	800d640 <chMBPostAheadI>
 800596e:	9002      	str	r0, [sp, #8]
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 8005970:	9b02      	ldr	r3, [sp, #8]
 8005972:	2b00      	cmp	r3, #0
 8005974:	bf14      	ite	ne
 8005976:	2300      	movne	r3, #0
 8005978:	2301      	moveq	r3, #1
 800597a:	b2db      	uxtb	r3, r3
 800597c:	2022      	movs	r0, #34	; 0x22
 800597e:	4619      	mov	r1, r3
 8005980:	f002 fdee 	bl	8008560 <_test_assert>
 8005984:	4603      	mov	r3, r0
 8005986:	2b00      	cmp	r3, #0
 8005988:	f040 814d 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  msg1 = chMBPostAheadI(&mb1, 'C');
 800598c:	f640 0070 	movw	r0, #2160	; 0x870
 8005990:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005994:	2143      	movs	r1, #67	; 0x43
 8005996:	f007 fe53 	bl	800d640 <chMBPostAheadI>
 800599a:	9002      	str	r0, [sp, #8]
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 800599c:	9b02      	ldr	r3, [sp, #8]
 800599e:	2b00      	cmp	r3, #0
 80059a0:	bf14      	ite	ne
 80059a2:	2300      	movne	r3, #0
 80059a4:	2301      	moveq	r3, #1
 80059a6:	b2db      	uxtb	r3, r3
 80059a8:	2023      	movs	r0, #35	; 0x23
 80059aa:	4619      	mov	r1, r3
 80059ac:	f002 fdd8 	bl	8008560 <_test_assert>
 80059b0:	4603      	mov	r3, r0
 80059b2:	2b00      	cmp	r3, #0
 80059b4:	f040 8137 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  msg1 = chMBPostAheadI(&mb1, 'B');
 80059b8:	f640 0070 	movw	r0, #2160	; 0x870
 80059bc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80059c0:	2142      	movs	r1, #66	; 0x42
 80059c2:	f007 fe3d 	bl	800d640 <chMBPostAheadI>
 80059c6:	9002      	str	r0, [sp, #8]
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 80059c8:	9b02      	ldr	r3, [sp, #8]
 80059ca:	2b00      	cmp	r3, #0
 80059cc:	bf14      	ite	ne
 80059ce:	2300      	movne	r3, #0
 80059d0:	2301      	moveq	r3, #1
 80059d2:	b2db      	uxtb	r3, r3
 80059d4:	2024      	movs	r0, #36	; 0x24
 80059d6:	4619      	mov	r1, r3
 80059d8:	f002 fdc2 	bl	8008560 <_test_assert>
 80059dc:	4603      	mov	r3, r0
 80059de:	2b00      	cmp	r3, #0
 80059e0:	f040 8121 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  msg1 = chMBPostAheadI(&mb1, 'A');
 80059e4:	f640 0070 	movw	r0, #2160	; 0x870
 80059e8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80059ec:	2141      	movs	r1, #65	; 0x41
 80059ee:	f007 fe27 	bl	800d640 <chMBPostAheadI>
 80059f2:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 80059f4:	f7ff fc04 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 80059f8:	9b02      	ldr	r3, [sp, #8]
 80059fa:	2b00      	cmp	r3, #0
 80059fc:	bf14      	ite	ne
 80059fe:	2300      	movne	r3, #0
 8005a00:	2301      	moveq	r3, #1
 8005a02:	b2db      	uxtb	r3, r3
 8005a04:	2025      	movs	r0, #37	; 0x25
 8005a06:	4619      	mov	r1, r3
 8005a08:	f002 fdaa 	bl	8008560 <_test_assert>
 8005a0c:	4603      	mov	r3, r0
 8005a0e:	2b00      	cmp	r3, #0
 8005a10:	f040 8109 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8005a14:	f640 0370 	movw	r3, #2160	; 0x870
 8005a18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a1c:	68da      	ldr	r2, [r3, #12]
 8005a1e:	f640 0370 	movw	r3, #2160	; 0x870
 8005a22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a26:	689b      	ldr	r3, [r3, #8]
 8005a28:	429a      	cmp	r2, r3
 8005a2a:	bf14      	ite	ne
 8005a2c:	2300      	movne	r3, #0
 8005a2e:	2301      	moveq	r3, #1
 8005a30:	b2db      	uxtb	r3, r3
 8005a32:	2026      	movs	r0, #38	; 0x26
 8005a34:	4619      	mov	r1, r3
 8005a36:	f002 fd93 	bl	8008560 <_test_assert>
 8005a3a:	4603      	mov	r3, r0
 8005a3c:	2b00      	cmp	r3, #0
 8005a3e:	f040 80f2 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  for (i = 0; i < MB_SIZE; i++) {
 8005a42:	2300      	movs	r3, #0
 8005a44:	9303      	str	r3, [sp, #12]
 8005a46:	e022      	b.n	8005a8e <mbox1_execute.12589+0x7be>
    chSysLock();
 8005a48:	f7ff fbd2 	bl	80051f0 <chSysLock.12585.4127>
    msg1 = chMBFetchI(&mb1, &msg2);
 8005a4c:	ab01      	add	r3, sp, #4
 8005a4e:	f640 0070 	movw	r0, #2160	; 0x870
 8005a52:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005a56:	4619      	mov	r1, r3
 8005a58:	f007 fe8a 	bl	800d770 <chMBFetchI>
 8005a5c:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 8005a5e:	f7ff fbcf 	bl	8005200 <chSysUnlock.12587.4125>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 8005a62:	9b02      	ldr	r3, [sp, #8]
 8005a64:	2b00      	cmp	r3, #0
 8005a66:	bf14      	ite	ne
 8005a68:	2300      	movne	r3, #0
 8005a6a:	2301      	moveq	r3, #1
 8005a6c:	b2db      	uxtb	r3, r3
 8005a6e:	2027      	movs	r0, #39	; 0x27
 8005a70:	4619      	mov	r1, r3
 8005a72:	f002 fd75 	bl	8008560 <_test_assert>
 8005a76:	4603      	mov	r3, r0
 8005a78:	2b00      	cmp	r3, #0
 8005a7a:	f040 80d4 	bne.w	8005c26 <mbox1_execute.12589+0x956>
    test_emit_token(msg2);
 8005a7e:	9b01      	ldr	r3, [sp, #4]
 8005a80:	b2db      	uxtb	r3, r3
 8005a82:	4618      	mov	r0, r3
 8005a84:	f002 fd34 	bl	80084f0 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 8005a88:	9b03      	ldr	r3, [sp, #12]
 8005a8a:	3301      	adds	r3, #1
 8005a8c:	9303      	str	r3, [sp, #12]
 8005a8e:	9b03      	ldr	r3, [sp, #12]
 8005a90:	2b04      	cmp	r3, #4
 8005a92:	d9d9      	bls.n	8005a48 <mbox1_execute.12589+0x778>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 8005a94:	2028      	movs	r0, #40	; 0x28
 8005a96:	f640 5184 	movw	r1, #3460	; 0xd84
 8005a9a:	f6c0 0101 	movt	r1, #2049	; 0x801
 8005a9e:	f002 fd77 	bl	8008590 <_test_assert_sequence>
 8005aa2:	4603      	mov	r3, r0
 8005aa4:	2b00      	cmp	r3, #0
 8005aa6:	f040 80be 	bne.w	8005c26 <mbox1_execute.12589+0x956>
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8005aaa:	f7ff fba1 	bl	80051f0 <chSysLock.12585.4127>
 8005aae:	f640 0070 	movw	r0, #2160	; 0x870
 8005ab2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005ab6:	f7ff fbdb 	bl	8005270 <chMBGetFreeCountI.12571.4119>
 8005aba:	4603      	mov	r3, r0
 8005abc:	2b05      	cmp	r3, #5
 8005abe:	bf14      	ite	ne
 8005ac0:	2300      	movne	r3, #0
 8005ac2:	2301      	moveq	r3, #1
 8005ac4:	b2db      	uxtb	r3, r3
 8005ac6:	2029      	movs	r0, #41	; 0x29
 8005ac8:	4619      	mov	r1, r3
 8005aca:	f002 fd49 	bl	8008560 <_test_assert>
 8005ace:	4603      	mov	r3, r0
 8005ad0:	2b00      	cmp	r3, #0
 8005ad2:	d002      	beq.n	8005ada <mbox1_execute.12589+0x80a>
 8005ad4:	f7ff fb94 	bl	8005200 <chSysUnlock.12587.4125>
 8005ad8:	e0a5      	b.n	8005c26 <mbox1_execute.12589+0x956>
 8005ada:	f7ff fb91 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 8005ade:	f7ff fb87 	bl	80051f0 <chSysLock.12585.4127>
 8005ae2:	f640 0070 	movw	r0, #2160	; 0x870
 8005ae6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005aea:	f7ff fbd1 	bl	8005290 <chMBGetUsedCountI.12582.4015>
 8005aee:	4603      	mov	r3, r0
 8005af0:	2b00      	cmp	r3, #0
 8005af2:	bf14      	ite	ne
 8005af4:	2300      	movne	r3, #0
 8005af6:	2301      	moveq	r3, #1
 8005af8:	b2db      	uxtb	r3, r3
 8005afa:	202a      	movs	r0, #42	; 0x2a
 8005afc:	4619      	mov	r1, r3
 8005afe:	f002 fd2f 	bl	8008560 <_test_assert>
 8005b02:	4603      	mov	r3, r0
 8005b04:	2b00      	cmp	r3, #0
 8005b06:	d002      	beq.n	8005b0e <mbox1_execute.12589+0x83e>
 8005b08:	f7ff fb7a 	bl	8005200 <chSysUnlock.12587.4125>
 8005b0c:	e08b      	b.n	8005c26 <mbox1_execute.12589+0x956>
 8005b0e:	f7ff fb77 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8005b12:	f640 0370 	movw	r3, #2160	; 0x870
 8005b16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b1a:	68da      	ldr	r2, [r3, #12]
 8005b1c:	f640 0370 	movw	r3, #2160	; 0x870
 8005b20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b24:	689b      	ldr	r3, [r3, #8]
 8005b26:	429a      	cmp	r2, r3
 8005b28:	bf14      	ite	ne
 8005b2a:	2300      	movne	r3, #0
 8005b2c:	2301      	moveq	r3, #1
 8005b2e:	b2db      	uxtb	r3, r3
 8005b30:	202b      	movs	r0, #43	; 0x2b
 8005b32:	4619      	mov	r1, r3
 8005b34:	f002 fd14 	bl	8008560 <_test_assert>
 8005b38:	4603      	mov	r3, r0
 8005b3a:	2b00      	cmp	r3, #0
 8005b3c:	d173      	bne.n	8005c26 <mbox1_execute.12589+0x956>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
 8005b3e:	f640 0070 	movw	r0, #2160	; 0x870
 8005b42:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005b46:	f007 fc53 	bl	800d3f0 <chMBReset>

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8005b4a:	f7ff fb51 	bl	80051f0 <chSysLock.12585.4127>
 8005b4e:	f640 0070 	movw	r0, #2160	; 0x870
 8005b52:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005b56:	f7ff fb8b 	bl	8005270 <chMBGetFreeCountI.12571.4119>
 8005b5a:	4603      	mov	r3, r0
 8005b5c:	2b05      	cmp	r3, #5
 8005b5e:	bf14      	ite	ne
 8005b60:	2300      	movne	r3, #0
 8005b62:	2301      	moveq	r3, #1
 8005b64:	b2db      	uxtb	r3, r3
 8005b66:	202c      	movs	r0, #44	; 0x2c
 8005b68:	4619      	mov	r1, r3
 8005b6a:	f002 fcf9 	bl	8008560 <_test_assert>
 8005b6e:	4603      	mov	r3, r0
 8005b70:	2b00      	cmp	r3, #0
 8005b72:	d002      	beq.n	8005b7a <mbox1_execute.12589+0x8aa>
 8005b74:	f7ff fb44 	bl	8005200 <chSysUnlock.12587.4125>
 8005b78:	e055      	b.n	8005c26 <mbox1_execute.12589+0x956>
 8005b7a:	f7ff fb41 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 8005b7e:	f7ff fb37 	bl	80051f0 <chSysLock.12585.4127>
 8005b82:	f640 0070 	movw	r0, #2160	; 0x870
 8005b86:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005b8a:	f7ff fb81 	bl	8005290 <chMBGetUsedCountI.12582.4015>
 8005b8e:	4603      	mov	r3, r0
 8005b90:	2b00      	cmp	r3, #0
 8005b92:	bf14      	ite	ne
 8005b94:	2300      	movne	r3, #0
 8005b96:	2301      	moveq	r3, #1
 8005b98:	b2db      	uxtb	r3, r3
 8005b9a:	202d      	movs	r0, #45	; 0x2d
 8005b9c:	4619      	mov	r1, r3
 8005b9e:	f002 fcdf 	bl	8008560 <_test_assert>
 8005ba2:	4603      	mov	r3, r0
 8005ba4:	2b00      	cmp	r3, #0
 8005ba6:	d002      	beq.n	8005bae <mbox1_execute.12589+0x8de>
 8005ba8:	f7ff fb2a 	bl	8005200 <chSysUnlock.12587.4125>
 8005bac:	e03b      	b.n	8005c26 <mbox1_execute.12589+0x956>
 8005bae:	f7ff fb27 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 8005bb2:	f7ff fb1d 	bl	80051f0 <chSysLock.12585.4127>
 8005bb6:	f640 0370 	movw	r3, #2160	; 0x870
 8005bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bbe:	681a      	ldr	r2, [r3, #0]
 8005bc0:	f640 0370 	movw	r3, #2160	; 0x870
 8005bc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bc8:	689b      	ldr	r3, [r3, #8]
 8005bca:	429a      	cmp	r2, r3
 8005bcc:	bf14      	ite	ne
 8005bce:	2300      	movne	r3, #0
 8005bd0:	2301      	moveq	r3, #1
 8005bd2:	b2db      	uxtb	r3, r3
 8005bd4:	202e      	movs	r0, #46	; 0x2e
 8005bd6:	4619      	mov	r1, r3
 8005bd8:	f002 fcc2 	bl	8008560 <_test_assert>
 8005bdc:	4603      	mov	r3, r0
 8005bde:	2b00      	cmp	r3, #0
 8005be0:	d002      	beq.n	8005be8 <mbox1_execute.12589+0x918>
 8005be2:	f7ff fb0d 	bl	8005200 <chSysUnlock.12587.4125>
 8005be6:	e01e      	b.n	8005c26 <mbox1_execute.12589+0x956>
 8005be8:	f7ff fb0a 	bl	8005200 <chSysUnlock.12587.4125>
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8005bec:	f7ff fb00 	bl	80051f0 <chSysLock.12585.4127>
 8005bf0:	f640 0370 	movw	r3, #2160	; 0x870
 8005bf4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005bf8:	681a      	ldr	r2, [r3, #0]
 8005bfa:	f640 0370 	movw	r3, #2160	; 0x870
 8005bfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c02:	68db      	ldr	r3, [r3, #12]
 8005c04:	429a      	cmp	r2, r3
 8005c06:	bf14      	ite	ne
 8005c08:	2300      	movne	r3, #0
 8005c0a:	2301      	moveq	r3, #1
 8005c0c:	b2db      	uxtb	r3, r3
 8005c0e:	202f      	movs	r0, #47	; 0x2f
 8005c10:	4619      	mov	r1, r3
 8005c12:	f002 fca5 	bl	8008560 <_test_assert>
 8005c16:	4603      	mov	r3, r0
 8005c18:	2b00      	cmp	r3, #0
 8005c1a:	d002      	beq.n	8005c22 <mbox1_execute.12589+0x952>
 8005c1c:	f7ff faf0 	bl	8005200 <chSysUnlock.12587.4125>
 8005c20:	e001      	b.n	8005c26 <mbox1_execute.12589+0x956>
 8005c22:	f7ff faed 	bl	8005200 <chSysUnlock.12587.4125>
}
 8005c26:	b005      	add	sp, #20
 8005c28:	f85d fb04 	ldr.w	pc, [sp], #4
 8005c2c:	f3af 8000 	nop.w

08005c30 <TestThread>:
/**
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
 8005c30:	b500      	push	{lr}
 8005c32:	b085      	sub	sp, #20
 8005c34:	9001      	str	r0, [sp, #4]
  int i, j;

  chp = p;
 8005c36:	f641 6374 	movw	r3, #7796	; 0x1e74
 8005c3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c3e:	9a01      	ldr	r2, [sp, #4]
 8005c40:	601a      	str	r2, [r3, #0]
  test_println("");
 8005c42:	f640 5090 	movw	r0, #3472	; 0xd90
 8005c46:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005c4a:	f002 fbf9 	bl	8008440 <test_println>
  test_println("*** ChibiOS/RT test suite");
 8005c4e:	f640 5094 	movw	r0, #3476	; 0xd94
 8005c52:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005c56:	f002 fbf3 	bl	8008440 <test_println>
  test_println("***");
 8005c5a:	f640 50b0 	movw	r0, #3504	; 0xdb0
 8005c5e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005c62:	f002 fbed 	bl	8008440 <test_println>
  test_print("*** Kernel:       ");
 8005c66:	f640 50b4 	movw	r0, #3508	; 0xdb4
 8005c6a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005c6e:	f002 fbc7 	bl	8008400 <test_print>
  test_println(CH_KERNEL_VERSION);
 8005c72:	f640 50c8 	movw	r0, #3528	; 0xdc8
 8005c76:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005c7a:	f002 fbe1 	bl	8008440 <test_println>
  test_print("*** Compiled:     ");
 8005c7e:	f640 50d0 	movw	r0, #3536	; 0xdd0
 8005c82:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005c86:	f002 fbbb 	bl	8008400 <test_print>
  test_println(__DATE__ " - " __TIME__);
 8005c8a:	f640 50e4 	movw	r0, #3556	; 0xde4
 8005c8e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005c92:	f002 fbd5 	bl	8008440 <test_println>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
 8005c96:	f640 50fc 	movw	r0, #3580	; 0xdfc
 8005c9a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005c9e:	f002 fbaf 	bl	8008400 <test_print>
  test_println(PORT_COMPILER_NAME);
 8005ca2:	f640 6010 	movw	r0, #3600	; 0xe10
 8005ca6:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005caa:	f002 fbc9 	bl	8008440 <test_println>
#endif
  test_print("*** Architecture: ");
 8005cae:	f640 601c 	movw	r0, #3612	; 0xe1c
 8005cb2:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005cb6:	f002 fba3 	bl	8008400 <test_print>
  test_println(PORT_ARCHITECTURE_NAME);
 8005cba:	f640 6030 	movw	r0, #3632	; 0xe30
 8005cbe:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005cc2:	f002 fbbd 	bl	8008440 <test_println>
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
 8005cc6:	f640 603c 	movw	r0, #3644	; 0xe3c
 8005cca:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005cce:	f002 fb97 	bl	8008400 <test_print>
  test_println(PORT_CORE_VARIANT_NAME);
 8005cd2:	f640 6050 	movw	r0, #3664	; 0xe50
 8005cd6:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005cda:	f002 fbb1 	bl	8008440 <test_println>
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
 8005cde:	f640 605c 	movw	r0, #3676	; 0xe5c
 8005ce2:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005ce6:	f002 fb8b 	bl	8008400 <test_print>
  test_println(PORT_INFO);
 8005cea:	f640 6070 	movw	r0, #3696	; 0xe70
 8005cee:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005cf2:	f002 fba5 	bl	8008440 <test_println>
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
 8005cf6:	f640 6088 	movw	r0, #3720	; 0xe88
 8005cfa:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005cfe:	f002 fb7f 	bl	8008400 <test_print>
  test_println(PLATFORM_NAME);
 8005d02:	f640 609c 	movw	r0, #3740	; 0xe9c
 8005d06:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005d0a:	f002 fb99 	bl	8008440 <test_println>
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
 8005d0e:	f640 60c8 	movw	r0, #3784	; 0xec8
 8005d12:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005d16:	f002 fb73 	bl	8008400 <test_print>
  test_println(BOARD_NAME);
 8005d1a:	f640 60dc 	movw	r0, #3804	; 0xedc
 8005d1e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005d22:	f002 fb8d 	bl	8008440 <test_println>
#endif
  test_println("");
 8005d26:	f640 5090 	movw	r0, #3472	; 0xd90
 8005d2a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005d2e:	f002 fb87 	bl	8008440 <test_println>

  test_global_fail = FALSE;
 8005d32:	f241 7338 	movw	r3, #5944	; 0x1738
 8005d36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d3a:	2200      	movs	r2, #0
 8005d3c:	701a      	strb	r2, [r3, #0]
  i = 0;
 8005d3e:	2300      	movs	r3, #0
 8005d40:	9303      	str	r3, [sp, #12]
 8005d42:	e084      	b.n	8005e4e <TestThread+0x21e>
  while (patterns[i]) {
    j = 0;
 8005d44:	2300      	movs	r3, #0
 8005d46:	9302      	str	r3, [sp, #8]
 8005d48:	e071      	b.n	8005e2e <TestThread+0x1fe>
    while (patterns[i][j]) {
      print_line();
 8005d4a:	f002 fd49 	bl	80087e0 <print_line.11256>
      test_print("--- Test Case ");
 8005d4e:	f640 7004 	movw	r0, #3844	; 0xf04
 8005d52:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005d56:	f002 fb53 	bl	8008400 <test_print>
      test_printn(i + 1);
 8005d5a:	9b03      	ldr	r3, [sp, #12]
 8005d5c:	3301      	adds	r3, #1
 8005d5e:	4618      	mov	r0, r3
 8005d60:	f002 faf6 	bl	8008350 <test_printn>
      test_print(".");
 8005d64:	f640 7014 	movw	r0, #3860	; 0xf14
 8005d68:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005d6c:	f002 fb48 	bl	8008400 <test_print>
      test_printn(j + 1);
 8005d70:	9b02      	ldr	r3, [sp, #8]
 8005d72:	3301      	adds	r3, #1
 8005d74:	4618      	mov	r0, r3
 8005d76:	f002 faeb 	bl	8008350 <test_printn>
      test_print(" (");
 8005d7a:	f640 7018 	movw	r0, #3864	; 0xf18
 8005d7e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005d82:	f002 fb3d 	bl	8008400 <test_print>
      test_print(patterns[i][j]->name);
 8005d86:	f640 0308 	movw	r3, #2056	; 0x808
 8005d8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d8e:	9a03      	ldr	r2, [sp, #12]
 8005d90:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8005d94:	9b02      	ldr	r3, [sp, #8]
 8005d96:	009b      	lsls	r3, r3, #2
 8005d98:	4413      	add	r3, r2
 8005d9a:	681b      	ldr	r3, [r3, #0]
 8005d9c:	681b      	ldr	r3, [r3, #0]
 8005d9e:	4618      	mov	r0, r3
 8005da0:	f002 fb2e 	bl	8008400 <test_print>
      test_println(")");
 8005da4:	f640 701c 	movw	r0, #3868	; 0xf1c
 8005da8:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005dac:	f002 fb48 	bl	8008440 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 8005db0:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8005db4:	f007 fe4c 	bl	800da50 <chThdSleep>
#endif
      execute_test(patterns[i][j]);
 8005db8:	f640 0308 	movw	r3, #2056	; 0x808
 8005dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005dc0:	9a03      	ldr	r2, [sp, #12]
 8005dc2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8005dc6:	9b02      	ldr	r3, [sp, #8]
 8005dc8:	009b      	lsls	r3, r3, #2
 8005dca:	4413      	add	r3, r2
 8005dcc:	681b      	ldr	r3, [r3, #0]
 8005dce:	4618      	mov	r0, r3
 8005dd0:	f002 fcce 	bl	8008770 <execute_test.11248>
      if (local_fail) {
 8005dd4:	f241 7339 	movw	r3, #5945	; 0x1739
 8005dd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ddc:	781b      	ldrb	r3, [r3, #0]
 8005dde:	2b00      	cmp	r3, #0
 8005de0:	d01c      	beq.n	8005e1c <TestThread+0x1ec>
        test_print("--- Result: FAILURE (#");
 8005de2:	f640 7020 	movw	r0, #3872	; 0xf20
 8005de6:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005dea:	f002 fb09 	bl	8008400 <test_print>
        test_printn(failpoint);
 8005dee:	f241 733c 	movw	r3, #5948	; 0x173c
 8005df2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005df6:	681b      	ldr	r3, [r3, #0]
 8005df8:	4618      	mov	r0, r3
 8005dfa:	f002 faa9 	bl	8008350 <test_printn>
        test_print(" [");
 8005dfe:	f640 7038 	movw	r0, #3896	; 0xf38
 8005e02:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005e06:	f002 fafb 	bl	8008400 <test_print>
        print_tokens();
 8005e0a:	f002 fb49 	bl	80084a0 <print_tokens.11218>
        test_println("])");
 8005e0e:	f640 703c 	movw	r0, #3900	; 0xf3c
 8005e12:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005e16:	f002 fb13 	bl	8008440 <test_println>
 8005e1a:	e005      	b.n	8005e28 <TestThread+0x1f8>
      }
      else
        test_println("--- Result: SUCCESS");
 8005e1c:	f640 7040 	movw	r0, #3904	; 0xf40
 8005e20:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005e24:	f002 fb0c 	bl	8008440 <test_println>
      j++;
 8005e28:	9b02      	ldr	r3, [sp, #8]
 8005e2a:	3301      	adds	r3, #1
 8005e2c:	9302      	str	r3, [sp, #8]

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8005e2e:	f640 0308 	movw	r3, #2056	; 0x808
 8005e32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e36:	9a03      	ldr	r2, [sp, #12]
 8005e38:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8005e3c:	9b02      	ldr	r3, [sp, #8]
 8005e3e:	009b      	lsls	r3, r3, #2
 8005e40:	4413      	add	r3, r2
 8005e42:	681b      	ldr	r3, [r3, #0]
 8005e44:	2b00      	cmp	r3, #0
 8005e46:	d180      	bne.n	8005d4a <TestThread+0x11a>
      }
      else
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
 8005e48:	9b03      	ldr	r3, [sp, #12]
 8005e4a:	3301      	adds	r3, #1
 8005e4c:	9303      	str	r3, [sp, #12]
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 8005e4e:	f640 0308 	movw	r3, #2056	; 0x808
 8005e52:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e56:	9a03      	ldr	r2, [sp, #12]
 8005e58:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005e5c:	2b00      	cmp	r3, #0
 8005e5e:	f47f af71 	bne.w	8005d44 <TestThread+0x114>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 8005e62:	f002 fcbd 	bl	80087e0 <print_line.11256>
  test_println("");
 8005e66:	f640 5090 	movw	r0, #3472	; 0xd90
 8005e6a:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005e6e:	f002 fae7 	bl	8008440 <test_println>
  test_print("Final result: ");
 8005e72:	f640 7054 	movw	r0, #3924	; 0xf54
 8005e76:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005e7a:	f002 fac1 	bl	8008400 <test_print>
  if (test_global_fail)
 8005e7e:	f241 7338 	movw	r3, #5944	; 0x1738
 8005e82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e86:	781b      	ldrb	r3, [r3, #0]
 8005e88:	2b00      	cmp	r3, #0
 8005e8a:	d006      	beq.n	8005e9a <TestThread+0x26a>
    test_println("FAILURE");
 8005e8c:	f640 7064 	movw	r0, #3940	; 0xf64
 8005e90:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005e94:	f002 fad4 	bl	8008440 <test_println>
 8005e98:	e005      	b.n	8005ea6 <TestThread+0x276>
  else
    test_println("SUCCESS");
 8005e9a:	f640 706c 	movw	r0, #3948	; 0xf6c
 8005e9e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005ea2:	f002 facd 	bl	8008440 <test_println>
}
 8005ea6:	b005      	add	sp, #20
 8005ea8:	f85d fb04 	ldr.w	pc, [sp], #4
 8005eac:	f3af 8000 	nop.w

08005eb0 <port_lock.11485.4237>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005eb0:	b082      	sub	sp, #8
 8005eb2:	2320      	movs	r3, #32
 8005eb4:	9301      	str	r3, [sp, #4]
 8005eb6:	9b01      	ldr	r3, [sp, #4]
 8005eb8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005ebc:	b002      	add	sp, #8
 8005ebe:	4770      	bx	lr

08005ec0 <port_unlock.11488.4235>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005ec0:	b082      	sub	sp, #8
 8005ec2:	2300      	movs	r3, #0
 8005ec4:	9301      	str	r3, [sp, #4]
 8005ec6:	9b01      	ldr	r3, [sp, #4]
 8005ec8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005ecc:	b002      	add	sp, #8
 8005ece:	4770      	bx	lr

08005ed0 <st_lld_get_counter.11490.4233>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005ed0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005ed4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8005ed6:	4618      	mov	r0, r3
 8005ed8:	4770      	bx	lr
 8005eda:	bf00      	nop
 8005edc:	f3af 8000 	nop.w

08005ee0 <port_timer_get_time.11495.4231>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8005ee0:	b508      	push	{r3, lr}

  return stGetCounter();
 8005ee2:	f7ff fff5 	bl	8005ed0 <st_lld_get_counter.11490.4233>
 8005ee6:	4603      	mov	r3, r0
}
 8005ee8:	4618      	mov	r0, r3
 8005eea:	bd08      	pop	{r3, pc}
 8005eec:	f3af 8000 	nop.w

08005ef0 <chSysLock.11592.4229>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005ef0:	b508      	push	{r3, lr}

  port_lock();
 8005ef2:	f7ff ffdd 	bl	8005eb0 <port_lock.11485.4237>
  _stats_start_measure_crit_thd();
 8005ef6:	f008 f843 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8005efa:	f009 fbf1 	bl	800f6e0 <_dbg_check_lock>
}
 8005efe:	bd08      	pop	{r3, pc}

08005f00 <chSysUnlock.11594.4227>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005f00:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8005f02:	f009 fc0d 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8005f06:	f008 f843 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005f0a:	f640 5350 	movw	r3, #3408	; 0xd50
 8005f0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f12:	681a      	ldr	r2, [r3, #0]
 8005f14:	f640 5350 	movw	r3, #3408	; 0xd50
 8005f18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f1c:	429a      	cmp	r2, r3
 8005f1e:	d013      	beq.n	8005f48 <chSysUnlock.11594.4227+0x48>
 8005f20:	f640 5350 	movw	r3, #3408	; 0xd50
 8005f24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f28:	699b      	ldr	r3, [r3, #24]
 8005f2a:	689a      	ldr	r2, [r3, #8]
 8005f2c:	f640 5350 	movw	r3, #3408	; 0xd50
 8005f30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f34:	681b      	ldr	r3, [r3, #0]
 8005f36:	689b      	ldr	r3, [r3, #8]
 8005f38:	429a      	cmp	r2, r3
 8005f3a:	d205      	bcs.n	8005f48 <chSysUnlock.11594.4227+0x48>
 8005f3c:	f242 0040 	movw	r0, #8256	; 0x2040
 8005f40:	f6c0 0001 	movt	r0, #2049	; 0x801
 8005f44:	f009 fa24 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005f48:	f7ff ffba 	bl	8005ec0 <port_unlock.11488.4235>
}
 8005f4c:	bd08      	pop	{r3, pc}
 8005f4e:	bf00      	nop

08005f50 <chVTGetSystemTimeX.11497.4225>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8005f50:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8005f52:	f7ff ffc5 	bl	8005ee0 <port_timer_get_time.11495.4231>
 8005f56:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005f58:	4618      	mov	r0, r3
 8005f5a:	bd08      	pop	{r3, pc}
 8005f5c:	f3af 8000 	nop.w

08005f60 <chVTGetSystemTime.11598.4223>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8005f60:	b500      	push	{lr}
 8005f62:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8005f64:	f7ff ffc4 	bl	8005ef0 <chSysLock.11592.4229>
  systime = chVTGetSystemTimeX();
 8005f68:	f7ff fff2 	bl	8005f50 <chVTGetSystemTimeX.11497.4225>
 8005f6c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8005f6e:	f7ff ffc7 	bl	8005f00 <chSysUnlock.11594.4227>

  return systime;
 8005f72:	9b01      	ldr	r3, [sp, #4]
}
 8005f74:	4618      	mov	r0, r3
 8005f76:	b003      	add	sp, #12
 8005f78:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f7c:	f3af 8000 	nop.w

08005f80 <chThdGetSelfX.11499.4221>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005f80:	f640 5350 	movw	r3, #3408	; 0xd50
 8005f84:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f88:	699b      	ldr	r3, [r3, #24]
}
 8005f8a:	4618      	mov	r0, r3
 8005f8c:	4770      	bx	lr
 8005f8e:	bf00      	nop

08005f90 <chThdGetPriorityX.11585.4219>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8005f90:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8005f92:	f7ff fff5 	bl	8005f80 <chThdGetSelfX.11499.4221>
 8005f96:	4603      	mov	r3, r0
 8005f98:	689b      	ldr	r3, [r3, #8]
}
 8005f9a:	4618      	mov	r0, r3
 8005f9c:	bd08      	pop	{r3, pc}
 8005f9e:	bf00      	nop

08005fa0 <thread.11587.4214>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {
 8005fa0:	b500      	push	{lr}
 8005fa2:	b083      	sub	sp, #12
 8005fa4:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 8005fa6:	9b01      	ldr	r3, [sp, #4]
 8005fa8:	781b      	ldrb	r3, [r3, #0]
 8005faa:	4618      	mov	r0, r3
 8005fac:	f002 faa0 	bl	80084f0 <test_emit_token>
}
 8005fb0:	b003      	add	sp, #12
 8005fb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8005fb6:	bf00      	nop
 8005fb8:	f3af 8000 	nop.w
 8005fbc:	f3af 8000 	nop.w

08005fc0 <thd1_execute.11590>:

static void thd1_execute(void) {
 8005fc0:	b510      	push	{r4, lr}
 8005fc2:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005fc4:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8005fc8:	f6c0 0301 	movt	r3, #2049	; 0x801
 8005fcc:	681c      	ldr	r4, [r3, #0]
 8005fce:	f7ff ffdf 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 8005fd2:	4603      	mov	r3, r0
 8005fd4:	1f5a      	subs	r2, r3, #5
 8005fd6:	f640 7374 	movw	r3, #3956	; 0xf74
 8005fda:	f6c0 0301 	movt	r3, #2049	; 0x801
 8005fde:	9300      	str	r3, [sp, #0]
 8005fe0:	4620      	mov	r0, r4
 8005fe2:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005fe6:	f645 73a1 	movw	r3, #24481	; 0x5fa1
 8005fea:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005fee:	f00a fbb7 	bl	8010760 <chThdCreateStatic>
 8005ff2:	4602      	mov	r2, r0
 8005ff4:	f641 6360 	movw	r3, #7776	; 0x1e60
 8005ff8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ffc:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005ffe:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006002:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006006:	685c      	ldr	r4, [r3, #4]
 8006008:	f7ff ffc2 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 800600c:	4603      	mov	r3, r0
 800600e:	1f1a      	subs	r2, r3, #4
 8006010:	f640 7378 	movw	r3, #3960	; 0xf78
 8006014:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006018:	9300      	str	r3, [sp, #0]
 800601a:	4620      	mov	r0, r4
 800601c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006020:	f645 73a1 	movw	r3, #24481	; 0x5fa1
 8006024:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006028:	f00a fb9a 	bl	8010760 <chThdCreateStatic>
 800602c:	4602      	mov	r2, r0
 800602e:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006032:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006036:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8006038:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 800603c:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006040:	689c      	ldr	r4, [r3, #8]
 8006042:	f7ff ffa5 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 8006046:	4603      	mov	r3, r0
 8006048:	1eda      	subs	r2, r3, #3
 800604a:	f640 737c 	movw	r3, #3964	; 0xf7c
 800604e:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006052:	9300      	str	r3, [sp, #0]
 8006054:	4620      	mov	r0, r4
 8006056:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800605a:	f645 73a1 	movw	r3, #24481	; 0x5fa1
 800605e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006062:	f00a fb7d 	bl	8010760 <chThdCreateStatic>
 8006066:	4602      	mov	r2, r0
 8006068:	f641 6360 	movw	r3, #7776	; 0x1e60
 800606c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006070:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8006072:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006076:	f6c0 0301 	movt	r3, #2049	; 0x801
 800607a:	68dc      	ldr	r4, [r3, #12]
 800607c:	f7ff ff88 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 8006080:	4603      	mov	r3, r0
 8006082:	1e9a      	subs	r2, r3, #2
 8006084:	f640 7380 	movw	r3, #3968	; 0xf80
 8006088:	f6c0 0301 	movt	r3, #2049	; 0x801
 800608c:	9300      	str	r3, [sp, #0]
 800608e:	4620      	mov	r0, r4
 8006090:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006094:	f645 73a1 	movw	r3, #24481	; 0x5fa1
 8006098:	f6c0 0300 	movt	r3, #2048	; 0x800
 800609c:	f00a fb60 	bl	8010760 <chThdCreateStatic>
 80060a0:	4602      	mov	r2, r0
 80060a2:	f641 6360 	movw	r3, #7776	; 0x1e60
 80060a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060aa:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80060ac:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80060b0:	f6c0 0301 	movt	r3, #2049	; 0x801
 80060b4:	691c      	ldr	r4, [r3, #16]
 80060b6:	f7ff ff6b 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 80060ba:	4603      	mov	r3, r0
 80060bc:	1e5a      	subs	r2, r3, #1
 80060be:	f640 7384 	movw	r3, #3972	; 0xf84
 80060c2:	f6c0 0301 	movt	r3, #2049	; 0x801
 80060c6:	9300      	str	r3, [sp, #0]
 80060c8:	4620      	mov	r0, r4
 80060ca:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80060ce:	f645 73a1 	movw	r3, #24481	; 0x5fa1
 80060d2:	f6c0 0300 	movt	r3, #2048	; 0x800
 80060d6:	f00a fb43 	bl	8010760 <chThdCreateStatic>
 80060da:	4602      	mov	r2, r0
 80060dc:	f641 6360 	movw	r3, #7776	; 0x1e60
 80060e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060e4:	611a      	str	r2, [r3, #16]
  test_wait_threads();
 80060e6:	f002 facb 	bl	8008680 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 80060ea:	2001      	movs	r0, #1
 80060ec:	f640 7188 	movw	r1, #3976	; 0xf88
 80060f0:	f6c0 0101 	movt	r1, #2049	; 0x801
 80060f4:	f002 fa4c 	bl	8008590 <_test_assert_sequence>
}
 80060f8:	b002      	add	sp, #8
 80060fa:	bd10      	pop	{r4, pc}
 80060fc:	f3af 8000 	nop.w

08006100 <thd2_execute.11596>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8006100:	b510      	push	{r4, lr}
 8006102:	b082      	sub	sp, #8

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8006104:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006108:	f6c0 0301 	movt	r3, #2049	; 0x801
 800610c:	685c      	ldr	r4, [r3, #4]
 800610e:	f7ff ff3f 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 8006112:	4603      	mov	r3, r0
 8006114:	1f1a      	subs	r2, r3, #4
 8006116:	f640 7378 	movw	r3, #3960	; 0xf78
 800611a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800611e:	9300      	str	r3, [sp, #0]
 8006120:	4620      	mov	r0, r4
 8006122:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006126:	f645 73a1 	movw	r3, #24481	; 0x5fa1
 800612a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800612e:	f00a fb17 	bl	8010760 <chThdCreateStatic>
 8006132:	4602      	mov	r2, r0
 8006134:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006138:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800613c:	605a      	str	r2, [r3, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800613e:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006142:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006146:	681c      	ldr	r4, [r3, #0]
 8006148:	f7ff ff22 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 800614c:	4603      	mov	r3, r0
 800614e:	1f5a      	subs	r2, r3, #5
 8006150:	f640 7374 	movw	r3, #3956	; 0xf74
 8006154:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006158:	9300      	str	r3, [sp, #0]
 800615a:	4620      	mov	r0, r4
 800615c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006160:	f645 73a1 	movw	r3, #24481	; 0x5fa1
 8006164:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006168:	f00a fafa 	bl	8010760 <chThdCreateStatic>
 800616c:	4602      	mov	r2, r0
 800616e:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006172:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006176:	601a      	str	r2, [r3, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8006178:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 800617c:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006180:	691c      	ldr	r4, [r3, #16]
 8006182:	f7ff ff05 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 8006186:	4603      	mov	r3, r0
 8006188:	1e5a      	subs	r2, r3, #1
 800618a:	f640 7384 	movw	r3, #3972	; 0xf84
 800618e:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006192:	9300      	str	r3, [sp, #0]
 8006194:	4620      	mov	r0, r4
 8006196:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800619a:	f645 73a1 	movw	r3, #24481	; 0x5fa1
 800619e:	f6c0 0300 	movt	r3, #2048	; 0x800
 80061a2:	f00a fadd 	bl	8010760 <chThdCreateStatic>
 80061a6:	4602      	mov	r2, r0
 80061a8:	f641 6360 	movw	r3, #7776	; 0x1e60
 80061ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80061b0:	611a      	str	r2, [r3, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80061b2:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80061b6:	f6c0 0301 	movt	r3, #2049	; 0x801
 80061ba:	68dc      	ldr	r4, [r3, #12]
 80061bc:	f7ff fee8 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 80061c0:	4603      	mov	r3, r0
 80061c2:	1e9a      	subs	r2, r3, #2
 80061c4:	f640 7380 	movw	r3, #3968	; 0xf80
 80061c8:	f6c0 0301 	movt	r3, #2049	; 0x801
 80061cc:	9300      	str	r3, [sp, #0]
 80061ce:	4620      	mov	r0, r4
 80061d0:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80061d4:	f645 73a1 	movw	r3, #24481	; 0x5fa1
 80061d8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80061dc:	f00a fac0 	bl	8010760 <chThdCreateStatic>
 80061e0:	4602      	mov	r2, r0
 80061e2:	f641 6360 	movw	r3, #7776	; 0x1e60
 80061e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80061ea:	60da      	str	r2, [r3, #12]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
 80061ec:	f7ff fe80 	bl	8005ef0 <chSysLock.11592.4229>
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80061f0:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80061f4:	f6c0 0301 	movt	r3, #2049	; 0x801
 80061f8:	689c      	ldr	r4, [r3, #8]
 80061fa:	f7ff fec9 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 80061fe:	4603      	mov	r3, r0
 8006200:	1eda      	subs	r2, r3, #3
 8006202:	f640 737c 	movw	r3, #3964	; 0xf7c
 8006206:	f6c0 0301 	movt	r3, #2049	; 0x801
 800620a:	9300      	str	r3, [sp, #0]
 800620c:	4620      	mov	r0, r4
 800620e:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006212:	f645 73a1 	movw	r3, #24481	; 0x5fa1
 8006216:	f6c0 0300 	movt	r3, #2048	; 0x800
 800621a:	f00a fa61 	bl	80106e0 <chThdCreateI>
 800621e:	4602      	mov	r2, r0
 8006220:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006224:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006228:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 800622a:	f7ff fe69 	bl	8005f00 <chSysUnlock.11594.4227>
  chThdStart(threads[2]);
 800622e:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006232:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006236:	689b      	ldr	r3, [r3, #8]
 8006238:	4618      	mov	r0, r3
 800623a:	f007 fb99 	bl	800d970 <chThdStart>
  test_wait_threads();
 800623e:	f002 fa1f 	bl	8008680 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8006242:	2001      	movs	r0, #1
 8006244:	f640 7188 	movw	r1, #3976	; 0xf88
 8006248:	f6c0 0101 	movt	r1, #2049	; 0x801
 800624c:	f002 f9a0 	bl	8008590 <_test_assert_sequence>
}
 8006250:	b002      	add	sp, #8
 8006252:	bd10      	pop	{r4, pc}
 8006254:	f3af 8000 	nop.w
 8006258:	f3af 8000 	nop.w
 800625c:	f3af 8000 	nop.w

08006260 <thd3_execute.11600>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 8006260:	b500      	push	{lr}
 8006262:	b083      	sub	sp, #12
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
 8006264:	f7ff fe94 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 8006268:	9001      	str	r0, [sp, #4]
  p1 = chThdSetPriority(prio + 1);
 800626a:	9b01      	ldr	r3, [sp, #4]
 800626c:	3301      	adds	r3, #1
 800626e:	4618      	mov	r0, r3
 8006270:	f007 fb8e 	bl	800d990 <chThdSetPriority>
 8006274:	9000      	str	r0, [sp, #0]
  test_assert(1, p1 == prio,
 8006276:	9a00      	ldr	r2, [sp, #0]
 8006278:	9b01      	ldr	r3, [sp, #4]
 800627a:	429a      	cmp	r2, r3
 800627c:	bf14      	ite	ne
 800627e:	2300      	movne	r3, #0
 8006280:	2301      	moveq	r3, #1
 8006282:	b2db      	uxtb	r3, r3
 8006284:	2001      	movs	r0, #1
 8006286:	4619      	mov	r1, r3
 8006288:	f002 f96a 	bl	8008560 <_test_assert>
 800628c:	4603      	mov	r3, r0
 800628e:	2b00      	cmp	r3, #0
 8006290:	f040 80d1 	bne.w	8006436 <thd3_execute.11600+0x1d6>
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 8006294:	f7ff fe7c 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 8006298:	4602      	mov	r2, r0
 800629a:	9b01      	ldr	r3, [sp, #4]
 800629c:	3301      	adds	r3, #1
 800629e:	429a      	cmp	r2, r3
 80062a0:	bf14      	ite	ne
 80062a2:	2300      	movne	r3, #0
 80062a4:	2301      	moveq	r3, #1
 80062a6:	b2db      	uxtb	r3, r3
 80062a8:	2002      	movs	r0, #2
 80062aa:	4619      	mov	r1, r3
 80062ac:	f002 f958 	bl	8008560 <_test_assert>
 80062b0:	4603      	mov	r3, r0
 80062b2:	2b00      	cmp	r3, #0
 80062b4:	f040 80bf 	bne.w	8006436 <thd3_execute.11600+0x1d6>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 80062b8:	9800      	ldr	r0, [sp, #0]
 80062ba:	f007 fb69 	bl	800d990 <chThdSetPriority>
 80062be:	9000      	str	r0, [sp, #0]
  test_assert(3, p1 == prio + 1,
 80062c0:	9b01      	ldr	r3, [sp, #4]
 80062c2:	1c5a      	adds	r2, r3, #1
 80062c4:	9b00      	ldr	r3, [sp, #0]
 80062c6:	429a      	cmp	r2, r3
 80062c8:	bf14      	ite	ne
 80062ca:	2300      	movne	r3, #0
 80062cc:	2301      	moveq	r3, #1
 80062ce:	b2db      	uxtb	r3, r3
 80062d0:	2003      	movs	r0, #3
 80062d2:	4619      	mov	r1, r3
 80062d4:	f002 f944 	bl	8008560 <_test_assert>
 80062d8:	4603      	mov	r3, r0
 80062da:	2b00      	cmp	r3, #0
 80062dc:	f040 80ab 	bne.w	8006436 <thd3_execute.11600+0x1d6>
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 80062e0:	f7ff fe56 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 80062e4:	4602      	mov	r2, r0
 80062e6:	9b01      	ldr	r3, [sp, #4]
 80062e8:	429a      	cmp	r2, r3
 80062ea:	bf14      	ite	ne
 80062ec:	2300      	movne	r3, #0
 80062ee:	2301      	moveq	r3, #1
 80062f0:	b2db      	uxtb	r3, r3
 80062f2:	2004      	movs	r0, #4
 80062f4:	4619      	mov	r1, r3
 80062f6:	f002 f933 	bl	8008560 <_test_assert>
 80062fa:	4603      	mov	r3, r0
 80062fc:	2b00      	cmp	r3, #0
 80062fe:	f040 809a 	bne.w	8006436 <thd3_execute.11600+0x1d6>
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
 8006302:	f7ff fdf5 	bl	8005ef0 <chSysLock.11592.4229>
  chThdGetSelfX()->p_prio += 2;
 8006306:	f7ff fe3b 	bl	8005f80 <chThdGetSelfX.11499.4221>
 800630a:	4603      	mov	r3, r0
 800630c:	689a      	ldr	r2, [r3, #8]
 800630e:	3202      	adds	r2, #2
 8006310:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 8006312:	f7ff fdf5 	bl	8005f00 <chSysUnlock.11594.4227>
  test_assert(5, chThdGetPriorityX() == prio + 2,
 8006316:	f7ff fe3b 	bl	8005f90 <chThdGetPriorityX.11585.4219>
 800631a:	4602      	mov	r2, r0
 800631c:	9b01      	ldr	r3, [sp, #4]
 800631e:	3302      	adds	r3, #2
 8006320:	429a      	cmp	r2, r3
 8006322:	bf14      	ite	ne
 8006324:	2300      	movne	r3, #0
 8006326:	2301      	moveq	r3, #1
 8006328:	b2db      	uxtb	r3, r3
 800632a:	2005      	movs	r0, #5
 800632c:	4619      	mov	r1, r3
 800632e:	f002 f917 	bl	8008560 <_test_assert>
 8006332:	4603      	mov	r3, r0
 8006334:	2b00      	cmp	r3, #0
 8006336:	d17e      	bne.n	8006436 <thd3_execute.11600+0x1d6>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 8006338:	9b01      	ldr	r3, [sp, #4]
 800633a:	3301      	adds	r3, #1
 800633c:	4618      	mov	r0, r3
 800633e:	f007 fb27 	bl	800d990 <chThdSetPriority>
 8006342:	9000      	str	r0, [sp, #0]
  test_assert(6, p1 == prio,
 8006344:	9a00      	ldr	r2, [sp, #0]
 8006346:	9b01      	ldr	r3, [sp, #4]
 8006348:	429a      	cmp	r2, r3
 800634a:	bf14      	ite	ne
 800634c:	2300      	movne	r3, #0
 800634e:	2301      	moveq	r3, #1
 8006350:	b2db      	uxtb	r3, r3
 8006352:	2006      	movs	r0, #6
 8006354:	4619      	mov	r1, r3
 8006356:	f002 f903 	bl	8008560 <_test_assert>
 800635a:	4603      	mov	r3, r0
 800635c:	2b00      	cmp	r3, #0
 800635e:	d16a      	bne.n	8006436 <thd3_execute.11600+0x1d6>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 8006360:	f7ff fe0e 	bl	8005f80 <chThdGetSelfX.11499.4221>
 8006364:	4603      	mov	r3, r0
 8006366:	689a      	ldr	r2, [r3, #8]
 8006368:	9b01      	ldr	r3, [sp, #4]
 800636a:	3302      	adds	r3, #2
 800636c:	429a      	cmp	r2, r3
 800636e:	bf14      	ite	ne
 8006370:	2300      	movne	r3, #0
 8006372:	2301      	moveq	r3, #1
 8006374:	b2db      	uxtb	r3, r3
 8006376:	2007      	movs	r0, #7
 8006378:	4619      	mov	r1, r3
 800637a:	f002 f8f1 	bl	8008560 <_test_assert>
 800637e:	4603      	mov	r3, r0
 8006380:	2b00      	cmp	r3, #0
 8006382:	d158      	bne.n	8006436 <thd3_execute.11600+0x1d6>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 8006384:	f7ff fdfc 	bl	8005f80 <chThdGetSelfX.11499.4221>
 8006388:	4603      	mov	r3, r0
 800638a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800638c:	9b01      	ldr	r3, [sp, #4]
 800638e:	3301      	adds	r3, #1
 8006390:	429a      	cmp	r2, r3
 8006392:	bf14      	ite	ne
 8006394:	2300      	movne	r3, #0
 8006396:	2301      	moveq	r3, #1
 8006398:	b2db      	uxtb	r3, r3
 800639a:	2008      	movs	r0, #8
 800639c:	4619      	mov	r1, r3
 800639e:	f002 f8df 	bl	8008560 <_test_assert>
 80063a2:	4603      	mov	r3, r0
 80063a4:	2b00      	cmp	r3, #0
 80063a6:	d146      	bne.n	8006436 <thd3_execute.11600+0x1d6>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 80063a8:	9b01      	ldr	r3, [sp, #4]
 80063aa:	3303      	adds	r3, #3
 80063ac:	4618      	mov	r0, r3
 80063ae:	f007 faef 	bl	800d990 <chThdSetPriority>
 80063b2:	9000      	str	r0, [sp, #0]
  test_assert(9, p1 == prio + 1,
 80063b4:	9b01      	ldr	r3, [sp, #4]
 80063b6:	1c5a      	adds	r2, r3, #1
 80063b8:	9b00      	ldr	r3, [sp, #0]
 80063ba:	429a      	cmp	r2, r3
 80063bc:	bf14      	ite	ne
 80063be:	2300      	movne	r3, #0
 80063c0:	2301      	moveq	r3, #1
 80063c2:	b2db      	uxtb	r3, r3
 80063c4:	2009      	movs	r0, #9
 80063c6:	4619      	mov	r1, r3
 80063c8:	f002 f8ca 	bl	8008560 <_test_assert>
 80063cc:	4603      	mov	r3, r0
 80063ce:	2b00      	cmp	r3, #0
 80063d0:	d131      	bne.n	8006436 <thd3_execute.11600+0x1d6>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 80063d2:	f7ff fdd5 	bl	8005f80 <chThdGetSelfX.11499.4221>
 80063d6:	4603      	mov	r3, r0
 80063d8:	689a      	ldr	r2, [r3, #8]
 80063da:	9b01      	ldr	r3, [sp, #4]
 80063dc:	3303      	adds	r3, #3
 80063de:	429a      	cmp	r2, r3
 80063e0:	bf14      	ite	ne
 80063e2:	2300      	movne	r3, #0
 80063e4:	2301      	moveq	r3, #1
 80063e6:	b2db      	uxtb	r3, r3
 80063e8:	200a      	movs	r0, #10
 80063ea:	4619      	mov	r1, r3
 80063ec:	f002 f8b8 	bl	8008560 <_test_assert>
 80063f0:	4603      	mov	r3, r0
 80063f2:	2b00      	cmp	r3, #0
 80063f4:	d11f      	bne.n	8006436 <thd3_execute.11600+0x1d6>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 80063f6:	f7ff fdc3 	bl	8005f80 <chThdGetSelfX.11499.4221>
 80063fa:	4603      	mov	r3, r0
 80063fc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80063fe:	9b01      	ldr	r3, [sp, #4]
 8006400:	3303      	adds	r3, #3
 8006402:	429a      	cmp	r2, r3
 8006404:	bf14      	ite	ne
 8006406:	2300      	movne	r3, #0
 8006408:	2301      	moveq	r3, #1
 800640a:	b2db      	uxtb	r3, r3
 800640c:	200b      	movs	r0, #11
 800640e:	4619      	mov	r1, r3
 8006410:	f002 f8a6 	bl	8008560 <_test_assert>
 8006414:	4603      	mov	r3, r0
 8006416:	2b00      	cmp	r3, #0
 8006418:	d10d      	bne.n	8006436 <thd3_execute.11600+0x1d6>
              "unexpected real priority level");

  chSysLock();
 800641a:	f7ff fd69 	bl	8005ef0 <chSysLock.11592.4229>
  chThdGetSelfX()->p_prio = prio;
 800641e:	f7ff fdaf 	bl	8005f80 <chThdGetSelfX.11499.4221>
 8006422:	4603      	mov	r3, r0
 8006424:	9a01      	ldr	r2, [sp, #4]
 8006426:	609a      	str	r2, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 8006428:	f7ff fdaa 	bl	8005f80 <chThdGetSelfX.11499.4221>
 800642c:	4603      	mov	r3, r0
 800642e:	9a01      	ldr	r2, [sp, #4]
 8006430:	641a      	str	r2, [r3, #64]	; 0x40
  chSysUnlock();
 8006432:	f7ff fd65 	bl	8005f00 <chSysUnlock.11594.4227>
#endif
}
 8006436:	b003      	add	sp, #12
 8006438:	f85d fb04 	ldr.w	pc, [sp], #4
 800643c:	f3af 8000 	nop.w

08006440 <thd4_execute.11602>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 8006440:	b500      	push	{lr}
 8006442:	b083      	sub	sp, #12
  systime_t time;

  test_wait_tick();
 8006444:	f002 f94c 	bl	80086e0 <test_wait_tick>

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
 8006448:	f7ff fd8a 	bl	8005f60 <chVTGetSystemTime.11598.4223>
 800644c:	9001      	str	r0, [sp, #4]
  chThdSleepMicroseconds(100000);
 800644e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006452:	f007 fafd 	bl	800da50 <chThdSleep>
  test_assert_time_window(1,
 8006456:	9b01      	ldr	r3, [sp, #4]
 8006458:	f503 727a 	add.w	r2, r3, #1000	; 0x3e8
 800645c:	9b01      	ldr	r3, [sp, #4]
 800645e:	f203 33eb 	addw	r3, r3, #1003	; 0x3eb
 8006462:	2001      	movs	r0, #1
 8006464:	4611      	mov	r1, r2
 8006466:	461a      	mov	r2, r3
 8006468:	f002 f8ca 	bl	8008600 <_test_assert_time_window>
 800646c:	4603      	mov	r3, r0
 800646e:	2b00      	cmp	r3, #0
 8006470:	d13b      	bne.n	80064ea <thd4_execute.11602+0xaa>
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
 8006472:	f7ff fd75 	bl	8005f60 <chVTGetSystemTime.11598.4223>
 8006476:	9001      	str	r0, [sp, #4]
  chThdSleepMilliseconds(100);
 8006478:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800647c:	f007 fae8 	bl	800da50 <chThdSleep>
  test_assert_time_window(2,
 8006480:	9b01      	ldr	r3, [sp, #4]
 8006482:	f503 727a 	add.w	r2, r3, #1000	; 0x3e8
 8006486:	9b01      	ldr	r3, [sp, #4]
 8006488:	f203 33eb 	addw	r3, r3, #1003	; 0x3eb
 800648c:	2002      	movs	r0, #2
 800648e:	4611      	mov	r1, r2
 8006490:	461a      	mov	r2, r3
 8006492:	f002 f8b5 	bl	8008600 <_test_assert_time_window>
 8006496:	4603      	mov	r3, r0
 8006498:	2b00      	cmp	r3, #0
 800649a:	d126      	bne.n	80064ea <thd4_execute.11602+0xaa>
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
 800649c:	f7ff fd60 	bl	8005f60 <chVTGetSystemTime.11598.4223>
 80064a0:	9001      	str	r0, [sp, #4]
  chThdSleepSeconds(1);
 80064a2:	f242 7010 	movw	r0, #10000	; 0x2710
 80064a6:	f007 fad3 	bl	800da50 <chThdSleep>
  test_assert_time_window(3,
 80064aa:	9b01      	ldr	r3, [sp, #4]
 80064ac:	f503 521c 	add.w	r2, r3, #9984	; 0x2700
 80064b0:	3210      	adds	r2, #16
 80064b2:	9b01      	ldr	r3, [sp, #4]
 80064b4:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 80064b8:	3313      	adds	r3, #19
 80064ba:	2003      	movs	r0, #3
 80064bc:	4611      	mov	r1, r2
 80064be:	461a      	mov	r2, r3
 80064c0:	f002 f89e 	bl	8008600 <_test_assert_time_window>
 80064c4:	4603      	mov	r3, r0
 80064c6:	2b00      	cmp	r3, #0
 80064c8:	d10f      	bne.n	80064ea <thd4_execute.11602+0xaa>
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 80064ca:	f7ff fd49 	bl	8005f60 <chVTGetSystemTime.11598.4223>
 80064ce:	4603      	mov	r3, r0
 80064d0:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 80064d4:	9301      	str	r3, [sp, #4]
  chThdSleepUntil(time);
 80064d6:	9801      	ldr	r0, [sp, #4]
 80064d8:	f007 faca 	bl	800da70 <chThdSleepUntil>
  test_assert_time_window(4,
 80064dc:	9b01      	ldr	r3, [sp, #4]
 80064de:	3303      	adds	r3, #3
 80064e0:	2004      	movs	r0, #4
 80064e2:	9901      	ldr	r1, [sp, #4]
 80064e4:	461a      	mov	r2, r3
 80064e6:	f002 f88b 	bl	8008600 <_test_assert_time_window>
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 80064ea:	b003      	add	sp, #12
 80064ec:	f85d fb04 	ldr.w	pc, [sp], #4

080064f0 <port_lock.11730.4205>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80064f0:	b082      	sub	sp, #8
 80064f2:	2320      	movs	r3, #32
 80064f4:	9301      	str	r3, [sp, #4]
 80064f6:	9b01      	ldr	r3, [sp, #4]
 80064f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80064fc:	b002      	add	sp, #8
 80064fe:	4770      	bx	lr

08006500 <port_unlock.11733.4203>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006500:	b082      	sub	sp, #8
 8006502:	2300      	movs	r3, #0
 8006504:	9301      	str	r3, [sp, #4]
 8006506:	9b01      	ldr	r3, [sp, #4]
 8006508:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800650c:	b002      	add	sp, #8
 800650e:	4770      	bx	lr

08006510 <st_lld_get_counter.11735.4201>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8006510:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006514:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8006516:	4618      	mov	r0, r3
 8006518:	4770      	bx	lr
 800651a:	bf00      	nop
 800651c:	f3af 8000 	nop.w

08006520 <port_timer_get_time.11740.4199>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8006520:	b508      	push	{r3, lr}

  return stGetCounter();
 8006522:	f7ff fff5 	bl	8006510 <st_lld_get_counter.11735.4201>
 8006526:	4603      	mov	r3, r0
}
 8006528:	4618      	mov	r0, r3
 800652a:	bd08      	pop	{r3, pc}
 800652c:	f3af 8000 	nop.w

08006530 <queue_isempty.11742.4196>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 8006530:	b082      	sub	sp, #8
 8006532:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8006534:	9b01      	ldr	r3, [sp, #4]
 8006536:	681a      	ldr	r2, [r3, #0]
 8006538:	9b01      	ldr	r3, [sp, #4]
 800653a:	429a      	cmp	r2, r3
 800653c:	bf14      	ite	ne
 800653e:	2300      	movne	r3, #0
 8006540:	2301      	moveq	r3, #1
 8006542:	b2db      	uxtb	r3, r3
}
 8006544:	4618      	mov	r0, r3
 8006546:	b002      	add	sp, #8
 8006548:	4770      	bx	lr
 800654a:	bf00      	nop
 800654c:	f3af 8000 	nop.w

08006550 <chSysLock.11859.4194>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006550:	b508      	push	{r3, lr}

  port_lock();
 8006552:	f7ff ffcd 	bl	80064f0 <port_lock.11730.4205>
  _stats_start_measure_crit_thd();
 8006556:	f007 fd13 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800655a:	f009 f8c1 	bl	800f6e0 <_dbg_check_lock>
}
 800655e:	bd08      	pop	{r3, pc}

08006560 <chSysUnlock.11867.4192>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8006560:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8006562:	f009 f8dd 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8006566:	f007 fd13 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800656a:	f640 5350 	movw	r3, #3408	; 0xd50
 800656e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006572:	681a      	ldr	r2, [r3, #0]
 8006574:	f640 5350 	movw	r3, #3408	; 0xd50
 8006578:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800657c:	429a      	cmp	r2, r3
 800657e:	d013      	beq.n	80065a8 <chSysUnlock.11867.4192+0x48>
 8006580:	f640 5350 	movw	r3, #3408	; 0xd50
 8006584:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006588:	699b      	ldr	r3, [r3, #24]
 800658a:	689a      	ldr	r2, [r3, #8]
 800658c:	f640 5350 	movw	r3, #3408	; 0xd50
 8006590:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006594:	681b      	ldr	r3, [r3, #0]
 8006596:	689b      	ldr	r3, [r3, #8]
 8006598:	429a      	cmp	r2, r3
 800659a:	d205      	bcs.n	80065a8 <chSysUnlock.11867.4192+0x48>
 800659c:	f242 00b0 	movw	r0, #8368	; 0x20b0
 80065a0:	f6c0 0001 	movt	r0, #2049	; 0x801
 80065a4:	f008 fef4 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80065a8:	f7ff ffaa 	bl	8006500 <port_unlock.11733.4203>
}
 80065ac:	bd08      	pop	{r3, pc}
 80065ae:	bf00      	nop

080065b0 <chVTGetSystemTimeX.11830.4190>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80065b0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80065b2:	f7ff ffb5 	bl	8006520 <port_timer_get_time.11740.4199>
 80065b6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80065b8:	4618      	mov	r0, r3
 80065ba:	bd08      	pop	{r3, pc}
 80065bc:	f3af 8000 	nop.w

080065c0 <chVTGetSystemTime.11871.4187>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 80065c0:	b500      	push	{lr}
 80065c2:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 80065c4:	f7ff ffc4 	bl	8006550 <chSysLock.11859.4194>
  systime = chVTGetSystemTimeX();
 80065c8:	f7ff fff2 	bl	80065b0 <chVTGetSystemTimeX.11830.4190>
 80065cc:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 80065ce:	f7ff ffc7 	bl	8006560 <chSysUnlock.11867.4192>

  return systime;
 80065d2:	9b01      	ldr	r3, [sp, #4]
}
 80065d4:	4618      	mov	r0, r3
 80065d6:	b003      	add	sp, #12
 80065d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80065dc:	f3af 8000 	nop.w

080065e0 <chThdGetSelfX.11832.4185>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80065e0:	f640 5350 	movw	r3, #3408	; 0xd50
 80065e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80065e8:	699b      	ldr	r3, [r3, #24]
}
 80065ea:	4618      	mov	r0, r3
 80065ec:	4770      	bx	lr
 80065ee:	bf00      	nop

080065f0 <chThdGetPriorityX.11834.4183>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 80065f0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 80065f2:	f7ff fff5 	bl	80065e0 <chThdGetSelfX.11832.4185>
 80065f6:	4603      	mov	r3, r0
 80065f8:	689b      	ldr	r3, [r3, #8]
}
 80065fa:	4618      	mov	r0, r3
 80065fc:	bd08      	pop	{r3, pc}
 80065fe:	bf00      	nop

08006600 <chSemGetCounterI.11861.4180>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 8006600:	b500      	push	{lr}
 8006602:	b083      	sub	sp, #12
 8006604:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8006606:	f009 f93b 	bl	800f880 <chDbgCheckClassI>

  return sp->s_cnt;
 800660a:	9b01      	ldr	r3, [sp, #4]
 800660c:	689b      	ldr	r3, [r3, #8]
}
 800660e:	4618      	mov	r0, r3
 8006610:	b003      	add	sp, #12
 8006612:	f85d fb04 	ldr.w	pc, [sp], #4
 8006616:	bf00      	nop
 8006618:	f3af 8000 	nop.w
 800661c:	f3af 8000 	nop.w

08006620 <chBSemObjectInit.11842.4176>:
 *                      - @a true, the initial state is taken.
 *                      .
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {
 8006620:	b500      	push	{lr}
 8006622:	b083      	sub	sp, #12
 8006624:	9001      	str	r0, [sp, #4]
 8006626:	460b      	mov	r3, r1
 8006628:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemObjectInit(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800662c:	9a01      	ldr	r2, [sp, #4]
 800662e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006632:	2b00      	cmp	r3, #0
 8006634:	d001      	beq.n	800663a <chBSemObjectInit.11842.4176+0x1a>
 8006636:	2300      	movs	r3, #0
 8006638:	e000      	b.n	800663c <chBSemObjectInit.11842.4176+0x1c>
 800663a:	2301      	movs	r3, #1
 800663c:	4610      	mov	r0, r2
 800663e:	4619      	mov	r1, r3
 8006640:	f007 ff4e 	bl	800e4e0 <chSemObjectInit>
}
 8006644:	b003      	add	sp, #12
 8006646:	f85d fb04 	ldr.w	pc, [sp], #4
 800664a:	bf00      	nop
 800664c:	f3af 8000 	nop.w

08006650 <chBSemWait.11850.4173>:
 * @retval MSG_RESET    if the binary semaphore has been reset using
 *                      @p bsemReset().
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {
 8006650:	b500      	push	{lr}
 8006652:	b083      	sub	sp, #12
 8006654:	9001      	str	r0, [sp, #4]

  return chSemWait(&bsp->bs_sem);
 8006656:	9b01      	ldr	r3, [sp, #4]
 8006658:	4618      	mov	r0, r3
 800665a:	f007 ffc9 	bl	800e5f0 <chSemWait>
 800665e:	4603      	mov	r3, r0
}
 8006660:	4618      	mov	r0, r3
 8006662:	b003      	add	sp, #12
 8006664:	f85d fb04 	ldr.w	pc, [sp], #4
 8006668:	f3af 8000 	nop.w
 800666c:	f3af 8000 	nop.w

08006670 <chBSemReset.11889.4169>:
 *                      - @a true, the new state is taken.
 *                      .
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {
 8006670:	b500      	push	{lr}
 8006672:	b083      	sub	sp, #12
 8006674:	9001      	str	r0, [sp, #4]
 8006676:	460b      	mov	r3, r1
 8006678:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemReset(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800667c:	9a01      	ldr	r2, [sp, #4]
 800667e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006682:	2b00      	cmp	r3, #0
 8006684:	d001      	beq.n	800668a <chBSemReset.11889.4169+0x1a>
 8006686:	2300      	movs	r3, #0
 8006688:	e000      	b.n	800668c <chBSemReset.11889.4169+0x1c>
 800668a:	2301      	movs	r3, #1
 800668c:	4610      	mov	r0, r2
 800668e:	4619      	mov	r1, r3
 8006690:	f007 ff46 	bl	800e520 <chSemReset>
}
 8006694:	b003      	add	sp, #12
 8006696:	f85d fb04 	ldr.w	pc, [sp], #4
 800669a:	bf00      	nop
 800669c:	f3af 8000 	nop.w

080066a0 <chBSemSignalI.11876.4166>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {
 80066a0:	b500      	push	{lr}
 80066a2:	b083      	sub	sp, #12
 80066a4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80066a6:	f009 f8eb 	bl	800f880 <chDbgCheckClassI>

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 80066aa:	9b01      	ldr	r3, [sp, #4]
 80066ac:	689b      	ldr	r3, [r3, #8]
 80066ae:	2b00      	cmp	r3, #0
 80066b0:	dc03      	bgt.n	80066ba <chBSemSignalI.11876.4166+0x1a>
    chSemSignalI(&bsp->bs_sem);
 80066b2:	9b01      	ldr	r3, [sp, #4]
 80066b4:	4618      	mov	r0, r3
 80066b6:	f008 f8d3 	bl	800e860 <chSemSignalI>
  }
}
 80066ba:	b003      	add	sp, #12
 80066bc:	f85d fb04 	ldr.w	pc, [sp], #4

080066c0 <chBSemSignal.11879.4163>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @api
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {
 80066c0:	b500      	push	{lr}
 80066c2:	b083      	sub	sp, #12
 80066c4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80066c6:	f7ff ff43 	bl	8006550 <chSysLock.11859.4194>
  chBSemSignalI(bsp);
 80066ca:	9801      	ldr	r0, [sp, #4]
 80066cc:	f7ff ffe8 	bl	80066a0 <chBSemSignalI.11876.4166>
  chSchRescheduleS();
 80066d0:	f009 fd46 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 80066d4:	f7ff ff44 	bl	8006560 <chSysUnlock.11867.4192>
}
 80066d8:	b003      	add	sp, #12
 80066da:	f85d fb04 	ldr.w	pc, [sp], #4
 80066de:	bf00      	nop

080066e0 <chBSemGetStateI.11864.4154>:
 * @retval false        if the binary semaphore is not taken.
 * @retval true         if the binary semaphore is taken.
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {
 80066e0:	b500      	push	{lr}
 80066e2:	b083      	sub	sp, #12
 80066e4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80066e6:	f009 f8cb 	bl	800f880 <chDbgCheckClassI>

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 80066ea:	9b01      	ldr	r3, [sp, #4]
 80066ec:	689b      	ldr	r3, [r3, #8]
 80066ee:	2b00      	cmp	r3, #0
 80066f0:	bfcc      	ite	gt
 80066f2:	2300      	movgt	r3, #0
 80066f4:	2301      	movle	r3, #1
 80066f6:	b2db      	uxtb	r3, r3
}
 80066f8:	4618      	mov	r0, r3
 80066fa:	b003      	add	sp, #12
 80066fc:	f85d fb04 	ldr.w	pc, [sp], #4

08006700 <sem1_setup.11836>:
 * The test expects that the threads reach their goal in FIFO order or
 * priority order depending on the CH_CFG_USE_SEMAPHORES_PRIORITY configuration
 * setting.
 */

static void sem1_setup(void) {
 8006700:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 8006702:	f640 003c 	movw	r0, #2108	; 0x83c
 8006706:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800670a:	2100      	movs	r1, #0
 800670c:	f007 fee8 	bl	800e4e0 <chSemObjectInit>
}
 8006710:	bd08      	pop	{r3, pc}
 8006712:	bf00      	nop
 8006714:	f3af 8000 	nop.w
 8006718:	f3af 8000 	nop.w
 800671c:	f3af 8000 	nop.w

08006720 <thread1.11853.4149>:

static THD_FUNCTION(thread1, p) {
 8006720:	b500      	push	{lr}
 8006722:	b083      	sub	sp, #12
 8006724:	9001      	str	r0, [sp, #4]

  chSemWait(&sem1);
 8006726:	f640 003c 	movw	r0, #2108	; 0x83c
 800672a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800672e:	f007 ff5f 	bl	800e5f0 <chSemWait>
  test_emit_token(*(char *)p);
 8006732:	9b01      	ldr	r3, [sp, #4]
 8006734:	781b      	ldrb	r3, [r3, #0]
 8006736:	4618      	mov	r0, r3
 8006738:	f001 feda 	bl	80084f0 <test_emit_token>
}
 800673c:	b003      	add	sp, #12
 800673e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006742:	bf00      	nop
 8006744:	f3af 8000 	nop.w
 8006748:	f3af 8000 	nop.w
 800674c:	f3af 8000 	nop.w

08006750 <sem1_execute.11869>:

static void sem1_execute(void) {
 8006750:	b510      	push	{r4, lr}
 8006752:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8006754:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006758:	f6c0 0301 	movt	r3, #2049	; 0x801
 800675c:	681c      	ldr	r4, [r3, #0]
 800675e:	f7ff ff47 	bl	80065f0 <chThdGetPriorityX.11834.4183>
 8006762:	4603      	mov	r3, r0
 8006764:	1d5a      	adds	r2, r3, #5
 8006766:	f640 7384 	movw	r3, #3972	; 0xf84
 800676a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800676e:	9300      	str	r3, [sp, #0]
 8006770:	4620      	mov	r0, r4
 8006772:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006776:	f246 7321 	movw	r3, #26401	; 0x6721
 800677a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800677e:	f009 ffef 	bl	8010760 <chThdCreateStatic>
 8006782:	4602      	mov	r2, r0
 8006784:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006788:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800678c:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800678e:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006792:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006796:	685c      	ldr	r4, [r3, #4]
 8006798:	f7ff ff2a 	bl	80065f0 <chThdGetPriorityX.11834.4183>
 800679c:	4603      	mov	r3, r0
 800679e:	1c5a      	adds	r2, r3, #1
 80067a0:	f640 7380 	movw	r3, #3968	; 0xf80
 80067a4:	f6c0 0301 	movt	r3, #2049	; 0x801
 80067a8:	9300      	str	r3, [sp, #0]
 80067aa:	4620      	mov	r0, r4
 80067ac:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80067b0:	f246 7321 	movw	r3, #26401	; 0x6721
 80067b4:	f6c0 0300 	movt	r3, #2048	; 0x800
 80067b8:	f009 ffd2 	bl	8010760 <chThdCreateStatic>
 80067bc:	4602      	mov	r2, r0
 80067be:	f641 6360 	movw	r3, #7776	; 0x1e60
 80067c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80067c6:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 80067c8:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80067cc:	f6c0 0301 	movt	r3, #2049	; 0x801
 80067d0:	689c      	ldr	r4, [r3, #8]
 80067d2:	f7ff ff0d 	bl	80065f0 <chThdGetPriorityX.11834.4183>
 80067d6:	4603      	mov	r3, r0
 80067d8:	1cda      	adds	r2, r3, #3
 80067da:	f640 737c 	movw	r3, #3964	; 0xf7c
 80067de:	f6c0 0301 	movt	r3, #2049	; 0x801
 80067e2:	9300      	str	r3, [sp, #0]
 80067e4:	4620      	mov	r0, r4
 80067e6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80067ea:	f246 7321 	movw	r3, #26401	; 0x6721
 80067ee:	f6c0 0300 	movt	r3, #2048	; 0x800
 80067f2:	f009 ffb5 	bl	8010760 <chThdCreateStatic>
 80067f6:	4602      	mov	r2, r0
 80067f8:	f641 6360 	movw	r3, #7776	; 0x1e60
 80067fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006800:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8006802:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006806:	f6c0 0301 	movt	r3, #2049	; 0x801
 800680a:	68dc      	ldr	r4, [r3, #12]
 800680c:	f7ff fef0 	bl	80065f0 <chThdGetPriorityX.11834.4183>
 8006810:	4603      	mov	r3, r0
 8006812:	1d1a      	adds	r2, r3, #4
 8006814:	f640 7378 	movw	r3, #3960	; 0xf78
 8006818:	f6c0 0301 	movt	r3, #2049	; 0x801
 800681c:	9300      	str	r3, [sp, #0]
 800681e:	4620      	mov	r0, r4
 8006820:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006824:	f246 7321 	movw	r3, #26401	; 0x6721
 8006828:	f6c0 0300 	movt	r3, #2048	; 0x800
 800682c:	f009 ff98 	bl	8010760 <chThdCreateStatic>
 8006830:	4602      	mov	r2, r0
 8006832:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006836:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800683a:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800683c:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006840:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006844:	691c      	ldr	r4, [r3, #16]
 8006846:	f7ff fed3 	bl	80065f0 <chThdGetPriorityX.11834.4183>
 800684a:	4603      	mov	r3, r0
 800684c:	1c9a      	adds	r2, r3, #2
 800684e:	f640 7374 	movw	r3, #3956	; 0xf74
 8006852:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006856:	9300      	str	r3, [sp, #0]
 8006858:	4620      	mov	r0, r4
 800685a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800685e:	f246 7321 	movw	r3, #26401	; 0x6721
 8006862:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006866:	f009 ff7b 	bl	8010760 <chThdCreateStatic>
 800686a:	4602      	mov	r2, r0
 800686c:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006870:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006874:	611a      	str	r2, [r3, #16]
  chSemSignal(&sem1);
 8006876:	f640 003c 	movw	r0, #2108	; 0x83c
 800687a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800687e:	f007 ffa7 	bl	800e7d0 <chSemSignal>
  chSemSignal(&sem1);
 8006882:	f640 003c 	movw	r0, #2108	; 0x83c
 8006886:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800688a:	f007 ffa1 	bl	800e7d0 <chSemSignal>
  chSemSignal(&sem1);
 800688e:	f640 003c 	movw	r0, #2108	; 0x83c
 8006892:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006896:	f007 ff9b 	bl	800e7d0 <chSemSignal>
  chSemSignal(&sem1);
 800689a:	f640 003c 	movw	r0, #2108	; 0x83c
 800689e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80068a2:	f007 ff95 	bl	800e7d0 <chSemSignal>
  chSemSignal(&sem1);
 80068a6:	f640 003c 	movw	r0, #2108	; 0x83c
 80068aa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80068ae:	f007 ff8f 	bl	800e7d0 <chSemSignal>
  test_wait_threads();
 80068b2:	f001 fee5 	bl	8008680 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 80068b6:	2001      	movs	r0, #1
 80068b8:	f640 7188 	movw	r1, #3976	; 0xf88
 80068bc:	f6c0 0101 	movt	r1, #2049	; 0x801
 80068c0:	f001 fe66 	bl	8008590 <_test_assert_sequence>
 80068c4:	4603      	mov	r3, r0
 80068c6:	2b00      	cmp	r3, #0
 80068c8:	d145      	bne.n	8006956 <sem1_execute.11869+0x206>
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80068ca:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 80068ce:	f6c0 0301 	movt	r3, #2049	; 0x801
 80068d2:	681c      	ldr	r4, [r3, #0]
 80068d4:	f7ff fe8c 	bl	80065f0 <chThdGetPriorityX.11834.4183>
 80068d8:	4603      	mov	r3, r0
 80068da:	1d5a      	adds	r2, r3, #5
 80068dc:	f640 7384 	movw	r3, #3972	; 0xf84
 80068e0:	f6c0 0301 	movt	r3, #2049	; 0x801
 80068e4:	9300      	str	r3, [sp, #0]
 80068e6:	4620      	mov	r0, r4
 80068e8:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80068ec:	f246 7321 	movw	r3, #26401	; 0x6721
 80068f0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80068f4:	f009 ff34 	bl	8010760 <chThdCreateStatic>
 80068f8:	4602      	mov	r2, r0
 80068fa:	f641 6360 	movw	r3, #7776	; 0x1e60
 80068fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006902:	601a      	str	r2, [r3, #0]
  chSysLock();
 8006904:	f7ff fe24 	bl	8006550 <chSysLock.11859.4194>
  chSemAddCounterI(&sem1, 2);
 8006908:	f640 003c 	movw	r0, #2108	; 0x83c
 800690c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006910:	2102      	movs	r1, #2
 8006912:	f007 ffed 	bl	800e8f0 <chSemAddCounterI>
  chSchRescheduleS();
 8006916:	f009 fc23 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 800691a:	f7ff fe21 	bl	8006560 <chSysUnlock.11867.4192>
  test_wait_threads();
 800691e:	f001 feaf 	bl	8008680 <test_wait_threads>
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 8006922:	f7ff fe15 	bl	8006550 <chSysLock.11859.4194>
 8006926:	f640 003c 	movw	r0, #2108	; 0x83c
 800692a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800692e:	f7ff fe67 	bl	8006600 <chSemGetCounterI.11861.4180>
 8006932:	4603      	mov	r3, r0
 8006934:	2b01      	cmp	r3, #1
 8006936:	bf14      	ite	ne
 8006938:	2300      	movne	r3, #0
 800693a:	2301      	moveq	r3, #1
 800693c:	b2db      	uxtb	r3, r3
 800693e:	2002      	movs	r0, #2
 8006940:	4619      	mov	r1, r3
 8006942:	f001 fe0d 	bl	8008560 <_test_assert>
 8006946:	4603      	mov	r3, r0
 8006948:	2b00      	cmp	r3, #0
 800694a:	d002      	beq.n	8006952 <sem1_execute.11869+0x202>
 800694c:	f7ff fe08 	bl	8006560 <chSysUnlock.11867.4192>
 8006950:	e001      	b.n	8006956 <sem1_execute.11869+0x206>
 8006952:	f7ff fe05 	bl	8006560 <chSysUnlock.11867.4192>
}
 8006956:	b002      	add	sp, #8
 8006958:	bd10      	pop	{r4, pc}
 800695a:	bf00      	nop
 800695c:	f3af 8000 	nop.w

08006960 <sem2_setup.11838>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem2_setup(void) {
 8006960:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 8006962:	f640 003c 	movw	r0, #2108	; 0x83c
 8006966:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800696a:	2100      	movs	r1, #0
 800696c:	f007 fdb8 	bl	800e4e0 <chSemObjectInit>
}
 8006970:	bd08      	pop	{r3, pc}
 8006972:	bf00      	nop
 8006974:	f3af 8000 	nop.w
 8006978:	f3af 8000 	nop.w
 800697c:	f3af 8000 	nop.w

08006980 <thread2.11873.4142>:

static THD_FUNCTION(thread2, p) {
 8006980:	b500      	push	{lr}
 8006982:	b083      	sub	sp, #12
 8006984:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 8006986:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800698a:	f007 f861 	bl	800da50 <chThdSleep>
  chSysLock();
 800698e:	f7ff fddf 	bl	8006550 <chSysLock.11859.4194>
  chSemSignalI(&sem1); /* For coverage reasons */
 8006992:	f640 003c 	movw	r0, #2108	; 0x83c
 8006996:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800699a:	f007 ff61 	bl	800e860 <chSemSignalI>
  chSchRescheduleS();
 800699e:	f009 fbdf 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 80069a2:	f7ff fddd 	bl	8006560 <chSysUnlock.11867.4192>
}
 80069a6:	b003      	add	sp, #12
 80069a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80069ac:	f3af 8000 	nop.w

080069b0 <sem2_execute.11885>:

static void sem2_execute(void) {
 80069b0:	b510      	push	{r4, lr}
 80069b2:	b086      	sub	sp, #24
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 80069b4:	f640 003c 	movw	r0, #2108	; 0x83c
 80069b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80069bc:	2100      	movs	r1, #0
 80069be:	f007 fe87 	bl	800e6d0 <chSemWaitTimeout>
 80069c2:	9004      	str	r0, [sp, #16]
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 80069c4:	9b04      	ldr	r3, [sp, #16]
 80069c6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80069ca:	bf14      	ite	ne
 80069cc:	2300      	movne	r3, #0
 80069ce:	2301      	moveq	r3, #1
 80069d0:	b2db      	uxtb	r3, r3
 80069d2:	2001      	movs	r0, #1
 80069d4:	4619      	mov	r1, r3
 80069d6:	f001 fdc3 	bl	8008560 <_test_assert>
 80069da:	4603      	mov	r3, r0
 80069dc:	2b00      	cmp	r3, #0
 80069de:	f040 80d2 	bne.w	8006b86 <sem2_execute.11885+0x1d6>
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 80069e2:	f640 003c 	movw	r0, #2108	; 0x83c
 80069e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80069ea:	f7ff fda1 	bl	8006530 <queue_isempty.11742.4196>
 80069ee:	4603      	mov	r3, r0
 80069f0:	2002      	movs	r0, #2
 80069f2:	4619      	mov	r1, r3
 80069f4:	f001 fdb4 	bl	8008560 <_test_assert>
 80069f8:	4603      	mov	r3, r0
 80069fa:	2b00      	cmp	r3, #0
 80069fc:	f040 80c3 	bne.w	8006b86 <sem2_execute.11885+0x1d6>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 8006a00:	f640 033c 	movw	r3, #2108	; 0x83c
 8006a04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006a08:	689b      	ldr	r3, [r3, #8]
 8006a0a:	2b00      	cmp	r3, #0
 8006a0c:	bf14      	ite	ne
 8006a0e:	2300      	movne	r3, #0
 8006a10:	2301      	moveq	r3, #1
 8006a12:	b2db      	uxtb	r3, r3
 8006a14:	2003      	movs	r0, #3
 8006a16:	4619      	mov	r1, r3
 8006a18:	f001 fda2 	bl	8008560 <_test_assert>
 8006a1c:	4603      	mov	r3, r0
 8006a1e:	2b00      	cmp	r3, #0
 8006a20:	f040 80b1 	bne.w	8006b86 <sem2_execute.11885+0x1d6>

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8006a24:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006a28:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006a2c:	681c      	ldr	r4, [r3, #0]
 8006a2e:	f7ff fddf 	bl	80065f0 <chThdGetPriorityX.11834.4183>
 8006a32:	4603      	mov	r3, r0
 8006a34:	3b01      	subs	r3, #1
 8006a36:	2200      	movs	r2, #0
 8006a38:	9200      	str	r2, [sp, #0]
 8006a3a:	4620      	mov	r0, r4
 8006a3c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006a40:	461a      	mov	r2, r3
 8006a42:	f646 1381 	movw	r3, #27009	; 0x6981
 8006a46:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006a4a:	f009 fe89 	bl	8010760 <chThdCreateStatic>
 8006a4e:	4602      	mov	r2, r0
 8006a50:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006a54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006a58:	601a      	str	r2, [r3, #0]
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 8006a5a:	f640 003c 	movw	r0, #2108	; 0x83c
 8006a5e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006a62:	f241 3188 	movw	r1, #5000	; 0x1388
 8006a66:	f007 fe33 	bl	800e6d0 <chSemWaitTimeout>
 8006a6a:	9004      	str	r0, [sp, #16]
  test_wait_threads();
 8006a6c:	f001 fe08 	bl	8008680 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 8006a70:	9b04      	ldr	r3, [sp, #16]
 8006a72:	2b00      	cmp	r3, #0
 8006a74:	bf14      	ite	ne
 8006a76:	2300      	movne	r3, #0
 8006a78:	2301      	moveq	r3, #1
 8006a7a:	b2db      	uxtb	r3, r3
 8006a7c:	2004      	movs	r0, #4
 8006a7e:	4619      	mov	r1, r3
 8006a80:	f001 fd6e 	bl	8008560 <_test_assert>
 8006a84:	4603      	mov	r3, r0
 8006a86:	2b00      	cmp	r3, #0
 8006a88:	d17d      	bne.n	8006b86 <sem2_execute.11885+0x1d6>
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 8006a8a:	f640 003c 	movw	r0, #2108	; 0x83c
 8006a8e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006a92:	f7ff fd4d 	bl	8006530 <queue_isempty.11742.4196>
 8006a96:	4603      	mov	r3, r0
 8006a98:	2005      	movs	r0, #5
 8006a9a:	4619      	mov	r1, r3
 8006a9c:	f001 fd60 	bl	8008560 <_test_assert>
 8006aa0:	4603      	mov	r3, r0
 8006aa2:	2b00      	cmp	r3, #0
 8006aa4:	d16f      	bne.n	8006b86 <sem2_execute.11885+0x1d6>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 8006aa6:	f640 033c 	movw	r3, #2108	; 0x83c
 8006aaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006aae:	689b      	ldr	r3, [r3, #8]
 8006ab0:	2b00      	cmp	r3, #0
 8006ab2:	bf14      	ite	ne
 8006ab4:	2300      	movne	r3, #0
 8006ab6:	2301      	moveq	r3, #1
 8006ab8:	b2db      	uxtb	r3, r3
 8006aba:	2006      	movs	r0, #6
 8006abc:	4619      	mov	r1, r3
 8006abe:	f001 fd4f 	bl	8008560 <_test_assert>
 8006ac2:	4603      	mov	r3, r0
 8006ac4:	2b00      	cmp	r3, #0
 8006ac6:	d15e      	bne.n	8006b86 <sem2_execute.11885+0x1d6>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 8006ac8:	f001 fe0a 	bl	80086e0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
 8006acc:	f7ff fd78 	bl	80065c0 <chVTGetSystemTime.11871.4187>
 8006ad0:	4603      	mov	r3, r0
 8006ad2:	f603 13c4 	addw	r3, r3, #2500	; 0x9c4
 8006ad6:	9303      	str	r3, [sp, #12]
  for (i = 0; i < 5; i++) {
 8006ad8:	2300      	movs	r3, #0
 8006ada:	9305      	str	r3, [sp, #20]
 8006adc:	e03f      	b.n	8006b5e <sem2_execute.11885+0x1ae>
    test_emit_token('A' + i);
 8006ade:	9b05      	ldr	r3, [sp, #20]
 8006ae0:	b2db      	uxtb	r3, r3
 8006ae2:	3341      	adds	r3, #65	; 0x41
 8006ae4:	b2db      	uxtb	r3, r3
 8006ae6:	4618      	mov	r0, r3
 8006ae8:	f001 fd02 	bl	80084f0 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
 8006aec:	f640 003c 	movw	r0, #2108	; 0x83c
 8006af0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006af4:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8006af8:	f007 fdea 	bl	800e6d0 <chSemWaitTimeout>
 8006afc:	9004      	str	r0, [sp, #16]
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 8006afe:	9b04      	ldr	r3, [sp, #16]
 8006b00:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8006b04:	bf14      	ite	ne
 8006b06:	2300      	movne	r3, #0
 8006b08:	2301      	moveq	r3, #1
 8006b0a:	b2db      	uxtb	r3, r3
 8006b0c:	2007      	movs	r0, #7
 8006b0e:	4619      	mov	r1, r3
 8006b10:	f001 fd26 	bl	8008560 <_test_assert>
 8006b14:	4603      	mov	r3, r0
 8006b16:	2b00      	cmp	r3, #0
 8006b18:	d135      	bne.n	8006b86 <sem2_execute.11885+0x1d6>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 8006b1a:	f640 003c 	movw	r0, #2108	; 0x83c
 8006b1e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006b22:	f7ff fd05 	bl	8006530 <queue_isempty.11742.4196>
 8006b26:	4603      	mov	r3, r0
 8006b28:	2008      	movs	r0, #8
 8006b2a:	4619      	mov	r1, r3
 8006b2c:	f001 fd18 	bl	8008560 <_test_assert>
 8006b30:	4603      	mov	r3, r0
 8006b32:	2b00      	cmp	r3, #0
 8006b34:	d127      	bne.n	8006b86 <sem2_execute.11885+0x1d6>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 8006b36:	f640 033c 	movw	r3, #2108	; 0x83c
 8006b3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006b3e:	689b      	ldr	r3, [r3, #8]
 8006b40:	2b00      	cmp	r3, #0
 8006b42:	bf14      	ite	ne
 8006b44:	2300      	movne	r3, #0
 8006b46:	2301      	moveq	r3, #1
 8006b48:	b2db      	uxtb	r3, r3
 8006b4a:	2009      	movs	r0, #9
 8006b4c:	4619      	mov	r1, r3
 8006b4e:	f001 fd07 	bl	8008560 <_test_assert>
 8006b52:	4603      	mov	r3, r0
 8006b54:	2b00      	cmp	r3, #0
 8006b56:	d116      	bne.n	8006b86 <sem2_execute.11885+0x1d6>
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 8006b58:	9b05      	ldr	r3, [sp, #20]
 8006b5a:	3301      	adds	r3, #1
 8006b5c:	9305      	str	r3, [sp, #20]
 8006b5e:	9b05      	ldr	r3, [sp, #20]
 8006b60:	2b04      	cmp	r3, #4
 8006b62:	ddbc      	ble.n	8006ade <sem2_execute.11885+0x12e>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 8006b64:	200a      	movs	r0, #10
 8006b66:	f640 7188 	movw	r1, #3976	; 0xf88
 8006b6a:	f6c0 0101 	movt	r1, #2049	; 0x801
 8006b6e:	f001 fd0f 	bl	8008590 <_test_assert_sequence>
 8006b72:	4603      	mov	r3, r0
 8006b74:	2b00      	cmp	r3, #0
 8006b76:	d106      	bne.n	8006b86 <sem2_execute.11885+0x1d6>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 8006b78:	9b03      	ldr	r3, [sp, #12]
 8006b7a:	3314      	adds	r3, #20
 8006b7c:	200b      	movs	r0, #11
 8006b7e:	9903      	ldr	r1, [sp, #12]
 8006b80:	461a      	mov	r2, r3
 8006b82:	f001 fd3d 	bl	8008600 <_test_assert_time_window>
}
 8006b86:	b006      	add	sp, #24
 8006b88:	bd10      	pop	{r4, pc}
 8006b8a:	bf00      	nop
 8006b8c:	f3af 8000 	nop.w

08006b90 <sem3_setup.11840>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem3_setup(void) {
 8006b90:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 8006b92:	f640 003c 	movw	r0, #2108	; 0x83c
 8006b96:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006b9a:	2100      	movs	r1, #0
 8006b9c:	f007 fca0 	bl	800e4e0 <chSemObjectInit>
}
 8006ba0:	bd08      	pop	{r3, pc}
 8006ba2:	bf00      	nop
 8006ba4:	f3af 8000 	nop.w
 8006ba8:	f3af 8000 	nop.w
 8006bac:	f3af 8000 	nop.w

08006bb0 <thread3.11856.4135>:

static THD_FUNCTION(thread3, p) {
 8006bb0:	b500      	push	{lr}
 8006bb2:	b083      	sub	sp, #12
 8006bb4:	9001      	str	r0, [sp, #4]

  (void)p;
  chSemWait(&sem1);
 8006bb6:	f640 003c 	movw	r0, #2108	; 0x83c
 8006bba:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006bbe:	f007 fd17 	bl	800e5f0 <chSemWait>
  chSemSignal(&sem1);
 8006bc2:	f640 003c 	movw	r0, #2108	; 0x83c
 8006bc6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006bca:	f007 fe01 	bl	800e7d0 <chSemSignal>
}
 8006bce:	b003      	add	sp, #12
 8006bd0:	f85d fb04 	ldr.w	pc, [sp], #4
 8006bd4:	f3af 8000 	nop.w
 8006bd8:	f3af 8000 	nop.w
 8006bdc:	f3af 8000 	nop.w

08006be0 <sem3_execute.11887>:

static void sem3_execute(void) {
 8006be0:	b510      	push	{r4, lr}
 8006be2:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8006be4:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006be8:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006bec:	681c      	ldr	r4, [r3, #0]
 8006bee:	f7ff fcff 	bl	80065f0 <chThdGetPriorityX.11834.4183>
 8006bf2:	4603      	mov	r3, r0
 8006bf4:	3301      	adds	r3, #1
 8006bf6:	2200      	movs	r2, #0
 8006bf8:	9200      	str	r2, [sp, #0]
 8006bfa:	4620      	mov	r0, r4
 8006bfc:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006c00:	461a      	mov	r2, r3
 8006c02:	f646 33b1 	movw	r3, #27569	; 0x6bb1
 8006c06:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006c0a:	f009 fda9 	bl	8010760 <chThdCreateStatic>
 8006c0e:	4602      	mov	r2, r0
 8006c10:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006c14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c18:	601a      	str	r2, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 8006c1a:	f640 003c 	movw	r0, #2108	; 0x83c
 8006c1e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006c22:	f640 013c 	movw	r1, #2108	; 0x83c
 8006c26:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8006c2a:	f007 feb9 	bl	800e9a0 <chSemSignalWait>
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 8006c2e:	f640 003c 	movw	r0, #2108	; 0x83c
 8006c32:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006c36:	f7ff fc7b 	bl	8006530 <queue_isempty.11742.4196>
 8006c3a:	4603      	mov	r3, r0
 8006c3c:	2001      	movs	r0, #1
 8006c3e:	4619      	mov	r1, r3
 8006c40:	f001 fc8e 	bl	8008560 <_test_assert>
 8006c44:	4603      	mov	r3, r0
 8006c46:	2b00      	cmp	r3, #0
 8006c48:	d136      	bne.n	8006cb8 <sem3_execute.11887+0xd8>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 8006c4a:	f640 033c 	movw	r3, #2108	; 0x83c
 8006c4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006c52:	689b      	ldr	r3, [r3, #8]
 8006c54:	2b00      	cmp	r3, #0
 8006c56:	bf14      	ite	ne
 8006c58:	2300      	movne	r3, #0
 8006c5a:	2301      	moveq	r3, #1
 8006c5c:	b2db      	uxtb	r3, r3
 8006c5e:	2002      	movs	r0, #2
 8006c60:	4619      	mov	r1, r3
 8006c62:	f001 fc7d 	bl	8008560 <_test_assert>
 8006c66:	4603      	mov	r3, r0
 8006c68:	2b00      	cmp	r3, #0
 8006c6a:	d125      	bne.n	8006cb8 <sem3_execute.11887+0xd8>

  chSemSignalWait(&sem1, &sem1);
 8006c6c:	f640 003c 	movw	r0, #2108	; 0x83c
 8006c70:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006c74:	f640 013c 	movw	r1, #2108	; 0x83c
 8006c78:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8006c7c:	f007 fe90 	bl	800e9a0 <chSemSignalWait>
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 8006c80:	f640 003c 	movw	r0, #2108	; 0x83c
 8006c84:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006c88:	f7ff fc52 	bl	8006530 <queue_isempty.11742.4196>
 8006c8c:	4603      	mov	r3, r0
 8006c8e:	2003      	movs	r0, #3
 8006c90:	4619      	mov	r1, r3
 8006c92:	f001 fc65 	bl	8008560 <_test_assert>
 8006c96:	4603      	mov	r3, r0
 8006c98:	2b00      	cmp	r3, #0
 8006c9a:	d10d      	bne.n	8006cb8 <sem3_execute.11887+0xd8>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8006c9c:	f640 033c 	movw	r3, #2108	; 0x83c
 8006ca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006ca4:	689b      	ldr	r3, [r3, #8]
 8006ca6:	2b00      	cmp	r3, #0
 8006ca8:	bf14      	ite	ne
 8006caa:	2300      	movne	r3, #0
 8006cac:	2301      	moveq	r3, #1
 8006cae:	b2db      	uxtb	r3, r3
 8006cb0:	2004      	movs	r0, #4
 8006cb2:	4619      	mov	r1, r3
 8006cb4:	f001 fc54 	bl	8008560 <_test_assert>
}
 8006cb8:	b002      	add	sp, #8
 8006cba:	bd10      	pop	{r4, pc}
 8006cbc:	f3af 8000 	nop.w

08006cc0 <thread4.11882.4130>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 8006cc0:	b500      	push	{lr}
 8006cc2:	b083      	sub	sp, #12
 8006cc4:	9001      	str	r0, [sp, #4]

  chBSemSignal((binary_semaphore_t *)p);
 8006cc6:	9801      	ldr	r0, [sp, #4]
 8006cc8:	f7ff fcfa 	bl	80066c0 <chBSemSignal.11879.4163>
}
 8006ccc:	b003      	add	sp, #12
 8006cce:	f85d fb04 	ldr.w	pc, [sp], #4
 8006cd2:	bf00      	nop
 8006cd4:	f3af 8000 	nop.w
 8006cd8:	f3af 8000 	nop.w
 8006cdc:	f3af 8000 	nop.w

08006ce0 <sem4_execute.11893>:

static void sem4_execute(void) {
 8006ce0:	b510      	push	{r4, lr}
 8006ce2:	b086      	sub	sp, #24
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
 8006ce4:	ab03      	add	r3, sp, #12
 8006ce6:	4618      	mov	r0, r3
 8006ce8:	2101      	movs	r1, #1
 8006cea:	f7ff fc99 	bl	8006620 <chBSemObjectInit.11842.4176>
  chBSemReset(&bsem, TRUE);
 8006cee:	ab03      	add	r3, sp, #12
 8006cf0:	4618      	mov	r0, r3
 8006cf2:	2101      	movs	r1, #1
 8006cf4:	f7ff fcbc 	bl	8006670 <chBSemReset.11889.4169>
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8006cf8:	f7ff fc2a 	bl	8006550 <chSysLock.11859.4194>
 8006cfc:	ab03      	add	r3, sp, #12
 8006cfe:	4618      	mov	r0, r3
 8006d00:	f7ff fcee 	bl	80066e0 <chBSemGetStateI.11864.4154>
 8006d04:	4603      	mov	r3, r0
 8006d06:	2b00      	cmp	r3, #0
 8006d08:	bf0c      	ite	eq
 8006d0a:	2300      	moveq	r3, #0
 8006d0c:	2301      	movne	r3, #1
 8006d0e:	b2db      	uxtb	r3, r3
 8006d10:	2001      	movs	r0, #1
 8006d12:	4619      	mov	r1, r3
 8006d14:	f001 fc24 	bl	8008560 <_test_assert>
 8006d18:	4603      	mov	r3, r0
 8006d1a:	2b00      	cmp	r3, #0
 8006d1c:	d002      	beq.n	8006d24 <sem4_execute.11893+0x44>
 8006d1e:	f7ff fc1f 	bl	8006560 <chSysUnlock.11867.4192>
 8006d22:	e0ac      	b.n	8006e7e <sem4_execute.11893+0x19e>
 8006d24:	f7ff fc1c 	bl	8006560 <chSysUnlock.11867.4192>

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8006d28:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006d2c:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006d30:	681c      	ldr	r4, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
 8006d32:	f7ff fc5d 	bl	80065f0 <chThdGetPriorityX.11834.4183>
 8006d36:	4603      	mov	r3, r0
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8006d38:	3b01      	subs	r3, #1
 8006d3a:	aa03      	add	r2, sp, #12
 8006d3c:	9200      	str	r2, [sp, #0]
 8006d3e:	4620      	mov	r0, r4
 8006d40:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006d44:	461a      	mov	r2, r3
 8006d46:	f646 43c1 	movw	r3, #27841	; 0x6cc1
 8006d4a:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006d4e:	f009 fd07 	bl	8010760 <chThdCreateStatic>
 8006d52:	4602      	mov	r2, r0
 8006d54:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006d58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006d5c:	601a      	str	r2, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
 8006d5e:	ab03      	add	r3, sp, #12
 8006d60:	4618      	mov	r0, r3
 8006d62:	f7ff fc75 	bl	8006650 <chBSemWait.11850.4173>
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8006d66:	f7ff fbf3 	bl	8006550 <chSysLock.11859.4194>
 8006d6a:	ab03      	add	r3, sp, #12
 8006d6c:	4618      	mov	r0, r3
 8006d6e:	f7ff fcb7 	bl	80066e0 <chBSemGetStateI.11864.4154>
 8006d72:	4603      	mov	r3, r0
 8006d74:	2b00      	cmp	r3, #0
 8006d76:	bf0c      	ite	eq
 8006d78:	2300      	moveq	r3, #0
 8006d7a:	2301      	movne	r3, #1
 8006d7c:	b2db      	uxtb	r3, r3
 8006d7e:	2002      	movs	r0, #2
 8006d80:	4619      	mov	r1, r3
 8006d82:	f001 fbed 	bl	8008560 <_test_assert>
 8006d86:	4603      	mov	r3, r0
 8006d88:	2b00      	cmp	r3, #0
 8006d8a:	d002      	beq.n	8006d92 <sem4_execute.11893+0xb2>
 8006d8c:	f7ff fbe8 	bl	8006560 <chSysUnlock.11867.4192>
 8006d90:	e075      	b.n	8006e7e <sem4_execute.11893+0x19e>
 8006d92:	f7ff fbe5 	bl	8006560 <chSysUnlock.11867.4192>

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
 8006d96:	ab03      	add	r3, sp, #12
 8006d98:	4618      	mov	r0, r3
 8006d9a:	f7ff fc91 	bl	80066c0 <chBSemSignal.11879.4163>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 8006d9e:	f7ff fbd7 	bl	8006550 <chSysLock.11859.4194>
 8006da2:	ab03      	add	r3, sp, #12
 8006da4:	4618      	mov	r0, r3
 8006da6:	f7ff fc9b 	bl	80066e0 <chBSemGetStateI.11864.4154>
 8006daa:	4603      	mov	r3, r0
 8006dac:	2b00      	cmp	r3, #0
 8006dae:	bf0c      	ite	eq
 8006db0:	2300      	moveq	r3, #0
 8006db2:	2301      	movne	r3, #1
 8006db4:	b2db      	uxtb	r3, r3
 8006db6:	f083 0301 	eor.w	r3, r3, #1
 8006dba:	b2db      	uxtb	r3, r3
 8006dbc:	f003 0301 	and.w	r3, r3, #1
 8006dc0:	b2db      	uxtb	r3, r3
 8006dc2:	2003      	movs	r0, #3
 8006dc4:	4619      	mov	r1, r3
 8006dc6:	f001 fbcb 	bl	8008560 <_test_assert>
 8006dca:	4603      	mov	r3, r0
 8006dcc:	2b00      	cmp	r3, #0
 8006dce:	d002      	beq.n	8006dd6 <sem4_execute.11893+0xf6>
 8006dd0:	f7ff fbc6 	bl	8006560 <chSysUnlock.11867.4192>
 8006dd4:	e053      	b.n	8006e7e <sem4_execute.11893+0x19e>
 8006dd6:	f7ff fbc3 	bl	8006560 <chSysUnlock.11867.4192>
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 8006dda:	f7ff fbb9 	bl	8006550 <chSysLock.11859.4194>
 8006dde:	ab03      	add	r3, sp, #12
 8006de0:	4618      	mov	r0, r3
 8006de2:	f7ff fc0d 	bl	8006600 <chSemGetCounterI.11861.4180>
 8006de6:	4603      	mov	r3, r0
 8006de8:	2b01      	cmp	r3, #1
 8006dea:	bf14      	ite	ne
 8006dec:	2300      	movne	r3, #0
 8006dee:	2301      	moveq	r3, #1
 8006df0:	b2db      	uxtb	r3, r3
 8006df2:	2004      	movs	r0, #4
 8006df4:	4619      	mov	r1, r3
 8006df6:	f001 fbb3 	bl	8008560 <_test_assert>
 8006dfa:	4603      	mov	r3, r0
 8006dfc:	2b00      	cmp	r3, #0
 8006dfe:	d002      	beq.n	8006e06 <sem4_execute.11893+0x126>
 8006e00:	f7ff fbae 	bl	8006560 <chSysUnlock.11867.4192>
 8006e04:	e03b      	b.n	8006e7e <sem4_execute.11893+0x19e>
 8006e06:	f7ff fbab 	bl	8006560 <chSysUnlock.11867.4192>

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
 8006e0a:	ab03      	add	r3, sp, #12
 8006e0c:	4618      	mov	r0, r3
 8006e0e:	f7ff fc57 	bl	80066c0 <chBSemSignal.11879.4163>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 8006e12:	f7ff fb9d 	bl	8006550 <chSysLock.11859.4194>
 8006e16:	ab03      	add	r3, sp, #12
 8006e18:	4618      	mov	r0, r3
 8006e1a:	f7ff fc61 	bl	80066e0 <chBSemGetStateI.11864.4154>
 8006e1e:	4603      	mov	r3, r0
 8006e20:	2b00      	cmp	r3, #0
 8006e22:	bf0c      	ite	eq
 8006e24:	2300      	moveq	r3, #0
 8006e26:	2301      	movne	r3, #1
 8006e28:	b2db      	uxtb	r3, r3
 8006e2a:	f083 0301 	eor.w	r3, r3, #1
 8006e2e:	b2db      	uxtb	r3, r3
 8006e30:	f003 0301 	and.w	r3, r3, #1
 8006e34:	b2db      	uxtb	r3, r3
 8006e36:	2003      	movs	r0, #3
 8006e38:	4619      	mov	r1, r3
 8006e3a:	f001 fb91 	bl	8008560 <_test_assert>
 8006e3e:	4603      	mov	r3, r0
 8006e40:	2b00      	cmp	r3, #0
 8006e42:	d002      	beq.n	8006e4a <sem4_execute.11893+0x16a>
 8006e44:	f7ff fb8c 	bl	8006560 <chSysUnlock.11867.4192>
 8006e48:	e019      	b.n	8006e7e <sem4_execute.11893+0x19e>
 8006e4a:	f7ff fb89 	bl	8006560 <chSysUnlock.11867.4192>
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 8006e4e:	f7ff fb7f 	bl	8006550 <chSysLock.11859.4194>
 8006e52:	ab03      	add	r3, sp, #12
 8006e54:	4618      	mov	r0, r3
 8006e56:	f7ff fbd3 	bl	8006600 <chSemGetCounterI.11861.4180>
 8006e5a:	4603      	mov	r3, r0
 8006e5c:	2b01      	cmp	r3, #1
 8006e5e:	bf14      	ite	ne
 8006e60:	2300      	movne	r3, #0
 8006e62:	2301      	moveq	r3, #1
 8006e64:	b2db      	uxtb	r3, r3
 8006e66:	2005      	movs	r0, #5
 8006e68:	4619      	mov	r1, r3
 8006e6a:	f001 fb79 	bl	8008560 <_test_assert>
 8006e6e:	4603      	mov	r3, r0
 8006e70:	2b00      	cmp	r3, #0
 8006e72:	d002      	beq.n	8006e7a <sem4_execute.11893+0x19a>
 8006e74:	f7ff fb74 	bl	8006560 <chSysUnlock.11867.4192>
 8006e78:	e001      	b.n	8006e7e <sem4_execute.11893+0x19e>
 8006e7a:	f7ff fb71 	bl	8006560 <chSysUnlock.11867.4192>
}
 8006e7e:	b006      	add	sp, #24
 8006e80:	bd10      	pop	{r4, pc}
 8006e82:	bf00      	nop
 8006e84:	f3af 8000 	nop.w
 8006e88:	f3af 8000 	nop.w
 8006e8c:	f3af 8000 	nop.w

08006e90 <port_lock.12031.4125>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006e90:	b082      	sub	sp, #8
 8006e92:	2320      	movs	r3, #32
 8006e94:	9301      	str	r3, [sp, #4]
 8006e96:	9b01      	ldr	r3, [sp, #4]
 8006e98:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006e9c:	b002      	add	sp, #8
 8006e9e:	4770      	bx	lr

08006ea0 <port_unlock.12034.4123>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006ea0:	b082      	sub	sp, #8
 8006ea2:	2300      	movs	r3, #0
 8006ea4:	9301      	str	r3, [sp, #4]
 8006ea6:	9b01      	ldr	r3, [sp, #4]
 8006ea8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8006eac:	b002      	add	sp, #8
 8006eae:	4770      	bx	lr

08006eb0 <queue_isempty.12036>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 8006eb0:	b082      	sub	sp, #8
 8006eb2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8006eb4:	9b01      	ldr	r3, [sp, #4]
 8006eb6:	681a      	ldr	r2, [r3, #0]
 8006eb8:	9b01      	ldr	r3, [sp, #4]
 8006eba:	429a      	cmp	r2, r3
 8006ebc:	bf14      	ite	ne
 8006ebe:	2300      	movne	r3, #0
 8006ec0:	2301      	moveq	r3, #1
 8006ec2:	b2db      	uxtb	r3, r3
}
 8006ec4:	4618      	mov	r0, r3
 8006ec6:	b002      	add	sp, #8
 8006ec8:	4770      	bx	lr
 8006eca:	bf00      	nop
 8006ecc:	f3af 8000 	nop.w

08006ed0 <chSysLock.12150>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006ed0:	b508      	push	{r3, lr}

  port_lock();
 8006ed2:	f7ff ffdd 	bl	8006e90 <port_lock.12031.4125>
  _stats_start_measure_crit_thd();
 8006ed6:	f007 f853 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8006eda:	f008 fc01 	bl	800f6e0 <_dbg_check_lock>
}
 8006ede:	bd08      	pop	{r3, pc}

08006ee0 <chSysUnlock.12152>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8006ee0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8006ee2:	f008 fc1d 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8006ee6:	f007 f853 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8006eea:	f640 5350 	movw	r3, #3408	; 0xd50
 8006eee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006ef2:	681a      	ldr	r2, [r3, #0]
 8006ef4:	f640 5350 	movw	r3, #3408	; 0xd50
 8006ef8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006efc:	429a      	cmp	r2, r3
 8006efe:	d013      	beq.n	8006f28 <chSysUnlock.12152+0x48>
 8006f00:	f640 5350 	movw	r3, #3408	; 0xd50
 8006f04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f08:	699b      	ldr	r3, [r3, #24]
 8006f0a:	689a      	ldr	r2, [r3, #8]
 8006f0c:	f640 5350 	movw	r3, #3408	; 0xd50
 8006f10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f14:	681b      	ldr	r3, [r3, #0]
 8006f16:	689b      	ldr	r3, [r3, #8]
 8006f18:	429a      	cmp	r2, r3
 8006f1a:	d205      	bcs.n	8006f28 <chSysUnlock.12152+0x48>
 8006f1c:	f242 1040 	movw	r0, #8512	; 0x2140
 8006f20:	f6c0 0001 	movt	r0, #2049	; 0x801
 8006f24:	f008 fa34 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8006f28:	f7ff ffba 	bl	8006ea0 <port_unlock.12034.4123>
}
 8006f2c:	bd08      	pop	{r3, pc}
 8006f2e:	bf00      	nop

08006f30 <chThdGetSelfX.12126.4027>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006f30:	f640 5350 	movw	r3, #3408	; 0xd50
 8006f34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006f38:	699b      	ldr	r3, [r3, #24]
}
 8006f3a:	4618      	mov	r0, r3
 8006f3c:	4770      	bx	lr
 8006f3e:	bf00      	nop

08006f40 <chThdGetPriorityX.12128>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8006f40:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8006f42:	f7ff fff5 	bl	8006f30 <chThdGetSelfX.12126.4027>
 8006f46:	4603      	mov	r3, r0
 8006f48:	689b      	ldr	r3, [r3, #8]
}
 8006f4a:	4618      	mov	r0, r3
 8006f4c:	bd08      	pop	{r3, pc}
 8006f4e:	bf00      	nop

08006f50 <mtx1_setup.12130>:
 * the mutex is unlocked.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void mtx1_setup(void) {
 8006f50:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 8006f52:	f640 0048 	movw	r0, #2120	; 0x848
 8006f56:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006f5a:	f007 fe79 	bl	800ec50 <chMtxObjectInit>
}
 8006f5e:	bd08      	pop	{r3, pc}

08006f60 <thread1.12136.4015>:

static THD_FUNCTION(thread1, p) {
 8006f60:	b500      	push	{lr}
 8006f62:	b083      	sub	sp, #12
 8006f64:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 8006f66:	f640 0048 	movw	r0, #2120	; 0x848
 8006f6a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006f6e:	f007 fe87 	bl	800ec80 <chMtxLock>
  test_emit_token(*(char *)p);
 8006f72:	9b01      	ldr	r3, [sp, #4]
 8006f74:	781b      	ldrb	r3, [r3, #0]
 8006f76:	4618      	mov	r0, r3
 8006f78:	f001 faba 	bl	80084f0 <test_emit_token>
  chMtxUnlock(&m1);
 8006f7c:	f640 0048 	movw	r0, #2120	; 0x848
 8006f80:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006f84:	f005 fa1c 	bl	800c3c0 <chMtxUnlock>
}
 8006f88:	b003      	add	sp, #12
 8006f8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f8e:	bf00      	nop

08006f90 <mtx1_execute.12142>:

static void mtx1_execute(void) {
 8006f90:	b500      	push	{lr}
 8006f92:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
 8006f94:	f7ff ffd4 	bl	8006f40 <chThdGetPriorityX.12128>
 8006f98:	9003      	str	r0, [sp, #12]
  chMtxLock(&m1);
 8006f9a:	f640 0048 	movw	r0, #2120	; 0x848
 8006f9e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006fa2:	f007 fe6d 	bl	800ec80 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8006fa6:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006faa:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006fae:	6819      	ldr	r1, [r3, #0]
 8006fb0:	9b03      	ldr	r3, [sp, #12]
 8006fb2:	1c5a      	adds	r2, r3, #1
 8006fb4:	f640 7374 	movw	r3, #3956	; 0xf74
 8006fb8:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006fbc:	9300      	str	r3, [sp, #0]
 8006fbe:	4608      	mov	r0, r1
 8006fc0:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006fc4:	f646 7361 	movw	r3, #28513	; 0x6f61
 8006fc8:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006fcc:	f009 fbc8 	bl	8010760 <chThdCreateStatic>
 8006fd0:	4602      	mov	r2, r0
 8006fd2:	f641 6360 	movw	r3, #7776	; 0x1e60
 8006fd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006fda:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8006fdc:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8006fe0:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006fe4:	6859      	ldr	r1, [r3, #4]
 8006fe6:	9b03      	ldr	r3, [sp, #12]
 8006fe8:	1c9a      	adds	r2, r3, #2
 8006fea:	f640 7378 	movw	r3, #3960	; 0xf78
 8006fee:	f6c0 0301 	movt	r3, #2049	; 0x801
 8006ff2:	9300      	str	r3, [sp, #0]
 8006ff4:	4608      	mov	r0, r1
 8006ff6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8006ffa:	f646 7361 	movw	r3, #28513	; 0x6f61
 8006ffe:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007002:	f009 fbad 	bl	8010760 <chThdCreateStatic>
 8007006:	4602      	mov	r2, r0
 8007008:	f641 6360 	movw	r3, #7776	; 0x1e60
 800700c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007010:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8007012:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8007016:	f6c0 0301 	movt	r3, #2049	; 0x801
 800701a:	6899      	ldr	r1, [r3, #8]
 800701c:	9b03      	ldr	r3, [sp, #12]
 800701e:	1cda      	adds	r2, r3, #3
 8007020:	f640 737c 	movw	r3, #3964	; 0xf7c
 8007024:	f6c0 0301 	movt	r3, #2049	; 0x801
 8007028:	9300      	str	r3, [sp, #0]
 800702a:	4608      	mov	r0, r1
 800702c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8007030:	f646 7361 	movw	r3, #28513	; 0x6f61
 8007034:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007038:	f009 fb92 	bl	8010760 <chThdCreateStatic>
 800703c:	4602      	mov	r2, r0
 800703e:	f641 6360 	movw	r3, #7776	; 0x1e60
 8007042:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007046:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8007048:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 800704c:	f6c0 0301 	movt	r3, #2049	; 0x801
 8007050:	68d9      	ldr	r1, [r3, #12]
 8007052:	9b03      	ldr	r3, [sp, #12]
 8007054:	1d1a      	adds	r2, r3, #4
 8007056:	f640 7380 	movw	r3, #3968	; 0xf80
 800705a:	f6c0 0301 	movt	r3, #2049	; 0x801
 800705e:	9300      	str	r3, [sp, #0]
 8007060:	4608      	mov	r0, r1
 8007062:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8007066:	f646 7361 	movw	r3, #28513	; 0x6f61
 800706a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800706e:	f009 fb77 	bl	8010760 <chThdCreateStatic>
 8007072:	4602      	mov	r2, r0
 8007074:	f641 6360 	movw	r3, #7776	; 0x1e60
 8007078:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800707c:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800707e:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 8007082:	f6c0 0301 	movt	r3, #2049	; 0x801
 8007086:	6919      	ldr	r1, [r3, #16]
 8007088:	9b03      	ldr	r3, [sp, #12]
 800708a:	1d5a      	adds	r2, r3, #5
 800708c:	f640 7384 	movw	r3, #3972	; 0xf84
 8007090:	f6c0 0301 	movt	r3, #2049	; 0x801
 8007094:	9300      	str	r3, [sp, #0]
 8007096:	4608      	mov	r0, r1
 8007098:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800709c:	f646 7361 	movw	r3, #28513	; 0x6f61
 80070a0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80070a4:	f009 fb5c 	bl	8010760 <chThdCreateStatic>
 80070a8:	4602      	mov	r2, r0
 80070aa:	f641 6360 	movw	r3, #7776	; 0x1e60
 80070ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80070b2:	611a      	str	r2, [r3, #16]
  chMtxUnlock(&m1);
 80070b4:	f640 0048 	movw	r0, #2120	; 0x848
 80070b8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80070bc:	f005 f980 	bl	800c3c0 <chMtxUnlock>
  test_wait_threads();
 80070c0:	f001 fade 	bl	8008680 <test_wait_threads>
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 80070c4:	f7ff ff3c 	bl	8006f40 <chThdGetPriorityX.12128>
 80070c8:	4602      	mov	r2, r0
 80070ca:	9b03      	ldr	r3, [sp, #12]
 80070cc:	429a      	cmp	r2, r3
 80070ce:	bf14      	ite	ne
 80070d0:	2300      	movne	r3, #0
 80070d2:	2301      	moveq	r3, #1
 80070d4:	b2db      	uxtb	r3, r3
 80070d6:	2001      	movs	r0, #1
 80070d8:	4619      	mov	r1, r3
 80070da:	f001 fa41 	bl	8008560 <_test_assert>
 80070de:	4603      	mov	r3, r0
 80070e0:	2b00      	cmp	r3, #0
 80070e2:	d106      	bne.n	80070f2 <mtx1_execute.12142+0x162>
  test_assert_sequence(2, "ABCDE");
 80070e4:	2002      	movs	r0, #2
 80070e6:	f640 7188 	movw	r1, #3976	; 0xf88
 80070ea:	f6c0 0101 	movt	r1, #2049	; 0x801
 80070ee:	f001 fa4f 	bl	8008590 <_test_assert_sequence>
}
 80070f2:	b005      	add	sp, #20
 80070f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80070f8:	f3af 8000 	nop.w
 80070fc:	f3af 8000 	nop.w

08007100 <mtx4_setup.12132>:
 * thread with precise timing.<br>
 * The test expects that the priority changes caused by the priority
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {
 8007100:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 8007102:	f640 0048 	movw	r0, #2120	; 0x848
 8007106:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800710a:	f007 fda1 	bl	800ec50 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800710e:	f640 0058 	movw	r0, #2136	; 0x858
 8007112:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8007116:	f007 fd9b 	bl	800ec50 <chMtxObjectInit>
}
 800711a:	bd08      	pop	{r3, pc}
 800711c:	f3af 8000 	nop.w

08007120 <otg_isoc_in_failed_handler.10881.4459>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 8007120:	b500      	push	{lr}
 8007122:	b085      	sub	sp, #20
 8007124:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8007126:	9b01      	ldr	r3, [sp, #4]
 8007128:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800712a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800712c:	2300      	movs	r3, #0
 800712e:	f88d 300f 	strb.w	r3, [sp, #15]
 8007132:	e080      	b.n	8007236 <otg_isoc_in_failed_handler.10881.4459+0x116>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8007134:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007138:	9a02      	ldr	r2, [sp, #8]
 800713a:	3348      	adds	r3, #72	; 0x48
 800713c:	015b      	lsls	r3, r3, #5
 800713e:	4413      	add	r3, r2
 8007140:	681b      	ldr	r3, [r3, #0]
 8007142:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8007146:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800714a:	d16f      	bne.n	800722c <otg_isoc_in_failed_handler.10881.4459+0x10c>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 800714c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007150:	9a02      	ldr	r2, [sp, #8]
 8007152:	3348      	adds	r3, #72	; 0x48
 8007154:	015b      	lsls	r3, r3, #5
 8007156:	4413      	add	r3, r2
 8007158:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 800715a:	2b00      	cmp	r3, #0
 800715c:	da66      	bge.n	800722c <otg_isoc_in_failed_handler.10881.4459+0x10c>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 800715e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007162:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8007166:	9902      	ldr	r1, [sp, #8]
 8007168:	3248      	adds	r2, #72	; 0x48
 800716a:	0152      	lsls	r2, r2, #5
 800716c:	440a      	add	r2, r1
 800716e:	6812      	ldr	r2, [r2, #0]
 8007170:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 8007174:	9902      	ldr	r1, [sp, #8]
 8007176:	3348      	adds	r3, #72	; 0x48
 8007178:	015b      	lsls	r3, r3, #5
 800717a:	440b      	add	r3, r1
 800717c:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 800717e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007182:	9a02      	ldr	r2, [sp, #8]
 8007184:	3348      	adds	r3, #72	; 0x48
 8007186:	015b      	lsls	r3, r3, #5
 8007188:	4413      	add	r3, r2
 800718a:	681b      	ldr	r3, [r3, #0]
 800718c:	2b00      	cmp	r3, #0
 800718e:	dbf6      	blt.n	800717e <otg_isoc_in_failed_handler.10881.4459+0x5e>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 8007190:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007194:	9801      	ldr	r0, [sp, #4]
 8007196:	4619      	mov	r1, r3
 8007198:	f002 fa9a 	bl	80096d0 <otg_txfifo_flush.10849>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 800719c:	9b01      	ldr	r3, [sp, #4]
 800719e:	891b      	ldrh	r3, [r3, #8]
 80071a0:	b29a      	uxth	r2, r3
 80071a2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80071a6:	2101      	movs	r1, #1
 80071a8:	fa01 f303 	lsl.w	r3, r1, r3
 80071ac:	b29b      	uxth	r3, r3
 80071ae:	43db      	mvns	r3, r3
 80071b0:	b29b      	uxth	r3, r3
 80071b2:	4013      	ands	r3, r2
 80071b4:	b29b      	uxth	r3, r3
 80071b6:	b29a      	uxth	r2, r3
 80071b8:	9b01      	ldr	r3, [sp, #4]
 80071ba:	811a      	strh	r2, [r3, #8]
 80071bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80071c0:	9a01      	ldr	r2, [sp, #4]
 80071c2:	3302      	adds	r3, #2
 80071c4:	009b      	lsls	r3, r3, #2
 80071c6:	4413      	add	r3, r2
 80071c8:	685b      	ldr	r3, [r3, #4]
 80071ca:	689b      	ldr	r3, [r3, #8]
 80071cc:	2b00      	cmp	r3, #0
 80071ce:	d00c      	beq.n	80071ea <otg_isoc_in_failed_handler.10881.4459+0xca>
 80071d0:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80071d4:	9a01      	ldr	r2, [sp, #4]
 80071d6:	3302      	adds	r3, #2
 80071d8:	009b      	lsls	r3, r3, #2
 80071da:	4413      	add	r3, r2
 80071dc:	685b      	ldr	r3, [r3, #4]
 80071de:	689b      	ldr	r3, [r3, #8]
 80071e0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80071e4:	9801      	ldr	r0, [sp, #4]
 80071e6:	4611      	mov	r1, r2
 80071e8:	4798      	blx	r3

      /* Pump out data for next frame */
      osalSysLockFromISR();
 80071ea:	f002 f9b1 	bl	8009550 <osalSysLockFromISR.10566>
      otgp->DIEPEMPMSK &= ~(1 << ep);
 80071ee:	9b02      	ldr	r3, [sp, #8]
 80071f0:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 80071f4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80071f8:	2101      	movs	r1, #1
 80071fa:	fa01 f303 	lsl.w	r3, r1, r3
 80071fe:	43db      	mvns	r3, r3
 8007200:	401a      	ands	r2, r3
 8007202:	9b02      	ldr	r3, [sp, #8]
 8007204:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 8007208:	9b01      	ldr	r3, [sp, #4]
 800720a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800720c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007210:	2101      	movs	r1, #1
 8007212:	fa01 f303 	lsl.w	r3, r1, r3
 8007216:	431a      	orrs	r2, r3
 8007218:	9b01      	ldr	r3, [sp, #4]
 800721a:	675a      	str	r2, [r3, #116]	; 0x74
      osalThreadResumeI(&usbp->wait, MSG_OK);
 800721c:	9b01      	ldr	r3, [sp, #4]
 800721e:	3378      	adds	r3, #120	; 0x78
 8007220:	4618      	mov	r0, r3
 8007222:	2100      	movs	r1, #0
 8007224:	f002 f9c4 	bl	80095b0 <osalThreadResumeI.10568>
      osalSysUnlockFromISR();
 8007228:	f002 f99a 	bl	8009560 <osalSysUnlockFromISR.10656>
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800722c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007230:	3301      	adds	r3, #1
 8007232:	f88d 300f 	strb.w	r3, [sp, #15]
 8007236:	f89d 200f 	ldrb.w	r2, [sp, #15]
 800723a:	9b01      	ldr	r3, [sp, #4]
 800723c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800723e:	689b      	ldr	r3, [r3, #8]
 8007240:	429a      	cmp	r2, r3
 8007242:	f67f af77 	bls.w	8007134 <otg_isoc_in_failed_handler.10881.4459+0x14>
      usbp->txpending |= (1 << ep);
      osalThreadResumeI(&usbp->wait, MSG_OK);
      osalSysUnlockFromISR();
    }
  }
}
 8007246:	b005      	add	sp, #20
 8007248:	f85d fb04 	ldr.w	pc, [sp], #4
 800724c:	f3af 8000 	nop.w

08007250 <otg_isoc_out_failed_handler.10884.4456>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 8007250:	b500      	push	{lr}
 8007252:	b085      	sub	sp, #20
 8007254:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8007256:	9b01      	ldr	r3, [sp, #4]
 8007258:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800725a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800725c:	2300      	movs	r3, #0
 800725e:	f88d 300f 	strb.w	r3, [sp, #15]
 8007262:	e040      	b.n	80072e6 <otg_isoc_out_failed_handler.10884.4456+0x96>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8007264:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007268:	9a02      	ldr	r2, [sp, #8]
 800726a:	3358      	adds	r3, #88	; 0x58
 800726c:	015b      	lsls	r3, r3, #5
 800726e:	4413      	add	r3, r2
 8007270:	681b      	ldr	r3, [r3, #0]
 8007272:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8007276:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800727a:	d12f      	bne.n	80072dc <otg_isoc_out_failed_handler.10884.4456+0x8c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 800727c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007280:	9a02      	ldr	r2, [sp, #8]
 8007282:	3358      	adds	r3, #88	; 0x58
 8007284:	015b      	lsls	r3, r3, #5
 8007286:	4413      	add	r3, r2
 8007288:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 800728a:	2b00      	cmp	r3, #0
 800728c:	da26      	bge.n	80072dc <otg_isoc_out_failed_handler.10884.4456+0x8c>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 800728e:	9b01      	ldr	r3, [sp, #4]
 8007290:	895b      	ldrh	r3, [r3, #10]
 8007292:	b29a      	uxth	r2, r3
 8007294:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8007298:	2101      	movs	r1, #1
 800729a:	fa01 f303 	lsl.w	r3, r1, r3
 800729e:	b29b      	uxth	r3, r3
 80072a0:	43db      	mvns	r3, r3
 80072a2:	b29b      	uxth	r3, r3
 80072a4:	4013      	ands	r3, r2
 80072a6:	b29b      	uxth	r3, r3
 80072a8:	b29a      	uxth	r2, r3
 80072aa:	9b01      	ldr	r3, [sp, #4]
 80072ac:	815a      	strh	r2, [r3, #10]
 80072ae:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80072b2:	9a01      	ldr	r2, [sp, #4]
 80072b4:	3302      	adds	r3, #2
 80072b6:	009b      	lsls	r3, r3, #2
 80072b8:	4413      	add	r3, r2
 80072ba:	685b      	ldr	r3, [r3, #4]
 80072bc:	68db      	ldr	r3, [r3, #12]
 80072be:	2b00      	cmp	r3, #0
 80072c0:	d00c      	beq.n	80072dc <otg_isoc_out_failed_handler.10884.4456+0x8c>
 80072c2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80072c6:	9a01      	ldr	r2, [sp, #4]
 80072c8:	3302      	adds	r3, #2
 80072ca:	009b      	lsls	r3, r3, #2
 80072cc:	4413      	add	r3, r2
 80072ce:	685b      	ldr	r3, [r3, #4]
 80072d0:	68db      	ldr	r3, [r3, #12]
 80072d2:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80072d6:	9801      	ldr	r0, [sp, #4]
 80072d8:	4611      	mov	r1, r2
 80072da:	4798      	blx	r3
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80072dc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80072e0:	3301      	adds	r3, #1
 80072e2:	f88d 300f 	strb.w	r3, [sp, #15]
 80072e6:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80072ea:	9b01      	ldr	r3, [sp, #4]
 80072ec:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80072ee:	689b      	ldr	r3, [r3, #8]
 80072f0:	429a      	cmp	r2, r3
 80072f2:	d9b7      	bls.n	8007264 <otg_isoc_out_failed_handler.10884.4456+0x14>
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
    }
  }
}
 80072f4:	b005      	add	sp, #20
 80072f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80072fa:	bf00      	nop
 80072fc:	f3af 8000 	nop.w

08007300 <usb_lld_serve_interrupt.10939.4453>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8007300:	b500      	push	{lr}
 8007302:	b087      	sub	sp, #28
 8007304:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8007306:	9b01      	ldr	r3, [sp, #4]
 8007308:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800730a:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 800730c:	9b05      	ldr	r3, [sp, #20]
 800730e:	695b      	ldr	r3, [r3, #20]
 8007310:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 8007312:	9b05      	ldr	r3, [sp, #20]
 8007314:	699b      	ldr	r3, [r3, #24]
 8007316:	9a04      	ldr	r2, [sp, #16]
 8007318:	4013      	ands	r3, r2
 800731a:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 800731c:	9b05      	ldr	r3, [sp, #20]
 800731e:	9a04      	ldr	r2, [sp, #16]
 8007320:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8007322:	9b04      	ldr	r3, [sp, #16]
 8007324:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8007328:	2b00      	cmp	r3, #0
 800732a:	d006      	beq.n	800733a <usb_lld_serve_interrupt.10939.4453+0x3a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 800732c:	9b01      	ldr	r3, [sp, #4]
 800732e:	2200      	movs	r2, #0
 8007330:	675a      	str	r2, [r3, #116]	; 0x74

    /* Default reset action.*/
    _usb_reset(usbp);
 8007332:	9801      	ldr	r0, [sp, #4]
 8007334:	f001 fb7c 	bl	8008a30 <_usb_reset>
 8007338:	e0f2      	b.n	8007520 <usb_lld_serve_interrupt.10939.4453+0x220>
    /* Preventing execution of more handlers, the core has been reset.*/
    return;
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 800733a:	9b04      	ldr	r3, [sp, #16]
 800733c:	2b00      	cmp	r3, #0
 800733e:	da19      	bge.n	8007374 <usb_lld_serve_interrupt.10939.4453+0x74>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8007340:	9b05      	ldr	r3, [sp, #20]
 8007342:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8007346:	f003 0303 	and.w	r3, r3, #3
 800734a:	2b00      	cmp	r3, #0
 800734c:	d007      	beq.n	800735e <usb_lld_serve_interrupt.10939.4453+0x5e>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 800734e:	9b05      	ldr	r3, [sp, #20]
 8007350:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8007354:	f023 0203 	bic.w	r2, r3, #3
 8007358:	9b05      	ldr	r3, [sp, #20]
 800735a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL |= DCTL_RWUSIG;
 800735e:	9b05      	ldr	r3, [sp, #20]
 8007360:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8007364:	f043 0201 	orr.w	r2, r3, #1
 8007368:	9b05      	ldr	r3, [sp, #20]
 800736a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 800736e:	9801      	ldr	r0, [sp, #4]
 8007370:	f001 fbb6 	bl	8008ae0 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8007374:	9b04      	ldr	r3, [sp, #16]
 8007376:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800737a:	2b00      	cmp	r3, #0
 800737c:	d005      	beq.n	800738a <usb_lld_serve_interrupt.10939.4453+0x8a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 800737e:	9b01      	ldr	r3, [sp, #4]
 8007380:	2200      	movs	r2, #0
 8007382:	675a      	str	r2, [r3, #116]	; 0x74

    /* Default suspend action.*/
    _usb_suspend(usbp);
 8007384:	9801      	ldr	r0, [sp, #4]
 8007386:	f001 fb93 	bl	8008ab0 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 800738a:	9b04      	ldr	r3, [sp, #16]
 800738c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8007390:	2b00      	cmp	r3, #0
 8007392:	d017      	beq.n	80073c4 <usb_lld_serve_interrupt.10939.4453+0xc4>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8007394:	9b05      	ldr	r3, [sp, #20]
 8007396:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 800739a:	f003 0306 	and.w	r3, r3, #6
 800739e:	2b00      	cmp	r3, #0
 80073a0:	d108      	bne.n	80073b4 <usb_lld_serve_interrupt.10939.4453+0xb4>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 80073a2:	9b05      	ldr	r3, [sp, #20]
 80073a4:	68db      	ldr	r3, [r3, #12]
 80073a6:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 80073aa:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 80073ae:	9b05      	ldr	r3, [sp, #20]
 80073b0:	60da      	str	r2, [r3, #12]
 80073b2:	e007      	b.n	80073c4 <usb_lld_serve_interrupt.10939.4453+0xc4>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 80073b4:	9b05      	ldr	r3, [sp, #20]
 80073b6:	68db      	ldr	r3, [r3, #12]
 80073b8:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 80073bc:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 80073c0:	9b05      	ldr	r3, [sp, #20]
 80073c2:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 80073c4:	9b04      	ldr	r3, [sp, #16]
 80073c6:	f003 0308 	and.w	r3, r3, #8
 80073ca:	2b00      	cmp	r3, #0
 80073cc:	d009      	beq.n	80073e2 <usb_lld_serve_interrupt.10939.4453+0xe2>
    _usb_isr_invoke_sof_cb(usbp);
 80073ce:	9b01      	ldr	r3, [sp, #4]
 80073d0:	685b      	ldr	r3, [r3, #4]
 80073d2:	68db      	ldr	r3, [r3, #12]
 80073d4:	2b00      	cmp	r3, #0
 80073d6:	d004      	beq.n	80073e2 <usb_lld_serve_interrupt.10939.4453+0xe2>
 80073d8:	9b01      	ldr	r3, [sp, #4]
 80073da:	685b      	ldr	r3, [r3, #4]
 80073dc:	68db      	ldr	r3, [r3, #12]
 80073de:	9801      	ldr	r0, [sp, #4]
 80073e0:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 80073e2:	9b04      	ldr	r3, [sp, #16]
 80073e4:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 80073e8:	2b00      	cmp	r3, #0
 80073ea:	d002      	beq.n	80073f2 <usb_lld_serve_interrupt.10939.4453+0xf2>
    otg_isoc_in_failed_handler(usbp);
 80073ec:	9801      	ldr	r0, [sp, #4]
 80073ee:	f7ff fe97 	bl	8007120 <otg_isoc_in_failed_handler.10881.4459>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 80073f2:	9b04      	ldr	r3, [sp, #16]
 80073f4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80073f8:	2b00      	cmp	r3, #0
 80073fa:	d002      	beq.n	8007402 <usb_lld_serve_interrupt.10939.4453+0x102>
    otg_isoc_out_failed_handler(usbp);
 80073fc:	9801      	ldr	r0, [sp, #4]
 80073fe:	f7ff ff27 	bl	8007250 <otg_isoc_out_failed_handler.10884.4456>
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 8007402:	9b04      	ldr	r3, [sp, #16]
 8007404:	f003 0310 	and.w	r3, r3, #16
 8007408:	2b00      	cmp	r3, #0
 800740a:	d00f      	beq.n	800742c <usb_lld_serve_interrupt.10939.4453+0x12c>
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
 800740c:	f002 f8a0 	bl	8009550 <osalSysLockFromISR.10566>
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 8007410:	9b05      	ldr	r3, [sp, #20]
 8007412:	699b      	ldr	r3, [r3, #24]
 8007414:	f023 0210 	bic.w	r2, r3, #16
 8007418:	9b05      	ldr	r3, [sp, #20]
 800741a:	619a      	str	r2, [r3, #24]
    osalThreadResumeI(&usbp->wait, MSG_OK);
 800741c:	9b01      	ldr	r3, [sp, #4]
 800741e:	3378      	adds	r3, #120	; 0x78
 8007420:	4618      	mov	r0, r3
 8007422:	2100      	movs	r1, #0
 8007424:	f002 f8c4 	bl	80095b0 <osalThreadResumeI.10568>
    osalSysUnlockFromISR();
 8007428:	f002 f89a 	bl	8009560 <osalSysUnlockFromISR.10656>
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 800742c:	9b05      	ldr	r3, [sp, #20]
 800742e:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 8007432:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_IEPINT) {
 8007434:	9b04      	ldr	r3, [sp, #16]
 8007436:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800743a:	2b00      	cmp	r3, #0
 800743c:	d035      	beq.n	80074aa <usb_lld_serve_interrupt.10939.4453+0x1aa>
    if (src & (1 << 0))
 800743e:	9b03      	ldr	r3, [sp, #12]
 8007440:	f003 0301 	and.w	r3, r3, #1
 8007444:	2b00      	cmp	r3, #0
 8007446:	d003      	beq.n	8007450 <usb_lld_serve_interrupt.10939.4453+0x150>
      otg_epin_handler(usbp, 0);
 8007448:	9801      	ldr	r0, [sp, #4]
 800744a:	2100      	movs	r1, #0
 800744c:	f002 faf8 	bl	8009a40 <otg_epin_handler.10935>
    if (src & (1 << 1))
 8007450:	9b03      	ldr	r3, [sp, #12]
 8007452:	f003 0302 	and.w	r3, r3, #2
 8007456:	2b00      	cmp	r3, #0
 8007458:	d003      	beq.n	8007462 <usb_lld_serve_interrupt.10939.4453+0x162>
      otg_epin_handler(usbp, 1);
 800745a:	9801      	ldr	r0, [sp, #4]
 800745c:	2101      	movs	r1, #1
 800745e:	f002 faef 	bl	8009a40 <otg_epin_handler.10935>
    if (src & (1 << 2))
 8007462:	9b03      	ldr	r3, [sp, #12]
 8007464:	f003 0304 	and.w	r3, r3, #4
 8007468:	2b00      	cmp	r3, #0
 800746a:	d003      	beq.n	8007474 <usb_lld_serve_interrupt.10939.4453+0x174>
      otg_epin_handler(usbp, 2);
 800746c:	9801      	ldr	r0, [sp, #4]
 800746e:	2102      	movs	r1, #2
 8007470:	f002 fae6 	bl	8009a40 <otg_epin_handler.10935>
    if (src & (1 << 3))
 8007474:	9b03      	ldr	r3, [sp, #12]
 8007476:	f003 0308 	and.w	r3, r3, #8
 800747a:	2b00      	cmp	r3, #0
 800747c:	d003      	beq.n	8007486 <usb_lld_serve_interrupt.10939.4453+0x186>
      otg_epin_handler(usbp, 3);
 800747e:	9801      	ldr	r0, [sp, #4]
 8007480:	2103      	movs	r1, #3
 8007482:	f002 fadd 	bl	8009a40 <otg_epin_handler.10935>
#if STM32_USB_USE_OTG2
    if (src & (1 << 4))
 8007486:	9b03      	ldr	r3, [sp, #12]
 8007488:	f003 0310 	and.w	r3, r3, #16
 800748c:	2b00      	cmp	r3, #0
 800748e:	d003      	beq.n	8007498 <usb_lld_serve_interrupt.10939.4453+0x198>
      otg_epin_handler(usbp, 4);
 8007490:	9801      	ldr	r0, [sp, #4]
 8007492:	2104      	movs	r1, #4
 8007494:	f002 fad4 	bl	8009a40 <otg_epin_handler.10935>
    if (src & (1 << 5))
 8007498:	9b03      	ldr	r3, [sp, #12]
 800749a:	f003 0320 	and.w	r3, r3, #32
 800749e:	2b00      	cmp	r3, #0
 80074a0:	d003      	beq.n	80074aa <usb_lld_serve_interrupt.10939.4453+0x1aa>
      otg_epin_handler(usbp, 5);
 80074a2:	9801      	ldr	r0, [sp, #4]
 80074a4:	2105      	movs	r1, #5
 80074a6:	f002 facb 	bl	8009a40 <otg_epin_handler.10935>
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 80074aa:	9b04      	ldr	r3, [sp, #16]
 80074ac:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80074b0:	2b00      	cmp	r3, #0
 80074b2:	d035      	beq.n	8007520 <usb_lld_serve_interrupt.10939.4453+0x220>
    if (src & (1 << 16))
 80074b4:	9b03      	ldr	r3, [sp, #12]
 80074b6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80074ba:	2b00      	cmp	r3, #0
 80074bc:	d003      	beq.n	80074c6 <usb_lld_serve_interrupt.10939.4453+0x1c6>
      otg_epout_handler(usbp, 0);
 80074be:	9801      	ldr	r0, [sp, #4]
 80074c0:	2100      	movs	r1, #0
 80074c2:	f002 fb65 	bl	8009b90 <otg_epout_handler.10927>
    if (src & (1 << 17))
 80074c6:	9b03      	ldr	r3, [sp, #12]
 80074c8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80074cc:	2b00      	cmp	r3, #0
 80074ce:	d003      	beq.n	80074d8 <usb_lld_serve_interrupt.10939.4453+0x1d8>
      otg_epout_handler(usbp, 1);
 80074d0:	9801      	ldr	r0, [sp, #4]
 80074d2:	2101      	movs	r1, #1
 80074d4:	f002 fb5c 	bl	8009b90 <otg_epout_handler.10927>
    if (src & (1 << 18))
 80074d8:	9b03      	ldr	r3, [sp, #12]
 80074da:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80074de:	2b00      	cmp	r3, #0
 80074e0:	d003      	beq.n	80074ea <usb_lld_serve_interrupt.10939.4453+0x1ea>
      otg_epout_handler(usbp, 2);
 80074e2:	9801      	ldr	r0, [sp, #4]
 80074e4:	2102      	movs	r1, #2
 80074e6:	f002 fb53 	bl	8009b90 <otg_epout_handler.10927>
    if (src & (1 << 19))
 80074ea:	9b03      	ldr	r3, [sp, #12]
 80074ec:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80074f0:	2b00      	cmp	r3, #0
 80074f2:	d003      	beq.n	80074fc <usb_lld_serve_interrupt.10939.4453+0x1fc>
      otg_epout_handler(usbp, 3);
 80074f4:	9801      	ldr	r0, [sp, #4]
 80074f6:	2103      	movs	r1, #3
 80074f8:	f002 fb4a 	bl	8009b90 <otg_epout_handler.10927>
#if STM32_USB_USE_OTG2
    if (src & (1 << 20))
 80074fc:	9b03      	ldr	r3, [sp, #12]
 80074fe:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8007502:	2b00      	cmp	r3, #0
 8007504:	d003      	beq.n	800750e <usb_lld_serve_interrupt.10939.4453+0x20e>
      otg_epout_handler(usbp, 4);
 8007506:	9801      	ldr	r0, [sp, #4]
 8007508:	2104      	movs	r1, #4
 800750a:	f002 fb41 	bl	8009b90 <otg_epout_handler.10927>
    if (src & (1 << 21))
 800750e:	9b03      	ldr	r3, [sp, #12]
 8007510:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8007514:	2b00      	cmp	r3, #0
 8007516:	d003      	beq.n	8007520 <usb_lld_serve_interrupt.10939.4453+0x220>
      otg_epout_handler(usbp, 5);
 8007518:	9801      	ldr	r0, [sp, #4]
 800751a:	2105      	movs	r1, #5
 800751c:	f002 fb38 	bl	8009b90 <otg_epout_handler.10927>
#endif
  }
}
 8007520:	b007      	add	sp, #28
 8007522:	f85d fb04 	ldr.w	pc, [sp], #4
 8007526:	bf00      	nop
 8007528:	f3af 8000 	nop.w
 800752c:	f3af 8000 	nop.w

08007530 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8007530:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8007532:	f006 fced 	bl	800df10 <_stats_increase_irq>
 8007536:	f008 f953 	bl	800f7e0 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD1);
 800753a:	f241 3050 	movw	r0, #4944	; 0x1350
 800753e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8007542:	f7ff fedd 	bl	8007300 <usb_lld_serve_interrupt.10939.4453>

  OSAL_IRQ_EPILOGUE();
 8007546:	f008 f973 	bl	800f830 <_dbg_check_leave_isr>
 800754a:	f004 fa61 	bl	800ba10 <_port_irq_epilogue>
}
 800754e:	bd08      	pop	{r3, pc}

08007550 <Vector174>:
/**
 * @brief   OTG2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 8007550:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8007552:	f006 fcdd 	bl	800df10 <_stats_increase_irq>
 8007556:	f008 f943 	bl	800f7e0 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD2);
 800755a:	f241 5038 	movw	r0, #5432	; 0x1538
 800755e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8007562:	f7ff fecd 	bl	8007300 <usb_lld_serve_interrupt.10939.4453>

  OSAL_IRQ_EPILOGUE();
 8007566:	f008 f963 	bl	800f830 <_dbg_check_leave_isr>
 800756a:	f004 fa51 	bl	800ba10 <_port_irq_epilogue>
}
 800756e:	bd08      	pop	{r3, pc}

08007570 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8007570:	b500      	push	{lr}
 8007572:	b083      	sub	sp, #12

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8007574:	f241 3050 	movw	r0, #4944	; 0x1350
 8007578:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800757c:	f003 fc18 	bl	800adb0 <usbObjectInit>
  USBD1.wait      = NULL;
 8007580:	f241 3350 	movw	r3, #4944	; 0x1350
 8007584:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007588:	2200      	movs	r2, #0
 800758a:	679a      	str	r2, [r3, #120]	; 0x78
  USBD1.otg       = OTG_FS;
 800758c:	f241 3350 	movw	r3, #4944	; 0x1350
 8007590:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007594:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8007598:	669a      	str	r2, [r3, #104]	; 0x68
  USBD1.otgparams = &fsparams;
 800759a:	f241 3350 	movw	r3, #4944	; 0x1350
 800759e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80075a2:	f641 6240 	movw	r2, #7744	; 0x1e40
 80075a6:	f6c0 0201 	movt	r2, #2049	; 0x801
 80075aa:	66da      	str	r2, [r3, #108]	; 0x6c

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 80075ac:	f241 3350 	movw	r3, #4944	; 0x1350
 80075b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80075b4:	2200      	movs	r2, #0
 80075b6:	67da      	str	r2, [r3, #124]	; 0x7c
  /* Filling the thread working area here because the function
     @p chThdCreateI() does not do it.*/
#if CH_DBG_FILL_THREADS
  {
    void *wsp = USBD1.wa_pump;
 80075b8:	4b26      	ldr	r3, [pc, #152]	; (8007654 <usb_lld_init+0xe4>)
 80075ba:	9301      	str	r3, [sp, #4]
    _thread_memfill((uint8_t *)wsp,
 80075bc:	9b01      	ldr	r3, [sp, #4]
 80075be:	3360      	adds	r3, #96	; 0x60
 80075c0:	9801      	ldr	r0, [sp, #4]
 80075c2:	4619      	mov	r1, r3
 80075c4:	22ff      	movs	r2, #255	; 0xff
 80075c6:	f009 f873 	bl	80106b0 <_thread_memfill>
                    (uint8_t *)wsp + sizeof(thread_t),
                    CH_DBG_THREAD_FILL_VALUE);
    _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 80075ca:	9b01      	ldr	r3, [sp, #4]
 80075cc:	f103 0260 	add.w	r2, r3, #96	; 0x60
 80075d0:	9b01      	ldr	r3, [sp, #4]
 80075d2:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 80075d6:	4610      	mov	r0, r2
 80075d8:	4619      	mov	r1, r3
 80075da:	2255      	movs	r2, #85	; 0x55
 80075dc:	f009 f868 	bl	80106b0 <_thread_memfill>
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif

#if STM32_USB_USE_OTG2
  usbObjectInit(&USBD2);
 80075e0:	f241 5038 	movw	r0, #5432	; 0x1538
 80075e4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80075e8:	f003 fbe2 	bl	800adb0 <usbObjectInit>
  USBD2.wait      = NULL;
 80075ec:	f241 5338 	movw	r3, #5432	; 0x1538
 80075f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80075f4:	2200      	movs	r2, #0
 80075f6:	679a      	str	r2, [r3, #120]	; 0x78
  USBD2.otg       = OTG_HS;
 80075f8:	f241 5338 	movw	r3, #5432	; 0x1538
 80075fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007600:	2200      	movs	r2, #0
 8007602:	f2c4 0204 	movt	r2, #16388	; 0x4004
 8007606:	669a      	str	r2, [r3, #104]	; 0x68
  USBD2.otgparams = &hsparams;
 8007608:	f241 5338 	movw	r3, #5432	; 0x1538
 800760c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007610:	f641 6250 	movw	r2, #7760	; 0x1e50
 8007614:	f6c0 0201 	movt	r2, #2049	; 0x801
 8007618:	66da      	str	r2, [r3, #108]	; 0x6c

#if defined(_CHIBIOS_RT_)
  USBD2.tr = NULL;
 800761a:	f241 5338 	movw	r3, #5432	; 0x1538
 800761e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007622:	2200      	movs	r2, #0
 8007624:	67da      	str	r2, [r3, #124]	; 0x7c
  /* Filling the thread working area here because the function
     @p chThdCreateI() does not do it.*/
#if CH_DBG_FILL_THREADS
  {
    void *wsp = USBD2.wa_pump;
 8007626:	4b0c      	ldr	r3, [pc, #48]	; (8007658 <usb_lld_init+0xe8>)
 8007628:	9300      	str	r3, [sp, #0]
    _thread_memfill((uint8_t *)wsp,
 800762a:	9b00      	ldr	r3, [sp, #0]
 800762c:	3360      	adds	r3, #96	; 0x60
 800762e:	9800      	ldr	r0, [sp, #0]
 8007630:	4619      	mov	r1, r3
 8007632:	22ff      	movs	r2, #255	; 0xff
 8007634:	f009 f83c 	bl	80106b0 <_thread_memfill>
                    (uint8_t *)wsp + sizeof(thread_t),
                    CH_DBG_THREAD_FILL_VALUE);
    _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 8007638:	9b00      	ldr	r3, [sp, #0]
 800763a:	f103 0260 	add.w	r2, r3, #96	; 0x60
 800763e:	9b00      	ldr	r3, [sp, #0]
 8007640:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8007644:	4610      	mov	r0, r2
 8007646:	4619      	mov	r1, r3
 8007648:	2255      	movs	r2, #85	; 0x55
 800764a:	f009 f831 	bl	80106b0 <_thread_memfill>
                    CH_DBG_STACK_FILL_VALUE);
  }
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif
}
 800764e:	b003      	add	sp, #12
 8007650:	f85d fb04 	ldr.w	pc, [sp], #4
 8007654:	200013d0 	.word	0x200013d0
 8007658:	200015b8 	.word	0x200015b8
 800765c:	f3af 8000 	nop.w

08007660 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8007660:	b500      	push	{lr}
 8007662:	b087      	sub	sp, #28
 8007664:	9003      	str	r0, [sp, #12]
  stm32_otg_t *otgp = usbp->otg;
 8007666:	9b03      	ldr	r3, [sp, #12]
 8007668:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800766a:	9305      	str	r3, [sp, #20]

  if (usbp->state == USB_STOP) {
 800766c:	9b03      	ldr	r3, [sp, #12]
 800766e:	781b      	ldrb	r3, [r3, #0]
 8007670:	2b01      	cmp	r3, #1
 8007672:	f040 80dd 	bne.w	8007830 <usb_lld_start+0x1d0>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8007676:	9a03      	ldr	r2, [sp, #12]
 8007678:	f241 3350 	movw	r3, #4944	; 0x1350
 800767c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8007680:	429a      	cmp	r2, r3
 8007682:	d12d      	bne.n	80076e0 <usb_lld_start+0x80>
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(false);
 8007684:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007688:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800768c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007690:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8007694:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8007696:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800769a:	635a      	str	r2, [r3, #52]	; 0x34
      rccResetOTG_FS();
 800769c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80076a0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80076a4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80076a8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80076ac:	6952      	ldr	r2, [r2, #20]
 80076ae:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80076b2:	615a      	str	r2, [r3, #20]
 80076b4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80076b8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80076bc:	2200      	movs	r2, #0
 80076be:	615a      	str	r2, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 80076c0:	2043      	movs	r0, #67	; 0x43
 80076c2:	210e      	movs	r1, #14
 80076c4:	f001 fbc4 	bl	8008e50 <nvicEnableVector>

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 80076c8:	9a05      	ldr	r2, [sp, #20]
 80076ca:	f44f 53a2 	mov.w	r3, #5184	; 0x1440
 80076ce:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80076d2:	60d3      	str	r3, [r2, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 80076d4:	9a05      	ldr	r2, [sp, #20]
 80076d6:	2303      	movs	r3, #3
 80076d8:	f2c0 2320 	movt	r3, #544	; 0x220
 80076dc:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
    }
#endif

#if STM32_USB_USE_OTG2
    if (&USBD2 == usbp) {
 80076e0:	9a03      	ldr	r2, [sp, #12]
 80076e2:	f241 5338 	movw	r3, #5432	; 0x1538
 80076e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80076ea:	429a      	cmp	r2, r3
 80076ec:	d145      	bne.n	800777a <usb_lld_start+0x11a>
      /* OTG HS clock enable and reset.*/
      rccEnableOTG_HS(false);
 80076ee:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80076f2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80076f6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80076fa:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80076fe:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8007700:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8007704:	631a      	str	r2, [r3, #48]	; 0x30
      rccResetOTG_HS();
 8007706:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800770a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800770e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007712:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8007716:	6912      	ldr	r2, [r2, #16]
 8007718:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800771c:	611a      	str	r2, [r3, #16]
 800771e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007722:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007726:	2200      	movs	r2, #0
 8007728:	611a      	str	r2, [r3, #16]
#if defined(BOARD_OTG2_USES_ULPI)
      rccEnableOTG_HSULPI(true);
#else
      /* Workaround for the problem described here:
         http://forum.chibios.org/phpbb/viewtopic.php?f=16&t=1798.*/
      rccDisableOTG_HSULPI(true);
 800772a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800772e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8007732:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8007736:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800773a:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800773c:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8007740:	631a      	str	r2, [r3, #48]	; 0x30
 8007742:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8007746:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800774a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800774e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8007752:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8007754:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8007758:	651a      	str	r2, [r3, #80]	; 0x50
#endif

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
 800775a:	204d      	movs	r0, #77	; 0x4d
 800775c:	210e      	movs	r1, #14
 800775e:	f001 fb77 	bl	8008e50 <nvicEnableVector>
#if defined(BOARD_OTG2_USES_ULPI)
      /* High speed ULPI PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_HS) |
                      GUSBCFG_SRPCAP | GUSBCFG_HNPCAP;
#else
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8007762:	9a05      	ldr	r2, [sp, #20]
 8007764:	f44f 53a2 	mov.w	r3, #5184	; 0x1440
 8007768:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800776c:	60d3      	str	r3, [r2, #12]
      /* USB 2.0 High Speed PHY in FS mode.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_HS_FS;
#endif
#else
      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 800776e:	9a05      	ldr	r2, [sp, #20]
 8007770:	2303      	movs	r3, #3
 8007772:	f2c0 2320 	movt	r3, #544	; 0x220
 8007776:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
#endif
    }
#endif

    /* Clearing mask of TXFIFOs to be filled.*/
    usbp->txpending = 0;
 800777a:	9b03      	ldr	r3, [sp, #12]
 800777c:	2200      	movs	r2, #0
 800777e:	675a      	str	r2, [r3, #116]	; 0x74

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8007780:	9b05      	ldr	r3, [sp, #20]
 8007782:	2200      	movs	r2, #0
 8007784:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8007788:	9b05      	ldr	r3, [sp, #20]
 800778a:	22c0      	movs	r2, #192	; 0xc0
 800778c:	601a      	str	r2, [r3, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 800778e:	9b05      	ldr	r3, [sp, #20]
 8007790:	f44f 2250 	mov.w	r2, #851968	; 0xd0000
 8007794:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 8007796:	9803      	ldr	r0, [sp, #12]
 8007798:	f001 ff1a 	bl	80095d0 <otg_core_reset.10672>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 800779c:	9b05      	ldr	r3, [sp, #20]
 800779e:	2200      	movs	r2, #0
 80077a0:	609a      	str	r2, [r3, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 80077a2:	9803      	ldr	r0, [sp, #12]
 80077a4:	f001 ff34 	bl	8009610 <otg_disable_ep.10843>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 80077a8:	9b05      	ldr	r3, [sp, #20]
 80077aa:	2200      	movs	r2, #0
 80077ac:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 80077b0:	9b05      	ldr	r3, [sp, #20]
 80077b2:	2200      	movs	r2, #0
 80077b4:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 80077b8:	9b05      	ldr	r3, [sp, #20]
 80077ba:	2200      	movs	r2, #0
 80077bc:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 80077c0:	9b03      	ldr	r3, [sp, #12]
 80077c2:	685b      	ldr	r3, [r3, #4]
 80077c4:	68db      	ldr	r3, [r3, #12]
 80077c6:	2b00      	cmp	r3, #0
 80077c8:	d106      	bne.n	80077d8 <usb_lld_start+0x178>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 80077ca:	9a05      	ldr	r2, [sp, #20]
 80077cc:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 80077d0:	f2cc 0330 	movt	r3, #49200	; 0xc030
 80077d4:	6193      	str	r3, [r2, #24]
 80077d6:	e005      	b.n	80077e4 <usb_lld_start+0x184>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 80077d8:	9a05      	ldr	r2, [sp, #20]
 80077da:	f643 4308 	movw	r3, #15368	; 0x3c08
 80077de:	f2cc 0330 	movt	r3, #49200	; 0xc030
 80077e2:	6193      	str	r3, [r2, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 80077e4:	9b05      	ldr	r3, [sp, #20]
 80077e6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80077ea:	615a      	str	r2, [r3, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 80077ec:	9b03      	ldr	r3, [sp, #12]
 80077ee:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80077f0:	2b00      	cmp	r3, #0
 80077f2:	d117      	bne.n	8007824 <usb_lld_start+0x1c4>
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 80077f4:	9b03      	ldr	r3, [sp, #12]
 80077f6:	3380      	adds	r3, #128	; 0x80
 80077f8:	9a03      	ldr	r2, [sp, #12]
 80077fa:	9200      	str	r2, [sp, #0]
 80077fc:	4618      	mov	r0, r3
 80077fe:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8007802:	2202      	movs	r2, #2
 8007804:	f248 0351 	movw	r3, #32849	; 0x8051
 8007808:	f6c0 0300 	movt	r3, #2048	; 0x800
 800780c:	f008 ff68 	bl	80106e0 <chThdCreateI>
 8007810:	4602      	mov	r2, r0
 8007812:	9b03      	ldr	r3, [sp, #12]
 8007814:	67da      	str	r2, [r3, #124]	; 0x7c
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
 8007816:	9b03      	ldr	r3, [sp, #12]
 8007818:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800781a:	4618      	mov	r0, r3
 800781c:	f001 fe60 	bl	80094e0 <chThdStartI.10658>
      chSchRescheduleS();
 8007820:	f008 fc9e 	bl	8010160 <chSchRescheduleS>
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8007824:	9b05      	ldr	r3, [sp, #20]
 8007826:	689b      	ldr	r3, [r3, #8]
 8007828:	f043 0201 	orr.w	r2, r3, #1
 800782c:	9b05      	ldr	r3, [sp, #20]
 800782e:	609a      	str	r2, [r3, #8]
  }
}
 8007830:	b007      	add	sp, #28
 8007832:	f85d fb04 	ldr.w	pc, [sp], #4
 8007836:	bf00      	nop
 8007838:	f3af 8000 	nop.w
 800783c:	f3af 8000 	nop.w

08007840 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8007840:	b510      	push	{r4, lr}
 8007842:	b084      	sub	sp, #16
 8007844:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8007846:	9b01      	ldr	r3, [sp, #4]
 8007848:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800784a:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 800784c:	9801      	ldr	r0, [sp, #4]
 800784e:	2100      	movs	r1, #0
 8007850:	f001 ff3e 	bl	80096d0 <otg_txfifo_flush.10849>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8007854:	9b02      	ldr	r3, [sp, #8]
 8007856:	2200      	movs	r2, #0
 8007858:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800785c:	9b02      	ldr	r3, [sp, #8]
 800785e:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8007862:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8007866:	2300      	movs	r3, #0
 8007868:	9303      	str	r3, [sp, #12]
 800786a:	e024      	b.n	80078b6 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800786c:	9a02      	ldr	r2, [sp, #8]
 800786e:	9b03      	ldr	r3, [sp, #12]
 8007870:	3348      	adds	r3, #72	; 0x48
 8007872:	015b      	lsls	r3, r3, #5
 8007874:	4413      	add	r3, r2
 8007876:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800787a:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 800787c:	9a02      	ldr	r2, [sp, #8]
 800787e:	9b03      	ldr	r3, [sp, #12]
 8007880:	3358      	adds	r3, #88	; 0x58
 8007882:	015b      	lsls	r3, r3, #5
 8007884:	4413      	add	r3, r2
 8007886:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800788a:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800788c:	9a02      	ldr	r2, [sp, #8]
 800788e:	9b03      	ldr	r3, [sp, #12]
 8007890:	015b      	lsls	r3, r3, #5
 8007892:	4413      	add	r3, r2
 8007894:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8007898:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800789c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800789e:	9a02      	ldr	r2, [sp, #8]
 80078a0:	9b03      	ldr	r3, [sp, #12]
 80078a2:	015b      	lsls	r3, r3, #5
 80078a4:	4413      	add	r3, r2
 80078a6:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80078aa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80078ae:	601a      	str	r2, [r3, #0]
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80078b0:	9b03      	ldr	r3, [sp, #12]
 80078b2:	3301      	adds	r3, #1
 80078b4:	9303      	str	r3, [sp, #12]
 80078b6:	9b01      	ldr	r3, [sp, #4]
 80078b8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80078ba:	689a      	ldr	r2, [r3, #8]
 80078bc:	9b03      	ldr	r3, [sp, #12]
 80078be:	429a      	cmp	r2, r3
 80078c0:	d2d4      	bcs.n	800786c <usb_lld_reset+0x2c>
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 80078c2:	9801      	ldr	r0, [sp, #4]
 80078c4:	f001 ff24 	bl	8009710 <otg_ram_reset.10853>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80078c8:	9b01      	ldr	r3, [sp, #4]
 80078ca:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80078cc:	681a      	ldr	r2, [r3, #0]
 80078ce:	9b02      	ldr	r3, [sp, #8]
 80078d0:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 80078d2:	9801      	ldr	r0, [sp, #4]
 80078d4:	f001 fee4 	bl	80096a0 <otg_rxfifo_flush.10846>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80078d8:	9b02      	ldr	r3, [sp, #8]
 80078da:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 80078de:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 80078e2:	9b02      	ldr	r3, [sp, #8]
 80078e4:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 80078e8:	9b02      	ldr	r3, [sp, #8]
 80078ea:	699b      	ldr	r3, [r3, #24]
 80078ec:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 80078f0:	f043 0310 	orr.w	r3, r3, #16
 80078f4:	9a02      	ldr	r2, [sp, #8]
 80078f6:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 80078f8:	9b02      	ldr	r3, [sp, #8]
 80078fa:	2209      	movs	r2, #9
 80078fc:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8007900:	9b02      	ldr	r3, [sp, #8]
 8007902:	2209      	movs	r2, #9
 8007904:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8007908:	9a01      	ldr	r2, [sp, #4]
 800790a:	f641 6310 	movw	r3, #7696	; 0x1e10
 800790e:	f6c0 0301 	movt	r3, #2049	; 0x801
 8007912:	60d3      	str	r3, [r2, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 8007914:	9b02      	ldr	r3, [sp, #8]
 8007916:	2200      	movs	r2, #0
 8007918:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 800791c:	2340      	movs	r3, #64	; 0x40
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 800791e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8007922:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8007926:	9a02      	ldr	r2, [sp, #8]
 8007928:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 800792c:	9b02      	ldr	r3, [sp, #8]
 800792e:	2200      	movs	r2, #0
 8007930:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 8007934:	2340      	movs	r3, #64	; 0x40
 8007936:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800793a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 800793e:	9a02      	ldr	r2, [sp, #8]
 8007940:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8007944:	2340      	movs	r3, #64	; 0x40
 8007946:	089b      	lsrs	r3, r3, #2
 8007948:	b29b      	uxth	r3, r3
 800794a:	041b      	lsls	r3, r3, #16
 800794c:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 800794e:	2340      	movs	r3, #64	; 0x40
 8007950:	089b      	lsrs	r3, r3, #2
 8007952:	b29b      	uxth	r3, r3
 8007954:	9801      	ldr	r0, [sp, #4]
 8007956:	4619      	mov	r1, r3
 8007958:	f001 feea 	bl	8009730 <otg_ram_alloc.10856>
 800795c:	4603      	mov	r3, r0
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800795e:	ea44 0203 	orr.w	r2, r4, r3
 8007962:	9b02      	ldr	r3, [sp, #8]
 8007964:	629a      	str	r2, [r3, #40]	; 0x28
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
                                                  ep0config.in_maxsize / 4));
}
 8007966:	b004      	add	sp, #16
 8007968:	bd10      	pop	{r4, pc}
 800796a:	bf00      	nop
 800796c:	f3af 8000 	nop.w

08007970 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 8007970:	b084      	sub	sp, #16
 8007972:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8007974:	9b01      	ldr	r3, [sp, #4]
 8007976:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8007978:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 800797a:	9b03      	ldr	r3, [sp, #12]
 800797c:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 8007980:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8007984:	9b01      	ldr	r3, [sp, #4]
 8007986:	f893 3066 	ldrb.w	r3, [r3, #102]	; 0x66
 800798a:	011b      	lsls	r3, r3, #4
 800798c:	431a      	orrs	r2, r3
 800798e:	9b03      	ldr	r3, [sp, #12]
 8007990:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 8007994:	b004      	add	sp, #16
 8007996:	4770      	bx	lr
 8007998:	f3af 8000 	nop.w
 800799c:	f3af 8000 	nop.w

080079a0 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 80079a0:	b530      	push	{r4, r5, lr}
 80079a2:	b087      	sub	sp, #28
 80079a4:	9001      	str	r0, [sp, #4]
 80079a6:	460b      	mov	r3, r1
 80079a8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 80079ac:	9b01      	ldr	r3, [sp, #4]
 80079ae:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80079b0:	9303      	str	r3, [sp, #12]

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80079b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80079b6:	9a01      	ldr	r2, [sp, #4]
 80079b8:	3302      	adds	r3, #2
 80079ba:	009b      	lsls	r3, r3, #2
 80079bc:	4413      	add	r3, r2
 80079be:	685b      	ldr	r3, [r3, #4]
 80079c0:	681b      	ldr	r3, [r3, #0]
 80079c2:	f003 0303 	and.w	r3, r3, #3
 80079c6:	2b03      	cmp	r3, #3
 80079c8:	f200 8115 	bhi.w	8007bf6 <usb_lld_init_endpoint+0x256>
 80079cc:	a201      	add	r2, pc, #4	; (adr r2, 80079d4 <usb_lld_init_endpoint+0x34>)
 80079ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80079d2:	bf00      	nop
 80079d4:	080079e5 	.word	0x080079e5
 80079d8:	080079f1 	.word	0x080079f1
 80079dc:	080079fd 	.word	0x080079fd
 80079e0:	08007a09 	.word	0x08007a09
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 80079e4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80079e8:	f2c1 0300 	movt	r3, #4096	; 0x1000
 80079ec:	9305      	str	r3, [sp, #20]
 80079ee:	e010      	b.n	8007a12 <usb_lld_init_endpoint+0x72>
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 80079f0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80079f4:	f2c1 0304 	movt	r3, #4100	; 0x1004
 80079f8:	9305      	str	r3, [sp, #20]
 80079fa:	e00a      	b.n	8007a12 <usb_lld_init_endpoint+0x72>
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 80079fc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8007a00:	f2c1 0308 	movt	r3, #4104	; 0x1008
 8007a04:	9305      	str	r3, [sp, #20]
 8007a06:	e004      	b.n	8007a12 <usb_lld_init_endpoint+0x72>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8007a08:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8007a0c:	f2c1 030c 	movt	r3, #4108	; 0x100c
 8007a10:	9305      	str	r3, [sp, #20]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 8007a12:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007a16:	9a03      	ldr	r2, [sp, #12]
 8007a18:	015b      	lsls	r3, r3, #5
 8007a1a:	4413      	add	r3, r2
 8007a1c:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8007a20:	2200      	movs	r2, #0
 8007a22:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 8007a24:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007a28:	9a01      	ldr	r2, [sp, #4]
 8007a2a:	3302      	adds	r3, #2
 8007a2c:	009b      	lsls	r3, r3, #2
 8007a2e:	4413      	add	r3, r2
 8007a30:	685b      	ldr	r3, [r3, #4]
 8007a32:	699b      	ldr	r3, [r3, #24]
 8007a34:	2b00      	cmp	r3, #0
 8007a36:	d020      	beq.n	8007a7a <usb_lld_init_endpoint+0xda>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8007a38:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8007a3c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007a40:	9a01      	ldr	r2, [sp, #4]
 8007a42:	3302      	adds	r3, #2
 8007a44:	009b      	lsls	r3, r3, #2
 8007a46:	4413      	add	r3, r2
 8007a48:	685b      	ldr	r3, [r3, #4]
 8007a4a:	8a5b      	ldrh	r3, [r3, #18]
 8007a4c:	461a      	mov	r2, r3
 8007a4e:	9b05      	ldr	r3, [sp, #20]
 8007a50:	431a      	orrs	r2, r3
 8007a52:	9903      	ldr	r1, [sp, #12]
 8007a54:	f100 0358 	add.w	r3, r0, #88	; 0x58
 8007a58:	015b      	lsls	r3, r3, #5
 8007a5a:	440b      	add	r3, r1
 8007a5c:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8007a5e:	9b03      	ldr	r3, [sp, #12]
 8007a60:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8007a64:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007a68:	3310      	adds	r3, #16
 8007a6a:	2101      	movs	r1, #1
 8007a6c:	fa01 f303 	lsl.w	r3, r1, r3
 8007a70:	431a      	orrs	r2, r3
 8007a72:	9b03      	ldr	r3, [sp, #12]
 8007a74:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8007a78:	e01d      	b.n	8007ab6 <usb_lld_init_endpoint+0x116>
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8007a7a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007a7e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007a82:	9903      	ldr	r1, [sp, #12]
 8007a84:	3258      	adds	r2, #88	; 0x58
 8007a86:	0152      	lsls	r2, r2, #5
 8007a88:	440a      	add	r2, r1
 8007a8a:	6812      	ldr	r2, [r2, #0]
 8007a8c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007a90:	9903      	ldr	r1, [sp, #12]
 8007a92:	3358      	adds	r3, #88	; 0x58
 8007a94:	015b      	lsls	r3, r3, #5
 8007a96:	440b      	add	r3, r1
 8007a98:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8007a9a:	9b03      	ldr	r3, [sp, #12]
 8007a9c:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8007aa0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007aa4:	3310      	adds	r3, #16
 8007aa6:	2101      	movs	r1, #1
 8007aa8:	fa01 f303 	lsl.w	r3, r1, r3
 8007aac:	43db      	mvns	r3, r3
 8007aae:	401a      	ands	r2, r3
 8007ab0:	9b03      	ldr	r3, [sp, #12]
 8007ab2:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 8007ab6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007aba:	9a03      	ldr	r2, [sp, #12]
 8007abc:	015b      	lsls	r3, r3, #5
 8007abe:	4413      	add	r3, r2
 8007ac0:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8007ac4:	2200      	movs	r2, #0
 8007ac6:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->in_state != NULL) {
 8007ac8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007acc:	9a01      	ldr	r2, [sp, #4]
 8007ace:	3302      	adds	r3, #2
 8007ad0:	009b      	lsls	r3, r3, #2
 8007ad2:	4413      	add	r3, r2
 8007ad4:	685b      	ldr	r3, [r3, #4]
 8007ad6:	695b      	ldr	r3, [r3, #20]
 8007ad8:	2b00      	cmp	r3, #0
 8007ada:	d05d      	beq.n	8007b98 <usb_lld_init_endpoint+0x1f8>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8007adc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007ae0:	9a01      	ldr	r2, [sp, #4]
 8007ae2:	3302      	adds	r3, #2
 8007ae4:	009b      	lsls	r3, r3, #2
 8007ae6:	4413      	add	r3, r2
 8007ae8:	685b      	ldr	r3, [r3, #4]
 8007aea:	8a1b      	ldrh	r3, [r3, #16]
 8007aec:	089b      	lsrs	r3, r3, #2
 8007aee:	b29b      	uxth	r3, r3
 8007af0:	9304      	str	r3, [sp, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8007af2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007af6:	9a01      	ldr	r2, [sp, #4]
 8007af8:	3302      	adds	r3, #2
 8007afa:	009b      	lsls	r3, r3, #2
 8007afc:	4413      	add	r3, r2
 8007afe:	685b      	ldr	r3, [r3, #4]
 8007b00:	8b9b      	ldrh	r3, [r3, #28]
 8007b02:	2b01      	cmp	r3, #1
 8007b04:	d90c      	bls.n	8007b20 <usb_lld_init_endpoint+0x180>
      fsize *= usbp->epc[ep]->in_multiplier;
 8007b06:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007b0a:	9a01      	ldr	r2, [sp, #4]
 8007b0c:	3302      	adds	r3, #2
 8007b0e:	009b      	lsls	r3, r3, #2
 8007b10:	4413      	add	r3, r2
 8007b12:	685b      	ldr	r3, [r3, #4]
 8007b14:	8b9b      	ldrh	r3, [r3, #28]
 8007b16:	461a      	mov	r2, r3
 8007b18:	9b04      	ldr	r3, [sp, #16]
 8007b1a:	fb02 f303 	mul.w	r3, r2, r3
 8007b1e:	9304      	str	r3, [sp, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8007b20:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007b24:	1e5c      	subs	r4, r3, #1
 8007b26:	9b04      	ldr	r3, [sp, #16]
 8007b28:	041d      	lsls	r5, r3, #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 8007b2a:	9801      	ldr	r0, [sp, #4]
 8007b2c:	9904      	ldr	r1, [sp, #16]
 8007b2e:	f001 fdff 	bl	8009730 <otg_ram_alloc.10856>
 8007b32:	4603      	mov	r3, r0
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8007b34:	ea45 0203 	orr.w	r2, r5, r3
 8007b38:	9903      	ldr	r1, [sp, #12]
 8007b3a:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8007b3e:	009b      	lsls	r3, r3, #2
 8007b40:	440b      	add	r3, r1
 8007b42:	605a      	str	r2, [r3, #4]
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);
 8007b44:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007b48:	9801      	ldr	r0, [sp, #4]
 8007b4a:	4619      	mov	r1, r3
 8007b4c:	f001 fdc0 	bl	80096d0 <otg_txfifo_flush.10849>

    otgp->ie[ep].DIEPCTL = ctl |
 8007b50:	f89d 0003 	ldrb.w	r0, [sp, #3]
                           DIEPCTL_TXFNUM(ep) |
 8007b54:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007b58:	059b      	lsls	r3, r3, #22
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8007b5a:	461a      	mov	r2, r3
 8007b5c:	9b05      	ldr	r3, [sp, #20]
 8007b5e:	431a      	orrs	r2, r3
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8007b60:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007b64:	9901      	ldr	r1, [sp, #4]
 8007b66:	3302      	adds	r3, #2
 8007b68:	009b      	lsls	r3, r3, #2
 8007b6a:	440b      	add	r3, r1
 8007b6c:	685b      	ldr	r3, [r3, #4]
 8007b6e:	8a1b      	ldrh	r3, [r3, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 8007b70:	431a      	orrs	r2, r3
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8007b72:	9903      	ldr	r1, [sp, #12]
 8007b74:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8007b78:	015b      	lsls	r3, r3, #5
 8007b7a:	440b      	add	r3, r1
 8007b7c:	601a      	str	r2, [r3, #0]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8007b7e:	9b03      	ldr	r3, [sp, #12]
 8007b80:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8007b84:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007b88:	2101      	movs	r1, #1
 8007b8a:	fa01 f303 	lsl.w	r3, r1, r3
 8007b8e:	431a      	orrs	r2, r3
 8007b90:	9b03      	ldr	r3, [sp, #12]
 8007b92:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8007b96:	e02e      	b.n	8007bf6 <usb_lld_init_endpoint+0x256>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8007b98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007b9c:	3b01      	subs	r3, #1
 8007b9e:	9a03      	ldr	r2, [sp, #12]
 8007ba0:	3340      	adds	r3, #64	; 0x40
 8007ba2:	009b      	lsls	r3, r3, #2
 8007ba4:	4413      	add	r3, r2
 8007ba6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8007baa:	f2c0 2200 	movt	r2, #512	; 0x200
 8007bae:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 8007bb0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007bb4:	9801      	ldr	r0, [sp, #4]
 8007bb6:	4619      	mov	r1, r3
 8007bb8:	f001 fd8a 	bl	80096d0 <otg_txfifo_flush.10849>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8007bbc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007bc0:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007bc4:	9903      	ldr	r1, [sp, #12]
 8007bc6:	3248      	adds	r2, #72	; 0x48
 8007bc8:	0152      	lsls	r2, r2, #5
 8007bca:	440a      	add	r2, r1
 8007bcc:	6812      	ldr	r2, [r2, #0]
 8007bce:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007bd2:	9903      	ldr	r1, [sp, #12]
 8007bd4:	3348      	adds	r3, #72	; 0x48
 8007bd6:	015b      	lsls	r3, r3, #5
 8007bd8:	440b      	add	r3, r1
 8007bda:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8007bdc:	9b03      	ldr	r3, [sp, #12]
 8007bde:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8007be2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007be6:	2101      	movs	r1, #1
 8007be8:	fa01 f303 	lsl.w	r3, r1, r3
 8007bec:	43db      	mvns	r3, r3
 8007bee:	401a      	ands	r2, r3
 8007bf0:	9b03      	ldr	r3, [sp, #12]
 8007bf2:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }
}
 8007bf6:	b007      	add	sp, #28
 8007bf8:	bd30      	pop	{r4, r5, pc}
 8007bfa:	bf00      	nop
 8007bfc:	f3af 8000 	nop.w

08007c00 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 8007c00:	b084      	sub	sp, #16
 8007c02:	9001      	str	r0, [sp, #4]
 8007c04:	460b      	mov	r3, r1
 8007c06:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 8007c0a:	9b01      	ldr	r3, [sp, #4]
 8007c0c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8007c0e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c12:	3358      	adds	r3, #88	; 0x58
 8007c14:	015b      	lsls	r3, r3, #5
 8007c16:	4413      	add	r3, r2
 8007c18:	681b      	ldr	r3, [r3, #0]
 8007c1a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 8007c1c:	9b03      	ldr	r3, [sp, #12]
 8007c1e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007c22:	2b00      	cmp	r3, #0
 8007c24:	d101      	bne.n	8007c2a <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 8007c26:	2300      	movs	r3, #0
 8007c28:	e007      	b.n	8007c3a <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 8007c2a:	9b03      	ldr	r3, [sp, #12]
 8007c2c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8007c30:	2b00      	cmp	r3, #0
 8007c32:	d001      	beq.n	8007c38 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 8007c34:	2301      	movs	r3, #1
 8007c36:	e000      	b.n	8007c3a <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 8007c38:	2302      	movs	r3, #2
}
 8007c3a:	4618      	mov	r0, r3
 8007c3c:	b004      	add	sp, #16
 8007c3e:	4770      	bx	lr

08007c40 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 8007c40:	b084      	sub	sp, #16
 8007c42:	9001      	str	r0, [sp, #4]
 8007c44:	460b      	mov	r3, r1
 8007c46:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8007c4a:	9b01      	ldr	r3, [sp, #4]
 8007c4c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8007c4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c52:	3348      	adds	r3, #72	; 0x48
 8007c54:	015b      	lsls	r3, r3, #5
 8007c56:	4413      	add	r3, r2
 8007c58:	681b      	ldr	r3, [r3, #0]
 8007c5a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 8007c5c:	9b03      	ldr	r3, [sp, #12]
 8007c5e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007c62:	2b00      	cmp	r3, #0
 8007c64:	d101      	bne.n	8007c6a <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 8007c66:	2300      	movs	r3, #0
 8007c68:	e007      	b.n	8007c7a <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 8007c6a:	9b03      	ldr	r3, [sp, #12]
 8007c6c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8007c70:	2b00      	cmp	r3, #0
 8007c72:	d001      	beq.n	8007c78 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 8007c74:	2301      	movs	r3, #1
 8007c76:	e000      	b.n	8007c7a <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 8007c78:	2302      	movs	r3, #2
}
 8007c7a:	4618      	mov	r0, r3
 8007c7c:	b004      	add	sp, #16
 8007c7e:	4770      	bx	lr

08007c80 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 8007c80:	b500      	push	{lr}
 8007c82:	b085      	sub	sp, #20
 8007c84:	9003      	str	r0, [sp, #12]
 8007c86:	460b      	mov	r3, r1
 8007c88:	9201      	str	r2, [sp, #4]
 8007c8a:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8007c8e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8007c92:	9a03      	ldr	r2, [sp, #12]
 8007c94:	3302      	adds	r3, #2
 8007c96:	009b      	lsls	r3, r3, #2
 8007c98:	4413      	add	r3, r2
 8007c9a:	685b      	ldr	r3, [r3, #4]
 8007c9c:	6a1b      	ldr	r3, [r3, #32]
 8007c9e:	9801      	ldr	r0, [sp, #4]
 8007ca0:	4619      	mov	r1, r3
 8007ca2:	2208      	movs	r2, #8
 8007ca4:	f7f8 fb34 	bl	8000310 <memcpy>
}
 8007ca8:	b005      	add	sp, #20
 8007caa:	f85d fb04 	ldr.w	pc, [sp], #4
 8007cae:	bf00      	nop

08007cb0 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8007cb0:	b086      	sub	sp, #24
 8007cb2:	9001      	str	r0, [sp, #4]
 8007cb4:	460b      	mov	r3, r1
 8007cb6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8007cba:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007cbe:	9a01      	ldr	r2, [sp, #4]
 8007cc0:	3302      	adds	r3, #2
 8007cc2:	009b      	lsls	r3, r3, #2
 8007cc4:	4413      	add	r3, r2
 8007cc6:	685b      	ldr	r3, [r3, #4]
 8007cc8:	699b      	ldr	r3, [r3, #24]
 8007cca:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 8007ccc:	9b05      	ldr	r3, [sp, #20]
 8007cce:	681a      	ldr	r2, [r3, #0]
 8007cd0:	9b05      	ldr	r3, [sp, #20]
 8007cd2:	60da      	str	r2, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8007cd4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007cd8:	2b00      	cmp	r3, #0
 8007cda:	d106      	bne.n	8007cea <usb_lld_start_out+0x3a>
 8007cdc:	9b05      	ldr	r3, [sp, #20]
 8007cde:	681b      	ldr	r3, [r3, #0]
 8007ce0:	2b40      	cmp	r3, #64	; 0x40
 8007ce2:	d902      	bls.n	8007cea <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8007ce4:	9b05      	ldr	r3, [sp, #20]
 8007ce6:	2240      	movs	r2, #64	; 0x40
 8007ce8:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8007cea:	9b05      	ldr	r3, [sp, #20]
 8007cec:	681a      	ldr	r2, [r3, #0]
 8007cee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007cf2:	9901      	ldr	r1, [sp, #4]
 8007cf4:	3302      	adds	r3, #2
 8007cf6:	009b      	lsls	r3, r3, #2
 8007cf8:	440b      	add	r3, r1
 8007cfa:	685b      	ldr	r3, [r3, #4]
 8007cfc:	8a5b      	ldrh	r3, [r3, #18]
 8007cfe:	4413      	add	r3, r2
 8007d00:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 8007d02:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d06:	9901      	ldr	r1, [sp, #4]
 8007d08:	3302      	adds	r3, #2
 8007d0a:	009b      	lsls	r3, r3, #2
 8007d0c:	440b      	add	r3, r1
 8007d0e:	685b      	ldr	r3, [r3, #4]
 8007d10:	8a5b      	ldrh	r3, [r3, #18]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8007d12:	fbb2 f3f3 	udiv	r3, r2, r3
 8007d16:	9304      	str	r3, [sp, #16]
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8007d18:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d1c:	9a01      	ldr	r2, [sp, #4]
 8007d1e:	3302      	adds	r3, #2
 8007d20:	009b      	lsls	r3, r3, #2
 8007d22:	4413      	add	r3, r2
 8007d24:	685b      	ldr	r3, [r3, #4]
 8007d26:	8a5b      	ldrh	r3, [r3, #18]
 8007d28:	9a04      	ldr	r2, [sp, #16]
 8007d2a:	fb02 f303 	mul.w	r3, r2, r3
 8007d2e:	3303      	adds	r3, #3
 8007d30:	f023 0303 	bic.w	r3, r3, #3
 8007d34:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007d36:	9b01      	ldr	r3, [sp, #4]
 8007d38:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007d3a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d3e:	9a04      	ldr	r2, [sp, #16]
 8007d40:	04d0      	lsls	r0, r2, #19
 8007d42:	9a03      	ldr	r2, [sp, #12]
 8007d44:	4302      	orrs	r2, r0
 8007d46:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 8007d4a:	015b      	lsls	r3, r3, #5
 8007d4c:	440b      	add	r3, r1
 8007d4e:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8007d52:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007d54:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d58:	9a01      	ldr	r2, [sp, #4]
 8007d5a:	3302      	adds	r3, #2
 8007d5c:	009b      	lsls	r3, r3, #2
 8007d5e:	4413      	add	r3, r2
 8007d60:	685b      	ldr	r3, [r3, #4]
 8007d62:	681b      	ldr	r3, [r3, #0]
 8007d64:	f003 0303 	and.w	r3, r3, #3
 8007d68:	2b01      	cmp	r3, #1
 8007d6a:	d12c      	bne.n	8007dc6 <usb_lld_start_out+0x116>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8007d6c:	9b01      	ldr	r3, [sp, #4]
 8007d6e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8007d70:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8007d74:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8007d78:	2b00      	cmp	r3, #0
 8007d7a:	d012      	beq.n	8007da2 <usb_lld_start_out+0xf2>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 8007d7c:	9b01      	ldr	r3, [sp, #4]
 8007d7e:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007d80:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007d84:	9a01      	ldr	r2, [sp, #4]
 8007d86:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8007d88:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007d8c:	3258      	adds	r2, #88	; 0x58
 8007d8e:	0152      	lsls	r2, r2, #5
 8007d90:	4402      	add	r2, r0
 8007d92:	6812      	ldr	r2, [r2, #0]
 8007d94:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007d98:	3358      	adds	r3, #88	; 0x58
 8007d9a:	015b      	lsls	r3, r3, #5
 8007d9c:	440b      	add	r3, r1
 8007d9e:	601a      	str	r2, [r3, #0]
 8007da0:	e011      	b.n	8007dc6 <usb_lld_start_out+0x116>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8007da2:	9b01      	ldr	r3, [sp, #4]
 8007da4:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007da6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007daa:	9a01      	ldr	r2, [sp, #4]
 8007dac:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8007dae:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007db2:	3258      	adds	r2, #88	; 0x58
 8007db4:	0152      	lsls	r2, r2, #5
 8007db6:	4402      	add	r2, r0
 8007db8:	6812      	ldr	r2, [r2, #0]
 8007dba:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8007dbe:	3358      	adds	r3, #88	; 0x58
 8007dc0:	015b      	lsls	r3, r3, #5
 8007dc2:	440b      	add	r3, r1
 8007dc4:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8007dc6:	9b01      	ldr	r3, [sp, #4]
 8007dc8:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007dca:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007dce:	9a01      	ldr	r2, [sp, #4]
 8007dd0:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8007dd2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007dd6:	3258      	adds	r2, #88	; 0x58
 8007dd8:	0152      	lsls	r2, r2, #5
 8007dda:	4402      	add	r2, r0
 8007ddc:	6812      	ldr	r2, [r2, #0]
 8007dde:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8007de2:	3358      	adds	r3, #88	; 0x58
 8007de4:	015b      	lsls	r3, r3, #5
 8007de6:	440b      	add	r3, r1
 8007de8:	601a      	str	r2, [r3, #0]
}
 8007dea:	b006      	add	sp, #24
 8007dec:	4770      	bx	lr
 8007dee:	bf00      	nop

08007df0 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8007df0:	b084      	sub	sp, #16
 8007df2:	9001      	str	r0, [sp, #4]
 8007df4:	460b      	mov	r3, r1
 8007df6:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8007dfa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007dfe:	9a01      	ldr	r2, [sp, #4]
 8007e00:	3302      	adds	r3, #2
 8007e02:	009b      	lsls	r3, r3, #2
 8007e04:	4413      	add	r3, r2
 8007e06:	685b      	ldr	r3, [r3, #4]
 8007e08:	695b      	ldr	r3, [r3, #20]
 8007e0a:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 8007e0c:	9b03      	ldr	r3, [sp, #12]
 8007e0e:	681a      	ldr	r2, [r3, #0]
 8007e10:	9b03      	ldr	r3, [sp, #12]
 8007e12:	60da      	str	r2, [r3, #12]
  if (isp->txsize == 0) {
 8007e14:	9b03      	ldr	r3, [sp, #12]
 8007e16:	681b      	ldr	r3, [r3, #0]
 8007e18:	2b00      	cmp	r3, #0
 8007e1a:	d10b      	bne.n	8007e34 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8007e1c:	9b01      	ldr	r3, [sp, #4]
 8007e1e:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8007e20:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007e24:	015b      	lsls	r3, r3, #5
 8007e26:	4413      	add	r3, r2
 8007e28:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8007e2c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8007e30:	601a      	str	r2, [r3, #0]
 8007e32:	e031      	b.n	8007e98 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8007e34:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007e38:	2b00      	cmp	r3, #0
 8007e3a:	d106      	bne.n	8007e4a <usb_lld_start_in+0x5a>
 8007e3c:	9b03      	ldr	r3, [sp, #12]
 8007e3e:	681b      	ldr	r3, [r3, #0]
 8007e40:	2b40      	cmp	r3, #64	; 0x40
 8007e42:	d902      	bls.n	8007e4a <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 8007e44:	9b03      	ldr	r3, [sp, #12]
 8007e46:	2240      	movs	r2, #64	; 0x40
 8007e48:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8007e4a:	9b03      	ldr	r3, [sp, #12]
 8007e4c:	681a      	ldr	r2, [r3, #0]
 8007e4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007e52:	9901      	ldr	r1, [sp, #4]
 8007e54:	3302      	adds	r3, #2
 8007e56:	009b      	lsls	r3, r3, #2
 8007e58:	440b      	add	r3, r1
 8007e5a:	685b      	ldr	r3, [r3, #4]
 8007e5c:	8a1b      	ldrh	r3, [r3, #16]
 8007e5e:	4413      	add	r3, r2
 8007e60:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 8007e62:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007e66:	9901      	ldr	r1, [sp, #4]
 8007e68:	3302      	adds	r3, #2
 8007e6a:	009b      	lsls	r3, r3, #2
 8007e6c:	440b      	add	r3, r1
 8007e6e:	685b      	ldr	r3, [r3, #4]
 8007e70:	8a1b      	ldrh	r3, [r3, #16]
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8007e72:	fbb2 f3f3 	udiv	r3, r2, r3
 8007e76:	9302      	str	r3, [sp, #8]
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8007e78:	9b01      	ldr	r3, [sp, #4]
 8007e7a:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007e7c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007e80:	9a02      	ldr	r2, [sp, #8]
 8007e82:	04d0      	lsls	r0, r2, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 8007e84:	9a03      	ldr	r2, [sp, #12]
 8007e86:	6812      	ldr	r2, [r2, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8007e88:	4302      	orrs	r2, r0
 8007e8a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8007e8e:	015b      	lsls	r3, r3, #5
 8007e90:	440b      	add	r3, r1
 8007e92:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8007e96:	601a      	str	r2, [r3, #0]
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007e98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007e9c:	9a01      	ldr	r2, [sp, #4]
 8007e9e:	3302      	adds	r3, #2
 8007ea0:	009b      	lsls	r3, r3, #2
 8007ea2:	4413      	add	r3, r2
 8007ea4:	685b      	ldr	r3, [r3, #4]
 8007ea6:	681b      	ldr	r3, [r3, #0]
 8007ea8:	f003 0303 	and.w	r3, r3, #3
 8007eac:	2b01      	cmp	r3, #1
 8007eae:	d12c      	bne.n	8007f0a <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8007eb0:	9b01      	ldr	r3, [sp, #4]
 8007eb2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8007eb4:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8007eb8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8007ebc:	2b00      	cmp	r3, #0
 8007ebe:	d012      	beq.n	8007ee6 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8007ec0:	9b01      	ldr	r3, [sp, #4]
 8007ec2:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007ec4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007ec8:	9a01      	ldr	r2, [sp, #4]
 8007eca:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8007ecc:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007ed0:	3248      	adds	r2, #72	; 0x48
 8007ed2:	0152      	lsls	r2, r2, #5
 8007ed4:	4402      	add	r2, r0
 8007ed6:	6812      	ldr	r2, [r2, #0]
 8007ed8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007edc:	3348      	adds	r3, #72	; 0x48
 8007ede:	015b      	lsls	r3, r3, #5
 8007ee0:	440b      	add	r3, r1
 8007ee2:	601a      	str	r2, [r3, #0]
 8007ee4:	e011      	b.n	8007f0a <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8007ee6:	9b01      	ldr	r3, [sp, #4]
 8007ee8:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007eea:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007eee:	9a01      	ldr	r2, [sp, #4]
 8007ef0:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8007ef2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007ef6:	3248      	adds	r2, #72	; 0x48
 8007ef8:	0152      	lsls	r2, r2, #5
 8007efa:	4402      	add	r2, r0
 8007efc:	6812      	ldr	r2, [r2, #0]
 8007efe:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8007f02:	3348      	adds	r3, #72	; 0x48
 8007f04:	015b      	lsls	r3, r3, #5
 8007f06:	440b      	add	r3, r1
 8007f08:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8007f0a:	9b01      	ldr	r3, [sp, #4]
 8007f0c:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007f0e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007f12:	9a01      	ldr	r2, [sp, #4]
 8007f14:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8007f16:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007f1a:	3248      	adds	r2, #72	; 0x48
 8007f1c:	0152      	lsls	r2, r2, #5
 8007f1e:	4402      	add	r2, r0
 8007f20:	6812      	ldr	r2, [r2, #0]
 8007f22:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8007f26:	3348      	adds	r3, #72	; 0x48
 8007f28:	015b      	lsls	r3, r3, #5
 8007f2a:	440b      	add	r3, r1
 8007f2c:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8007f2e:	9b01      	ldr	r3, [sp, #4]
 8007f30:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8007f32:	9a01      	ldr	r2, [sp, #4]
 8007f34:	6e92      	ldr	r2, [r2, #104]	; 0x68
 8007f36:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 8007f3a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007f3e:	2001      	movs	r0, #1
 8007f40:	fa00 f202 	lsl.w	r2, r0, r2
 8007f44:	430a      	orrs	r2, r1
 8007f46:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 8007f4a:	b004      	add	sp, #16
 8007f4c:	4770      	bx	lr
 8007f4e:	bf00      	nop

08007f50 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8007f50:	b082      	sub	sp, #8
 8007f52:	9001      	str	r0, [sp, #4]
 8007f54:	460b      	mov	r3, r1
 8007f56:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8007f5a:	9b01      	ldr	r3, [sp, #4]
 8007f5c:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007f5e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007f62:	9a01      	ldr	r2, [sp, #4]
 8007f64:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8007f66:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007f6a:	3258      	adds	r2, #88	; 0x58
 8007f6c:	0152      	lsls	r2, r2, #5
 8007f6e:	4402      	add	r2, r0
 8007f70:	6812      	ldr	r2, [r2, #0]
 8007f72:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8007f76:	3358      	adds	r3, #88	; 0x58
 8007f78:	015b      	lsls	r3, r3, #5
 8007f7a:	440b      	add	r3, r1
 8007f7c:	601a      	str	r2, [r3, #0]
}
 8007f7e:	b002      	add	sp, #8
 8007f80:	4770      	bx	lr
 8007f82:	bf00      	nop
 8007f84:	f3af 8000 	nop.w
 8007f88:	f3af 8000 	nop.w
 8007f8c:	f3af 8000 	nop.w

08007f90 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8007f90:	b082      	sub	sp, #8
 8007f92:	9001      	str	r0, [sp, #4]
 8007f94:	460b      	mov	r3, r1
 8007f96:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8007f9a:	9b01      	ldr	r3, [sp, #4]
 8007f9c:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007f9e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007fa2:	9a01      	ldr	r2, [sp, #4]
 8007fa4:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8007fa6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007faa:	3248      	adds	r2, #72	; 0x48
 8007fac:	0152      	lsls	r2, r2, #5
 8007fae:	4402      	add	r2, r0
 8007fb0:	6812      	ldr	r2, [r2, #0]
 8007fb2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8007fb6:	3348      	adds	r3, #72	; 0x48
 8007fb8:	015b      	lsls	r3, r3, #5
 8007fba:	440b      	add	r3, r1
 8007fbc:	601a      	str	r2, [r3, #0]
}
 8007fbe:	b002      	add	sp, #8
 8007fc0:	4770      	bx	lr
 8007fc2:	bf00      	nop
 8007fc4:	f3af 8000 	nop.w
 8007fc8:	f3af 8000 	nop.w
 8007fcc:	f3af 8000 	nop.w

08007fd0 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8007fd0:	b082      	sub	sp, #8
 8007fd2:	9001      	str	r0, [sp, #4]
 8007fd4:	460b      	mov	r3, r1
 8007fd6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8007fda:	9b01      	ldr	r3, [sp, #4]
 8007fdc:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8007fde:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007fe2:	9a01      	ldr	r2, [sp, #4]
 8007fe4:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8007fe6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8007fea:	3258      	adds	r2, #88	; 0x58
 8007fec:	0152      	lsls	r2, r2, #5
 8007fee:	4402      	add	r2, r0
 8007ff0:	6812      	ldr	r2, [r2, #0]
 8007ff2:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8007ff6:	3358      	adds	r3, #88	; 0x58
 8007ff8:	015b      	lsls	r3, r3, #5
 8007ffa:	440b      	add	r3, r1
 8007ffc:	601a      	str	r2, [r3, #0]
}
 8007ffe:	b002      	add	sp, #8
 8008000:	4770      	bx	lr
 8008002:	bf00      	nop
 8008004:	f3af 8000 	nop.w
 8008008:	f3af 8000 	nop.w
 800800c:	f3af 8000 	nop.w

08008010 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8008010:	b082      	sub	sp, #8
 8008012:	9001      	str	r0, [sp, #4]
 8008014:	460b      	mov	r3, r1
 8008016:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 800801a:	9b01      	ldr	r3, [sp, #4]
 800801c:	6e99      	ldr	r1, [r3, #104]	; 0x68
 800801e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008022:	9a01      	ldr	r2, [sp, #4]
 8008024:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8008026:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800802a:	3248      	adds	r2, #72	; 0x48
 800802c:	0152      	lsls	r2, r2, #5
 800802e:	4402      	add	r2, r0
 8008030:	6812      	ldr	r2, [r2, #0]
 8008032:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8008036:	3348      	adds	r3, #72	; 0x48
 8008038:	015b      	lsls	r3, r3, #5
 800803a:	440b      	add	r3, r1
 800803c:	601a      	str	r2, [r3, #0]
}
 800803e:	b002      	add	sp, #8
 8008040:	4770      	bx	lr
 8008042:	bf00      	nop
 8008044:	f3af 8000 	nop.w
 8008048:	f3af 8000 	nop.w
 800804c:	f3af 8000 	nop.w

08008050 <usb_lld_pump.4130>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8008050:	b500      	push	{lr}
 8008052:	b089      	sub	sp, #36	; 0x24
 8008054:	9001      	str	r0, [sp, #4]
  USBDriver *usbp = (USBDriver *)p;
 8008056:	9b01      	ldr	r3, [sp, #4]
 8008058:	9306      	str	r3, [sp, #24]
  stm32_otg_t *otgp = usbp->otg;
 800805a:	9b06      	ldr	r3, [sp, #24]
 800805c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800805e:	9305      	str	r3, [sp, #20]

#if defined(_CHIBIOS_RT_)
  chRegSetThreadName("usb_lld_pump");
 8008060:	f640 7090 	movw	r0, #3984	; 0xf90
 8008064:	f6c0 0001 	movt	r0, #2049	; 0x801
 8008068:	f001 fa52 	bl	8009510 <chRegSetThreadName.10554>
#endif
  osalSysLock();
 800806c:	f001 fa60 	bl	8009530 <osalSysLock.10670>
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 8008070:	9b06      	ldr	r3, [sp, #24]
 8008072:	781b      	ldrb	r3, [r3, #0]
 8008074:	2b01      	cmp	r3, #1
 8008076:	d009      	beq.n	800808c <usb_lld_pump.4130+0x3c>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 8008078:	9b06      	ldr	r3, [sp, #24]
 800807a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 800807c:	2b00      	cmp	r3, #0
 800807e:	d110      	bne.n	80080a2 <usb_lld_pump.4130+0x52>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 8008080:	9b05      	ldr	r3, [sp, #20]
 8008082:	695b      	ldr	r3, [r3, #20]
 8008084:	f003 0310 	and.w	r3, r3, #16
 8008088:	2b00      	cmp	r3, #0
 800808a:	d10a      	bne.n	80080a2 <usb_lld_pump.4130+0x52>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 800808c:	9b05      	ldr	r3, [sp, #20]
 800808e:	699b      	ldr	r3, [r3, #24]
 8008090:	f043 0210 	orr.w	r2, r3, #16
 8008094:	9b05      	ldr	r3, [sp, #20]
 8008096:	619a      	str	r2, [r3, #24]
      osalThreadSuspendS(&usbp->wait);
 8008098:	9b06      	ldr	r3, [sp, #24]
 800809a:	3378      	adds	r3, #120	; 0x78
 800809c:	4618      	mov	r0, r3
 800809e:	f001 fa77 	bl	8009590 <osalThreadSuspendS.10661>
    }
    osalSysUnlock();
 80080a2:	f001 fa4d 	bl	8009540 <osalSysUnlock.10666>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80080a6:	2300      	movs	r3, #0
 80080a8:	f88d 301f 	strb.w	r3, [sp, #31]
 80080ac:	e04c      	b.n	8008148 <usb_lld_pump.4130+0xf8>

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
 80080ae:	9806      	ldr	r0, [sp, #24]
 80080b0:	f001 fba6 	bl	8009800 <otg_rxfifo_handler.10871>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80080b4:	9b05      	ldr	r3, [sp, #20]
 80080b6:	695b      	ldr	r3, [r3, #20]
 80080b8:	f003 0310 	and.w	r3, r3, #16
 80080bc:	2b00      	cmp	r3, #0
 80080be:	d1f6      	bne.n	80080ae <usb_lld_pump.4130+0x5e>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 80080c0:	f89d 301f 	ldrb.w	r3, [sp, #31]
 80080c4:	2201      	movs	r2, #1
 80080c6:	fa02 f303 	lsl.w	r3, r2, r3
 80080ca:	9304      	str	r3, [sp, #16]
      if (usbp->txpending & epmask) {
 80080cc:	9b06      	ldr	r3, [sp, #24]
 80080ce:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80080d0:	9b04      	ldr	r3, [sp, #16]
 80080d2:	4013      	ands	r3, r2
 80080d4:	2b00      	cmp	r3, #0
 80080d6:	d032      	beq.n	800813e <usb_lld_pump.4130+0xee>
        bool done;

        osalSysLock();
 80080d8:	f001 fa2a 	bl	8009530 <osalSysLock.10670>
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 80080dc:	9b05      	ldr	r3, [sp, #20]
 80080de:	689b      	ldr	r3, [r3, #8]
 80080e0:	f023 0201 	bic.w	r2, r3, #1
 80080e4:	9b05      	ldr	r3, [sp, #20]
 80080e6:	609a      	str	r2, [r3, #8]
        usbp->txpending &= ~epmask;
 80080e8:	9b06      	ldr	r3, [sp, #24]
 80080ea:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80080ec:	9b04      	ldr	r3, [sp, #16]
 80080ee:	43db      	mvns	r3, r3
 80080f0:	401a      	ands	r2, r3
 80080f2:	9b06      	ldr	r3, [sp, #24]
 80080f4:	675a      	str	r2, [r3, #116]	; 0x74
        osalSysUnlock();
 80080f6:	f001 fa23 	bl	8009540 <osalSysUnlock.10666>

        done = otg_txfifo_handler(usbp, ep);
 80080fa:	f89d 301f 	ldrb.w	r3, [sp, #31]
 80080fe:	9806      	ldr	r0, [sp, #24]
 8008100:	4619      	mov	r1, r3
 8008102:	f001 fc05 	bl	8009910 <otg_txfifo_handler.10874>
 8008106:	4603      	mov	r3, r0
 8008108:	f88d 300f 	strb.w	r3, [sp, #15]

        osalSysLock();
 800810c:	f001 fa10 	bl	8009530 <osalSysLock.10670>
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8008110:	9b05      	ldr	r3, [sp, #20]
 8008112:	689b      	ldr	r3, [r3, #8]
 8008114:	f043 0201 	orr.w	r2, r3, #1
 8008118:	9b05      	ldr	r3, [sp, #20]
 800811a:	609a      	str	r2, [r3, #8]
        if (!done)
 800811c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008120:	f083 0301 	eor.w	r3, r3, #1
 8008124:	b2db      	uxtb	r3, r3
 8008126:	2b00      	cmp	r3, #0
 8008128:	d007      	beq.n	800813a <usb_lld_pump.4130+0xea>
          otgp->DIEPEMPMSK |= epmask;
 800812a:	9b05      	ldr	r3, [sp, #20]
 800812c:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008130:	9b04      	ldr	r3, [sp, #16]
 8008132:	431a      	orrs	r2, r3
 8008134:	9b05      	ldr	r3, [sp, #20]
 8008136:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
        osalSysUnlock();
 800813a:	f001 fa01 	bl	8009540 <osalSysUnlock.10666>
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800813e:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8008142:	3301      	adds	r3, #1
 8008144:	f88d 301f 	strb.w	r3, [sp, #31]
 8008148:	f89d 201f 	ldrb.w	r2, [sp, #31]
 800814c:	9b06      	ldr	r3, [sp, #24]
 800814e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008150:	689b      	ldr	r3, [r3, #8]
 8008152:	429a      	cmp	r2, r3
 8008154:	d9ae      	bls.n	80080b4 <usb_lld_pump.4130+0x64>
        if (!done)
          otgp->DIEPEMPMSK |= epmask;
        osalSysUnlock();
      }
    }
    osalSysLock();
 8008156:	f001 f9eb 	bl	8009530 <osalSysLock.10670>
 800815a:	e789      	b.n	8008070 <usb_lld_pump.4130+0x20>
 800815c:	f3af 8000 	nop.w

08008160 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8008160:	b508      	push	{r3, lr}

  stm32_clock_init();
 8008162:	f000 ff2d 	bl	8008fc0 <stm32_clock_init>
}
 8008166:	bd08      	pop	{r3, pc}
 8008168:	f3af 8000 	nop.w
 800816c:	f3af 8000 	nop.w

08008170 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8008170:	4770      	bx	lr
 8008172:	bf00      	nop
 8008174:	f3af 8000 	nop.w
 8008178:	f3af 8000 	nop.w
 800817c:	f3af 8000 	nop.w

08008180 <port_lock.11147.4123>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008180:	b082      	sub	sp, #8
 8008182:	2320      	movs	r3, #32
 8008184:	9301      	str	r3, [sp, #4]
 8008186:	9b01      	ldr	r3, [sp, #4]
 8008188:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800818c:	b002      	add	sp, #8
 800818e:	4770      	bx	lr

08008190 <port_unlock.11150.4121>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008190:	b082      	sub	sp, #8
 8008192:	2300      	movs	r3, #0
 8008194:	9301      	str	r3, [sp, #4]
 8008196:	9b01      	ldr	r3, [sp, #4]
 8008198:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800819c:	b002      	add	sp, #8
 800819e:	4770      	bx	lr

080081a0 <st_lld_get_counter.11152.4119>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80081a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80081a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80081a6:	4618      	mov	r0, r3
 80081a8:	4770      	bx	lr
 80081aa:	bf00      	nop
 80081ac:	f3af 8000 	nop.w

080081b0 <port_timer_get_time.11157.4117>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80081b0:	b508      	push	{r3, lr}

  return stGetCounter();
 80081b2:	f7ff fff5 	bl	80081a0 <st_lld_get_counter.11152.4119>
 80081b6:	4603      	mov	r3, r0
}
 80081b8:	4618      	mov	r0, r3
 80081ba:	bd08      	pop	{r3, pc}
 80081bc:	f3af 8000 	nop.w

080081c0 <chSysLock.11170.4115>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80081c0:	b508      	push	{r3, lr}

  port_lock();
 80081c2:	f7ff ffdd 	bl	8008180 <port_lock.11147.4123>
  _stats_start_measure_crit_thd();
 80081c6:	f005 fedb 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80081ca:	f007 fa89 	bl	800f6e0 <_dbg_check_lock>
}
 80081ce:	bd08      	pop	{r3, pc}

080081d0 <chSysUnlock.11172.4113>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80081d0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80081d2:	f007 faa5 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80081d6:	f005 fedb 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80081da:	f640 5350 	movw	r3, #3408	; 0xd50
 80081de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80081e2:	681a      	ldr	r2, [r3, #0]
 80081e4:	f640 5350 	movw	r3, #3408	; 0xd50
 80081e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80081ec:	429a      	cmp	r2, r3
 80081ee:	d013      	beq.n	8008218 <chSysUnlock.11172.4113+0x48>
 80081f0:	f640 5350 	movw	r3, #3408	; 0xd50
 80081f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80081f8:	699b      	ldr	r3, [r3, #24]
 80081fa:	689a      	ldr	r2, [r3, #8]
 80081fc:	f640 5350 	movw	r3, #3408	; 0xd50
 8008200:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008204:	681b      	ldr	r3, [r3, #0]
 8008206:	689b      	ldr	r3, [r3, #8]
 8008208:	429a      	cmp	r2, r3
 800820a:	d205      	bcs.n	8008218 <chSysUnlock.11172.4113+0x48>
 800820c:	f641 70d0 	movw	r0, #8144	; 0x1fd0
 8008210:	f6c0 0001 	movt	r0, #2049	; 0x801
 8008214:	f007 f8bc 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8008218:	f7ff ffba 	bl	8008190 <port_unlock.11150.4121>
}
 800821c:	bd08      	pop	{r3, pc}
 800821e:	bf00      	nop

08008220 <chVTGetSystemTimeX.11159.4111>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8008220:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8008222:	f7ff ffc5 	bl	80081b0 <port_timer_get_time.11157.4117>
 8008226:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8008228:	4618      	mov	r0, r3
 800822a:	bd08      	pop	{r3, pc}
 800822c:	f3af 8000 	nop.w

08008230 <chVTGetSystemTime.11174.4109>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8008230:	b500      	push	{lr}
 8008232:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8008234:	f7ff ffc4 	bl	80081c0 <chSysLock.11170.4115>
  systime = chVTGetSystemTimeX();
 8008238:	f7ff fff2 	bl	8008220 <chVTGetSystemTimeX.11159.4111>
 800823c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800823e:	f7ff ffc7 	bl	80081d0 <chSysUnlock.11172.4113>

  return systime;
 8008242:	9b01      	ldr	r3, [sp, #4]
}
 8008244:	4618      	mov	r0, r3
 8008246:	b003      	add	sp, #12
 8008248:	f85d fb04 	ldr.w	pc, [sp], #4
 800824c:	f3af 8000 	nop.w

08008250 <chVTIsTimeWithinX.11161.4104>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8008250:	b084      	sub	sp, #16
 8008252:	9003      	str	r0, [sp, #12]
 8008254:	9102      	str	r1, [sp, #8]
 8008256:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8008258:	9a03      	ldr	r2, [sp, #12]
 800825a:	9b02      	ldr	r3, [sp, #8]
 800825c:	1ad2      	subs	r2, r2, r3
 800825e:	9901      	ldr	r1, [sp, #4]
 8008260:	9b02      	ldr	r3, [sp, #8]
 8008262:	1acb      	subs	r3, r1, r3
 8008264:	429a      	cmp	r2, r3
 8008266:	bf2c      	ite	cs
 8008268:	2300      	movcs	r3, #0
 800826a:	2301      	movcc	r3, #1
 800826c:	b2db      	uxtb	r3, r3
}
 800826e:	4618      	mov	r0, r3
 8008270:	b004      	add	sp, #16
 8008272:	4770      	bx	lr
 8008274:	f3af 8000 	nop.w
 8008278:	f3af 8000 	nop.w
 800827c:	f3af 8000 	nop.w

08008280 <chVTIsSystemTimeWithin.11176.4100>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @api
 */
static inline bool chVTIsSystemTimeWithin(systime_t start, systime_t end) {
 8008280:	b500      	push	{lr}
 8008282:	b083      	sub	sp, #12
 8008284:	9001      	str	r0, [sp, #4]
 8008286:	9100      	str	r1, [sp, #0]

  return chVTIsTimeWithinX(chVTGetSystemTime(), start, end);
 8008288:	f7ff ffd2 	bl	8008230 <chVTGetSystemTime.11174.4109>
 800828c:	4603      	mov	r3, r0
 800828e:	4618      	mov	r0, r3
 8008290:	9901      	ldr	r1, [sp, #4]
 8008292:	9a00      	ldr	r2, [sp, #0]
 8008294:	f7ff ffdc 	bl	8008250 <chVTIsTimeWithinX.11161.4104>
 8008298:	4603      	mov	r3, r0
}
 800829a:	4618      	mov	r0, r3
 800829c:	b003      	add	sp, #12
 800829e:	f85d fb04 	ldr.w	pc, [sp], #4
 80082a2:	bf00      	nop
 80082a4:	f3af 8000 	nop.w
 80082a8:	f3af 8000 	nop.w
 80082ac:	f3af 8000 	nop.w

080082b0 <chVTIsArmedI.11180.4097>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 80082b0:	b500      	push	{lr}
 80082b2:	b083      	sub	sp, #12
 80082b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80082b6:	f007 fae3 	bl	800f880 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
 80082ba:	9b01      	ldr	r3, [sp, #4]
 80082bc:	68db      	ldr	r3, [r3, #12]
 80082be:	2b00      	cmp	r3, #0
 80082c0:	bf0c      	ite	eq
 80082c2:	2300      	moveq	r3, #0
 80082c4:	2301      	movne	r3, #1
 80082c6:	b2db      	uxtb	r3, r3
}
 80082c8:	4618      	mov	r0, r3
 80082ca:	b003      	add	sp, #12
 80082cc:	f85d fb04 	ldr.w	pc, [sp], #4

080082d0 <chVTResetI.11191.4094>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 80082d0:	b500      	push	{lr}
 80082d2:	b083      	sub	sp, #12
 80082d4:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 80082d6:	9801      	ldr	r0, [sp, #4]
 80082d8:	f7ff ffea 	bl	80082b0 <chVTIsArmedI.11180.4097>
 80082dc:	4603      	mov	r3, r0
 80082de:	2b00      	cmp	r3, #0
 80082e0:	d002      	beq.n	80082e8 <chVTResetI.11191.4094+0x18>
    chVTDoResetI(vtp);
 80082e2:	9801      	ldr	r0, [sp, #4]
 80082e4:	f007 fc5c 	bl	800fba0 <chVTDoResetI>
  }
}
 80082e8:	b003      	add	sp, #12
 80082ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80082ee:	bf00      	nop

080082f0 <chVTSetI.11194.4088>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 80082f0:	b500      	push	{lr}
 80082f2:	b085      	sub	sp, #20
 80082f4:	9003      	str	r0, [sp, #12]
 80082f6:	9102      	str	r1, [sp, #8]
 80082f8:	9201      	str	r2, [sp, #4]
 80082fa:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 80082fc:	9803      	ldr	r0, [sp, #12]
 80082fe:	f7ff ffe7 	bl	80082d0 <chVTResetI.11191.4094>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8008302:	9803      	ldr	r0, [sp, #12]
 8008304:	9902      	ldr	r1, [sp, #8]
 8008306:	9a01      	ldr	r2, [sp, #4]
 8008308:	9b00      	ldr	r3, [sp, #0]
 800830a:	f007 fba1 	bl	800fa50 <chVTDoSetI>
}
 800830e:	b005      	add	sp, #20
 8008310:	f85d fb04 	ldr.w	pc, [sp], #4
 8008314:	f3af 8000 	nop.w
 8008318:	f3af 8000 	nop.w
 800831c:	f3af 8000 	nop.w

08008320 <chVTSet.11200.4074>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 8008320:	b500      	push	{lr}
 8008322:	b085      	sub	sp, #20
 8008324:	9003      	str	r0, [sp, #12]
 8008326:	9102      	str	r1, [sp, #8]
 8008328:	9201      	str	r2, [sp, #4]
 800832a:	9300      	str	r3, [sp, #0]

  chSysLock();
 800832c:	f7ff ff48 	bl	80081c0 <chSysLock.11170.4115>
  chVTSetI(vtp, delay, vtfunc, par);
 8008330:	9803      	ldr	r0, [sp, #12]
 8008332:	9902      	ldr	r1, [sp, #8]
 8008334:	9a01      	ldr	r2, [sp, #4]
 8008336:	9b00      	ldr	r3, [sp, #0]
 8008338:	f7ff ffda 	bl	80082f0 <chVTSetI.11194.4088>
  chSysUnlock();
 800833c:	f7ff ff48 	bl	80081d0 <chSysUnlock.11172.4113>
}
 8008340:	b005      	add	sp, #20
 8008342:	f85d fb04 	ldr.w	pc, [sp], #4
 8008346:	bf00      	nop
 8008348:	f3af 8000 	nop.w
 800834c:	f3af 8000 	nop.w

08008350 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 8008350:	b500      	push	{lr}
 8008352:	b089      	sub	sp, #36	; 0x24
 8008354:	9001      	str	r0, [sp, #4]
  char buf[16], *p;

  if (!n)
 8008356:	9b01      	ldr	r3, [sp, #4]
 8008358:	2b00      	cmp	r3, #0
 800835a:	d10f      	bne.n	800837c <test_printn+0x2c>
    chSequentialStreamPut(chp, '0');
 800835c:	f641 6374 	movw	r3, #7796	; 0x1e74
 8008360:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008364:	681b      	ldr	r3, [r3, #0]
 8008366:	681b      	ldr	r3, [r3, #0]
 8008368:	689a      	ldr	r2, [r3, #8]
 800836a:	f641 6374 	movw	r3, #7796	; 0x1e74
 800836e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008372:	681b      	ldr	r3, [r3, #0]
 8008374:	4618      	mov	r0, r3
 8008376:	2130      	movs	r1, #48	; 0x30
 8008378:	4790      	blx	r2
 800837a:	e03b      	b.n	80083f4 <test_printn+0xa4>
  else {
    p = buf;
 800837c:	ab03      	add	r3, sp, #12
 800837e:	9307      	str	r3, [sp, #28]
 8008380:	e01c      	b.n	80083bc <test_printn+0x6c>
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8008382:	9907      	ldr	r1, [sp, #28]
 8008384:	1c4b      	adds	r3, r1, #1
 8008386:	9307      	str	r3, [sp, #28]
 8008388:	9801      	ldr	r0, [sp, #4]
 800838a:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 800838e:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
 8008392:	fba3 2300 	umull	r2, r3, r3, r0
 8008396:	08da      	lsrs	r2, r3, #3
 8008398:	4613      	mov	r3, r2
 800839a:	009b      	lsls	r3, r3, #2
 800839c:	4413      	add	r3, r2
 800839e:	005b      	lsls	r3, r3, #1
 80083a0:	1ac2      	subs	r2, r0, r3
 80083a2:	b2d3      	uxtb	r3, r2
 80083a4:	3330      	adds	r3, #48	; 0x30
 80083a6:	b2db      	uxtb	r3, r3
 80083a8:	700b      	strb	r3, [r1, #0]
 80083aa:	9a01      	ldr	r2, [sp, #4]
 80083ac:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 80083b0:	f6cc 43cc 	movt	r3, #52428	; 0xcccc
 80083b4:	fba3 1302 	umull	r1, r3, r3, r2
 80083b8:	08db      	lsrs	r3, r3, #3
 80083ba:	9301      	str	r3, [sp, #4]

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 80083bc:	9b01      	ldr	r3, [sp, #4]
 80083be:	2b00      	cmp	r3, #0
 80083c0:	d1df      	bne.n	8008382 <test_printn+0x32>
 80083c2:	e013      	b.n	80083ec <test_printn+0x9c>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
      chSequentialStreamPut(chp, *--p);
 80083c4:	f641 6374 	movw	r3, #7796	; 0x1e74
 80083c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80083cc:	681b      	ldr	r3, [r3, #0]
 80083ce:	681b      	ldr	r3, [r3, #0]
 80083d0:	689a      	ldr	r2, [r3, #8]
 80083d2:	f641 6374 	movw	r3, #7796	; 0x1e74
 80083d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80083da:	6819      	ldr	r1, [r3, #0]
 80083dc:	9b07      	ldr	r3, [sp, #28]
 80083de:	3b01      	subs	r3, #1
 80083e0:	9307      	str	r3, [sp, #28]
 80083e2:	9b07      	ldr	r3, [sp, #28]
 80083e4:	781b      	ldrb	r3, [r3, #0]
 80083e6:	4608      	mov	r0, r1
 80083e8:	4619      	mov	r1, r3
 80083ea:	4790      	blx	r2
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 80083ec:	ab03      	add	r3, sp, #12
 80083ee:	9a07      	ldr	r2, [sp, #28]
 80083f0:	429a      	cmp	r2, r3
 80083f2:	d8e7      	bhi.n	80083c4 <test_printn+0x74>
      chSequentialStreamPut(chp, *--p);
  }
}
 80083f4:	b009      	add	sp, #36	; 0x24
 80083f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80083fa:	bf00      	nop
 80083fc:	f3af 8000 	nop.w

08008400 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 8008400:	b500      	push	{lr}
 8008402:	b083      	sub	sp, #12
 8008404:	9001      	str	r0, [sp, #4]
 8008406:	e012      	b.n	800842e <test_print+0x2e>

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8008408:	f641 6374 	movw	r3, #7796	; 0x1e74
 800840c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008410:	681b      	ldr	r3, [r3, #0]
 8008412:	681b      	ldr	r3, [r3, #0]
 8008414:	689a      	ldr	r2, [r3, #8]
 8008416:	f641 6374 	movw	r3, #7796	; 0x1e74
 800841a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800841e:	6819      	ldr	r1, [r3, #0]
 8008420:	9b01      	ldr	r3, [sp, #4]
 8008422:	1c58      	adds	r0, r3, #1
 8008424:	9001      	str	r0, [sp, #4]
 8008426:	781b      	ldrb	r3, [r3, #0]
 8008428:	4608      	mov	r0, r1
 800842a:	4619      	mov	r1, r3
 800842c:	4790      	blx	r2
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800842e:	9b01      	ldr	r3, [sp, #4]
 8008430:	781b      	ldrb	r3, [r3, #0]
 8008432:	2b00      	cmp	r3, #0
 8008434:	d1e8      	bne.n	8008408 <test_print+0x8>
    chSequentialStreamPut(chp, *msgp++);
}
 8008436:	b003      	add	sp, #12
 8008438:	f85d fb04 	ldr.w	pc, [sp], #4
 800843c:	f3af 8000 	nop.w

08008440 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8008440:	b510      	push	{r4, lr}
 8008442:	b082      	sub	sp, #8
 8008444:	9001      	str	r0, [sp, #4]

  test_print(msgp);
 8008446:	9801      	ldr	r0, [sp, #4]
 8008448:	f7ff ffda 	bl	8008400 <test_print>
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800844c:	f641 6374 	movw	r3, #7796	; 0x1e74
 8008450:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008454:	681b      	ldr	r3, [r3, #0]
 8008456:	681b      	ldr	r3, [r3, #0]
 8008458:	681c      	ldr	r4, [r3, #0]
 800845a:	f641 6374 	movw	r3, #7796	; 0x1e74
 800845e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008462:	681b      	ldr	r3, [r3, #0]
 8008464:	4618      	mov	r0, r3
 8008466:	f640 71a0 	movw	r1, #4000	; 0xfa0
 800846a:	f6c0 0101 	movt	r1, #2049	; 0x801
 800846e:	2202      	movs	r2, #2
 8008470:	47a0      	blx	r4
}
 8008472:	b002      	add	sp, #8
 8008474:	bd10      	pop	{r4, pc}
 8008476:	bf00      	nop
 8008478:	f3af 8000 	nop.w
 800847c:	f3af 8000 	nop.w

08008480 <clear_tokens.11216.4063>:
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8008480:	f241 7350 	movw	r3, #5968	; 0x1750
 8008484:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008488:	f241 7240 	movw	r2, #5952	; 0x1740
 800848c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8008490:	601a      	str	r2, [r3, #0]
}
 8008492:	4770      	bx	lr
 8008494:	f3af 8000 	nop.w
 8008498:	f3af 8000 	nop.w
 800849c:	f3af 8000 	nop.w

080084a0 <print_tokens.11218>:

static void print_tokens(void) {
 80084a0:	b500      	push	{lr}
 80084a2:	b083      	sub	sp, #12
  char *cp = tokens_buffer;
 80084a4:	f241 7340 	movw	r3, #5952	; 0x1740
 80084a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80084ac:	9301      	str	r3, [sp, #4]
 80084ae:	e012      	b.n	80084d6 <print_tokens.11218+0x36>

  while (cp < tokp)
    chSequentialStreamPut(chp, *cp++);
 80084b0:	f641 6374 	movw	r3, #7796	; 0x1e74
 80084b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80084b8:	681b      	ldr	r3, [r3, #0]
 80084ba:	681b      	ldr	r3, [r3, #0]
 80084bc:	689a      	ldr	r2, [r3, #8]
 80084be:	f641 6374 	movw	r3, #7796	; 0x1e74
 80084c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80084c6:	6819      	ldr	r1, [r3, #0]
 80084c8:	9b01      	ldr	r3, [sp, #4]
 80084ca:	1c58      	adds	r0, r3, #1
 80084cc:	9001      	str	r0, [sp, #4]
 80084ce:	781b      	ldrb	r3, [r3, #0]
 80084d0:	4608      	mov	r0, r1
 80084d2:	4619      	mov	r1, r3
 80084d4:	4790      	blx	r2
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 80084d6:	f241 7350 	movw	r3, #5968	; 0x1750
 80084da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80084de:	681b      	ldr	r3, [r3, #0]
 80084e0:	9a01      	ldr	r2, [sp, #4]
 80084e2:	429a      	cmp	r2, r3
 80084e4:	d3e4      	bcc.n	80084b0 <print_tokens.11218+0x10>
    chSequentialStreamPut(chp, *cp++);
}
 80084e6:	b003      	add	sp, #12
 80084e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80084ec:	f3af 8000 	nop.w

080084f0 <test_emit_token>:
/**
 * @brief   Emits a token into the tokens buffer.
 *
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {
 80084f0:	b500      	push	{lr}
 80084f2:	b083      	sub	sp, #12
 80084f4:	4603      	mov	r3, r0
 80084f6:	f88d 3007 	strb.w	r3, [sp, #7]

  chSysLock();
 80084fa:	f7ff fe61 	bl	80081c0 <chSysLock.11170.4115>
  *tokp++ = token;
 80084fe:	f241 7350 	movw	r3, #5968	; 0x1750
 8008502:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008506:	681b      	ldr	r3, [r3, #0]
 8008508:	461a      	mov	r2, r3
 800850a:	1c51      	adds	r1, r2, #1
 800850c:	f241 7350 	movw	r3, #5968	; 0x1750
 8008510:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008514:	6019      	str	r1, [r3, #0]
 8008516:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800851a:	7013      	strb	r3, [r2, #0]
  chSysUnlock();
 800851c:	f7ff fe58 	bl	80081d0 <chSysUnlock.11172.4113>
}
 8008520:	b003      	add	sp, #12
 8008522:	f85d fb04 	ldr.w	pc, [sp], #4
 8008526:	bf00      	nop
 8008528:	f3af 8000 	nop.w
 800852c:	f3af 8000 	nop.w

08008530 <_test_fail.4055>:

/*
 * Assertions.
 */
bool _test_fail(unsigned point) {
 8008530:	b082      	sub	sp, #8
 8008532:	9001      	str	r0, [sp, #4]

  test_global_fail = TRUE;
 8008534:	f241 7338 	movw	r3, #5944	; 0x1738
 8008538:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800853c:	2201      	movs	r2, #1
 800853e:	701a      	strb	r2, [r3, #0]
  local_fail = TRUE;
 8008540:	f241 7339 	movw	r3, #5945	; 0x1739
 8008544:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008548:	2201      	movs	r2, #1
 800854a:	701a      	strb	r2, [r3, #0]
  failpoint = point;
 800854c:	f241 733c 	movw	r3, #5948	; 0x173c
 8008550:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008554:	9a01      	ldr	r2, [sp, #4]
 8008556:	601a      	str	r2, [r3, #0]
  return TRUE;
 8008558:	2301      	movs	r3, #1
}
 800855a:	4618      	mov	r0, r3
 800855c:	b002      	add	sp, #8
 800855e:	4770      	bx	lr

08008560 <_test_assert>:

bool _test_assert(unsigned point, bool condition) {
 8008560:	b500      	push	{lr}
 8008562:	b083      	sub	sp, #12
 8008564:	9001      	str	r0, [sp, #4]
 8008566:	460b      	mov	r3, r1
 8008568:	f88d 3003 	strb.w	r3, [sp, #3]

  if (!condition)
 800856c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008570:	f083 0301 	eor.w	r3, r3, #1
 8008574:	b2db      	uxtb	r3, r3
 8008576:	2b00      	cmp	r3, #0
 8008578:	d004      	beq.n	8008584 <_test_assert+0x24>
    return _test_fail(point);
 800857a:	9801      	ldr	r0, [sp, #4]
 800857c:	f7ff ffd8 	bl	8008530 <_test_fail.4055>
 8008580:	4603      	mov	r3, r0
 8008582:	e000      	b.n	8008586 <_test_assert+0x26>
  return FALSE;
 8008584:	2300      	movs	r3, #0
}
 8008586:	4618      	mov	r0, r3
 8008588:	b003      	add	sp, #12
 800858a:	f85d fb04 	ldr.w	pc, [sp], #4
 800858e:	bf00      	nop

08008590 <_test_assert_sequence>:

bool _test_assert_sequence(unsigned point, char *expected) {
 8008590:	b500      	push	{lr}
 8008592:	b085      	sub	sp, #20
 8008594:	9001      	str	r0, [sp, #4]
 8008596:	9100      	str	r1, [sp, #0]
  char *cp = tokens_buffer;
 8008598:	f241 7340 	movw	r3, #5952	; 0x1740
 800859c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80085a0:	9303      	str	r3, [sp, #12]
 80085a2:	e00e      	b.n	80085c2 <_test_assert_sequence+0x32>
  while (cp < tokp) {
    if (*cp++ != *expected++)
 80085a4:	9b03      	ldr	r3, [sp, #12]
 80085a6:	1c5a      	adds	r2, r3, #1
 80085a8:	9203      	str	r2, [sp, #12]
 80085aa:	781a      	ldrb	r2, [r3, #0]
 80085ac:	9b00      	ldr	r3, [sp, #0]
 80085ae:	1c59      	adds	r1, r3, #1
 80085b0:	9100      	str	r1, [sp, #0]
 80085b2:	781b      	ldrb	r3, [r3, #0]
 80085b4:	429a      	cmp	r2, r3
 80085b6:	d004      	beq.n	80085c2 <_test_assert_sequence+0x32>
     return _test_fail(point);
 80085b8:	9801      	ldr	r0, [sp, #4]
 80085ba:	f7ff ffb9 	bl	8008530 <_test_fail.4055>
 80085be:	4603      	mov	r3, r0
 80085c0:	e013      	b.n	80085ea <_test_assert_sequence+0x5a>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 80085c2:	f241 7350 	movw	r3, #5968	; 0x1750
 80085c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80085ca:	681b      	ldr	r3, [r3, #0]
 80085cc:	9a03      	ldr	r2, [sp, #12]
 80085ce:	429a      	cmp	r2, r3
 80085d0:	d3e8      	bcc.n	80085a4 <_test_assert_sequence+0x14>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 80085d2:	9b00      	ldr	r3, [sp, #0]
 80085d4:	781b      	ldrb	r3, [r3, #0]
 80085d6:	2b00      	cmp	r3, #0
 80085d8:	d004      	beq.n	80085e4 <_test_assert_sequence+0x54>
    return _test_fail(point);
 80085da:	9801      	ldr	r0, [sp, #4]
 80085dc:	f7ff ffa8 	bl	8008530 <_test_fail.4055>
 80085e0:	4603      	mov	r3, r0
 80085e2:	e002      	b.n	80085ea <_test_assert_sequence+0x5a>
  clear_tokens();
 80085e4:	f7ff ff4c 	bl	8008480 <clear_tokens.11216.4063>
  return FALSE;
 80085e8:	2300      	movs	r3, #0
}
 80085ea:	4618      	mov	r0, r3
 80085ec:	b005      	add	sp, #20
 80085ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80085f2:	bf00      	nop
 80085f4:	f3af 8000 	nop.w
 80085f8:	f3af 8000 	nop.w
 80085fc:	f3af 8000 	nop.w

08008600 <_test_assert_time_window>:

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 8008600:	b500      	push	{lr}
 8008602:	b085      	sub	sp, #20
 8008604:	9003      	str	r0, [sp, #12]
 8008606:	9102      	str	r1, [sp, #8]
 8008608:	9201      	str	r2, [sp, #4]

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
 800860a:	9802      	ldr	r0, [sp, #8]
 800860c:	9901      	ldr	r1, [sp, #4]
 800860e:	f7ff fe37 	bl	8008280 <chVTIsSystemTimeWithin.11176.4100>
 8008612:	4603      	mov	r3, r0
 8008614:	9803      	ldr	r0, [sp, #12]
 8008616:	4619      	mov	r1, r3
 8008618:	f7ff ffa2 	bl	8008560 <_test_assert>
 800861c:	4603      	mov	r3, r0
}
 800861e:	4618      	mov	r0, r3
 8008620:	b005      	add	sp, #20
 8008622:	f85d fb04 	ldr.w	pc, [sp], #4
 8008626:	bf00      	nop
 8008628:	f3af 8000 	nop.w
 800862c:	f3af 8000 	nop.w

08008630 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8008630:	b500      	push	{lr}
 8008632:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8008634:	2300      	movs	r3, #0
 8008636:	9301      	str	r3, [sp, #4]
 8008638:	e015      	b.n	8008666 <test_terminate_threads+0x36>
    if (threads[i])
 800863a:	f641 6360 	movw	r3, #7776	; 0x1e60
 800863e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008642:	9a01      	ldr	r2, [sp, #4]
 8008644:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8008648:	2b00      	cmp	r3, #0
 800864a:	d009      	beq.n	8008660 <test_terminate_threads+0x30>
      chThdTerminate(threads[i]);
 800864c:	f641 6360 	movw	r3, #7776	; 0x1e60
 8008650:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008654:	9a01      	ldr	r2, [sp, #4]
 8008656:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800865a:	4618      	mov	r0, r3
 800865c:	f005 f9e0 	bl	800da20 <chThdTerminate>
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8008660:	9b01      	ldr	r3, [sp, #4]
 8008662:	3301      	adds	r3, #1
 8008664:	9301      	str	r3, [sp, #4]
 8008666:	9b01      	ldr	r3, [sp, #4]
 8008668:	2b04      	cmp	r3, #4
 800866a:	dde6      	ble.n	800863a <test_terminate_threads+0xa>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 800866c:	b003      	add	sp, #12
 800866e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008672:	bf00      	nop
 8008674:	f3af 8000 	nop.w
 8008678:	f3af 8000 	nop.w
 800867c:	f3af 8000 	nop.w

08008680 <test_wait_threads>:

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8008680:	b500      	push	{lr}
 8008682:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8008684:	2300      	movs	r3, #0
 8008686:	9301      	str	r3, [sp, #4]
 8008688:	e01d      	b.n	80086c6 <test_wait_threads+0x46>
    if (threads[i] != NULL) {
 800868a:	f641 6360 	movw	r3, #7776	; 0x1e60
 800868e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008692:	9a01      	ldr	r2, [sp, #4]
 8008694:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8008698:	2b00      	cmp	r3, #0
 800869a:	d011      	beq.n	80086c0 <test_wait_threads+0x40>
      chThdWait(threads[i]);
 800869c:	f641 6360 	movw	r3, #7776	; 0x1e60
 80086a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80086a4:	9a01      	ldr	r2, [sp, #4]
 80086a6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80086aa:	4618      	mov	r0, r3
 80086ac:	f005 fa50 	bl	800db50 <chThdWait>
      threads[i] = NULL;
 80086b0:	f641 6360 	movw	r3, #7776	; 0x1e60
 80086b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80086b8:	9a01      	ldr	r2, [sp, #4]
 80086ba:	2100      	movs	r1, #0
 80086bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 80086c0:	9b01      	ldr	r3, [sp, #4]
 80086c2:	3301      	adds	r3, #1
 80086c4:	9301      	str	r3, [sp, #4]
 80086c6:	9b01      	ldr	r3, [sp, #4]
 80086c8:	2b04      	cmp	r3, #4
 80086ca:	ddde      	ble.n	800868a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 80086cc:	b003      	add	sp, #12
 80086ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80086d2:	bf00      	nop
 80086d4:	f3af 8000 	nop.w
 80086d8:	f3af 8000 	nop.w
 80086dc:	f3af 8000 	nop.w

080086e0 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 80086e0:	b508      	push	{r3, lr}

  chThdSleep(1);
 80086e2:	2001      	movs	r0, #1
 80086e4:	f005 f9b4 	bl	800da50 <chThdSleep>
  return chVTGetSystemTime();
 80086e8:	f7ff fda2 	bl	8008230 <chVTGetSystemTime.11174.4109>
 80086ec:	4603      	mov	r3, r0
}
 80086ee:	4618      	mov	r0, r3
 80086f0:	bd08      	pop	{r3, pc}
 80086f2:	bf00      	nop
 80086f4:	f3af 8000 	nop.w
 80086f8:	f3af 8000 	nop.w
 80086fc:	f3af 8000 	nop.w

08008700 <tmr.11167.4027>:
 * @brief   Set to @p TRUE when the test timer reaches its deadline.
 */
bool test_timer_done;

static virtual_timer_t vt;
static void tmr(void *p) {
 8008700:	b082      	sub	sp, #8
 8008702:	9001      	str	r0, [sp, #4]
  (void)p;

  test_timer_done = TRUE;
 8008704:	f641 6378 	movw	r3, #7800	; 0x1e78
 8008708:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800870c:	2201      	movs	r2, #1
 800870e:	701a      	strb	r2, [r3, #0]
}
 8008710:	b002      	add	sp, #8
 8008712:	4770      	bx	lr
 8008714:	f3af 8000 	nop.w
 8008718:	f3af 8000 	nop.w
 800871c:	f3af 8000 	nop.w

08008720 <test_start_timer>:
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 8008720:	b500      	push	{lr}
 8008722:	b085      	sub	sp, #20
 8008724:	9001      	str	r0, [sp, #4]

  systime_t duration = MS2ST(ms);
 8008726:	9b01      	ldr	r3, [sp, #4]
 8008728:	f242 7210 	movw	r2, #10000	; 0x2710
 800872c:	fb02 f303 	mul.w	r3, r2, r3
 8008730:	f203 32e7 	addw	r2, r3, #999	; 0x3e7
 8008734:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 8008738:	f2c1 0362 	movt	r3, #4194	; 0x1062
 800873c:	fba3 1302 	umull	r1, r3, r3, r2
 8008740:	099b      	lsrs	r3, r3, #6
 8008742:	9303      	str	r3, [sp, #12]
  test_timer_done = FALSE;
 8008744:	f641 6378 	movw	r3, #7800	; 0x1e78
 8008748:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800874c:	2200      	movs	r2, #0
 800874e:	701a      	strb	r2, [r3, #0]
  chVTSet(&vt, duration, tmr, NULL);
 8008750:	f641 607c 	movw	r0, #7804	; 0x1e7c
 8008754:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8008758:	9903      	ldr	r1, [sp, #12]
 800875a:	f248 7201 	movw	r2, #34561	; 0x8701
 800875e:	f6c0 0200 	movt	r2, #2048	; 0x800
 8008762:	2300      	movs	r3, #0
 8008764:	f7ff fddc 	bl	8008320 <chVTSet.11200.4074>
}
 8008768:	b005      	add	sp, #20
 800876a:	f85d fb04 	ldr.w	pc, [sp], #4
 800876e:	bf00      	nop

08008770 <execute_test.11248>:

/*
 * Test suite execution.
 */
static void execute_test(const struct testcase *tcp) {
 8008770:	b500      	push	{lr}
 8008772:	b085      	sub	sp, #20
 8008774:	9001      	str	r0, [sp, #4]
  int i;

  /* Initialization */
  clear_tokens();
 8008776:	f7ff fe83 	bl	8008480 <clear_tokens.11216.4063>
  local_fail = FALSE;
 800877a:	f241 7339 	movw	r3, #5945	; 0x1739
 800877e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008782:	2200      	movs	r2, #0
 8008784:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < MAX_THREADS; i++)
 8008786:	2300      	movs	r3, #0
 8008788:	9303      	str	r3, [sp, #12]
 800878a:	e00a      	b.n	80087a2 <execute_test.11248+0x32>
    threads[i] = NULL;
 800878c:	f641 6360 	movw	r3, #7776	; 0x1e60
 8008790:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008794:	9a03      	ldr	r2, [sp, #12]
 8008796:	2100      	movs	r1, #0
 8008798:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
 800879c:	9b03      	ldr	r3, [sp, #12]
 800879e:	3301      	adds	r3, #1
 80087a0:	9303      	str	r3, [sp, #12]
 80087a2:	9b03      	ldr	r3, [sp, #12]
 80087a4:	2b04      	cmp	r3, #4
 80087a6:	ddf1      	ble.n	800878c <execute_test.11248+0x1c>
    threads[i] = NULL;

  if (tcp->setup != NULL)
 80087a8:	9b01      	ldr	r3, [sp, #4]
 80087aa:	685b      	ldr	r3, [r3, #4]
 80087ac:	2b00      	cmp	r3, #0
 80087ae:	d002      	beq.n	80087b6 <execute_test.11248+0x46>
    tcp->setup();
 80087b0:	9b01      	ldr	r3, [sp, #4]
 80087b2:	685b      	ldr	r3, [r3, #4]
 80087b4:	4798      	blx	r3
  tcp->execute();
 80087b6:	9b01      	ldr	r3, [sp, #4]
 80087b8:	68db      	ldr	r3, [r3, #12]
 80087ba:	4798      	blx	r3
  if (tcp->teardown != NULL)
 80087bc:	9b01      	ldr	r3, [sp, #4]
 80087be:	689b      	ldr	r3, [r3, #8]
 80087c0:	2b00      	cmp	r3, #0
 80087c2:	d002      	beq.n	80087ca <execute_test.11248+0x5a>
    tcp->teardown();
 80087c4:	9b01      	ldr	r3, [sp, #4]
 80087c6:	689b      	ldr	r3, [r3, #8]
 80087c8:	4798      	blx	r3

  test_wait_threads();
 80087ca:	f7ff ff59 	bl	8008680 <test_wait_threads>
}
 80087ce:	b005      	add	sp, #20
 80087d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80087d4:	f3af 8000 	nop.w
 80087d8:	f3af 8000 	nop.w
 80087dc:	f3af 8000 	nop.w

080087e0 <print_line.11256>:

static void print_line(void) {
 80087e0:	b510      	push	{r4, lr}
 80087e2:	b082      	sub	sp, #8
  unsigned i;

  for (i = 0; i < 76; i++)
 80087e4:	2300      	movs	r3, #0
 80087e6:	9301      	str	r3, [sp, #4]
 80087e8:	e011      	b.n	800880e <print_line.11256+0x2e>
    chSequentialStreamPut(chp, '-');
 80087ea:	f641 6374 	movw	r3, #7796	; 0x1e74
 80087ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80087f2:	681b      	ldr	r3, [r3, #0]
 80087f4:	681b      	ldr	r3, [r3, #0]
 80087f6:	689a      	ldr	r2, [r3, #8]
 80087f8:	f641 6374 	movw	r3, #7796	; 0x1e74
 80087fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8008800:	681b      	ldr	r3, [r3, #0]
 8008802:	4618      	mov	r0, r3
 8008804:	212d      	movs	r1, #45	; 0x2d
 8008806:	4790      	blx	r2
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8008808:	9b01      	ldr	r3, [sp, #4]
 800880a:	3301      	adds	r3, #1
 800880c:	9301      	str	r3, [sp, #4]
 800880e:	9b01      	ldr	r3, [sp, #4]
 8008810:	2b4b      	cmp	r3, #75	; 0x4b
 8008812:	d9ea      	bls.n	80087ea <print_line.11256+0xa>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8008814:	f641 6374 	movw	r3, #7796	; 0x1e74
 8008818:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800881c:	681b      	ldr	r3, [r3, #0]
 800881e:	681b      	ldr	r3, [r3, #0]
 8008820:	681c      	ldr	r4, [r3, #0]
 8008822:	f641 6374 	movw	r3, #7796	; 0x1e74
 8008826:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800882a:	681b      	ldr	r3, [r3, #0]
 800882c:	4618      	mov	r0, r3
 800882e:	f640 71a0 	movw	r1, #4000	; 0xfa0
 8008832:	f6c0 0101 	movt	r1, #2049	; 0x801
 8008836:	2202      	movs	r2, #2
 8008838:	47a0      	blx	r4
}
 800883a:	b002      	add	sp, #8
 800883c:	bd10      	pop	{r4, pc}
 800883e:	bf00      	nop

08008840 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8008840:	b500      	push	{lr}
 8008842:	b085      	sub	sp, #20
 8008844:	9003      	str	r0, [sp, #12]
 8008846:	460b      	mov	r3, r1
 8008848:	9201      	str	r2, [sp, #4]
 800884a:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheckClassI();
 800884e:	f007 f817 	bl	800f880 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 8008852:	9b03      	ldr	r3, [sp, #12]
 8008854:	2b00      	cmp	r3, #0
 8008856:	d002      	beq.n	800885e <usbInitEndpointI+0x1e>
 8008858:	9b01      	ldr	r3, [sp, #4]
 800885a:	2b00      	cmp	r3, #0
 800885c:	d105      	bne.n	800886a <usbInitEndpointI+0x2a>
 800885e:	f641 5090 	movw	r0, #7568	; 0x1d90
 8008862:	f6c0 0001 	movt	r0, #2049	; 0x801
 8008866:	f006 fd93 	bl	800f390 <chSysHalt>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 800886a:	9b03      	ldr	r3, [sp, #12]
 800886c:	781b      	ldrb	r3, [r3, #0]
 800886e:	2b04      	cmp	r3, #4
 8008870:	d005      	beq.n	800887e <usbInitEndpointI+0x3e>
 8008872:	f641 5090 	movw	r0, #7568	; 0x1d90
 8008876:	f6c0 0001 	movt	r0, #2049	; 0x801
 800887a:	f006 fd89 	bl	800f390 <chSysHalt>
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 800887e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8008882:	9a03      	ldr	r2, [sp, #12]
 8008884:	3302      	adds	r3, #2
 8008886:	009b      	lsls	r3, r3, #2
 8008888:	4413      	add	r3, r2
 800888a:	685b      	ldr	r3, [r3, #4]
 800888c:	2b00      	cmp	r3, #0
 800888e:	d005      	beq.n	800889c <usbInitEndpointI+0x5c>
 8008890:	f641 5090 	movw	r0, #7568	; 0x1d90
 8008894:	f6c0 0001 	movt	r0, #2049	; 0x801
 8008898:	f006 fd7a 	bl	800f390 <chSysHalt>

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 800889c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80088a0:	9a03      	ldr	r2, [sp, #12]
 80088a2:	3302      	adds	r3, #2
 80088a4:	009b      	lsls	r3, r3, #2
 80088a6:	4413      	add	r3, r2
 80088a8:	9a01      	ldr	r2, [sp, #4]
 80088aa:	605a      	str	r2, [r3, #4]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 80088ac:	9b01      	ldr	r3, [sp, #4]
 80088ae:	695b      	ldr	r3, [r3, #20]
 80088b0:	2b00      	cmp	r3, #0
 80088b2:	d006      	beq.n	80088c2 <usbInitEndpointI+0x82>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 80088b4:	9b01      	ldr	r3, [sp, #4]
 80088b6:	695b      	ldr	r3, [r3, #20]
 80088b8:	4618      	mov	r0, r3
 80088ba:	2100      	movs	r1, #0
 80088bc:	2210      	movs	r2, #16
 80088be:	f007 ff7f 	bl	80107c0 <memset>
  }
  if (epcp->out_state != NULL) {
 80088c2:	9b01      	ldr	r3, [sp, #4]
 80088c4:	699b      	ldr	r3, [r3, #24]
 80088c6:	2b00      	cmp	r3, #0
 80088c8:	d006      	beq.n	80088d8 <usbInitEndpointI+0x98>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 80088ca:	9b01      	ldr	r3, [sp, #4]
 80088cc:	699b      	ldr	r3, [r3, #24]
 80088ce:	4618      	mov	r0, r3
 80088d0:	2100      	movs	r1, #0
 80088d2:	2210      	movs	r2, #16
 80088d4:	f007 ff74 	bl	80107c0 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 80088d8:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80088dc:	9803      	ldr	r0, [sp, #12]
 80088de:	4619      	mov	r1, r3
 80088e0:	f7ff f85e 	bl	80079a0 <usb_lld_init_endpoint>
}
 80088e4:	b005      	add	sp, #20
 80088e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80088ea:	bf00      	nop
 80088ec:	f3af 8000 	nop.w

080088f0 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 80088f0:	b500      	push	{lr}
 80088f2:	b087      	sub	sp, #28
 80088f4:	9003      	str	r0, [sp, #12]
 80088f6:	9201      	str	r2, [sp, #4]
 80088f8:	9300      	str	r3, [sp, #0]
 80088fa:	460b      	mov	r3, r1
 80088fc:	f88d 300b 	strb.w	r3, [sp, #11]
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
 8008900:	f006 ffbe 	bl	800f880 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8008904:	9b03      	ldr	r3, [sp, #12]
 8008906:	2b00      	cmp	r3, #0
 8008908:	d003      	beq.n	8008912 <usbStartReceiveI+0x22>
 800890a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800890e:	2b05      	cmp	r3, #5
 8008910:	d905      	bls.n	800891e <usbStartReceiveI+0x2e>
 8008912:	f641 50b0 	movw	r0, #7600	; 0x1db0
 8008916:	f6c0 0001 	movt	r0, #2049	; 0x801
 800891a:	f006 fd39 	bl	800f390 <chSysHalt>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 800891e:	9b03      	ldr	r3, [sp, #12]
 8008920:	895a      	ldrh	r2, [r3, #10]
 8008922:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8008926:	2101      	movs	r1, #1
 8008928:	fa01 f303 	lsl.w	r3, r1, r3
 800892c:	b29b      	uxth	r3, r3
 800892e:	4013      	ands	r3, r2
 8008930:	b29b      	uxth	r3, r3
 8008932:	2b00      	cmp	r3, #0
 8008934:	d005      	beq.n	8008942 <usbStartReceiveI+0x52>
 8008936:	f641 50b0 	movw	r0, #7600	; 0x1db0
 800893a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800893e:	f006 fd27 	bl	800f390 <chSysHalt>

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8008942:	9b03      	ldr	r3, [sp, #12]
 8008944:	895a      	ldrh	r2, [r3, #10]
 8008946:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800894a:	2101      	movs	r1, #1
 800894c:	fa01 f303 	lsl.w	r3, r1, r3
 8008950:	b29b      	uxth	r3, r3
 8008952:	4313      	orrs	r3, r2
 8008954:	b29a      	uxth	r2, r3
 8008956:	9b03      	ldr	r3, [sp, #12]
 8008958:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 800895a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800895e:	9a03      	ldr	r2, [sp, #12]
 8008960:	3302      	adds	r3, #2
 8008962:	009b      	lsls	r3, r3, #2
 8008964:	4413      	add	r3, r2
 8008966:	685b      	ldr	r3, [r3, #4]
 8008968:	699b      	ldr	r3, [r3, #24]
 800896a:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 800896c:	9b05      	ldr	r3, [sp, #20]
 800896e:	9a01      	ldr	r2, [sp, #4]
 8008970:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8008972:	9b05      	ldr	r3, [sp, #20]
 8008974:	9a00      	ldr	r2, [sp, #0]
 8008976:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 8008978:	9b05      	ldr	r3, [sp, #20]
 800897a:	2200      	movs	r2, #0
 800897c:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 800897e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8008982:	9803      	ldr	r0, [sp, #12]
 8008984:	4619      	mov	r1, r3
 8008986:	f7ff f993 	bl	8007cb0 <usb_lld_start_out>
}
 800898a:	b007      	add	sp, #28
 800898c:	f85d fb04 	ldr.w	pc, [sp], #4

08008990 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8008990:	b500      	push	{lr}
 8008992:	b087      	sub	sp, #28
 8008994:	9003      	str	r0, [sp, #12]
 8008996:	9201      	str	r2, [sp, #4]
 8008998:	9300      	str	r3, [sp, #0]
 800899a:	460b      	mov	r3, r1
 800899c:	f88d 300b 	strb.w	r3, [sp, #11]
  USBInEndpointState *isp;

  osalDbgCheckClassI();
 80089a0:	f006 ff6e 	bl	800f880 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 80089a4:	9b03      	ldr	r3, [sp, #12]
 80089a6:	2b00      	cmp	r3, #0
 80089a8:	d003      	beq.n	80089b2 <usbStartTransmitI+0x22>
 80089aa:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80089ae:	2b05      	cmp	r3, #5
 80089b0:	d905      	bls.n	80089be <usbStartTransmitI+0x2e>
 80089b2:	f641 50d0 	movw	r0, #7632	; 0x1dd0
 80089b6:	f6c0 0001 	movt	r0, #2049	; 0x801
 80089ba:	f006 fce9 	bl	800f390 <chSysHalt>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 80089be:	9b03      	ldr	r3, [sp, #12]
 80089c0:	891a      	ldrh	r2, [r3, #8]
 80089c2:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80089c6:	2101      	movs	r1, #1
 80089c8:	fa01 f303 	lsl.w	r3, r1, r3
 80089cc:	b29b      	uxth	r3, r3
 80089ce:	4013      	ands	r3, r2
 80089d0:	b29b      	uxth	r3, r3
 80089d2:	2b00      	cmp	r3, #0
 80089d4:	d005      	beq.n	80089e2 <usbStartTransmitI+0x52>
 80089d6:	f641 50d0 	movw	r0, #7632	; 0x1dd0
 80089da:	f6c0 0001 	movt	r0, #2049	; 0x801
 80089de:	f006 fcd7 	bl	800f390 <chSysHalt>

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80089e2:	9b03      	ldr	r3, [sp, #12]
 80089e4:	891a      	ldrh	r2, [r3, #8]
 80089e6:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80089ea:	2101      	movs	r1, #1
 80089ec:	fa01 f303 	lsl.w	r3, r1, r3
 80089f0:	b29b      	uxth	r3, r3
 80089f2:	4313      	orrs	r3, r2
 80089f4:	b29a      	uxth	r2, r3
 80089f6:	9b03      	ldr	r3, [sp, #12]
 80089f8:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 80089fa:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80089fe:	9a03      	ldr	r2, [sp, #12]
 8008a00:	3302      	adds	r3, #2
 8008a02:	009b      	lsls	r3, r3, #2
 8008a04:	4413      	add	r3, r2
 8008a06:	685b      	ldr	r3, [r3, #4]
 8008a08:	695b      	ldr	r3, [r3, #20]
 8008a0a:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 8008a0c:	9b05      	ldr	r3, [sp, #20]
 8008a0e:	9a01      	ldr	r2, [sp, #4]
 8008a10:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8008a12:	9b05      	ldr	r3, [sp, #20]
 8008a14:	9a00      	ldr	r2, [sp, #0]
 8008a16:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 8008a18:	9b05      	ldr	r3, [sp, #20]
 8008a1a:	2200      	movs	r2, #0
 8008a1c:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8008a1e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8008a22:	9803      	ldr	r0, [sp, #12]
 8008a24:	4619      	mov	r1, r3
 8008a26:	f7ff f9e3 	bl	8007df0 <usb_lld_start_in>
}
 8008a2a:	b007      	add	sp, #28
 8008a2c:	f85d fb04 	ldr.w	pc, [sp], #4

08008a30 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8008a30:	b500      	push	{lr}
 8008a32:	b085      	sub	sp, #20
 8008a34:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8008a36:	9b01      	ldr	r3, [sp, #4]
 8008a38:	2202      	movs	r2, #2
 8008a3a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 8008a3c:	9b01      	ldr	r3, [sp, #4]
 8008a3e:	2200      	movs	r2, #0
 8008a40:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
  usbp->address       = 0;
 8008a44:	9b01      	ldr	r3, [sp, #4]
 8008a46:	2200      	movs	r2, #0
 8008a48:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usbp->configuration = 0;
 8008a4c:	9b01      	ldr	r3, [sp, #4]
 8008a4e:	2200      	movs	r2, #0
 8008a50:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
  usbp->transmitting  = 0;
 8008a54:	9b01      	ldr	r3, [sp, #4]
 8008a56:	2200      	movs	r2, #0
 8008a58:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 8008a5a:	9b01      	ldr	r3, [sp, #4]
 8008a5c:	2200      	movs	r2, #0
 8008a5e:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8008a60:	2300      	movs	r3, #0
 8008a62:	9303      	str	r3, [sp, #12]
 8008a64:	e009      	b.n	8008a7a <_usb_reset+0x4a>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8008a66:	9a01      	ldr	r2, [sp, #4]
 8008a68:	9b03      	ldr	r3, [sp, #12]
 8008a6a:	3302      	adds	r3, #2
 8008a6c:	009b      	lsls	r3, r3, #2
 8008a6e:	4413      	add	r3, r2
 8008a70:	2200      	movs	r2, #0
 8008a72:	605a      	str	r2, [r3, #4]
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8008a74:	9b03      	ldr	r3, [sp, #12]
 8008a76:	3301      	adds	r3, #1
 8008a78:	9303      	str	r3, [sp, #12]
 8008a7a:	9b03      	ldr	r3, [sp, #12]
 8008a7c:	2b05      	cmp	r3, #5
 8008a7e:	d9f2      	bls.n	8008a66 <_usb_reset+0x36>
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8008a80:	9b01      	ldr	r3, [sp, #4]
 8008a82:	2200      	movs	r2, #0
 8008a84:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8008a88:	9801      	ldr	r0, [sp, #4]
 8008a8a:	f7fe fed9 	bl	8007840 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8008a8e:	9b01      	ldr	r3, [sp, #4]
 8008a90:	685b      	ldr	r3, [r3, #4]
 8008a92:	681b      	ldr	r3, [r3, #0]
 8008a94:	2b00      	cmp	r3, #0
 8008a96:	d005      	beq.n	8008aa4 <_usb_reset+0x74>
 8008a98:	9b01      	ldr	r3, [sp, #4]
 8008a9a:	685b      	ldr	r3, [r3, #4]
 8008a9c:	681b      	ldr	r3, [r3, #0]
 8008a9e:	9801      	ldr	r0, [sp, #4]
 8008aa0:	2100      	movs	r1, #0
 8008aa2:	4798      	blx	r3
}
 8008aa4:	b005      	add	sp, #20
 8008aa6:	f85d fb04 	ldr.w	pc, [sp], #4
 8008aaa:	bf00      	nop
 8008aac:	f3af 8000 	nop.w

08008ab0 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8008ab0:	b500      	push	{lr}
 8008ab2:	b083      	sub	sp, #12
 8008ab4:	9001      	str	r0, [sp, #4]

  /* State transition.*/
  usbp->state = USB_SUSPENDED;
 8008ab6:	9b01      	ldr	r3, [sp, #4]
 8008ab8:	2205      	movs	r2, #5
 8008aba:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8008abc:	9b01      	ldr	r3, [sp, #4]
 8008abe:	685b      	ldr	r3, [r3, #4]
 8008ac0:	681b      	ldr	r3, [r3, #0]
 8008ac2:	2b00      	cmp	r3, #0
 8008ac4:	d005      	beq.n	8008ad2 <_usb_suspend+0x22>
 8008ac6:	9b01      	ldr	r3, [sp, #4]
 8008ac8:	685b      	ldr	r3, [r3, #4]
 8008aca:	681b      	ldr	r3, [r3, #0]
 8008acc:	9801      	ldr	r0, [sp, #4]
 8008ace:	2103      	movs	r1, #3
 8008ad0:	4798      	blx	r3
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 8008ad2:	b003      	add	sp, #12
 8008ad4:	f85d fb04 	ldr.w	pc, [sp], #4
 8008ad8:	f3af 8000 	nop.w
 8008adc:	f3af 8000 	nop.w

08008ae0 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 8008ae0:	b500      	push	{lr}
 8008ae2:	b083      	sub	sp, #12
 8008ae4:	9001      	str	r0, [sp, #4]

  /* State transition.*/
  usbp->state = USB_ACTIVE;
 8008ae6:	9b01      	ldr	r3, [sp, #4]
 8008ae8:	2204      	movs	r2, #4
 8008aea:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8008aec:	9b01      	ldr	r3, [sp, #4]
 8008aee:	685b      	ldr	r3, [r3, #4]
 8008af0:	681b      	ldr	r3, [r3, #0]
 8008af2:	2b00      	cmp	r3, #0
 8008af4:	d005      	beq.n	8008b02 <_usb_wakeup+0x22>
 8008af6:	9b01      	ldr	r3, [sp, #4]
 8008af8:	685b      	ldr	r3, [r3, #4]
 8008afa:	681b      	ldr	r3, [r3, #0]
 8008afc:	9801      	ldr	r0, [sp, #4]
 8008afe:	2104      	movs	r1, #4
 8008b00:	4798      	blx	r3
}
 8008b02:	b003      	add	sp, #12
 8008b04:	f85d fb04 	ldr.w	pc, [sp], #4
 8008b08:	f3af 8000 	nop.w
 8008b0c:	f3af 8000 	nop.w

08008b10 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8008b10:	b500      	push	{lr}
 8008b12:	b085      	sub	sp, #20
 8008b14:	9001      	str	r0, [sp, #4]
 8008b16:	460b      	mov	r3, r1
 8008b18:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8008b1c:	9b01      	ldr	r3, [sp, #4]
 8008b1e:	2200      	movs	r2, #0
 8008b20:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  usbReadSetup(usbp, ep, usbp->setup);
 8008b24:	9b01      	ldr	r3, [sp, #4]
 8008b26:	335c      	adds	r3, #92	; 0x5c
 8008b28:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8008b2c:	9801      	ldr	r0, [sp, #4]
 8008b2e:	4611      	mov	r1, r2
 8008b30:	461a      	mov	r2, r3
 8008b32:	f7ff f8a5 	bl	8007c80 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8008b36:	9b01      	ldr	r3, [sp, #4]
 8008b38:	685b      	ldr	r3, [r3, #4]
 8008b3a:	689b      	ldr	r3, [r3, #8]
 8008b3c:	2b00      	cmp	r3, #0
 8008b3e:	d00a      	beq.n	8008b56 <_usb_ep0setup+0x46>
      !(usbp->config->requests_hook_cb(usbp))) {
 8008b40:	9b01      	ldr	r3, [sp, #4]
 8008b42:	685b      	ldr	r3, [r3, #4]
 8008b44:	689b      	ldr	r3, [r3, #8]
 8008b46:	9801      	ldr	r0, [sp, #4]
 8008b48:	4798      	blx	r3
 8008b4a:	4603      	mov	r3, r0
 8008b4c:	f083 0301 	eor.w	r3, r3, #1
 8008b50:	b2db      	uxtb	r3, r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8008b52:	2b00      	cmp	r3, #0
 8008b54:	d027      	beq.n	8008ba6 <_usb_ep0setup+0x96>
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8008b56:	9b01      	ldr	r3, [sp, #4]
 8008b58:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8008b5c:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8008b60:	2b00      	cmp	r3, #0
 8008b62:	d108      	bne.n	8008b76 <_usb_ep0setup+0x66>
        !default_handler(usbp)) {
 8008b64:	9801      	ldr	r0, [sp, #4]
 8008b66:	f001 ff43 	bl	800a9f0 <default_handler.10033>
 8008b6a:	4603      	mov	r3, r0
 8008b6c:	f083 0301 	eor.w	r3, r3, #1
 8008b70:	b2db      	uxtb	r3, r3
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8008b72:	2b00      	cmp	r3, #0
 8008b74:	d017      	beq.n	8008ba6 <_usb_ep0setup+0x96>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8008b76:	9801      	ldr	r0, [sp, #4]
 8008b78:	2100      	movs	r1, #0
 8008b7a:	f7ff fa09 	bl	8007f90 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 8008b7e:	9801      	ldr	r0, [sp, #4]
 8008b80:	2100      	movs	r1, #0
 8008b82:	f7ff f9e5 	bl	8007f50 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8008b86:	9b01      	ldr	r3, [sp, #4]
 8008b88:	685b      	ldr	r3, [r3, #4]
 8008b8a:	681b      	ldr	r3, [r3, #0]
 8008b8c:	2b00      	cmp	r3, #0
 8008b8e:	d005      	beq.n	8008b9c <_usb_ep0setup+0x8c>
 8008b90:	9b01      	ldr	r3, [sp, #4]
 8008b92:	685b      	ldr	r3, [r3, #4]
 8008b94:	681b      	ldr	r3, [r3, #0]
 8008b96:	9801      	ldr	r0, [sp, #4]
 8008b98:	2105      	movs	r1, #5
 8008b9a:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8008b9c:	9b01      	ldr	r3, [sp, #4]
 8008b9e:	2206      	movs	r2, #6
 8008ba0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8008ba4:	e05c      	b.n	8008c60 <_usb_ep0setup+0x150>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8008ba6:	9b01      	ldr	r3, [sp, #4]
 8008ba8:	3362      	adds	r3, #98	; 0x62
 8008baa:	4618      	mov	r0, r3
 8008bac:	f001 fee8 	bl	800a980 <get_hword.9773>
 8008bb0:	4603      	mov	r3, r0
 8008bb2:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8008bb4:	9b01      	ldr	r3, [sp, #4]
 8008bb6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8008bb8:	9b03      	ldr	r3, [sp, #12]
 8008bba:	429a      	cmp	r2, r3
 8008bbc:	d902      	bls.n	8008bc4 <_usb_ep0setup+0xb4>
    usbp->ep0n = max;
 8008bbe:	9b01      	ldr	r3, [sp, #4]
 8008bc0:	9a03      	ldr	r2, [sp, #12]
 8008bc2:	655a      	str	r2, [r3, #84]	; 0x54
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8008bc4:	9b01      	ldr	r3, [sp, #4]
 8008bc6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8008bca:	b2db      	uxtb	r3, r3
 8008bcc:	b25b      	sxtb	r3, r3
 8008bce:	2b00      	cmp	r3, #0
 8008bd0:	da23      	bge.n	8008c1a <_usb_ep0setup+0x10a>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8008bd2:	9b01      	ldr	r3, [sp, #4]
 8008bd4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008bd6:	2b00      	cmp	r3, #0
 8008bd8:	d010      	beq.n	8008bfc <_usb_ep0setup+0xec>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8008bda:	9b01      	ldr	r3, [sp, #4]
 8008bdc:	2201      	movs	r2, #1
 8008bde:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 8008be2:	f001 febd 	bl	800a960 <osalSysLockFromISR.9767>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8008be6:	9b01      	ldr	r3, [sp, #4]
 8008be8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8008bea:	9b01      	ldr	r3, [sp, #4]
 8008bec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008bee:	9801      	ldr	r0, [sp, #4]
 8008bf0:	2100      	movs	r1, #0
 8008bf2:	f7ff fecd 	bl	8008990 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8008bf6:	f001 febb 	bl	800a970 <osalSysUnlockFromISR.9771>
 8008bfa:	e031      	b.n	8008c60 <_usb_ep0setup+0x150>
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 8008bfc:	9b01      	ldr	r3, [sp, #4]
 8008bfe:	2203      	movs	r2, #3
 8008c00:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8008c04:	f001 feac 	bl	800a960 <osalSysLockFromISR.9767>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8008c08:	9801      	ldr	r0, [sp, #4]
 8008c0a:	2100      	movs	r1, #0
 8008c0c:	2200      	movs	r2, #0
 8008c0e:	2300      	movs	r3, #0
 8008c10:	f7ff fe6e 	bl	80088f0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8008c14:	f001 feac 	bl	800a970 <osalSysUnlockFromISR.9771>
 8008c18:	e022      	b.n	8008c60 <_usb_ep0setup+0x150>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8008c1a:	9b01      	ldr	r3, [sp, #4]
 8008c1c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008c1e:	2b00      	cmp	r3, #0
 8008c20:	d010      	beq.n	8008c44 <_usb_ep0setup+0x134>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8008c22:	9b01      	ldr	r3, [sp, #4]
 8008c24:	2204      	movs	r2, #4
 8008c26:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 8008c2a:	f001 fe99 	bl	800a960 <osalSysLockFromISR.9767>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8008c2e:	9b01      	ldr	r3, [sp, #4]
 8008c30:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8008c32:	9b01      	ldr	r3, [sp, #4]
 8008c34:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008c36:	9801      	ldr	r0, [sp, #4]
 8008c38:	2100      	movs	r1, #0
 8008c3a:	f7ff fe59 	bl	80088f0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8008c3e:	f001 fe97 	bl	800a970 <osalSysUnlockFromISR.9771>
 8008c42:	e00d      	b.n	8008c60 <_usb_ep0setup+0x150>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8008c44:	9b01      	ldr	r3, [sp, #4]
 8008c46:	2205      	movs	r2, #5
 8008c48:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8008c4c:	f001 fe88 	bl	800a960 <osalSysLockFromISR.9767>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8008c50:	9801      	ldr	r0, [sp, #4]
 8008c52:	2100      	movs	r1, #0
 8008c54:	2200      	movs	r2, #0
 8008c56:	2300      	movs	r3, #0
 8008c58:	f7ff fe9a 	bl	8008990 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8008c5c:	f001 fe88 	bl	800a970 <osalSysUnlockFromISR.9771>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8008c60:	b005      	add	sp, #20
 8008c62:	f85d fb04 	ldr.w	pc, [sp], #4
 8008c66:	bf00      	nop
 8008c68:	f3af 8000 	nop.w
 8008c6c:	f3af 8000 	nop.w

08008c70 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8008c70:	b500      	push	{lr}
 8008c72:	b085      	sub	sp, #20
 8008c74:	9001      	str	r0, [sp, #4]
 8008c76:	460b      	mov	r3, r1
 8008c78:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8008c7c:	9b01      	ldr	r3, [sp, #4]
 8008c7e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8008c82:	2b06      	cmp	r3, #6
 8008c84:	d871      	bhi.n	8008d6a <_usb_ep0in+0xfa>
 8008c86:	a201      	add	r2, pc, #4	; (adr r2, 8008c8c <_usb_ep0in+0x1c>)
 8008c88:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008c8c:	08008d2f 	.word	0x08008d2f
 8008c90:	08008ca9 	.word	0x08008ca9
 8008c94:	08008cf7 	.word	0x08008cf7
 8008c98:	08008d2f 	.word	0x08008d2f
 8008c9c:	08008d2f 	.word	0x08008d2f
 8008ca0:	08008d15 	.word	0x08008d15
 8008ca4:	08008d3b 	.word	0x08008d3b
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 8008ca8:	9b01      	ldr	r3, [sp, #4]
 8008caa:	3362      	adds	r3, #98	; 0x62
 8008cac:	4618      	mov	r0, r3
 8008cae:	f001 fe67 	bl	800a980 <get_hword.9773>
 8008cb2:	4603      	mov	r3, r0
 8008cb4:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8008cb6:	9b01      	ldr	r3, [sp, #4]
 8008cb8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8008cba:	9b03      	ldr	r3, [sp, #12]
 8008cbc:	429a      	cmp	r2, r3
 8008cbe:	d21a      	bcs.n	8008cf6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8008cc0:	9b01      	ldr	r3, [sp, #4]
 8008cc2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008cc4:	9a01      	ldr	r2, [sp, #4]
 8008cc6:	68d2      	ldr	r2, [r2, #12]
 8008cc8:	8a12      	ldrh	r2, [r2, #16]
 8008cca:	fbb3 f1f2 	udiv	r1, r3, r2
 8008cce:	fb02 f201 	mul.w	r2, r2, r1
 8008cd2:	1a9b      	subs	r3, r3, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8008cd4:	2b00      	cmp	r3, #0
 8008cd6:	d10e      	bne.n	8008cf6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
 8008cd8:	f001 fe42 	bl	800a960 <osalSysLockFromISR.9767>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8008cdc:	9801      	ldr	r0, [sp, #4]
 8008cde:	2100      	movs	r1, #0
 8008ce0:	2200      	movs	r2, #0
 8008ce2:	2300      	movs	r3, #0
 8008ce4:	f7ff fe54 	bl	8008990 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8008ce8:	f001 fe42 	bl	800a970 <osalSysUnlockFromISR.9771>
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8008cec:	9b01      	ldr	r3, [sp, #4]
 8008cee:	2202      	movs	r2, #2
 8008cf0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8008cf4:	e03f      	b.n	8008d76 <_usb_ep0in+0x106>
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 8008cf6:	9b01      	ldr	r3, [sp, #4]
 8008cf8:	2203      	movs	r2, #3
 8008cfa:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 8008cfe:	f001 fe2f 	bl	800a960 <osalSysLockFromISR.9767>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8008d02:	9801      	ldr	r0, [sp, #4]
 8008d04:	2100      	movs	r1, #0
 8008d06:	2200      	movs	r2, #0
 8008d08:	2300      	movs	r3, #0
 8008d0a:	f7ff fdf1 	bl	80088f0 <usbStartReceiveI>
    osalSysUnlockFromISR();
 8008d0e:	f001 fe2f 	bl	800a970 <osalSysUnlockFromISR.9771>
 8008d12:	e030      	b.n	8008d76 <_usb_ep0in+0x106>
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8008d14:	9b01      	ldr	r3, [sp, #4]
 8008d16:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008d18:	2b00      	cmp	r3, #0
 8008d1a:	d003      	beq.n	8008d24 <_usb_ep0in+0xb4>
      usbp->ep0endcb(usbp);
 8008d1c:	9b01      	ldr	r3, [sp, #4]
 8008d1e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008d20:	9801      	ldr	r0, [sp, #4]
 8008d22:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8008d24:	9b01      	ldr	r3, [sp, #4]
 8008d26:	2200      	movs	r2, #0
 8008d28:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8008d2c:	e023      	b.n	8008d76 <_usb_ep0in+0x106>
    return;
  case USB_EP0_WAITING_SETUP:
  case USB_EP0_WAITING_STS:
  case USB_EP0_RX:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 8008d2e:	f641 50f0 	movw	r0, #7664	; 0x1df0
 8008d32:	f6c0 0001 	movt	r0, #2049	; 0x801
 8008d36:	f006 fb2b 	bl	800f390 <chSysHalt>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8008d3a:	9801      	ldr	r0, [sp, #4]
 8008d3c:	2100      	movs	r1, #0
 8008d3e:	f7ff f927 	bl	8007f90 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8008d42:	9801      	ldr	r0, [sp, #4]
 8008d44:	2100      	movs	r1, #0
 8008d46:	f7ff f903 	bl	8007f50 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8008d4a:	9b01      	ldr	r3, [sp, #4]
 8008d4c:	685b      	ldr	r3, [r3, #4]
 8008d4e:	681b      	ldr	r3, [r3, #0]
 8008d50:	2b00      	cmp	r3, #0
 8008d52:	d005      	beq.n	8008d60 <_usb_ep0in+0xf0>
 8008d54:	9b01      	ldr	r3, [sp, #4]
 8008d56:	685b      	ldr	r3, [r3, #4]
 8008d58:	681b      	ldr	r3, [r3, #0]
 8008d5a:	9801      	ldr	r0, [sp, #4]
 8008d5c:	2105      	movs	r1, #5
 8008d5e:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8008d60:	9b01      	ldr	r3, [sp, #4]
 8008d62:	2206      	movs	r2, #6
 8008d64:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8008d68:	e005      	b.n	8008d76 <_usb_ep0in+0x106>
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 8008d6a:	f641 50f0 	movw	r0, #7664	; 0x1df0
 8008d6e:	f6c0 0001 	movt	r0, #2049	; 0x801
 8008d72:	f006 fb0d 	bl	800f390 <chSysHalt>
  }
}
 8008d76:	b005      	add	sp, #20
 8008d78:	f85d fb04 	ldr.w	pc, [sp], #4
 8008d7c:	f3af 8000 	nop.w

08008d80 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8008d80:	b500      	push	{lr}
 8008d82:	b083      	sub	sp, #12
 8008d84:	9001      	str	r0, [sp, #4]
 8008d86:	460b      	mov	r3, r1
 8008d88:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 8008d8c:	9b01      	ldr	r3, [sp, #4]
 8008d8e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8008d92:	2b06      	cmp	r3, #6
 8008d94:	d850      	bhi.n	8008e38 <_usb_ep0out+0xb8>
 8008d96:	a201      	add	r2, pc, #4	; (adr r2, 8008d9c <_usb_ep0out+0x1c>)
 8008d98:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008d9c:	08008dfd 	.word	0x08008dfd
 8008da0:	08008dfd 	.word	0x08008dfd
 8008da4:	08008dfd 	.word	0x08008dfd
 8008da8:	08008dd7 	.word	0x08008dd7
 8008dac:	08008db9 	.word	0x08008db9
 8008db0:	08008dfd 	.word	0x08008dfd
 8008db4:	08008e09 	.word	0x08008e09
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 8008db8:	9b01      	ldr	r3, [sp, #4]
 8008dba:	2205      	movs	r2, #5
 8008dbc:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 8008dc0:	f001 fdce 	bl	800a960 <osalSysLockFromISR.9767>
    usbStartTransmitI(usbp, 0, NULL, 0);
 8008dc4:	9801      	ldr	r0, [sp, #4]
 8008dc6:	2100      	movs	r1, #0
 8008dc8:	2200      	movs	r2, #0
 8008dca:	2300      	movs	r3, #0
 8008dcc:	f7ff fde0 	bl	8008990 <usbStartTransmitI>
    osalSysUnlockFromISR();
 8008dd0:	f001 fdce 	bl	800a970 <osalSysUnlockFromISR.9771>
 8008dd4:	e036      	b.n	8008e44 <_usb_ep0out+0xc4>
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8008dd6:	9b01      	ldr	r3, [sp, #4]
 8008dd8:	68db      	ldr	r3, [r3, #12]
 8008dda:	699b      	ldr	r3, [r3, #24]
 8008ddc:	685b      	ldr	r3, [r3, #4]
 8008dde:	2b00      	cmp	r3, #0
 8008de0:	d130      	bne.n	8008e44 <_usb_ep0out+0xc4>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 8008de2:	9b01      	ldr	r3, [sp, #4]
 8008de4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008de6:	2b00      	cmp	r3, #0
 8008de8:	d003      	beq.n	8008df2 <_usb_ep0out+0x72>
      usbp->ep0endcb(usbp);
 8008dea:	9b01      	ldr	r3, [sp, #4]
 8008dec:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008dee:	9801      	ldr	r0, [sp, #4]
 8008df0:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8008df2:	9b01      	ldr	r3, [sp, #4]
 8008df4:	2200      	movs	r2, #0
 8008df6:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8008dfa:	e023      	b.n	8008e44 <_usb_ep0out+0xc4>
  case USB_EP0_WAITING_SETUP:
  case USB_EP0_TX:
  case USB_EP0_WAITING_TX0:
  case USB_EP0_SENDING_STS:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 8008dfc:	f641 6000 	movw	r0, #7680	; 0x1e00
 8008e00:	f6c0 0001 	movt	r0, #2049	; 0x801
 8008e04:	f006 fac4 	bl	800f390 <chSysHalt>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8008e08:	9801      	ldr	r0, [sp, #4]
 8008e0a:	2100      	movs	r1, #0
 8008e0c:	f7ff f8c0 	bl	8007f90 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8008e10:	9801      	ldr	r0, [sp, #4]
 8008e12:	2100      	movs	r1, #0
 8008e14:	f7ff f89c 	bl	8007f50 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8008e18:	9b01      	ldr	r3, [sp, #4]
 8008e1a:	685b      	ldr	r3, [r3, #4]
 8008e1c:	681b      	ldr	r3, [r3, #0]
 8008e1e:	2b00      	cmp	r3, #0
 8008e20:	d005      	beq.n	8008e2e <_usb_ep0out+0xae>
 8008e22:	9b01      	ldr	r3, [sp, #4]
 8008e24:	685b      	ldr	r3, [r3, #4]
 8008e26:	681b      	ldr	r3, [r3, #0]
 8008e28:	9801      	ldr	r0, [sp, #4]
 8008e2a:	2105      	movs	r1, #5
 8008e2c:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8008e2e:	9b01      	ldr	r3, [sp, #4]
 8008e30:	2206      	movs	r2, #6
 8008e32:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8008e36:	e005      	b.n	8008e44 <_usb_ep0out+0xc4>
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 8008e38:	f641 6000 	movw	r0, #7680	; 0x1e00
 8008e3c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8008e40:	f006 faa6 	bl	800f390 <chSysHalt>
  }
}
 8008e44:	b003      	add	sp, #12
 8008e46:	f85d fb04 	ldr.w	pc, [sp], #4
 8008e4a:	bf00      	nop
 8008e4c:	f3af 8000 	nop.w

08008e50 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8008e50:	b082      	sub	sp, #8
 8008e52:	9001      	str	r0, [sp, #4]
 8008e54:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8008e56:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8008e5a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008e5e:	9a00      	ldr	r2, [sp, #0]
 8008e60:	b2d2      	uxtb	r2, r2
 8008e62:	0112      	lsls	r2, r2, #4
 8008e64:	b2d2      	uxtb	r2, r2
 8008e66:	9901      	ldr	r1, [sp, #4]
 8008e68:	440b      	add	r3, r1
 8008e6a:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8008e6e:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8008e70:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8008e74:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008e78:	9a01      	ldr	r2, [sp, #4]
 8008e7a:	0952      	lsrs	r2, r2, #5
 8008e7c:	9901      	ldr	r1, [sp, #4]
 8008e7e:	f001 011f 	and.w	r1, r1, #31
 8008e82:	2001      	movs	r0, #1
 8008e84:	fa00 f101 	lsl.w	r1, r0, r1
 8008e88:	3260      	adds	r2, #96	; 0x60
 8008e8a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8008e8e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8008e92:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8008e96:	9a01      	ldr	r2, [sp, #4]
 8008e98:	0952      	lsrs	r2, r2, #5
 8008e9a:	9901      	ldr	r1, [sp, #4]
 8008e9c:	f001 011f 	and.w	r1, r1, #31
 8008ea0:	2001      	movs	r0, #1
 8008ea2:	fa00 f101 	lsl.w	r1, r0, r1
 8008ea6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8008eaa:	b002      	add	sp, #8
 8008eac:	4770      	bx	lr
 8008eae:	bf00      	nop

08008eb0 <hal_lld_backup_domain_init.10299.4444>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8008eb0:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8008eb4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008eb8:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8008ebc:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8008ec0:	6812      	ldr	r2, [r2, #0]
 8008ec2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8008ec6:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8008ec8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008ecc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ed0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008ed2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8008ed6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008eda:	d00c      	beq.n	8008ef6 <hal_lld_backup_domain_init.10299.4444+0x46>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8008edc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008ee0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ee4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8008ee8:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8008eea:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008eee:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ef2:	2200      	movs	r2, #0
 8008ef4:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8008ef6:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8008efa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008efe:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8008f02:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8008f06:	6852      	ldr	r2, [r2, #4]
 8008f08:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8008f0c:	605a      	str	r2, [r3, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8008f0e:	4770      	bx	lr

08008f10 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8008f10:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8008f12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f16:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f1a:	691b      	ldr	r3, [r3, #16]
 8008f1c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f20:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f24:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008f28:	611a      	str	r2, [r3, #16]
 8008f2a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f2e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f32:	2200      	movs	r2, #0
 8008f34:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8008f36:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f3a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f3e:	695b      	ldr	r3, [r3, #20]
 8008f40:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f44:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f48:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008f4c:	615a      	str	r2, [r3, #20]
 8008f4e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f52:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f56:	2200      	movs	r2, #0
 8008f58:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8008f5a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f5e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f62:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008f66:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008f6a:	6a12      	ldr	r2, [r2, #32]
 8008f6c:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 8008f70:	621a      	str	r2, [r3, #32]
 8008f72:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f76:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f7a:	2200      	movs	r2, #0
 8008f7c:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8008f7e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f82:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f86:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008f88:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f8c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f90:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008f94:	625a      	str	r2, [r3, #36]	; 0x24
 8008f96:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008f9a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008f9e:	2200      	movs	r2, #0
 8008fa0:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8008fa2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008fa6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008faa:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008fae:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008fb2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8008fb4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8008fb8:	641a      	str	r2, [r3, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8008fba:	f7ff ff79 	bl	8008eb0 <hal_lld_backup_domain_init.10299.4444>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8008fbe:	bd08      	pop	{r3, pc}

08008fc0 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8008fc0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008fc4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008fc8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8008fcc:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8008fce:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8008fd2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008fd6:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8008fda:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8008fdc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008fe0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008fe4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8008fe8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8008fec:	6812      	ldr	r2, [r2, #0]
 8008fee:	f042 0201 	orr.w	r2, r2, #1
 8008ff2:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8008ff4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8008ff8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8008ffc:	681b      	ldr	r3, [r3, #0]
 8008ffe:	f003 0302 	and.w	r3, r3, #2
 8009002:	2b00      	cmp	r3, #0
 8009004:	d0f6      	beq.n	8008ff4 <stm32_clock_init+0x34>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8009006:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800900a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800900e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009012:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009016:	6892      	ldr	r2, [r2, #8]
 8009018:	f022 0203 	bic.w	r2, r2, #3
 800901c:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 800901e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009022:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009026:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800902a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800902e:	6892      	ldr	r2, [r2, #8]
 8009030:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8009032:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009036:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800903a:	689b      	ldr	r3, [r3, #8]
 800903c:	f003 030c 	and.w	r3, r3, #12
 8009040:	2b00      	cmp	r3, #0
 8009042:	d1f6      	bne.n	8009032 <stm32_clock_init+0x72>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8009044:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009048:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800904c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009050:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009054:	6812      	ldr	r2, [r2, #0]
 8009056:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 800905a:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 800905c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009060:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009064:	2200      	movs	r2, #0
 8009066:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8009068:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800906c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009070:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009074:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009078:	6812      	ldr	r2, [r2, #0]
 800907a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800907e:	601a      	str	r2, [r3, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8009080:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009084:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009088:	681b      	ldr	r3, [r3, #0]
 800908a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800908e:	2b00      	cmp	r3, #0
 8009090:	d0f6      	beq.n	8009080 <stm32_clock_init+0xc0>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8009092:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009096:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800909a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800909e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80090a2:	6f52      	ldr	r2, [r2, #116]	; 0x74
 80090a4:	f042 0201 	orr.w	r2, r2, #1
 80090a8:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80090aa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80090ae:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80090b2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80090b4:	f003 0302 	and.w	r3, r3, #2
 80090b8:	2b00      	cmp	r3, #0
 80090ba:	d0f6      	beq.n	80090aa <stm32_clock_init+0xea>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 80090bc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80090c0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80090c4:	f245 4208 	movw	r2, #21512	; 0x5408
 80090c8:	f2c0 7240 	movt	r2, #1856	; 0x740
 80090cc:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80090ce:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80090d2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80090d6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80090da:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80090de:	6812      	ldr	r2, [r2, #0]
 80090e0:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80090e4:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80090e6:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 80090ea:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80090ee:	685b      	ldr	r3, [r3, #4]
 80090f0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80090f4:	2b00      	cmp	r3, #0
 80090f6:	d0f6      	beq.n	80090e6 <stm32_clock_init+0x126>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80090f8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80090fc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009100:	681b      	ldr	r3, [r3, #0]
 8009102:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8009106:	2b00      	cmp	r3, #0
 8009108:	d0f6      	beq.n	80090f8 <stm32_clock_init+0x138>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800910a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800910e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009112:	f44f 4214 	mov.w	r2, #37888	; 0x9400
 8009116:	f6c3 0288 	movt	r2, #14472	; 0x3888
 800911a:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800911c:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8009120:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009124:	f240 7205 	movw	r2, #1797	; 0x705
 8009128:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800912a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800912e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009132:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009136:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800913a:	6892      	ldr	r2, [r2, #8]
 800913c:	f042 0202 	orr.w	r2, r2, #2
 8009140:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8009142:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009146:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800914a:	689b      	ldr	r3, [r3, #8]
 800914c:	f003 030c 	and.w	r3, r3, #12
 8009150:	2b08      	cmp	r3, #8
 8009152:	d1f6      	bne.n	8009142 <stm32_clock_init+0x182>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8009154:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009158:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800915c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009160:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009164:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8009166:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800916a:	645a      	str	r2, [r3, #68]	; 0x44
 800916c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009170:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8009174:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009178:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800917c:	6e52      	ldr	r2, [r2, #100]	; 0x64
 800917e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8009182:	665a      	str	r2, [r3, #100]	; 0x64
}
 8009184:	4770      	bx	lr
 8009186:	bf00      	nop
 8009188:	f3af 8000 	nop.w
 800918c:	f3af 8000 	nop.w

08009190 <port_lock.10354.4437>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009190:	b082      	sub	sp, #8
 8009192:	2320      	movs	r3, #32
 8009194:	9301      	str	r3, [sp, #4]
 8009196:	9b01      	ldr	r3, [sp, #4]
 8009198:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800919c:	b002      	add	sp, #8
 800919e:	4770      	bx	lr

080091a0 <port_unlock.10357.4435>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80091a0:	b082      	sub	sp, #8
 80091a2:	2300      	movs	r3, #0
 80091a4:	9301      	str	r3, [sp, #4]
 80091a6:	9b01      	ldr	r3, [sp, #4]
 80091a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80091ac:	b002      	add	sp, #8
 80091ae:	4770      	bx	lr

080091b0 <port_lock_from_isr.10359.4433>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80091b0:	b508      	push	{r3, lr}

  port_lock();
 80091b2:	f7ff ffed 	bl	8009190 <port_lock.10354.4437>
}
 80091b6:	bd08      	pop	{r3, pc}
 80091b8:	f3af 8000 	nop.w
 80091bc:	f3af 8000 	nop.w

080091c0 <port_unlock_from_isr.10361.4431>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80091c0:	b508      	push	{r3, lr}

  port_unlock();
 80091c2:	f7ff ffed 	bl	80091a0 <port_unlock.10357.4435>
}
 80091c6:	bd08      	pop	{r3, pc}
 80091c8:	f3af 8000 	nop.w
 80091cc:	f3af 8000 	nop.w

080091d0 <chSysLockFromISR.10363.4429>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80091d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80091d2:	f7ff ffed 	bl	80091b0 <port_lock_from_isr.10359.4433>
  _stats_start_measure_crit_isr();
 80091d6:	f004 fee3 	bl	800dfa0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80091da:	f006 fac1 	bl	800f760 <_dbg_check_lock_from_isr>
}
 80091de:	bd08      	pop	{r3, pc}

080091e0 <chSysUnlockFromISR.10369.4427>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80091e0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 80091e2:	f006 fadd 	bl	800f7a0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80091e6:	f004 fee3 	bl	800dfb0 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 80091ea:	f7ff ffe9 	bl	80091c0 <port_unlock_from_isr.10361.4431>
}
 80091ee:	bd08      	pop	{r3, pc}

080091f0 <osalSysLockFromISR.10365.4425>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80091f0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80091f2:	f7ff ffed 	bl	80091d0 <chSysLockFromISR.10363.4429>
}
 80091f6:	bd08      	pop	{r3, pc}
 80091f8:	f3af 8000 	nop.w
 80091fc:	f3af 8000 	nop.w

08009200 <osalSysUnlockFromISR.10371.4423>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8009200:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8009202:	f7ff ffed 	bl	80091e0 <chSysUnlockFromISR.10369.4427>
}
 8009206:	bd08      	pop	{r3, pc}
 8009208:	f3af 8000 	nop.w
 800920c:	f3af 8000 	nop.w

08009210 <osalOsTimerHandlerI.10367.4421>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8009210:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8009212:	f006 f975 	bl	800f500 <chSysTimerHandlerI>
}
 8009216:	bd08      	pop	{r3, pc}
 8009218:	f3af 8000 	nop.w
 800921c:	f3af 8000 	nop.w

08009220 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8009220:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8009222:	f004 fe75 	bl	800df10 <_stats_increase_irq>
 8009226:	f006 fadb 	bl	800f7e0 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800922a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800922e:	691b      	ldr	r3, [r3, #16]
 8009230:	f003 0302 	and.w	r3, r3, #2
 8009234:	2b00      	cmp	r3, #0
 8009236:	d009      	beq.n	800924c <VectorB0+0x2c>
    STM32_ST_TIM->SR = 0U;
 8009238:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800923c:	2200      	movs	r2, #0
 800923e:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 8009240:	f7ff ffd6 	bl	80091f0 <osalSysLockFromISR.10365.4425>
    osalOsTimerHandlerI();
 8009244:	f7ff ffe4 	bl	8009210 <osalOsTimerHandlerI.10367.4421>
    osalSysUnlockFromISR();
 8009248:	f7ff ffda 	bl	8009200 <osalSysUnlockFromISR.10371.4423>
  }

  OSAL_IRQ_EPILOGUE();
 800924c:	f006 faf0 	bl	800f830 <_dbg_check_leave_isr>
 8009250:	f002 fbde 	bl	800ba10 <_port_irq_epilogue>
}
 8009254:	bd08      	pop	{r3, pc}
 8009256:	bf00      	nop
 8009258:	f3af 8000 	nop.w
 800925c:	f3af 8000 	nop.w

08009260 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8009260:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8009262:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009266:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800926a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800926e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009272:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009274:	f042 0201 	orr.w	r2, r2, #1
 8009278:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800927a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800927e:	f2ce 0304 	movt	r3, #57348	; 0xe004
 8009282:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8009286:	f2ce 0204 	movt	r2, #57348	; 0xe004
 800928a:	6892      	ldr	r2, [r2, #8]
 800928c:	f042 0201 	orr.w	r2, r2, #1
 8009290:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8009292:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009296:	f242 02cf 	movw	r2, #8399	; 0x20cf
 800929a:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800929c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80092a0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80092a4:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80092a6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80092aa:	2200      	movs	r2, #0
 80092ac:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80092ae:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80092b2:	2200      	movs	r2, #0
 80092b4:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80092b6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80092ba:	2200      	movs	r2, #0
 80092bc:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80092be:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80092c2:	2200      	movs	r2, #0
 80092c4:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80092c6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80092ca:	2201      	movs	r2, #1
 80092cc:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80092ce:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80092d2:	2201      	movs	r2, #1
 80092d4:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80092d6:	201c      	movs	r0, #28
 80092d8:	2108      	movs	r1, #8
 80092da:	f7ff fdb9 	bl	8008e50 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80092de:	bd08      	pop	{r3, pc}

080092e0 <initgpio.10453.4411>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 80092e0:	b082      	sub	sp, #8
 80092e2:	9001      	str	r0, [sp, #4]
 80092e4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 80092e6:	9b00      	ldr	r3, [sp, #0]
 80092e8:	685a      	ldr	r2, [r3, #4]
 80092ea:	9b01      	ldr	r3, [sp, #4]
 80092ec:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80092ee:	9b00      	ldr	r3, [sp, #0]
 80092f0:	689a      	ldr	r2, [r3, #8]
 80092f2:	9b01      	ldr	r3, [sp, #4]
 80092f4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80092f6:	9b00      	ldr	r3, [sp, #0]
 80092f8:	68da      	ldr	r2, [r3, #12]
 80092fa:	9b01      	ldr	r3, [sp, #4]
 80092fc:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80092fe:	9b00      	ldr	r3, [sp, #0]
 8009300:	691a      	ldr	r2, [r3, #16]
 8009302:	9b01      	ldr	r3, [sp, #4]
 8009304:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8009306:	9b00      	ldr	r3, [sp, #0]
 8009308:	695a      	ldr	r2, [r3, #20]
 800930a:	9b01      	ldr	r3, [sp, #4]
 800930c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800930e:	9b00      	ldr	r3, [sp, #0]
 8009310:	699a      	ldr	r2, [r3, #24]
 8009312:	9b01      	ldr	r3, [sp, #4]
 8009314:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8009316:	9b00      	ldr	r3, [sp, #0]
 8009318:	681a      	ldr	r2, [r3, #0]
 800931a:	9b01      	ldr	r3, [sp, #4]
 800931c:	601a      	str	r2, [r3, #0]
}
 800931e:	b002      	add	sp, #8
 8009320:	4770      	bx	lr
 8009322:	bf00      	nop
 8009324:	f3af 8000 	nop.w
 8009328:	f3af 8000 	nop.w
 800932c:	f3af 8000 	nop.w

08009330 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8009330:	b500      	push	{lr}
 8009332:	b083      	sub	sp, #12
 8009334:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8009336:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800933a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800933e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8009342:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009346:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8009348:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 800934c:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 8009350:	631a      	str	r2, [r3, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8009352:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009356:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800935a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800935e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8009362:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8009364:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 8009368:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 800936c:	651a      	str	r2, [r3, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 800936e:	9b01      	ldr	r3, [sp, #4]
 8009370:	2000      	movs	r0, #0
 8009372:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8009376:	4619      	mov	r1, r3
 8009378:	f7ff ffb2 	bl	80092e0 <initgpio.10453.4411>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 800937c:	9b01      	ldr	r3, [sp, #4]
 800937e:	331c      	adds	r3, #28
 8009380:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8009384:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8009388:	4619      	mov	r1, r3
 800938a:	f7ff ffa9 	bl	80092e0 <initgpio.10453.4411>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 800938e:	9b01      	ldr	r3, [sp, #4]
 8009390:	3338      	adds	r3, #56	; 0x38
 8009392:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8009396:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800939a:	4619      	mov	r1, r3
 800939c:	f7ff ffa0 	bl	80092e0 <initgpio.10453.4411>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 80093a0:	9b01      	ldr	r3, [sp, #4]
 80093a2:	3354      	adds	r3, #84	; 0x54
 80093a4:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 80093a8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80093ac:	4619      	mov	r1, r3
 80093ae:	f7ff ff97 	bl	80092e0 <initgpio.10453.4411>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 80093b2:	9b01      	ldr	r3, [sp, #4]
 80093b4:	3370      	adds	r3, #112	; 0x70
 80093b6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80093ba:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80093be:	4619      	mov	r1, r3
 80093c0:	f7ff ff8e 	bl	80092e0 <initgpio.10453.4411>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 80093c4:	9b01      	ldr	r3, [sp, #4]
 80093c6:	338c      	adds	r3, #140	; 0x8c
 80093c8:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
 80093cc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80093d0:	4619      	mov	r1, r3
 80093d2:	f7ff ff85 	bl	80092e0 <initgpio.10453.4411>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 80093d6:	9b01      	ldr	r3, [sp, #4]
 80093d8:	33a8      	adds	r3, #168	; 0xa8
 80093da:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 80093de:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80093e2:	4619      	mov	r1, r3
 80093e4:	f7ff ff7c 	bl	80092e0 <initgpio.10453.4411>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 80093e8:	9b01      	ldr	r3, [sp, #4]
 80093ea:	33c4      	adds	r3, #196	; 0xc4
 80093ec:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
 80093f0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80093f4:	4619      	mov	r1, r3
 80093f6:	f7ff ff73 	bl	80092e0 <initgpio.10453.4411>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
 80093fa:	9b01      	ldr	r3, [sp, #4]
 80093fc:	33e0      	adds	r3, #224	; 0xe0
 80093fe:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8009402:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8009406:	4619      	mov	r1, r3
 8009408:	f7ff ff6a 	bl	80092e0 <initgpio.10453.4411>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 800940c:	b003      	add	sp, #12
 800940e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009412:	bf00      	nop
 8009414:	f3af 8000 	nop.w
 8009418:	f3af 8000 	nop.w
 800941c:	f3af 8000 	nop.w

08009420 <port_lock.10545.4356>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009420:	b082      	sub	sp, #8
 8009422:	2320      	movs	r3, #32
 8009424:	9301      	str	r3, [sp, #4]
 8009426:	9b01      	ldr	r3, [sp, #4]
 8009428:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800942c:	b002      	add	sp, #8
 800942e:	4770      	bx	lr

08009430 <port_unlock.10548.4354>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8009430:	b082      	sub	sp, #8
 8009432:	2300      	movs	r3, #0
 8009434:	9301      	str	r3, [sp, #4]
 8009436:	9b01      	ldr	r3, [sp, #4]
 8009438:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800943c:	b002      	add	sp, #8
 800943e:	4770      	bx	lr

08009440 <port_lock_from_isr.10550.4352>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8009440:	b508      	push	{r3, lr}

  port_lock();
 8009442:	f7ff ffed 	bl	8009420 <port_lock.10545.4356>
}
 8009446:	bd08      	pop	{r3, pc}
 8009448:	f3af 8000 	nop.w
 800944c:	f3af 8000 	nop.w

08009450 <port_unlock_from_isr.10552.4350>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8009450:	b508      	push	{r3, lr}

  port_unlock();
 8009452:	f7ff ffed 	bl	8009430 <port_unlock.10548.4354>
}
 8009456:	bd08      	pop	{r3, pc}
 8009458:	f3af 8000 	nop.w
 800945c:	f3af 8000 	nop.w

08009460 <chSysLock.10668.4348>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8009460:	b508      	push	{r3, lr}

  port_lock();
 8009462:	f7ff ffdd 	bl	8009420 <port_lock.10545.4356>
  _stats_start_measure_crit_thd();
 8009466:	f004 fd8b 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800946a:	f006 f939 	bl	800f6e0 <_dbg_check_lock>
}
 800946e:	bd08      	pop	{r3, pc}

08009470 <chSysUnlock.10664.4346>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8009470:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8009472:	f006 f955 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8009476:	f004 fd8b 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800947a:	f640 5350 	movw	r3, #3408	; 0xd50
 800947e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009482:	681a      	ldr	r2, [r3, #0]
 8009484:	f640 5350 	movw	r3, #3408	; 0xd50
 8009488:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800948c:	429a      	cmp	r2, r3
 800948e:	d013      	beq.n	80094b8 <chSysUnlock.10664.4346+0x48>
 8009490:	f640 5350 	movw	r3, #3408	; 0xd50
 8009494:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009498:	699b      	ldr	r3, [r3, #24]
 800949a:	689a      	ldr	r2, [r3, #8]
 800949c:	f640 5350 	movw	r3, #3408	; 0xd50
 80094a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80094a4:	681b      	ldr	r3, [r3, #0]
 80094a6:	689b      	ldr	r3, [r3, #8]
 80094a8:	429a      	cmp	r2, r3
 80094aa:	d205      	bcs.n	80094b8 <chSysUnlock.10664.4346+0x48>
 80094ac:	f641 60a0 	movw	r0, #7840	; 0x1ea0
 80094b0:	f6c0 0001 	movt	r0, #2049	; 0x801
 80094b4:	f005 ff6c 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80094b8:	f7ff ffba 	bl	8009430 <port_unlock.10548.4354>
}
 80094bc:	bd08      	pop	{r3, pc}
 80094be:	bf00      	nop

080094c0 <chSysLockFromISR.10564.4344>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80094c0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80094c2:	f7ff ffbd 	bl	8009440 <port_lock_from_isr.10550.4352>
  _stats_start_measure_crit_isr();
 80094c6:	f004 fd6b 	bl	800dfa0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80094ca:	f006 f949 	bl	800f760 <_dbg_check_lock_from_isr>
}
 80094ce:	bd08      	pop	{r3, pc}

080094d0 <chSysUnlockFromISR.10654.4342>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80094d0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 80094d2:	f006 f965 	bl	800f7a0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80094d6:	f004 fd6b 	bl	800dfb0 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 80094da:	f7ff ffb9 	bl	8009450 <port_unlock_from_isr.10552.4350>
}
 80094de:	bd08      	pop	{r3, pc}

080094e0 <chThdStartI.10658>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 80094e0:	b500      	push	{lr}
 80094e2:	b083      	sub	sp, #12
 80094e4:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");
 80094e6:	9b01      	ldr	r3, [sp, #4]
 80094e8:	f893 3020 	ldrb.w	r3, [r3, #32]
 80094ec:	2b02      	cmp	r3, #2
 80094ee:	d005      	beq.n	80094fc <chThdStartI.10658+0x1c>
 80094f0:	f641 6090 	movw	r0, #7824	; 0x1e90
 80094f4:	f6c0 0001 	movt	r0, #2049	; 0x801
 80094f8:	f005 ff4a 	bl	800f390 <chSysHalt>

  return chSchReadyI(tp);
 80094fc:	9801      	ldr	r0, [sp, #4]
 80094fe:	f006 fcaf 	bl	800fe60 <chSchReadyI>
 8009502:	4603      	mov	r3, r0
}
 8009504:	4618      	mov	r0, r3
 8009506:	b003      	add	sp, #12
 8009508:	f85d fb04 	ldr.w	pc, [sp], #4
 800950c:	f3af 8000 	nop.w

08009510 <chRegSetThreadName.10554>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8009510:	b082      	sub	sp, #8
 8009512:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8009514:	f640 5350 	movw	r3, #3408	; 0xd50
 8009518:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800951c:	699b      	ldr	r3, [r3, #24]
 800951e:	9a01      	ldr	r2, [sp, #4]
 8009520:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8009522:	b002      	add	sp, #8
 8009524:	4770      	bx	lr
 8009526:	bf00      	nop
 8009528:	f3af 8000 	nop.w
 800952c:	f3af 8000 	nop.w

08009530 <osalSysLock.10670>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8009530:	b508      	push	{r3, lr}

  chSysLock();
 8009532:	f7ff ff95 	bl	8009460 <chSysLock.10668.4348>
}
 8009536:	bd08      	pop	{r3, pc}
 8009538:	f3af 8000 	nop.w
 800953c:	f3af 8000 	nop.w

08009540 <osalSysUnlock.10666>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8009540:	b508      	push	{r3, lr}

  chSysUnlock();
 8009542:	f7ff ff95 	bl	8009470 <chSysUnlock.10664.4346>
}
 8009546:	bd08      	pop	{r3, pc}
 8009548:	f3af 8000 	nop.w
 800954c:	f3af 8000 	nop.w

08009550 <osalSysLockFromISR.10566>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8009550:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8009552:	f7ff ffb5 	bl	80094c0 <chSysLockFromISR.10564.4344>
}
 8009556:	bd08      	pop	{r3, pc}
 8009558:	f3af 8000 	nop.w
 800955c:	f3af 8000 	nop.w

08009560 <osalSysUnlockFromISR.10656>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8009560:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8009562:	f7ff ffb5 	bl	80094d0 <chSysUnlockFromISR.10654.4342>
}
 8009566:	bd08      	pop	{r3, pc}
 8009568:	f3af 8000 	nop.w
 800956c:	f3af 8000 	nop.w

08009570 <osalSysPolledDelayX.10558.4325>:
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8009570:	b500      	push	{lr}
 8009572:	b083      	sub	sp, #12
 8009574:	9001      	str	r0, [sp, #4]

  chSysPolledDelayX(cycles);
 8009576:	9801      	ldr	r0, [sp, #4]
 8009578:	f006 f81a 	bl	800f5b0 <chSysPolledDelayX>
}
 800957c:	b003      	add	sp, #12
 800957e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009582:	bf00      	nop
 8009584:	f3af 8000 	nop.w
 8009588:	f3af 8000 	nop.w
 800958c:	f3af 8000 	nop.w

08009590 <osalThreadSuspendS.10661>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8009590:	b500      	push	{lr}
 8009592:	b083      	sub	sp, #12
 8009594:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 8009596:	9801      	ldr	r0, [sp, #4]
 8009598:	f004 fb22 	bl	800dbe0 <chThdSuspendS>
 800959c:	4603      	mov	r3, r0
}
 800959e:	4618      	mov	r0, r3
 80095a0:	b003      	add	sp, #12
 80095a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80095a6:	bf00      	nop
 80095a8:	f3af 8000 	nop.w
 80095ac:	f3af 8000 	nop.w

080095b0 <osalThreadResumeI.10568>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80095b0:	b500      	push	{lr}
 80095b2:	b083      	sub	sp, #12
 80095b4:	9001      	str	r0, [sp, #4]
 80095b6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 80095b8:	9801      	ldr	r0, [sp, #4]
 80095ba:	9900      	ldr	r1, [sp, #0]
 80095bc:	f004 fb38 	bl	800dc30 <chThdResumeI>
}
 80095c0:	b003      	add	sp, #12
 80095c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80095c6:	bf00      	nop
 80095c8:	f3af 8000 	nop.w
 80095cc:	f3af 8000 	nop.w

080095d0 <otg_core_reset.10672>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void otg_core_reset(USBDriver *usbp) {
 80095d0:	b500      	push	{lr}
 80095d2:	b085      	sub	sp, #20
 80095d4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80095d6:	9b01      	ldr	r3, [sp, #4]
 80095d8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80095da:	9303      	str	r3, [sp, #12]

  osalSysPolledDelayX(32);
 80095dc:	2020      	movs	r0, #32
 80095de:	f7ff ffc7 	bl	8009570 <osalSysPolledDelayX.10558.4325>

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 80095e2:	9b03      	ldr	r3, [sp, #12]
 80095e4:	2201      	movs	r2, #1
 80095e6:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 80095e8:	9b03      	ldr	r3, [sp, #12]
 80095ea:	691b      	ldr	r3, [r3, #16]
 80095ec:	f003 0301 	and.w	r3, r3, #1
 80095f0:	2b00      	cmp	r3, #0
 80095f2:	d1f9      	bne.n	80095e8 <otg_core_reset.10672+0x18>
    ;

  osalSysPolledDelayX(18);
 80095f4:	2012      	movs	r0, #18
 80095f6:	f7ff ffbb 	bl	8009570 <osalSysPolledDelayX.10558.4325>

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 80095fa:	9b03      	ldr	r3, [sp, #12]
 80095fc:	691b      	ldr	r3, [r3, #16]
 80095fe:	2b00      	cmp	r3, #0
 8009600:	dafb      	bge.n	80095fa <otg_core_reset.10672+0x2a>
    ;
}
 8009602:	b005      	add	sp, #20
 8009604:	f85d fb04 	ldr.w	pc, [sp], #4
 8009608:	f3af 8000 	nop.w
 800960c:	f3af 8000 	nop.w

08009610 <otg_disable_ep.10843>:

static void otg_disable_ep(USBDriver *usbp) {
 8009610:	b084      	sub	sp, #16
 8009612:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8009614:	9b01      	ldr	r3, [sp, #4]
 8009616:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8009618:	9302      	str	r3, [sp, #8]
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800961a:	2300      	movs	r3, #0
 800961c:	9303      	str	r3, [sp, #12]
 800961e:	e032      	b.n	8009686 <otg_disable_ep.10843+0x76>
    otgp->ie[i].DIEPCTL = 0;
 8009620:	9a02      	ldr	r2, [sp, #8]
 8009622:	9b03      	ldr	r3, [sp, #12]
 8009624:	3348      	adds	r3, #72	; 0x48
 8009626:	015b      	lsls	r3, r3, #5
 8009628:	4413      	add	r3, r2
 800962a:	2200      	movs	r2, #0
 800962c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 800962e:	9a02      	ldr	r2, [sp, #8]
 8009630:	9b03      	ldr	r3, [sp, #12]
 8009632:	015b      	lsls	r3, r3, #5
 8009634:	4413      	add	r3, r2
 8009636:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800963a:	2200      	movs	r2, #0
 800963c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800963e:	9a02      	ldr	r2, [sp, #8]
 8009640:	9b03      	ldr	r3, [sp, #12]
 8009642:	015b      	lsls	r3, r3, #5
 8009644:	4413      	add	r3, r2
 8009646:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800964a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800964e:	601a      	str	r2, [r3, #0]

    otgp->oe[i].DOEPCTL = 0;
 8009650:	9a02      	ldr	r2, [sp, #8]
 8009652:	9b03      	ldr	r3, [sp, #12]
 8009654:	3358      	adds	r3, #88	; 0x58
 8009656:	015b      	lsls	r3, r3, #5
 8009658:	4413      	add	r3, r2
 800965a:	2200      	movs	r2, #0
 800965c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 800965e:	9a02      	ldr	r2, [sp, #8]
 8009660:	9b03      	ldr	r3, [sp, #12]
 8009662:	015b      	lsls	r3, r3, #5
 8009664:	4413      	add	r3, r2
 8009666:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800966a:	2200      	movs	r2, #0
 800966c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800966e:	9a02      	ldr	r2, [sp, #8]
 8009670:	9b03      	ldr	r3, [sp, #12]
 8009672:	015b      	lsls	r3, r3, #5
 8009674:	4413      	add	r3, r2
 8009676:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800967a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800967e:	601a      	str	r2, [r3, #0]

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8009680:	9b03      	ldr	r3, [sp, #12]
 8009682:	3301      	adds	r3, #1
 8009684:	9303      	str	r3, [sp, #12]
 8009686:	9b01      	ldr	r3, [sp, #4]
 8009688:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800968a:	689a      	ldr	r2, [r3, #8]
 800968c:	9b03      	ldr	r3, [sp, #12]
 800968e:	429a      	cmp	r2, r3
 8009690:	d2c6      	bcs.n	8009620 <otg_disable_ep.10843+0x10>

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8009692:	9b02      	ldr	r3, [sp, #8]
 8009694:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8009698:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 800969c:	b004      	add	sp, #16
 800969e:	4770      	bx	lr

080096a0 <otg_rxfifo_flush.10846>:

static void otg_rxfifo_flush(USBDriver *usbp) {
 80096a0:	b500      	push	{lr}
 80096a2:	b085      	sub	sp, #20
 80096a4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80096a6:	9b01      	ldr	r3, [sp, #4]
 80096a8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80096aa:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80096ac:	9b03      	ldr	r3, [sp, #12]
 80096ae:	2210      	movs	r2, #16
 80096b0:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80096b2:	9b03      	ldr	r3, [sp, #12]
 80096b4:	691b      	ldr	r3, [r3, #16]
 80096b6:	f003 0310 	and.w	r3, r3, #16
 80096ba:	2b00      	cmp	r3, #0
 80096bc:	d1f9      	bne.n	80096b2 <otg_rxfifo_flush.10846+0x12>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 80096be:	2012      	movs	r0, #18
 80096c0:	f7ff ff56 	bl	8009570 <osalSysPolledDelayX.10558.4325>
}
 80096c4:	b005      	add	sp, #20
 80096c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80096ca:	bf00      	nop
 80096cc:	f3af 8000 	nop.w

080096d0 <otg_txfifo_flush.10849>:

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 80096d0:	b500      	push	{lr}
 80096d2:	b085      	sub	sp, #20
 80096d4:	9001      	str	r0, [sp, #4]
 80096d6:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 80096d8:	9b01      	ldr	r3, [sp, #4]
 80096da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80096dc:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80096de:	9b00      	ldr	r3, [sp, #0]
 80096e0:	019b      	lsls	r3, r3, #6
 80096e2:	f043 0220 	orr.w	r2, r3, #32
 80096e6:	9b03      	ldr	r3, [sp, #12]
 80096e8:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80096ea:	9b03      	ldr	r3, [sp, #12]
 80096ec:	691b      	ldr	r3, [r3, #16]
 80096ee:	f003 0320 	and.w	r3, r3, #32
 80096f2:	2b00      	cmp	r3, #0
 80096f4:	d1f9      	bne.n	80096ea <otg_txfifo_flush.10849+0x1a>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 80096f6:	2012      	movs	r0, #18
 80096f8:	f7ff ff3a 	bl	8009570 <osalSysPolledDelayX.10558.4325>
}
 80096fc:	b005      	add	sp, #20
 80096fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8009702:	bf00      	nop
 8009704:	f3af 8000 	nop.w
 8009708:	f3af 8000 	nop.w
 800970c:	f3af 8000 	nop.w

08009710 <otg_ram_reset.10853>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {
 8009710:	b082      	sub	sp, #8
 8009712:	9001      	str	r0, [sp, #4]

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8009714:	9b01      	ldr	r3, [sp, #4]
 8009716:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009718:	681a      	ldr	r2, [r3, #0]
 800971a:	9b01      	ldr	r3, [sp, #4]
 800971c:	671a      	str	r2, [r3, #112]	; 0x70
}
 800971e:	b002      	add	sp, #8
 8009720:	4770      	bx	lr
 8009722:	bf00      	nop
 8009724:	f3af 8000 	nop.w
 8009728:	f3af 8000 	nop.w
 800972c:	f3af 8000 	nop.w

08009730 <otg_ram_alloc.10856>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] size      size of the packet buffer to allocate in words
 *
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 8009730:	b500      	push	{lr}
 8009732:	b085      	sub	sp, #20
 8009734:	9001      	str	r0, [sp, #4]
 8009736:	9100      	str	r1, [sp, #0]
  uint32_t next;

  next = usbp->pmnext;
 8009738:	9b01      	ldr	r3, [sp, #4]
 800973a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800973c:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 800973e:	9b01      	ldr	r3, [sp, #4]
 8009740:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8009742:	9b00      	ldr	r3, [sp, #0]
 8009744:	441a      	add	r2, r3
 8009746:	9b01      	ldr	r3, [sp, #4]
 8009748:	671a      	str	r2, [r3, #112]	; 0x70
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800974a:	9b01      	ldr	r3, [sp, #4]
 800974c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800974e:	9b01      	ldr	r3, [sp, #4]
 8009750:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009752:	685b      	ldr	r3, [r3, #4]
 8009754:	429a      	cmp	r2, r3
 8009756:	d905      	bls.n	8009764 <otg_ram_alloc.10856+0x34>
 8009758:	f641 6060 	movw	r0, #7776	; 0x1e60
 800975c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8009760:	f005 fe16 	bl	800f390 <chSysHalt>
                "OTG FIFO memory overflow");
  return next;
 8009764:	9b03      	ldr	r3, [sp, #12]
}
 8009766:	4618      	mov	r0, r3
 8009768:	b005      	add	sp, #20
 800976a:	f85d fb04 	ldr.w	pc, [sp], #4
 800976e:	bf00      	nop

08009770 <otg_fifo_write_from_buffer.10860.4293>:
 *
 * @notapi
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {
 8009770:	b500      	push	{lr}
 8009772:	b085      	sub	sp, #20
 8009774:	9003      	str	r0, [sp, #12]
 8009776:	9102      	str	r1, [sp, #8]
 8009778:	9201      	str	r2, [sp, #4]

  osalDbgAssert(n > 0, "is zero");
 800977a:	9b01      	ldr	r3, [sp, #4]
 800977c:	2b00      	cmp	r3, #0
 800977e:	d105      	bne.n	800978c <otg_fifo_write_from_buffer.10860.4293+0x1c>
 8009780:	f641 6070 	movw	r0, #7792	; 0x1e70
 8009784:	f6c0 0001 	movt	r0, #2049	; 0x801
 8009788:	f005 fe02 	bl	800f390 <chSysHalt>

  while (true) {
    *fifop = *((uint32_t *)buf);
 800978c:	9b02      	ldr	r3, [sp, #8]
 800978e:	681a      	ldr	r2, [r3, #0]
 8009790:	9b03      	ldr	r3, [sp, #12]
 8009792:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 8009794:	9b01      	ldr	r3, [sp, #4]
 8009796:	2b04      	cmp	r3, #4
 8009798:	d906      	bls.n	80097a8 <otg_fifo_write_from_buffer.10860.4293+0x38>
      break;
    }
    n -= 4;
 800979a:	9b01      	ldr	r3, [sp, #4]
 800979c:	3b04      	subs	r3, #4
 800979e:	9301      	str	r3, [sp, #4]
    buf += 4;
 80097a0:	9b02      	ldr	r3, [sp, #8]
 80097a2:	3304      	adds	r3, #4
 80097a4:	9302      	str	r3, [sp, #8]
 80097a6:	e7f1      	b.n	800978c <otg_fifo_write_from_buffer.10860.4293+0x1c>
  }
}
 80097a8:	b005      	add	sp, #20
 80097aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80097ae:	bf00      	nop

080097b0 <otg_fifo_read_to_buffer.10865.4287>:
 * @notapi
 */
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {
 80097b0:	b086      	sub	sp, #24
 80097b2:	9003      	str	r0, [sp, #12]
 80097b4:	9102      	str	r1, [sp, #8]
 80097b6:	9201      	str	r2, [sp, #4]
 80097b8:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 80097ba:	2300      	movs	r3, #0
 80097bc:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 80097be:	2300      	movs	r3, #0
 80097c0:	9304      	str	r3, [sp, #16]
 80097c2:	e017      	b.n	80097f4 <otg_fifo_read_to_buffer.10865.4287+0x44>

  while (i < n) {
    if ((i & 3) == 0){
 80097c4:	9b04      	ldr	r3, [sp, #16]
 80097c6:	f003 0303 	and.w	r3, r3, #3
 80097ca:	2b00      	cmp	r3, #0
 80097cc:	d102      	bne.n	80097d4 <otg_fifo_read_to_buffer.10865.4287+0x24>
      w = *fifop;
 80097ce:	9b03      	ldr	r3, [sp, #12]
 80097d0:	681b      	ldr	r3, [r3, #0]
 80097d2:	9305      	str	r3, [sp, #20]
    }
    if (i < max) {
 80097d4:	9a04      	ldr	r2, [sp, #16]
 80097d6:	9b00      	ldr	r3, [sp, #0]
 80097d8:	429a      	cmp	r2, r3
 80097da:	d208      	bcs.n	80097ee <otg_fifo_read_to_buffer.10865.4287+0x3e>
      *buf++ = (uint8_t)w;
 80097dc:	9b02      	ldr	r3, [sp, #8]
 80097de:	1c5a      	adds	r2, r3, #1
 80097e0:	9202      	str	r2, [sp, #8]
 80097e2:	9a05      	ldr	r2, [sp, #20]
 80097e4:	b2d2      	uxtb	r2, r2
 80097e6:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 80097e8:	9b05      	ldr	r3, [sp, #20]
 80097ea:	0a1b      	lsrs	r3, r3, #8
 80097ec:	9305      	str	r3, [sp, #20]
    }
    i++;
 80097ee:	9b04      	ldr	r3, [sp, #16]
 80097f0:	3301      	adds	r3, #1
 80097f2:	9304      	str	r3, [sp, #16]
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80097f4:	9a04      	ldr	r2, [sp, #16]
 80097f6:	9b01      	ldr	r3, [sp, #4]
 80097f8:	429a      	cmp	r2, r3
 80097fa:	d3e3      	bcc.n	80097c4 <otg_fifo_read_to_buffer.10865.4287+0x14>
      *buf++ = (uint8_t)w;
      w >>= 8;
    }
    i++;
  }
}
 80097fc:	b006      	add	sp, #24
 80097fe:	4770      	bx	lr

08009800 <otg_rxfifo_handler.10871>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
 8009800:	b510      	push	{r4, lr}
 8009802:	b086      	sub	sp, #24
 8009804:	9001      	str	r0, [sp, #4]
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 8009806:	9b01      	ldr	r3, [sp, #4]
 8009808:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800980a:	6a1b      	ldr	r3, [r3, #32]
 800980c:	9305      	str	r3, [sp, #20]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 800980e:	9b05      	ldr	r3, [sp, #20]
 8009810:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 8009814:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8009818:	d072      	beq.n	8009900 <otg_rxfifo_handler.10871+0x100>
 800981a:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 800981e:	d003      	beq.n	8009828 <otg_rxfifo_handler.10871+0x28>
 8009820:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8009824:	d01c      	beq.n	8009860 <otg_rxfifo_handler.10871+0x60>
 8009826:	e06b      	b.n	8009900 <otg_rxfifo_handler.10871+0x100>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8009828:	9a05      	ldr	r2, [sp, #20]
 800982a:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 800982e:	4013      	ands	r3, r2
 8009830:	091b      	lsrs	r3, r3, #4
 8009832:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8009834:	9b05      	ldr	r3, [sp, #20]
 8009836:	f003 030f 	and.w	r3, r3, #15
 800983a:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800983c:	9b01      	ldr	r3, [sp, #4]
 800983e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8009840:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8009844:	9901      	ldr	r1, [sp, #4]
 8009846:	9b03      	ldr	r3, [sp, #12]
 8009848:	3302      	adds	r3, #2
 800984a:	009b      	lsls	r3, r3, #2
 800984c:	440b      	add	r3, r1
 800984e:	685b      	ldr	r3, [r3, #4]
 8009850:	6a1b      	ldr	r3, [r3, #32]
 8009852:	4610      	mov	r0, r2
 8009854:	4619      	mov	r1, r3
 8009856:	9a04      	ldr	r2, [sp, #16]
 8009858:	2308      	movs	r3, #8
 800985a:	f7ff ffa9 	bl	80097b0 <otg_fifo_read_to_buffer.10865.4287>
 800985e:	e04f      	b.n	8009900 <otg_rxfifo_handler.10871+0x100>
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8009860:	9a05      	ldr	r2, [sp, #20]
 8009862:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8009866:	4013      	ands	r3, r2
 8009868:	091b      	lsrs	r3, r3, #4
 800986a:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800986c:	9b05      	ldr	r3, [sp, #20]
 800986e:	f003 030f 	and.w	r3, r3, #15
 8009872:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8009874:	9b01      	ldr	r3, [sp, #4]
 8009876:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8009878:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 800987c:	9a01      	ldr	r2, [sp, #4]
 800987e:	9b03      	ldr	r3, [sp, #12]
 8009880:	3302      	adds	r3, #2
 8009882:	009b      	lsls	r3, r3, #2
 8009884:	4413      	add	r3, r2
 8009886:	685b      	ldr	r3, [r3, #4]
 8009888:	699b      	ldr	r3, [r3, #24]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800988a:	689a      	ldr	r2, [r3, #8]
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
 800988c:	9801      	ldr	r0, [sp, #4]
 800988e:	9b03      	ldr	r3, [sp, #12]
 8009890:	3302      	adds	r3, #2
 8009892:	009b      	lsls	r3, r3, #2
 8009894:	4403      	add	r3, r0
 8009896:	685b      	ldr	r3, [r3, #4]
 8009898:	699b      	ldr	r3, [r3, #24]
 800989a:	6818      	ldr	r0, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 800989c:	9c01      	ldr	r4, [sp, #4]
 800989e:	9b03      	ldr	r3, [sp, #12]
 80098a0:	3302      	adds	r3, #2
 80098a2:	009b      	lsls	r3, r3, #2
 80098a4:	4423      	add	r3, r4
 80098a6:	685b      	ldr	r3, [r3, #4]
 80098a8:	699b      	ldr	r3, [r3, #24]
 80098aa:	685b      	ldr	r3, [r3, #4]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80098ac:	1ac3      	subs	r3, r0, r3
 80098ae:	4608      	mov	r0, r1
 80098b0:	4611      	mov	r1, r2
 80098b2:	9a04      	ldr	r2, [sp, #16]
 80098b4:	f7ff ff7c 	bl	80097b0 <otg_fifo_read_to_buffer.10865.4287>
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 80098b8:	9a01      	ldr	r2, [sp, #4]
 80098ba:	9b03      	ldr	r3, [sp, #12]
 80098bc:	3302      	adds	r3, #2
 80098be:	009b      	lsls	r3, r3, #2
 80098c0:	4413      	add	r3, r2
 80098c2:	685b      	ldr	r3, [r3, #4]
 80098c4:	699a      	ldr	r2, [r3, #24]
 80098c6:	9901      	ldr	r1, [sp, #4]
 80098c8:	9b03      	ldr	r3, [sp, #12]
 80098ca:	3302      	adds	r3, #2
 80098cc:	009b      	lsls	r3, r3, #2
 80098ce:	440b      	add	r3, r1
 80098d0:	685b      	ldr	r3, [r3, #4]
 80098d2:	699b      	ldr	r3, [r3, #24]
 80098d4:	6899      	ldr	r1, [r3, #8]
 80098d6:	9b04      	ldr	r3, [sp, #16]
 80098d8:	440b      	add	r3, r1
 80098da:	6093      	str	r3, [r2, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80098dc:	9a01      	ldr	r2, [sp, #4]
 80098de:	9b03      	ldr	r3, [sp, #12]
 80098e0:	3302      	adds	r3, #2
 80098e2:	009b      	lsls	r3, r3, #2
 80098e4:	4413      	add	r3, r2
 80098e6:	685b      	ldr	r3, [r3, #4]
 80098e8:	699a      	ldr	r2, [r3, #24]
 80098ea:	9901      	ldr	r1, [sp, #4]
 80098ec:	9b03      	ldr	r3, [sp, #12]
 80098ee:	3302      	adds	r3, #2
 80098f0:	009b      	lsls	r3, r3, #2
 80098f2:	440b      	add	r3, r1
 80098f4:	685b      	ldr	r3, [r3, #4]
 80098f6:	699b      	ldr	r3, [r3, #24]
 80098f8:	6859      	ldr	r1, [r3, #4]
 80098fa:	9b04      	ldr	r3, [sp, #16]
 80098fc:	440b      	add	r3, r1
 80098fe:	6053      	str	r3, [r2, #4]
  case GRXSTSP_OUT_GLOBAL_NAK:
  case GRXSTSP_OUT_COMP:
  default:
    ;
  }
}
 8009900:	b006      	add	sp, #24
 8009902:	bd10      	pop	{r4, pc}
 8009904:	f3af 8000 	nop.w
 8009908:	f3af 8000 	nop.w
 800990c:	f3af 8000 	nop.w

08009910 <otg_txfifo_handler.10874>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8009910:	b500      	push	{lr}
 8009912:	b085      	sub	sp, #20
 8009914:	9001      	str	r0, [sp, #4]
 8009916:	460b      	mov	r3, r1
 8009918:	f88d 3003 	strb.w	r3, [sp, #3]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 800991c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009920:	9a01      	ldr	r2, [sp, #4]
 8009922:	3302      	adds	r3, #2
 8009924:	009b      	lsls	r3, r3, #2
 8009926:	4413      	add	r3, r2
 8009928:	685b      	ldr	r3, [r3, #4]
 800992a:	695b      	ldr	r3, [r3, #20]
 800992c:	685a      	ldr	r2, [r3, #4]
 800992e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009932:	9901      	ldr	r1, [sp, #4]
 8009934:	3302      	adds	r3, #2
 8009936:	009b      	lsls	r3, r3, #2
 8009938:	440b      	add	r3, r1
 800993a:	685b      	ldr	r3, [r3, #4]
 800993c:	695b      	ldr	r3, [r3, #20]
 800993e:	681b      	ldr	r3, [r3, #0]
 8009940:	429a      	cmp	r2, r3
 8009942:	d301      	bcc.n	8009948 <otg_txfifo_handler.10874+0x38>
      return true;
 8009944:	2301      	movs	r3, #1
 8009946:	e076      	b.n	8009a36 <otg_txfifo_handler.10874+0x126>

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8009948:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800994c:	9a01      	ldr	r2, [sp, #4]
 800994e:	3302      	adds	r3, #2
 8009950:	009b      	lsls	r3, r3, #2
 8009952:	4413      	add	r3, r2
 8009954:	685b      	ldr	r3, [r3, #4]
 8009956:	695b      	ldr	r3, [r3, #20]
 8009958:	681a      	ldr	r2, [r3, #0]
 800995a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800995e:	9901      	ldr	r1, [sp, #4]
 8009960:	3302      	adds	r3, #2
 8009962:	009b      	lsls	r3, r3, #2
 8009964:	440b      	add	r3, r1
 8009966:	685b      	ldr	r3, [r3, #4]
 8009968:	695b      	ldr	r3, [r3, #20]
 800996a:	685b      	ldr	r3, [r3, #4]
 800996c:	1ad3      	subs	r3, r2, r3
 800996e:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 8009970:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009974:	9a01      	ldr	r2, [sp, #4]
 8009976:	3302      	adds	r3, #2
 8009978:	009b      	lsls	r3, r3, #2
 800997a:	4413      	add	r3, r2
 800997c:	685b      	ldr	r3, [r3, #4]
 800997e:	8a1b      	ldrh	r3, [r3, #16]
 8009980:	461a      	mov	r2, r3
 8009982:	9b03      	ldr	r3, [sp, #12]
 8009984:	429a      	cmp	r2, r3
 8009986:	d208      	bcs.n	800999a <otg_txfifo_handler.10874+0x8a>
      n = usbp->epc[ep]->in_maxsize;
 8009988:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800998c:	9a01      	ldr	r2, [sp, #4]
 800998e:	3302      	adds	r3, #2
 8009990:	009b      	lsls	r3, r3, #2
 8009992:	4413      	add	r3, r2
 8009994:	685b      	ldr	r3, [r3, #4]
 8009996:	8a1b      	ldrh	r3, [r3, #16]
 8009998:	9303      	str	r3, [sp, #12]

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800999a:	9b01      	ldr	r3, [sp, #4]
 800999c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800999e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80099a2:	015b      	lsls	r3, r3, #5
 80099a4:	4413      	add	r3, r2
 80099a6:	f603 1318 	addw	r3, r3, #2328	; 0x918
 80099aa:	681b      	ldr	r3, [r3, #0]
 80099ac:	b29b      	uxth	r3, r3
 80099ae:	009a      	lsls	r2, r3, #2
 80099b0:	9b03      	ldr	r3, [sp, #12]
 80099b2:	429a      	cmp	r2, r3
 80099b4:	d201      	bcs.n	80099ba <otg_txfifo_handler.10874+0xaa>
      return false;
 80099b6:	2300      	movs	r3, #0
 80099b8:	e03d      	b.n	8009a36 <otg_txfifo_handler.10874+0x126>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80099ba:	9b01      	ldr	r3, [sp, #4]
 80099bc:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80099be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80099c2:	3301      	adds	r3, #1
 80099c4:	031b      	lsls	r3, r3, #12
 80099c6:	441a      	add	r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 80099c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80099cc:	9901      	ldr	r1, [sp, #4]
 80099ce:	3302      	adds	r3, #2
 80099d0:	009b      	lsls	r3, r3, #2
 80099d2:	440b      	add	r3, r1
 80099d4:	685b      	ldr	r3, [r3, #4]
 80099d6:	695b      	ldr	r3, [r3, #20]
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80099d8:	689b      	ldr	r3, [r3, #8]
 80099da:	4610      	mov	r0, r2
 80099dc:	4619      	mov	r1, r3
 80099de:	9a03      	ldr	r2, [sp, #12]
 80099e0:	f7ff fec6 	bl	8009770 <otg_fifo_write_from_buffer.10860.4293>
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 80099e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80099e8:	9a01      	ldr	r2, [sp, #4]
 80099ea:	3302      	adds	r3, #2
 80099ec:	009b      	lsls	r3, r3, #2
 80099ee:	4413      	add	r3, r2
 80099f0:	685b      	ldr	r3, [r3, #4]
 80099f2:	695a      	ldr	r2, [r3, #20]
 80099f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80099f8:	9901      	ldr	r1, [sp, #4]
 80099fa:	3302      	adds	r3, #2
 80099fc:	009b      	lsls	r3, r3, #2
 80099fe:	440b      	add	r3, r1
 8009a00:	685b      	ldr	r3, [r3, #4]
 8009a02:	695b      	ldr	r3, [r3, #20]
 8009a04:	6899      	ldr	r1, [r3, #8]
 8009a06:	9b03      	ldr	r3, [sp, #12]
 8009a08:	440b      	add	r3, r1
 8009a0a:	6093      	str	r3, [r2, #8]
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 8009a0c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009a10:	9a01      	ldr	r2, [sp, #4]
 8009a12:	3302      	adds	r3, #2
 8009a14:	009b      	lsls	r3, r3, #2
 8009a16:	4413      	add	r3, r2
 8009a18:	685b      	ldr	r3, [r3, #4]
 8009a1a:	695a      	ldr	r2, [r3, #20]
 8009a1c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009a20:	9901      	ldr	r1, [sp, #4]
 8009a22:	3302      	adds	r3, #2
 8009a24:	009b      	lsls	r3, r3, #2
 8009a26:	440b      	add	r3, r1
 8009a28:	685b      	ldr	r3, [r3, #4]
 8009a2a:	695b      	ldr	r3, [r3, #20]
 8009a2c:	6859      	ldr	r1, [r3, #4]
 8009a2e:	9b03      	ldr	r3, [sp, #12]
 8009a30:	440b      	add	r3, r1
 8009a32:	6053      	str	r3, [r2, #4]
 8009a34:	e772      	b.n	800991c <otg_txfifo_handler.10874+0xc>
  }
}
 8009a36:	4618      	mov	r0, r3
 8009a38:	b005      	add	sp, #20
 8009a3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8009a3e:	bf00      	nop

08009a40 <otg_epin_handler.10935>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8009a40:	b500      	push	{lr}
 8009a42:	b087      	sub	sp, #28
 8009a44:	9001      	str	r0, [sp, #4]
 8009a46:	460b      	mov	r3, r1
 8009a48:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 8009a4c:	9b01      	ldr	r3, [sp, #4]
 8009a4e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8009a50:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8009a52:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009a56:	9a05      	ldr	r2, [sp, #20]
 8009a58:	015b      	lsls	r3, r3, #5
 8009a5a:	4413      	add	r3, r2
 8009a5c:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8009a60:	681b      	ldr	r3, [r3, #0]
 8009a62:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 8009a64:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009a68:	9a05      	ldr	r2, [sp, #20]
 8009a6a:	015b      	lsls	r3, r3, #5
 8009a6c:	4413      	add	r3, r2
 8009a6e:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8009a72:	9a04      	ldr	r2, [sp, #16]
 8009a74:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8009a76:	9b04      	ldr	r3, [sp, #16]
 8009a78:	f003 0301 	and.w	r3, r3, #1
 8009a7c:	2b00      	cmp	r3, #0
 8009a7e:	d051      	beq.n	8009b24 <otg_epin_handler.10935+0xe4>
 8009a80:	9b05      	ldr	r3, [sp, #20]
 8009a82:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 8009a86:	f003 0301 	and.w	r3, r3, #1
 8009a8a:	2b00      	cmp	r3, #0
 8009a8c:	d04a      	beq.n	8009b24 <otg_epin_handler.10935+0xe4>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8009a8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009a92:	9a01      	ldr	r2, [sp, #4]
 8009a94:	3302      	adds	r3, #2
 8009a96:	009b      	lsls	r3, r3, #2
 8009a98:	4413      	add	r3, r2
 8009a9a:	685b      	ldr	r3, [r3, #4]
 8009a9c:	695b      	ldr	r3, [r3, #20]
 8009a9e:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 8009aa0:	9b03      	ldr	r3, [sp, #12]
 8009aa2:	681a      	ldr	r2, [r3, #0]
 8009aa4:	9b03      	ldr	r3, [sp, #12]
 8009aa6:	68db      	ldr	r3, [r3, #12]
 8009aa8:	429a      	cmp	r2, r3
 8009aaa:	d214      	bcs.n	8009ad6 <otg_epin_handler.10935+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 8009aac:	9b03      	ldr	r3, [sp, #12]
 8009aae:	68da      	ldr	r2, [r3, #12]
 8009ab0:	9b03      	ldr	r3, [sp, #12]
 8009ab2:	681b      	ldr	r3, [r3, #0]
 8009ab4:	1ad2      	subs	r2, r2, r3
 8009ab6:	9b03      	ldr	r3, [sp, #12]
 8009ab8:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 8009aba:	9b03      	ldr	r3, [sp, #12]
 8009abc:	2200      	movs	r2, #0
 8009abe:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8009ac0:	f7ff fd46 	bl	8009550 <osalSysLockFromISR.10566>
      usb_lld_start_in(usbp, ep);
 8009ac4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009ac8:	9801      	ldr	r0, [sp, #4]
 8009aca:	4619      	mov	r1, r3
 8009acc:	f7fe f990 	bl	8007df0 <usb_lld_start_in>
      osalSysUnlockFromISR();
 8009ad0:	f7ff fd46 	bl	8009560 <osalSysUnlockFromISR.10656>
 8009ad4:	e026      	b.n	8009b24 <otg_epin_handler.10935+0xe4>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 8009ad6:	9b01      	ldr	r3, [sp, #4]
 8009ad8:	891b      	ldrh	r3, [r3, #8]
 8009ada:	b29a      	uxth	r2, r3
 8009adc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009ae0:	2101      	movs	r1, #1
 8009ae2:	fa01 f303 	lsl.w	r3, r1, r3
 8009ae6:	b29b      	uxth	r3, r3
 8009ae8:	43db      	mvns	r3, r3
 8009aea:	b29b      	uxth	r3, r3
 8009aec:	4013      	ands	r3, r2
 8009aee:	b29b      	uxth	r3, r3
 8009af0:	b29a      	uxth	r2, r3
 8009af2:	9b01      	ldr	r3, [sp, #4]
 8009af4:	811a      	strh	r2, [r3, #8]
 8009af6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009afa:	9a01      	ldr	r2, [sp, #4]
 8009afc:	3302      	adds	r3, #2
 8009afe:	009b      	lsls	r3, r3, #2
 8009b00:	4413      	add	r3, r2
 8009b02:	685b      	ldr	r3, [r3, #4]
 8009b04:	689b      	ldr	r3, [r3, #8]
 8009b06:	2b00      	cmp	r3, #0
 8009b08:	d00c      	beq.n	8009b24 <otg_epin_handler.10935+0xe4>
 8009b0a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009b0e:	9a01      	ldr	r2, [sp, #4]
 8009b10:	3302      	adds	r3, #2
 8009b12:	009b      	lsls	r3, r3, #2
 8009b14:	4413      	add	r3, r2
 8009b16:	685b      	ldr	r3, [r3, #4]
 8009b18:	689b      	ldr	r3, [r3, #8]
 8009b1a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009b1e:	9801      	ldr	r0, [sp, #4]
 8009b20:	4611      	mov	r1, r2
 8009b22:	4798      	blx	r3
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8009b24:	9b04      	ldr	r3, [sp, #16]
 8009b26:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009b2a:	2b00      	cmp	r3, #0
 8009b2c:	d02b      	beq.n	8009b86 <otg_epin_handler.10935+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8009b2e:	9b05      	ldr	r3, [sp, #20]
 8009b30:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8009b34:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009b38:	2101      	movs	r1, #1
 8009b3a:	fa01 f303 	lsl.w	r3, r1, r3
 8009b3e:	4013      	ands	r3, r2
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8009b40:	2b00      	cmp	r3, #0
 8009b42:	d020      	beq.n	8009b86 <otg_epin_handler.10935+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
 8009b44:	f7ff fd04 	bl	8009550 <osalSysLockFromISR.10566>
    usbp->txpending |= (1 << ep);
 8009b48:	9b01      	ldr	r3, [sp, #4]
 8009b4a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8009b4c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009b50:	2101      	movs	r1, #1
 8009b52:	fa01 f303 	lsl.w	r3, r1, r3
 8009b56:	431a      	orrs	r2, r3
 8009b58:	9b01      	ldr	r3, [sp, #4]
 8009b5a:	675a      	str	r2, [r3, #116]	; 0x74
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8009b5c:	9b05      	ldr	r3, [sp, #20]
 8009b5e:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8009b62:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009b66:	2101      	movs	r1, #1
 8009b68:	fa01 f303 	lsl.w	r3, r1, r3
 8009b6c:	43db      	mvns	r3, r3
 8009b6e:	401a      	ands	r2, r3
 8009b70:	9b05      	ldr	r3, [sp, #20]
 8009b72:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8009b76:	9b01      	ldr	r3, [sp, #4]
 8009b78:	3378      	adds	r3, #120	; 0x78
 8009b7a:	4618      	mov	r0, r3
 8009b7c:	2100      	movs	r1, #0
 8009b7e:	f7ff fd17 	bl	80095b0 <osalThreadResumeI.10568>
    osalSysUnlockFromISR();
 8009b82:	f7ff fced 	bl	8009560 <osalSysUnlockFromISR.10656>
  }
}
 8009b86:	b007      	add	sp, #28
 8009b88:	f85d fb04 	ldr.w	pc, [sp], #4
 8009b8c:	f3af 8000 	nop.w

08009b90 <otg_epout_handler.10927>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8009b90:	b500      	push	{lr}
 8009b92:	b087      	sub	sp, #28
 8009b94:	9001      	str	r0, [sp, #4]
 8009b96:	460b      	mov	r3, r1
 8009b98:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 8009b9c:	9b01      	ldr	r3, [sp, #4]
 8009b9e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8009ba0:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8009ba2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009ba6:	9a05      	ldr	r2, [sp, #20]
 8009ba8:	015b      	lsls	r3, r3, #5
 8009baa:	4413      	add	r3, r2
 8009bac:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8009bb0:	681b      	ldr	r3, [r3, #0]
 8009bb2:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8009bb4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009bb8:	9a05      	ldr	r2, [sp, #20]
 8009bba:	015b      	lsls	r3, r3, #5
 8009bbc:	4413      	add	r3, r2
 8009bbe:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8009bc2:	9a04      	ldr	r2, [sp, #16]
 8009bc4:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8009bc6:	9b04      	ldr	r3, [sp, #16]
 8009bc8:	f003 0308 	and.w	r3, r3, #8
 8009bcc:	2b00      	cmp	r3, #0
 8009bce:	d013      	beq.n	8009bf8 <otg_epout_handler.10927+0x68>
 8009bd0:	9b05      	ldr	r3, [sp, #20]
 8009bd2:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 8009bd6:	f003 0308 	and.w	r3, r3, #8
 8009bda:	2b00      	cmp	r3, #0
 8009bdc:	d00c      	beq.n	8009bf8 <otg_epout_handler.10927+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 8009bde:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009be2:	9a01      	ldr	r2, [sp, #4]
 8009be4:	3302      	adds	r3, #2
 8009be6:	009b      	lsls	r3, r3, #2
 8009be8:	4413      	add	r3, r2
 8009bea:	685b      	ldr	r3, [r3, #4]
 8009bec:	685b      	ldr	r3, [r3, #4]
 8009bee:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009bf2:	9801      	ldr	r0, [sp, #4]
 8009bf4:	4611      	mov	r1, r2
 8009bf6:	4798      	blx	r3

  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8009bf8:	9b04      	ldr	r3, [sp, #16]
 8009bfa:	f003 0301 	and.w	r3, r3, #1
 8009bfe:	2b00      	cmp	r3, #0
 8009c00:	d062      	beq.n	8009cc8 <otg_epout_handler.10927+0x138>
 8009c02:	9b05      	ldr	r3, [sp, #20]
 8009c04:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 8009c08:	f003 0301 	and.w	r3, r3, #1
 8009c0c:	2b00      	cmp	r3, #0
 8009c0e:	d05b      	beq.n	8009cc8 <otg_epout_handler.10927+0x138>
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8009c10:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009c14:	9a01      	ldr	r2, [sp, #4]
 8009c16:	3302      	adds	r3, #2
 8009c18:	009b      	lsls	r3, r3, #2
 8009c1a:	4413      	add	r3, r2
 8009c1c:	685b      	ldr	r3, [r3, #4]
 8009c1e:	699b      	ldr	r3, [r3, #24]
 8009c20:	9303      	str	r3, [sp, #12]

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8009c22:	9b03      	ldr	r3, [sp, #12]
 8009c24:	685a      	ldr	r2, [r3, #4]
 8009c26:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009c2a:	9901      	ldr	r1, [sp, #4]
 8009c2c:	3302      	adds	r3, #2
 8009c2e:	009b      	lsls	r3, r3, #2
 8009c30:	440b      	add	r3, r1
 8009c32:	685b      	ldr	r3, [r3, #4]
 8009c34:	8a5b      	ldrh	r3, [r3, #18]
 8009c36:	fbb2 f1f3 	udiv	r1, r2, r3
 8009c3a:	fb03 f301 	mul.w	r3, r3, r1
 8009c3e:	1ad3      	subs	r3, r2, r3
 8009c40:	2b00      	cmp	r3, #0
 8009c42:	d11a      	bne.n	8009c7a <otg_epout_handler.10927+0xea>
        (osp->rxsize < osp->totsize)) {
 8009c44:	9b03      	ldr	r3, [sp, #12]
 8009c46:	681a      	ldr	r2, [r3, #0]
 8009c48:	9b03      	ldr	r3, [sp, #12]
 8009c4a:	68db      	ldr	r3, [r3, #12]
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8009c4c:	429a      	cmp	r2, r3
 8009c4e:	d214      	bcs.n	8009c7a <otg_epout_handler.10927+0xea>
        (osp->rxsize < osp->totsize)) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8009c50:	9b03      	ldr	r3, [sp, #12]
 8009c52:	68da      	ldr	r2, [r3, #12]
 8009c54:	9b03      	ldr	r3, [sp, #12]
 8009c56:	681b      	ldr	r3, [r3, #0]
 8009c58:	1ad2      	subs	r2, r2, r3
 8009c5a:	9b03      	ldr	r3, [sp, #12]
 8009c5c:	601a      	str	r2, [r3, #0]
      osp->rxcnt  = 0;
 8009c5e:	9b03      	ldr	r3, [sp, #12]
 8009c60:	2200      	movs	r2, #0
 8009c62:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8009c64:	f7ff fc74 	bl	8009550 <osalSysLockFromISR.10566>
      usb_lld_start_out(usbp, ep);
 8009c68:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009c6c:	9801      	ldr	r0, [sp, #4]
 8009c6e:	4619      	mov	r1, r3
 8009c70:	f7fe f81e 	bl	8007cb0 <usb_lld_start_out>
      osalSysUnlockFromISR();
 8009c74:	f7ff fc74 	bl	8009560 <osalSysUnlockFromISR.10656>
 8009c78:	e026      	b.n	8009cc8 <otg_epout_handler.10927+0x138>
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 8009c7a:	9b01      	ldr	r3, [sp, #4]
 8009c7c:	895b      	ldrh	r3, [r3, #10]
 8009c7e:	b29a      	uxth	r2, r3
 8009c80:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009c84:	2101      	movs	r1, #1
 8009c86:	fa01 f303 	lsl.w	r3, r1, r3
 8009c8a:	b29b      	uxth	r3, r3
 8009c8c:	43db      	mvns	r3, r3
 8009c8e:	b29b      	uxth	r3, r3
 8009c90:	4013      	ands	r3, r2
 8009c92:	b29b      	uxth	r3, r3
 8009c94:	b29a      	uxth	r2, r3
 8009c96:	9b01      	ldr	r3, [sp, #4]
 8009c98:	815a      	strh	r2, [r3, #10]
 8009c9a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009c9e:	9a01      	ldr	r2, [sp, #4]
 8009ca0:	3302      	adds	r3, #2
 8009ca2:	009b      	lsls	r3, r3, #2
 8009ca4:	4413      	add	r3, r2
 8009ca6:	685b      	ldr	r3, [r3, #4]
 8009ca8:	68db      	ldr	r3, [r3, #12]
 8009caa:	2b00      	cmp	r3, #0
 8009cac:	d00c      	beq.n	8009cc8 <otg_epout_handler.10927+0x138>
 8009cae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009cb2:	9a01      	ldr	r2, [sp, #4]
 8009cb4:	3302      	adds	r3, #2
 8009cb6:	009b      	lsls	r3, r3, #2
 8009cb8:	4413      	add	r3, r2
 8009cba:	685b      	ldr	r3, [r3, #4]
 8009cbc:	68db      	ldr	r3, [r3, #12]
 8009cbe:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009cc2:	9801      	ldr	r0, [sp, #4]
 8009cc4:	4611      	mov	r1, r2
 8009cc6:	4798      	blx	r3
    }
  }
}
 8009cc8:	b007      	add	sp, #28
 8009cca:	f85d fb04 	ldr.w	pc, [sp], #4
 8009cce:	bf00      	nop

08009cd0 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8009cd0:	b500      	push	{lr}
 8009cd2:	b083      	sub	sp, #12
 8009cd4:	9001      	str	r0, [sp, #4]
 8009cd6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 8009cd8:	f005 fdea 	bl	800f8b0 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 8009cdc:	9b00      	ldr	r3, [sp, #0]
 8009cde:	2b00      	cmp	r3, #0
 8009ce0:	d005      	beq.n	8009cee <obqPostFullBufferS+0x1e>
 8009ce2:	9b01      	ldr	r3, [sp, #4]
 8009ce4:	699b      	ldr	r3, [r3, #24]
 8009ce6:	1f1a      	subs	r2, r3, #4
 8009ce8:	9b00      	ldr	r3, [sp, #0]
 8009cea:	429a      	cmp	r2, r3
 8009cec:	d205      	bcs.n	8009cfa <obqPostFullBufferS+0x2a>
 8009cee:	f641 40b0 	movw	r0, #7344	; 0x1cb0
 8009cf2:	f6c0 0001 	movt	r0, #2049	; 0x801
 8009cf6:	f005 fb4b 	bl	800f390 <chSysHalt>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8009cfa:	9b01      	ldr	r3, [sp, #4]
 8009cfc:	689b      	ldr	r3, [r3, #8]
 8009cfe:	2b00      	cmp	r3, #0
 8009d00:	d105      	bne.n	8009d0e <obqPostFullBufferS+0x3e>
 8009d02:	f641 40b0 	movw	r0, #7344	; 0x1cb0
 8009d06:	f6c0 0001 	movt	r0, #2049	; 0x801
 8009d0a:	f005 fb41 	bl	800f390 <chSysHalt>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8009d0e:	9b01      	ldr	r3, [sp, #4]
 8009d10:	68db      	ldr	r3, [r3, #12]
 8009d12:	9a00      	ldr	r2, [sp, #0]
 8009d14:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 8009d16:	9b01      	ldr	r3, [sp, #4]
 8009d18:	689b      	ldr	r3, [r3, #8]
 8009d1a:	1e5a      	subs	r2, r3, #1
 8009d1c:	9b01      	ldr	r3, [sp, #4]
 8009d1e:	609a      	str	r2, [r3, #8]
  obqp->bwrptr += obqp->bsize;
 8009d20:	9b01      	ldr	r3, [sp, #4]
 8009d22:	68da      	ldr	r2, [r3, #12]
 8009d24:	9b01      	ldr	r3, [sp, #4]
 8009d26:	699b      	ldr	r3, [r3, #24]
 8009d28:	441a      	add	r2, r3
 8009d2a:	9b01      	ldr	r3, [sp, #4]
 8009d2c:	60da      	str	r2, [r3, #12]
  if (obqp->bwrptr >= obqp->btop) {
 8009d2e:	9b01      	ldr	r3, [sp, #4]
 8009d30:	68da      	ldr	r2, [r3, #12]
 8009d32:	9b01      	ldr	r3, [sp, #4]
 8009d34:	695b      	ldr	r3, [r3, #20]
 8009d36:	429a      	cmp	r2, r3
 8009d38:	d303      	bcc.n	8009d42 <obqPostFullBufferS+0x72>
    obqp->bwrptr = obqp->buffers;
 8009d3a:	9b01      	ldr	r3, [sp, #4]
 8009d3c:	6a1a      	ldr	r2, [r3, #32]
 8009d3e:	9b01      	ldr	r3, [sp, #4]
 8009d40:	60da      	str	r2, [r3, #12]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 8009d42:	9b01      	ldr	r3, [sp, #4]
 8009d44:	2200      	movs	r2, #0
 8009d46:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8009d48:	9b01      	ldr	r3, [sp, #4]
 8009d4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009d4c:	2b00      	cmp	r3, #0
 8009d4e:	d003      	beq.n	8009d58 <obqPostFullBufferS+0x88>
    obqp->notify(obqp);
 8009d50:	9b01      	ldr	r3, [sp, #4]
 8009d52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009d54:	9801      	ldr	r0, [sp, #4]
 8009d56:	4798      	blx	r3
  }
}
 8009d58:	b003      	add	sp, #12
 8009d5a:	f85d fb04 	ldr.w	pc, [sp], #4
 8009d5e:	bf00      	nop

08009d60 <obqPutTimeout.4546>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 8009d60:	b500      	push	{lr}
 8009d62:	b087      	sub	sp, #28
 8009d64:	9003      	str	r0, [sp, #12]
 8009d66:	460b      	mov	r3, r1
 8009d68:	9201      	str	r2, [sp, #4]
 8009d6a:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 8009d6e:	f001 ff8f 	bl	800bc90 <osalSysLock.8909>

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 8009d72:	9b03      	ldr	r3, [sp, #12]
 8009d74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009d76:	2b00      	cmp	r3, #0
 8009d78:	d10b      	bne.n	8009d92 <obqPutTimeout.4546+0x32>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8009d7a:	9803      	ldr	r0, [sp, #12]
 8009d7c:	9901      	ldr	r1, [sp, #4]
 8009d7e:	f002 fab7 	bl	800c2f0 <obqGetEmptyBufferTimeoutS>
 8009d82:	9005      	str	r0, [sp, #20]
    if (msg != MSG_OK) {
 8009d84:	9b05      	ldr	r3, [sp, #20]
 8009d86:	2b00      	cmp	r3, #0
 8009d88:	d003      	beq.n	8009d92 <obqPutTimeout.4546+0x32>
      osalSysUnlock();
 8009d8a:	f001 ff89 	bl	800bca0 <osalSysUnlock.8913>
      return msg;
 8009d8e:	9b05      	ldr	r3, [sp, #20]
 8009d90:	e019      	b.n	8009dc6 <obqPutTimeout.4546+0x66>
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8009d92:	9b03      	ldr	r3, [sp, #12]
 8009d94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009d96:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8009d9a:	701a      	strb	r2, [r3, #0]
  obqp->ptr++;
 8009d9c:	9b03      	ldr	r3, [sp, #12]
 8009d9e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009da0:	1c5a      	adds	r2, r3, #1
 8009da2:	9b03      	ldr	r3, [sp, #12]
 8009da4:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8009da6:	9b03      	ldr	r3, [sp, #12]
 8009da8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009daa:	9b03      	ldr	r3, [sp, #12]
 8009dac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009dae:	429a      	cmp	r2, r3
 8009db0:	d306      	bcc.n	8009dc0 <obqPutTimeout.4546+0x60>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8009db2:	9b03      	ldr	r3, [sp, #12]
 8009db4:	699b      	ldr	r3, [r3, #24]
 8009db6:	3b04      	subs	r3, #4
 8009db8:	9803      	ldr	r0, [sp, #12]
 8009dba:	4619      	mov	r1, r3
 8009dbc:	f7ff ff88 	bl	8009cd0 <obqPostFullBufferS>
  }

  osalSysUnlock();
 8009dc0:	f001 ff6e 	bl	800bca0 <osalSysUnlock.8913>
  return MSG_OK;
 8009dc4:	2300      	movs	r3, #0
}
 8009dc6:	4618      	mov	r0, r3
 8009dc8:	b007      	add	sp, #28
 8009dca:	f85d fb04 	ldr.w	pc, [sp], #4
 8009dce:	bf00      	nop

08009dd0 <obqWriteTimeout.4540>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8009dd0:	b500      	push	{lr}
 8009dd2:	b08b      	sub	sp, #44	; 0x2c
 8009dd4:	9003      	str	r0, [sp, #12]
 8009dd6:	9102      	str	r1, [sp, #8]
 8009dd8:	9201      	str	r2, [sp, #4]
 8009dda:	9300      	str	r3, [sp, #0]
  size_t w = 0;
 8009ddc:	2300      	movs	r3, #0
 8009dde:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 8009de0:	f001 ff56 	bl	800bc90 <osalSysLock.8909>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8009de4:	f001 ff64 	bl	800bcb0 <osalOsGetSystemTimeX.8894>
 8009de8:	4602      	mov	r2, r0
 8009dea:	9b00      	ldr	r3, [sp, #0]
 8009dec:	4413      	add	r3, r2
 8009dee:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8009df0:	9b03      	ldr	r3, [sp, #12]
 8009df2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009df4:	2b00      	cmp	r3, #0
 8009df6:	d126      	bne.n	8009e46 <obqWriteTimeout.4540+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8009df8:	9b00      	ldr	r3, [sp, #0]
 8009dfa:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009dfe:	d002      	beq.n	8009e06 <obqWriteTimeout.4540+0x36>
 8009e00:	9b00      	ldr	r3, [sp, #0]
 8009e02:	2b00      	cmp	r3, #0
 8009e04:	d105      	bne.n	8009e12 <obqWriteTimeout.4540+0x42>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8009e06:	9803      	ldr	r0, [sp, #12]
 8009e08:	9900      	ldr	r1, [sp, #0]
 8009e0a:	f002 fa71 	bl	800c2f0 <obqGetEmptyBufferTimeoutS>
 8009e0e:	9007      	str	r0, [sp, #28]
 8009e10:	e012      	b.n	8009e38 <obqWriteTimeout.4540+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8009e12:	f001 ff4d 	bl	800bcb0 <osalOsGetSystemTimeX.8894>
 8009e16:	4603      	mov	r3, r0
 8009e18:	9a06      	ldr	r2, [sp, #24]
 8009e1a:	1ad3      	subs	r3, r2, r3
 8009e1c:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8009e1e:	9a05      	ldr	r2, [sp, #20]
 8009e20:	9b00      	ldr	r3, [sp, #0]
 8009e22:	429a      	cmp	r2, r3
 8009e24:	d903      	bls.n	8009e2e <obqWriteTimeout.4540+0x5e>
          osalSysUnlock();
 8009e26:	f001 ff3b 	bl	800bca0 <osalSysUnlock.8913>
          return w;
 8009e2a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009e2c:	e060      	b.n	8009ef0 <obqWriteTimeout.4540+0x120>
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 8009e2e:	9803      	ldr	r0, [sp, #12]
 8009e30:	9905      	ldr	r1, [sp, #20]
 8009e32:	f002 fa5d 	bl	800c2f0 <obqGetEmptyBufferTimeoutS>
 8009e36:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8009e38:	9b07      	ldr	r3, [sp, #28]
 8009e3a:	2b00      	cmp	r3, #0
 8009e3c:	d003      	beq.n	8009e46 <obqWriteTimeout.4540+0x76>
        osalSysUnlock();
 8009e3e:	f001 ff2f 	bl	800bca0 <osalSysUnlock.8913>
        return w;
 8009e42:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009e44:	e054      	b.n	8009ef0 <obqWriteTimeout.4540+0x120>
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8009e46:	9b03      	ldr	r3, [sp, #12]
 8009e48:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009e4a:	461a      	mov	r2, r3
 8009e4c:	9b03      	ldr	r3, [sp, #12]
 8009e4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009e50:	1ad3      	subs	r3, r2, r3
 8009e52:	9308      	str	r3, [sp, #32]
    if (size > (n - w)) {
 8009e54:	9a01      	ldr	r2, [sp, #4]
 8009e56:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009e58:	1ad2      	subs	r2, r2, r3
 8009e5a:	9b08      	ldr	r3, [sp, #32]
 8009e5c:	429a      	cmp	r2, r3
 8009e5e:	d203      	bcs.n	8009e68 <obqWriteTimeout.4540+0x98>
      size = n - w;
 8009e60:	9a01      	ldr	r2, [sp, #4]
 8009e62:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009e64:	1ad3      	subs	r3, r2, r3
 8009e66:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8009e68:	9b08      	ldr	r3, [sp, #32]
 8009e6a:	2b40      	cmp	r3, #64	; 0x40
 8009e6c:	d913      	bls.n	8009e96 <obqWriteTimeout.4540+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 8009e6e:	9b03      	ldr	r3, [sp, #12]
 8009e70:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009e72:	4618      	mov	r0, r3
 8009e74:	9902      	ldr	r1, [sp, #8]
 8009e76:	2240      	movs	r2, #64	; 0x40
 8009e78:	f7f6 fa4a 	bl	8000310 <memcpy>
      bp        += 64U;
 8009e7c:	9b02      	ldr	r3, [sp, #8]
 8009e7e:	3340      	adds	r3, #64	; 0x40
 8009e80:	9302      	str	r3, [sp, #8]
      obqp->ptr += 64U;
 8009e82:	9b03      	ldr	r3, [sp, #12]
 8009e84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009e86:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8009e8a:	9b03      	ldr	r3, [sp, #12]
 8009e8c:	625a      	str	r2, [r3, #36]	; 0x24
      w         += 64U;
 8009e8e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009e90:	3340      	adds	r3, #64	; 0x40
 8009e92:	9309      	str	r3, [sp, #36]	; 0x24
 8009e94:	e014      	b.n	8009ec0 <obqWriteTimeout.4540+0xf0>
    }
    else {
      memcpy(obqp->ptr, bp, size);
 8009e96:	9b03      	ldr	r3, [sp, #12]
 8009e98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009e9a:	4618      	mov	r0, r3
 8009e9c:	9902      	ldr	r1, [sp, #8]
 8009e9e:	9a08      	ldr	r2, [sp, #32]
 8009ea0:	f7f6 fa36 	bl	8000310 <memcpy>
      bp        += size;
 8009ea4:	9a02      	ldr	r2, [sp, #8]
 8009ea6:	9b08      	ldr	r3, [sp, #32]
 8009ea8:	4413      	add	r3, r2
 8009eaa:	9302      	str	r3, [sp, #8]
      obqp->ptr += size;
 8009eac:	9b03      	ldr	r3, [sp, #12]
 8009eae:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009eb0:	9b08      	ldr	r3, [sp, #32]
 8009eb2:	441a      	add	r2, r3
 8009eb4:	9b03      	ldr	r3, [sp, #12]
 8009eb6:	625a      	str	r2, [r3, #36]	; 0x24
      w         += size;
 8009eb8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009eba:	9b08      	ldr	r3, [sp, #32]
 8009ebc:	4413      	add	r3, r2
 8009ebe:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8009ec0:	9b03      	ldr	r3, [sp, #12]
 8009ec2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009ec4:	9b03      	ldr	r3, [sp, #12]
 8009ec6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009ec8:	429a      	cmp	r2, r3
 8009eca:	d306      	bcc.n	8009eda <obqWriteTimeout.4540+0x10a>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8009ecc:	9b03      	ldr	r3, [sp, #12]
 8009ece:	699b      	ldr	r3, [r3, #24]
 8009ed0:	3b04      	subs	r3, #4
 8009ed2:	9803      	ldr	r0, [sp, #12]
 8009ed4:	4619      	mov	r1, r3
 8009ed6:	f7ff fefb 	bl	8009cd0 <obqPostFullBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 8009eda:	f001 fee1 	bl	800bca0 <osalSysUnlock.8913>
    if (w >= n) {
 8009ede:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009ee0:	9b01      	ldr	r3, [sp, #4]
 8009ee2:	429a      	cmp	r2, r3
 8009ee4:	d301      	bcc.n	8009eea <obqWriteTimeout.4540+0x11a>
      return w;
 8009ee6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009ee8:	e002      	b.n	8009ef0 <obqWriteTimeout.4540+0x120>
    }
    osalSysLock();
 8009eea:	f001 fed1 	bl	800bc90 <osalSysLock.8909>
 8009eee:	e77f      	b.n	8009df0 <obqWriteTimeout.4540+0x20>
  }
}
 8009ef0:	4618      	mov	r0, r3
 8009ef2:	b00b      	add	sp, #44	; 0x2c
 8009ef4:	f85d fb04 	ldr.w	pc, [sp], #4
 8009ef8:	f3af 8000 	nop.w
 8009efc:	f3af 8000 	nop.w

08009f00 <obqTryFlushI.4537>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 8009f00:	b500      	push	{lr}
 8009f02:	b085      	sub	sp, #20
 8009f04:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8009f06:	f005 fcbb 	bl	800f880 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8009f0a:	9b01      	ldr	r3, [sp, #4]
 8009f0c:	68da      	ldr	r2, [r3, #12]
 8009f0e:	9b01      	ldr	r3, [sp, #4]
 8009f10:	691b      	ldr	r3, [r3, #16]
 8009f12:	429a      	cmp	r2, r3
 8009f14:	d105      	bne.n	8009f22 <obqTryFlushI.4537+0x22>
 8009f16:	9b01      	ldr	r3, [sp, #4]
 8009f18:	689b      	ldr	r3, [r3, #8]
 8009f1a:	2b00      	cmp	r3, #0
 8009f1c:	d001      	beq.n	8009f22 <obqTryFlushI.4537+0x22>
 8009f1e:	2301      	movs	r3, #1
 8009f20:	e000      	b.n	8009f24 <obqTryFlushI.4537+0x24>
 8009f22:	2300      	movs	r3, #0
 8009f24:	f003 0301 	and.w	r3, r3, #1
 8009f28:	b2db      	uxtb	r3, r3
 8009f2a:	2b00      	cmp	r3, #0
 8009f2c:	d02d      	beq.n	8009f8a <obqTryFlushI.4537+0x8a>
 8009f2e:	9b01      	ldr	r3, [sp, #4]
 8009f30:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009f32:	2b00      	cmp	r3, #0
 8009f34:	d029      	beq.n	8009f8a <obqTryFlushI.4537+0x8a>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 8009f36:	9b01      	ldr	r3, [sp, #4]
 8009f38:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009f3a:	461a      	mov	r2, r3
 8009f3c:	9b01      	ldr	r3, [sp, #4]
 8009f3e:	68db      	ldr	r3, [r3, #12]
 8009f40:	1ad3      	subs	r3, r2, r3
 8009f42:	3b04      	subs	r3, #4
 8009f44:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 8009f46:	9b03      	ldr	r3, [sp, #12]
 8009f48:	2b00      	cmp	r3, #0
 8009f4a:	d01e      	beq.n	8009f8a <obqTryFlushI.4537+0x8a>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 8009f4c:	9b01      	ldr	r3, [sp, #4]
 8009f4e:	68db      	ldr	r3, [r3, #12]
 8009f50:	9a03      	ldr	r2, [sp, #12]
 8009f52:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8009f54:	9b01      	ldr	r3, [sp, #4]
 8009f56:	689b      	ldr	r3, [r3, #8]
 8009f58:	1e5a      	subs	r2, r3, #1
 8009f5a:	9b01      	ldr	r3, [sp, #4]
 8009f5c:	609a      	str	r2, [r3, #8]
      obqp->bwrptr += obqp->bsize;
 8009f5e:	9b01      	ldr	r3, [sp, #4]
 8009f60:	68da      	ldr	r2, [r3, #12]
 8009f62:	9b01      	ldr	r3, [sp, #4]
 8009f64:	699b      	ldr	r3, [r3, #24]
 8009f66:	441a      	add	r2, r3
 8009f68:	9b01      	ldr	r3, [sp, #4]
 8009f6a:	60da      	str	r2, [r3, #12]
      if (obqp->bwrptr >= obqp->btop) {
 8009f6c:	9b01      	ldr	r3, [sp, #4]
 8009f6e:	68da      	ldr	r2, [r3, #12]
 8009f70:	9b01      	ldr	r3, [sp, #4]
 8009f72:	695b      	ldr	r3, [r3, #20]
 8009f74:	429a      	cmp	r2, r3
 8009f76:	d303      	bcc.n	8009f80 <obqTryFlushI.4537+0x80>
        obqp->bwrptr = obqp->buffers;
 8009f78:	9b01      	ldr	r3, [sp, #4]
 8009f7a:	6a1a      	ldr	r2, [r3, #32]
 8009f7c:	9b01      	ldr	r3, [sp, #4]
 8009f7e:	60da      	str	r2, [r3, #12]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 8009f80:	9b01      	ldr	r3, [sp, #4]
 8009f82:	2200      	movs	r2, #0
 8009f84:	625a      	str	r2, [r3, #36]	; 0x24

      return true;
 8009f86:	2301      	movs	r3, #1
 8009f88:	e000      	b.n	8009f8c <obqTryFlushI.4537+0x8c>
    }
  }
  return false;
 8009f8a:	2300      	movs	r3, #0
}
 8009f8c:	4618      	mov	r0, r3
 8009f8e:	b005      	add	sp, #20
 8009f90:	f85d fb04 	ldr.w	pc, [sp], #4
 8009f94:	f3af 8000 	nop.w
 8009f98:	f3af 8000 	nop.w
 8009f9c:	f3af 8000 	nop.w

08009fa0 <port_lock.9201.4492>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009fa0:	b082      	sub	sp, #8
 8009fa2:	2320      	movs	r3, #32
 8009fa4:	9301      	str	r3, [sp, #4]
 8009fa6:	9b01      	ldr	r3, [sp, #4]
 8009fa8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009fac:	b002      	add	sp, #8
 8009fae:	4770      	bx	lr

08009fb0 <port_unlock.9204.4490>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8009fb0:	b082      	sub	sp, #8
 8009fb2:	2300      	movs	r3, #0
 8009fb4:	9301      	str	r3, [sp, #4]
 8009fb6:	9b01      	ldr	r3, [sp, #4]
 8009fb8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009fbc:	b002      	add	sp, #8
 8009fbe:	4770      	bx	lr

08009fc0 <port_lock_from_isr.9206.4488>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8009fc0:	b508      	push	{r3, lr}

  port_lock();
 8009fc2:	f7ff ffed 	bl	8009fa0 <port_lock.9201.4492>
}
 8009fc6:	bd08      	pop	{r3, pc}
 8009fc8:	f3af 8000 	nop.w
 8009fcc:	f3af 8000 	nop.w

08009fd0 <port_unlock_from_isr.9208.4486>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8009fd0:	b508      	push	{r3, lr}

  port_unlock();
 8009fd2:	f7ff ffed 	bl	8009fb0 <port_unlock.9204.4490>
}
 8009fd6:	bd08      	pop	{r3, pc}
 8009fd8:	f3af 8000 	nop.w
 8009fdc:	f3af 8000 	nop.w

08009fe0 <chSysLock.9374.4484>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8009fe0:	b508      	push	{r3, lr}

  port_lock();
 8009fe2:	f7ff ffdd 	bl	8009fa0 <port_lock.9201.4492>
  _stats_start_measure_crit_thd();
 8009fe6:	f003 ffcb 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8009fea:	f005 fb79 	bl	800f6e0 <_dbg_check_lock>
}
 8009fee:	bd08      	pop	{r3, pc}

08009ff0 <chSysUnlock.9378.4482>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8009ff0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8009ff2:	f005 fb95 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8009ff6:	f003 ffcb 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8009ffa:	f640 5350 	movw	r3, #3408	; 0xd50
 8009ffe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a002:	681a      	ldr	r2, [r3, #0]
 800a004:	f640 5350 	movw	r3, #3408	; 0xd50
 800a008:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a00c:	429a      	cmp	r2, r3
 800a00e:	d013      	beq.n	800a038 <chSysUnlock.9378.4482+0x48>
 800a010:	f640 5350 	movw	r3, #3408	; 0xd50
 800a014:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a018:	699b      	ldr	r3, [r3, #24]
 800a01a:	689a      	ldr	r2, [r3, #8]
 800a01c:	f640 5350 	movw	r3, #3408	; 0xd50
 800a020:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a024:	681b      	ldr	r3, [r3, #0]
 800a026:	689b      	ldr	r3, [r3, #8]
 800a028:	429a      	cmp	r2, r3
 800a02a:	d205      	bcs.n	800a038 <chSysUnlock.9378.4482+0x48>
 800a02c:	f641 5000 	movw	r0, #7424	; 0x1d00
 800a030:	f6c0 0001 	movt	r0, #2049	; 0x801
 800a034:	f005 f9ac 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800a038:	f7ff ffba 	bl	8009fb0 <port_unlock.9204.4490>
}
 800a03c:	bd08      	pop	{r3, pc}
 800a03e:	bf00      	nop

0800a040 <chSysLockFromISR.9388.4480>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800a040:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800a042:	f7ff ffbd 	bl	8009fc0 <port_lock_from_isr.9206.4488>
  _stats_start_measure_crit_isr();
 800a046:	f003 ffab 	bl	800dfa0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800a04a:	f005 fb89 	bl	800f760 <_dbg_check_lock_from_isr>
}
 800a04e:	bd08      	pop	{r3, pc}

0800a050 <chSysUnlockFromISR.9392.4478>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800a050:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 800a052:	f005 fba5 	bl	800f7a0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 800a056:	f003 ffab 	bl	800dfb0 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800a05a:	f7ff ffb9 	bl	8009fd0 <port_unlock_from_isr.9208.4486>
}
 800a05e:	bd08      	pop	{r3, pc}

0800a060 <chEvtObjectInit.9210.4475>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 800a060:	b082      	sub	sp, #8
 800a062:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 800a064:	9b01      	ldr	r3, [sp, #4]
 800a066:	9a01      	ldr	r2, [sp, #4]
 800a068:	601a      	str	r2, [r3, #0]
}
 800a06a:	b002      	add	sp, #8
 800a06c:	4770      	bx	lr
 800a06e:	bf00      	nop

0800a070 <osalSysLock.9376.4473>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 800a070:	b508      	push	{r3, lr}

  chSysLock();
 800a072:	f7ff ffb5 	bl	8009fe0 <chSysLock.9374.4484>
}
 800a076:	bd08      	pop	{r3, pc}
 800a078:	f3af 8000 	nop.w
 800a07c:	f3af 8000 	nop.w

0800a080 <osalSysUnlock.9380.4471>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 800a080:	b508      	push	{r3, lr}

  chSysUnlock();
 800a082:	f7ff ffb5 	bl	8009ff0 <chSysUnlock.9378.4482>
}
 800a086:	bd08      	pop	{r3, pc}
 800a088:	f3af 8000 	nop.w
 800a08c:	f3af 8000 	nop.w

0800a090 <osalSysLockFromISR.9390.4469>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800a090:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800a092:	f7ff ffd5 	bl	800a040 <chSysLockFromISR.9388.4480>
}
 800a096:	bd08      	pop	{r3, pc}
 800a098:	f3af 8000 	nop.w
 800a09c:	f3af 8000 	nop.w

0800a0a0 <osalSysUnlockFromISR.9394.4467>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800a0a0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800a0a2:	f7ff ffd5 	bl	800a050 <chSysUnlockFromISR.9392.4478>
}
 800a0a6:	bd08      	pop	{r3, pc}
 800a0a8:	f3af 8000 	nop.w
 800a0ac:	f3af 8000 	nop.w

0800a0b0 <osalEventObjectInit.9310.4462>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 800a0b0:	b500      	push	{lr}
 800a0b2:	b083      	sub	sp, #12
 800a0b4:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 800a0b6:	9801      	ldr	r0, [sp, #4]
 800a0b8:	f7ff ffd2 	bl	800a060 <chEvtObjectInit.9210.4475>
}
 800a0bc:	b003      	add	sp, #12
 800a0be:	f85d fb04 	ldr.w	pc, [sp], #4
 800a0c2:	bf00      	nop
 800a0c4:	f3af 8000 	nop.w
 800a0c8:	f3af 8000 	nop.w
 800a0cc:	f3af 8000 	nop.w

0800a0d0 <osalEventBroadcastFlagsI.9384.4458>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 800a0d0:	b500      	push	{lr}
 800a0d2:	b083      	sub	sp, #12
 800a0d4:	9001      	str	r0, [sp, #4]
 800a0d6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 800a0d8:	9801      	ldr	r0, [sp, #4]
 800a0da:	9900      	ldr	r1, [sp, #0]
 800a0dc:	f002 fd98 	bl	800cc10 <chEvtBroadcastFlagsI>
}
 800a0e0:	b003      	add	sp, #12
 800a0e2:	f85d fb04 	ldr.w	pc, [sp], #4
 800a0e6:	bf00      	nop
 800a0e8:	f3af 8000 	nop.w
 800a0ec:	f3af 8000 	nop.w

0800a0f0 <write.9313>:

/*
 * Interface implementation.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 800a0f0:	b500      	push	{lr}
 800a0f2:	b085      	sub	sp, #20
 800a0f4:	9003      	str	r0, [sp, #12]
 800a0f6:	9102      	str	r1, [sp, #8]
 800a0f8:	9201      	str	r2, [sp, #4]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800a0fa:	9b03      	ldr	r3, [sp, #12]
 800a0fc:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a100:	681b      	ldr	r3, [r3, #0]
 800a102:	781b      	ldrb	r3, [r3, #0]
 800a104:	2b04      	cmp	r3, #4
 800a106:	d001      	beq.n	800a10c <write.9313+0x1c>
    return 0;
 800a108:	2300      	movs	r3, #0
 800a10a:	e009      	b.n	800a120 <write.9313+0x30>
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 800a10c:	9b03      	ldr	r3, [sp, #12]
 800a10e:	3340      	adds	r3, #64	; 0x40
 800a110:	4618      	mov	r0, r3
 800a112:	9902      	ldr	r1, [sp, #8]
 800a114:	9a01      	ldr	r2, [sp, #4]
 800a116:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800a11a:	f7ff fe59 	bl	8009dd0 <obqWriteTimeout.4540>
 800a11e:	4603      	mov	r3, r0
                         n, TIME_INFINITE);
}
 800a120:	4618      	mov	r0, r3
 800a122:	b005      	add	sp, #20
 800a124:	f85d fb04 	ldr.w	pc, [sp], #4
 800a128:	f3af 8000 	nop.w
 800a12c:	f3af 8000 	nop.w

0800a130 <read.9326>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 800a130:	b500      	push	{lr}
 800a132:	b085      	sub	sp, #20
 800a134:	9003      	str	r0, [sp, #12]
 800a136:	9102      	str	r1, [sp, #8]
 800a138:	9201      	str	r2, [sp, #4]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800a13a:	9b03      	ldr	r3, [sp, #12]
 800a13c:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a140:	681b      	ldr	r3, [r3, #0]
 800a142:	781b      	ldrb	r3, [r3, #0]
 800a144:	2b04      	cmp	r3, #4
 800a146:	d001      	beq.n	800a14c <read.9326+0x1c>
    return 0;
 800a148:	2300      	movs	r3, #0
 800a14a:	e009      	b.n	800a160 <read.9326+0x30>
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 800a14c:	9b03      	ldr	r3, [sp, #12]
 800a14e:	330c      	adds	r3, #12
 800a150:	4618      	mov	r0, r3
 800a152:	9902      	ldr	r1, [sp, #8]
 800a154:	9a01      	ldr	r2, [sp, #4]
 800a156:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800a15a:	f001 ff69 	bl	800c030 <ibqReadTimeout>
 800a15e:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800a160:	4618      	mov	r0, r3
 800a162:	b005      	add	sp, #20
 800a164:	f85d fb04 	ldr.w	pc, [sp], #4
 800a168:	f3af 8000 	nop.w
 800a16c:	f3af 8000 	nop.w

0800a170 <put.9337>:

static msg_t put(void *ip, uint8_t b) {
 800a170:	b500      	push	{lr}
 800a172:	b083      	sub	sp, #12
 800a174:	9001      	str	r0, [sp, #4]
 800a176:	460b      	mov	r3, r1
 800a178:	f88d 3003 	strb.w	r3, [sp, #3]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800a17c:	9b01      	ldr	r3, [sp, #4]
 800a17e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a182:	681b      	ldr	r3, [r3, #0]
 800a184:	781b      	ldrb	r3, [r3, #0]
 800a186:	2b04      	cmp	r3, #4
 800a188:	d002      	beq.n	800a190 <put.9337+0x20>
    return MSG_RESET;
 800a18a:	f06f 0301 	mvn.w	r3, #1
 800a18e:	e00b      	b.n	800a1a8 <put.9337+0x38>
  }

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 800a190:	9b01      	ldr	r3, [sp, #4]
 800a192:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800a196:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a19a:	4610      	mov	r0, r2
 800a19c:	4619      	mov	r1, r3
 800a19e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800a1a2:	f7ff fddd 	bl	8009d60 <obqPutTimeout.4546>
 800a1a6:	4603      	mov	r3, r0
}
 800a1a8:	4618      	mov	r0, r3
 800a1aa:	b003      	add	sp, #12
 800a1ac:	f85d fb04 	ldr.w	pc, [sp], #4

0800a1b0 <get.9346>:

static msg_t get(void *ip) {
 800a1b0:	b500      	push	{lr}
 800a1b2:	b083      	sub	sp, #12
 800a1b4:	9001      	str	r0, [sp, #4]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800a1b6:	9b01      	ldr	r3, [sp, #4]
 800a1b8:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a1bc:	681b      	ldr	r3, [r3, #0]
 800a1be:	781b      	ldrb	r3, [r3, #0]
 800a1c0:	2b04      	cmp	r3, #4
 800a1c2:	d002      	beq.n	800a1ca <get.9346+0x1a>
    return MSG_RESET;
 800a1c4:	f06f 0301 	mvn.w	r3, #1
 800a1c8:	e007      	b.n	800a1da <get.9346+0x2a>
  }

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 800a1ca:	9b01      	ldr	r3, [sp, #4]
 800a1cc:	330c      	adds	r3, #12
 800a1ce:	4618      	mov	r0, r3
 800a1d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800a1d4:	f001 fefc 	bl	800bfd0 <ibqGetTimeout>
 800a1d8:	4603      	mov	r3, r0
}
 800a1da:	4618      	mov	r0, r3
 800a1dc:	b003      	add	sp, #12
 800a1de:	f85d fb04 	ldr.w	pc, [sp], #4
 800a1e2:	bf00      	nop
 800a1e4:	f3af 8000 	nop.w
 800a1e8:	f3af 8000 	nop.w
 800a1ec:	f3af 8000 	nop.w

0800a1f0 <putt.9341>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 800a1f0:	b500      	push	{lr}
 800a1f2:	b085      	sub	sp, #20
 800a1f4:	9003      	str	r0, [sp, #12]
 800a1f6:	460b      	mov	r3, r1
 800a1f8:	9201      	str	r2, [sp, #4]
 800a1fa:	f88d 300b 	strb.w	r3, [sp, #11]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800a1fe:	9b03      	ldr	r3, [sp, #12]
 800a200:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a204:	681b      	ldr	r3, [r3, #0]
 800a206:	781b      	ldrb	r3, [r3, #0]
 800a208:	2b04      	cmp	r3, #4
 800a20a:	d002      	beq.n	800a212 <putt.9341+0x22>
    return MSG_RESET;
 800a20c:	f06f 0301 	mvn.w	r3, #1
 800a210:	e00a      	b.n	800a228 <putt.9341+0x38>
  }

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 800a212:	9b03      	ldr	r3, [sp, #12]
 800a214:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800a218:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800a21c:	4610      	mov	r0, r2
 800a21e:	4619      	mov	r1, r3
 800a220:	9a01      	ldr	r2, [sp, #4]
 800a222:	f7ff fd9d 	bl	8009d60 <obqPutTimeout.4546>
 800a226:	4603      	mov	r3, r0
}
 800a228:	4618      	mov	r0, r3
 800a22a:	b005      	add	sp, #20
 800a22c:	f85d fb04 	ldr.w	pc, [sp], #4

0800a230 <gett.9349>:

static msg_t gett(void *ip, systime_t timeout) {
 800a230:	b500      	push	{lr}
 800a232:	b083      	sub	sp, #12
 800a234:	9001      	str	r0, [sp, #4]
 800a236:	9100      	str	r1, [sp, #0]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800a238:	9b01      	ldr	r3, [sp, #4]
 800a23a:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a23e:	681b      	ldr	r3, [r3, #0]
 800a240:	781b      	ldrb	r3, [r3, #0]
 800a242:	2b04      	cmp	r3, #4
 800a244:	d002      	beq.n	800a24c <gett.9349+0x1c>
    return MSG_RESET;
 800a246:	f06f 0301 	mvn.w	r3, #1
 800a24a:	e006      	b.n	800a25a <gett.9349+0x2a>
  }

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 800a24c:	9b01      	ldr	r3, [sp, #4]
 800a24e:	330c      	adds	r3, #12
 800a250:	4618      	mov	r0, r3
 800a252:	9900      	ldr	r1, [sp, #0]
 800a254:	f001 febc 	bl	800bfd0 <ibqGetTimeout>
 800a258:	4603      	mov	r3, r0
}
 800a25a:	4618      	mov	r0, r3
 800a25c:	b003      	add	sp, #12
 800a25e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a262:	bf00      	nop
 800a264:	f3af 8000 	nop.w
 800a268:	f3af 8000 	nop.w
 800a26c:	f3af 8000 	nop.w

0800a270 <writet.9319>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 800a270:	b500      	push	{lr}
 800a272:	b085      	sub	sp, #20
 800a274:	9003      	str	r0, [sp, #12]
 800a276:	9102      	str	r1, [sp, #8]
 800a278:	9201      	str	r2, [sp, #4]
 800a27a:	9300      	str	r3, [sp, #0]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800a27c:	9b03      	ldr	r3, [sp, #12]
 800a27e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a282:	681b      	ldr	r3, [r3, #0]
 800a284:	781b      	ldrb	r3, [r3, #0]
 800a286:	2b04      	cmp	r3, #4
 800a288:	d001      	beq.n	800a28e <writet.9319+0x1e>
    return 0;
 800a28a:	2300      	movs	r3, #0
 800a28c:	e008      	b.n	800a2a0 <writet.9319+0x30>
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 800a28e:	9b03      	ldr	r3, [sp, #12]
 800a290:	3340      	adds	r3, #64	; 0x40
 800a292:	4618      	mov	r0, r3
 800a294:	9902      	ldr	r1, [sp, #8]
 800a296:	9a01      	ldr	r2, [sp, #4]
 800a298:	9b00      	ldr	r3, [sp, #0]
 800a29a:	f7ff fd99 	bl	8009dd0 <obqWriteTimeout.4540>
 800a29e:	4603      	mov	r3, r0
}
 800a2a0:	4618      	mov	r0, r3
 800a2a2:	b005      	add	sp, #20
 800a2a4:	f85d fb04 	ldr.w	pc, [sp], #4
 800a2a8:	f3af 8000 	nop.w
 800a2ac:	f3af 8000 	nop.w

0800a2b0 <readt.9331>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 800a2b0:	b500      	push	{lr}
 800a2b2:	b085      	sub	sp, #20
 800a2b4:	9003      	str	r0, [sp, #12]
 800a2b6:	9102      	str	r1, [sp, #8]
 800a2b8:	9201      	str	r2, [sp, #4]
 800a2ba:	9300      	str	r3, [sp, #0]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 800a2bc:	9b03      	ldr	r3, [sp, #12]
 800a2be:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a2c2:	681b      	ldr	r3, [r3, #0]
 800a2c4:	781b      	ldrb	r3, [r3, #0]
 800a2c6:	2b04      	cmp	r3, #4
 800a2c8:	d001      	beq.n	800a2ce <readt.9331+0x1e>
    return 0;
 800a2ca:	2300      	movs	r3, #0
 800a2cc:	e008      	b.n	800a2e0 <readt.9331+0x30>
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 800a2ce:	9b03      	ldr	r3, [sp, #12]
 800a2d0:	330c      	adds	r3, #12
 800a2d2:	4618      	mov	r0, r3
 800a2d4:	9902      	ldr	r1, [sp, #8]
 800a2d6:	9a01      	ldr	r2, [sp, #4]
 800a2d8:	9b00      	ldr	r3, [sp, #0]
 800a2da:	f001 fea9 	bl	800c030 <ibqReadTimeout>
 800a2de:	4603      	mov	r3, r0
}
 800a2e0:	4618      	mov	r0, r3
 800a2e2:	b005      	add	sp, #20
 800a2e4:	f85d fb04 	ldr.w	pc, [sp], #4
 800a2e8:	f3af 8000 	nop.w
 800a2ec:	f3af 8000 	nop.w

0800a2f0 <ibnotify.9353.4412>:
/**
 * @brief   Notification of empty buffer released into the input buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void ibnotify(io_buffers_queue_t *bqp) {
 800a2f0:	b500      	push	{lr}
 800a2f2:	b085      	sub	sp, #20
 800a2f4:	9001      	str	r0, [sp, #4]
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 800a2f6:	9b01      	ldr	r3, [sp, #4]
 800a2f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a2fa:	9303      	str	r3, [sp, #12]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a2fc:	9b03      	ldr	r3, [sp, #12]
 800a2fe:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a302:	681b      	ldr	r3, [r3, #0]
 800a304:	781b      	ldrb	r3, [r3, #0]
 800a306:	2b04      	cmp	r3, #4
 800a308:	d12c      	bne.n	800a364 <ibnotify.9353.4412+0x74>
      (sdup->state != SDU_READY)) {
 800a30a:	9b03      	ldr	r3, [sp, #12]
 800a30c:	7a1b      	ldrb	r3, [r3, #8]
static void ibnotify(io_buffers_queue_t *bqp) {
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a30e:	2b02      	cmp	r3, #2
 800a310:	d128      	bne.n	800a364 <ibnotify.9353.4412+0x74>
      (sdup->state != SDU_READY)) {
    return;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 800a312:	9b03      	ldr	r3, [sp, #12]
 800a314:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a318:	681b      	ldr	r3, [r3, #0]
 800a31a:	895a      	ldrh	r2, [r3, #10]
 800a31c:	9b03      	ldr	r3, [sp, #12]
 800a31e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a322:	795b      	ldrb	r3, [r3, #5]
 800a324:	2101      	movs	r1, #1
 800a326:	fa01 f303 	lsl.w	r3, r1, r3
 800a32a:	b29b      	uxth	r3, r3
 800a32c:	4013      	ands	r3, r2
 800a32e:	b29b      	uxth	r3, r3
 800a330:	2b00      	cmp	r3, #0
 800a332:	d117      	bne.n	800a364 <ibnotify.9353.4412+0x74>
    /* Trying to get a free buffer.*/
    uint8_t *buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 800a334:	9b03      	ldr	r3, [sp, #12]
 800a336:	330c      	adds	r3, #12
 800a338:	4618      	mov	r0, r3
 800a33a:	f001 fd69 	bl	800be10 <ibqGetEmptyBufferI>
 800a33e:	9002      	str	r0, [sp, #8]
    if (buf != NULL) {
 800a340:	9b02      	ldr	r3, [sp, #8]
 800a342:	2b00      	cmp	r3, #0
 800a344:	d00e      	beq.n	800a364 <ibnotify.9353.4412+0x74>
      /* Buffer found, starting a new transaction.*/
      usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 800a346:	9b03      	ldr	r3, [sp, #12]
 800a348:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a34c:	681a      	ldr	r2, [r3, #0]
 800a34e:	9b03      	ldr	r3, [sp, #12]
 800a350:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a354:	795b      	ldrb	r3, [r3, #5]
 800a356:	4610      	mov	r0, r2
 800a358:	4619      	mov	r1, r3
 800a35a:	9a02      	ldr	r2, [sp, #8]
 800a35c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800a360:	f7fe fac6 	bl	80088f0 <usbStartReceiveI>
                       buf, SERIAL_USB_BUFFERS_SIZE);
    }
  }
}
 800a364:	b005      	add	sp, #20
 800a366:	f85d fb04 	ldr.w	pc, [sp], #4
 800a36a:	bf00      	nop
 800a36c:	f3af 8000 	nop.w

0800a370 <obnotify.9371.4415>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 800a370:	b500      	push	{lr}
 800a372:	b087      	sub	sp, #28
 800a374:	9001      	str	r0, [sp, #4]
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 800a376:	9b01      	ldr	r3, [sp, #4]
 800a378:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a37a:	9305      	str	r3, [sp, #20]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a37c:	9b05      	ldr	r3, [sp, #20]
 800a37e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a382:	681b      	ldr	r3, [r3, #0]
 800a384:	781b      	ldrb	r3, [r3, #0]
 800a386:	2b04      	cmp	r3, #4
 800a388:	d12f      	bne.n	800a3ea <obnotify.9371.4415+0x7a>
      (sdup->state != SDU_READY)) {
 800a38a:	9b05      	ldr	r3, [sp, #20]
 800a38c:	7a1b      	ldrb	r3, [r3, #8]
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a38e:	2b02      	cmp	r3, #2
 800a390:	d12b      	bne.n	800a3ea <obnotify.9371.4415+0x7a>
      (sdup->state != SDU_READY)) {
    return;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800a392:	9b05      	ldr	r3, [sp, #20]
 800a394:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a398:	681b      	ldr	r3, [r3, #0]
 800a39a:	891a      	ldrh	r2, [r3, #8]
 800a39c:	9b05      	ldr	r3, [sp, #20]
 800a39e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a3a2:	791b      	ldrb	r3, [r3, #4]
 800a3a4:	2101      	movs	r1, #1
 800a3a6:	fa01 f303 	lsl.w	r3, r1, r3
 800a3aa:	b29b      	uxth	r3, r3
 800a3ac:	4013      	ands	r3, r2
 800a3ae:	b29b      	uxth	r3, r3
 800a3b0:	2b00      	cmp	r3, #0
 800a3b2:	d11b      	bne.n	800a3ec <obnotify.9371.4415+0x7c>
    /* Trying to get a full buffer.*/
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800a3b4:	9b05      	ldr	r3, [sp, #20]
 800a3b6:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800a3ba:	ab03      	add	r3, sp, #12
 800a3bc:	4610      	mov	r0, r2
 800a3be:	4619      	mov	r1, r3
 800a3c0:	f001 ff2e 	bl	800c220 <obqGetFullBufferI>
 800a3c4:	9004      	str	r0, [sp, #16]
    if (buf != NULL) {
 800a3c6:	9b04      	ldr	r3, [sp, #16]
 800a3c8:	2b00      	cmp	r3, #0
 800a3ca:	d00f      	beq.n	800a3ec <obnotify.9371.4415+0x7c>
      /* Buffer found, starting a new transaction.*/
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 800a3cc:	9b05      	ldr	r3, [sp, #20]
 800a3ce:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a3d2:	6819      	ldr	r1, [r3, #0]
 800a3d4:	9b05      	ldr	r3, [sp, #20]
 800a3d6:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a3da:	791a      	ldrb	r2, [r3, #4]
 800a3dc:	9b03      	ldr	r3, [sp, #12]
 800a3de:	4608      	mov	r0, r1
 800a3e0:	4611      	mov	r1, r2
 800a3e2:	9a04      	ldr	r2, [sp, #16]
 800a3e4:	f7fe fad4 	bl	8008990 <usbStartTransmitI>
 800a3e8:	e000      	b.n	800a3ec <obnotify.9371.4415+0x7c>

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
      (sdup->state != SDU_READY)) {
    return;
 800a3ea:	bf00      	nop
    if (buf != NULL) {
      /* Buffer found, starting a new transaction.*/
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
    }
  }
}
 800a3ec:	b007      	add	sp, #28
 800a3ee:	f85d fb04 	ldr.w	pc, [sp], #4
 800a3f2:	bf00      	nop
 800a3f4:	f3af 8000 	nop.w
 800a3f8:	f3af 8000 	nop.w
 800a3fc:	f3af 8000 	nop.w

0800a400 <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 800a400:	4770      	bx	lr
 800a402:	bf00      	nop
 800a404:	f3af 8000 	nop.w
 800a408:	f3af 8000 	nop.w
 800a40c:	f3af 8000 	nop.w

0800a410 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 800a410:	b500      	push	{lr}
 800a412:	b085      	sub	sp, #20
 800a414:	9003      	str	r0, [sp, #12]

  sdup->vmt = &vmt;
 800a416:	9a03      	ldr	r2, [sp, #12]
 800a418:	f641 43d0 	movw	r3, #7376	; 0x1cd0
 800a41c:	f6c0 0301 	movt	r3, #2049	; 0x801
 800a420:	6013      	str	r3, [r2, #0]
  osalEventObjectInit(&sdup->event);
 800a422:	9b03      	ldr	r3, [sp, #12]
 800a424:	3304      	adds	r3, #4
 800a426:	4618      	mov	r0, r3
 800a428:	f7ff fe42 	bl	800a0b0 <osalEventObjectInit.9310.4462>
  sdup->state = SDU_STOP;
 800a42c:	9b03      	ldr	r3, [sp, #12]
 800a42e:	2201      	movs	r2, #1
 800a430:	721a      	strb	r2, [r3, #8]
  ibqObjectInit(&sdup->ibqueue, sdup->ib,
 800a432:	9b03      	ldr	r3, [sp, #12]
 800a434:	f103 010c 	add.w	r1, r3, #12
 800a438:	9b03      	ldr	r3, [sp, #12]
 800a43a:	f103 0274 	add.w	r2, r3, #116	; 0x74
 800a43e:	f24a 23f1 	movw	r3, #41713	; 0xa2f1
 800a442:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a446:	9300      	str	r3, [sp, #0]
 800a448:	9b03      	ldr	r3, [sp, #12]
 800a44a:	9301      	str	r3, [sp, #4]
 800a44c:	4608      	mov	r0, r1
 800a44e:	4611      	mov	r1, r2
 800a450:	f44f 7280 	mov.w	r2, #256	; 0x100
 800a454:	2302      	movs	r3, #2
 800a456:	f001 fc73 	bl	800bd40 <ibqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                ibnotify, sdup);
  obqObjectInit(&sdup->obqueue, sdup->ob,
 800a45a:	9b03      	ldr	r3, [sp, #12]
 800a45c:	f103 0140 	add.w	r1, r3, #64	; 0x40
 800a460:	9b03      	ldr	r3, [sp, #12]
 800a462:	f503 721f 	add.w	r2, r3, #636	; 0x27c
 800a466:	f24a 3371 	movw	r3, #41841	; 0xa371
 800a46a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800a46e:	9300      	str	r3, [sp, #0]
 800a470:	9b03      	ldr	r3, [sp, #12]
 800a472:	9301      	str	r3, [sp, #4]
 800a474:	4608      	mov	r0, r1
 800a476:	4611      	mov	r1, r2
 800a478:	f44f 7280 	mov.w	r2, #256	; 0x100
 800a47c:	2302      	movs	r3, #2
 800a47e:	f001 fe67 	bl	800c150 <obqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                obnotify, sdup);
}
 800a482:	b005      	add	sp, #20
 800a484:	f85d fb04 	ldr.w	pc, [sp], #4
 800a488:	f3af 8000 	nop.w
 800a48c:	f3af 8000 	nop.w

0800a490 <sduStart>:
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
 800a490:	b500      	push	{lr}
 800a492:	b085      	sub	sp, #20
 800a494:	9001      	str	r0, [sp, #4]
 800a496:	9100      	str	r1, [sp, #0]
  USBDriver *usbp = config->usbp;
 800a498:	9b00      	ldr	r3, [sp, #0]
 800a49a:	681b      	ldr	r3, [r3, #0]
 800a49c:	9303      	str	r3, [sp, #12]

  osalDbgCheck(sdup != NULL);
 800a49e:	9b01      	ldr	r3, [sp, #4]
 800a4a0:	2b00      	cmp	r3, #0
 800a4a2:	d105      	bne.n	800a4b0 <sduStart+0x20>
 800a4a4:	f641 40f0 	movw	r0, #7408	; 0x1cf0
 800a4a8:	f6c0 0001 	movt	r0, #2049	; 0x801
 800a4ac:	f004 ff70 	bl	800f390 <chSysHalt>

  osalSysLock();
 800a4b0:	f7ff fdde 	bl	800a070 <osalSysLock.9376.4473>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 800a4b4:	9b01      	ldr	r3, [sp, #4]
 800a4b6:	7a1b      	ldrb	r3, [r3, #8]
 800a4b8:	2b01      	cmp	r3, #1
 800a4ba:	d009      	beq.n	800a4d0 <sduStart+0x40>
 800a4bc:	9b01      	ldr	r3, [sp, #4]
 800a4be:	7a1b      	ldrb	r3, [r3, #8]
 800a4c0:	2b02      	cmp	r3, #2
 800a4c2:	d005      	beq.n	800a4d0 <sduStart+0x40>
 800a4c4:	f641 40f0 	movw	r0, #7408	; 0x1cf0
 800a4c8:	f6c0 0001 	movt	r0, #2049	; 0x801
 800a4cc:	f004 ff60 	bl	800f390 <chSysHalt>
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 800a4d0:	9b00      	ldr	r3, [sp, #0]
 800a4d2:	791b      	ldrb	r3, [r3, #4]
 800a4d4:	3b01      	subs	r3, #1
 800a4d6:	9a03      	ldr	r2, [sp, #12]
 800a4d8:	3308      	adds	r3, #8
 800a4da:	009b      	lsls	r3, r3, #2
 800a4dc:	4413      	add	r3, r2
 800a4de:	9a01      	ldr	r2, [sp, #4]
 800a4e0:	605a      	str	r2, [r3, #4]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 800a4e2:	9b00      	ldr	r3, [sp, #0]
 800a4e4:	795b      	ldrb	r3, [r3, #5]
 800a4e6:	1e5a      	subs	r2, r3, #1
 800a4e8:	9b03      	ldr	r3, [sp, #12]
 800a4ea:	320e      	adds	r2, #14
 800a4ec:	9901      	ldr	r1, [sp, #4]
 800a4ee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 800a4f2:	9b00      	ldr	r3, [sp, #0]
 800a4f4:	799b      	ldrb	r3, [r3, #6]
 800a4f6:	2b00      	cmp	r3, #0
 800a4f8:	d008      	beq.n	800a50c <sduStart+0x7c>
    usbp->in_params[config->int_in - 1U]  = sdup;
 800a4fa:	9b00      	ldr	r3, [sp, #0]
 800a4fc:	799b      	ldrb	r3, [r3, #6]
 800a4fe:	3b01      	subs	r3, #1
 800a500:	9a03      	ldr	r2, [sp, #12]
 800a502:	3308      	adds	r3, #8
 800a504:	009b      	lsls	r3, r3, #2
 800a506:	4413      	add	r3, r2
 800a508:	9a01      	ldr	r2, [sp, #4]
 800a50a:	605a      	str	r2, [r3, #4]
  }
  sdup->config = config;
 800a50c:	9b01      	ldr	r3, [sp, #4]
 800a50e:	9a00      	ldr	r2, [sp, #0]
 800a510:	f8c3 2484 	str.w	r2, [r3, #1156]	; 0x484
  sdup->state = SDU_READY;
 800a514:	9b01      	ldr	r3, [sp, #4]
 800a516:	2202      	movs	r2, #2
 800a518:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800a51a:	f7ff fdb1 	bl	800a080 <osalSysUnlock.9380.4471>
}
 800a51e:	b005      	add	sp, #20
 800a520:	f85d fb04 	ldr.w	pc, [sp], #4
 800a524:	f3af 8000 	nop.w
 800a528:	f3af 8000 	nop.w
 800a52c:	f3af 8000 	nop.w

0800a530 <sduDisconnectI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduDisconnectI(SerialUSBDriver *sdup) {
 800a530:	b500      	push	{lr}
 800a532:	b083      	sub	sp, #12
 800a534:	9001      	str	r0, [sp, #4]

  /* Queues reset in order to signal the driver stop to the application.*/
  chnAddFlagsI(sdup, CHN_DISCONNECTED);
 800a536:	9b01      	ldr	r3, [sp, #4]
 800a538:	3304      	adds	r3, #4
 800a53a:	4618      	mov	r0, r3
 800a53c:	2102      	movs	r1, #2
 800a53e:	f7ff fdc7 	bl	800a0d0 <osalEventBroadcastFlagsI.9384.4458>
  ibqResetI(&sdup->ibqueue);
 800a542:	9b01      	ldr	r3, [sp, #4]
 800a544:	330c      	adds	r3, #12
 800a546:	4618      	mov	r0, r3
 800a548:	f001 fc42 	bl	800bdd0 <ibqResetI>
  obqResetI(&sdup->obqueue);
 800a54c:	9b01      	ldr	r3, [sp, #4]
 800a54e:	3340      	adds	r3, #64	; 0x40
 800a550:	4618      	mov	r0, r3
 800a552:	f001 fe45 	bl	800c1e0 <obqResetI>
}
 800a556:	b003      	add	sp, #12
 800a558:	f85d fb04 	ldr.w	pc, [sp], #4
 800a55c:	f3af 8000 	nop.w

0800a560 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 800a560:	b500      	push	{lr}
 800a562:	b085      	sub	sp, #20
 800a564:	9001      	str	r0, [sp, #4]
  uint8_t *buf;

  ibqResetI(&sdup->ibqueue);
 800a566:	9b01      	ldr	r3, [sp, #4]
 800a568:	330c      	adds	r3, #12
 800a56a:	4618      	mov	r0, r3
 800a56c:	f001 fc30 	bl	800bdd0 <ibqResetI>
  obqResetI(&sdup->obqueue);
 800a570:	9b01      	ldr	r3, [sp, #4]
 800a572:	3340      	adds	r3, #64	; 0x40
 800a574:	4618      	mov	r0, r3
 800a576:	f001 fe33 	bl	800c1e0 <obqResetI>
  chnAddFlagsI(sdup, CHN_CONNECTED);
 800a57a:	9b01      	ldr	r3, [sp, #4]
 800a57c:	3304      	adds	r3, #4
 800a57e:	4618      	mov	r0, r3
 800a580:	2101      	movs	r1, #1
 800a582:	f7ff fda5 	bl	800a0d0 <osalEventBroadcastFlagsI.9384.4458>

  /* Starts the first OUT transaction immediately.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 800a586:	9b01      	ldr	r3, [sp, #4]
 800a588:	330c      	adds	r3, #12
 800a58a:	4618      	mov	r0, r3
 800a58c:	f001 fc40 	bl	800be10 <ibqGetEmptyBufferI>
 800a590:	9003      	str	r0, [sp, #12]

  osalDbgAssert(buf != NULL, "no free buffer");
 800a592:	9b03      	ldr	r3, [sp, #12]
 800a594:	2b00      	cmp	r3, #0
 800a596:	d105      	bne.n	800a5a4 <sduConfigureHookI+0x44>
 800a598:	f641 5010 	movw	r0, #7440	; 0x1d10
 800a59c:	f6c0 0001 	movt	r0, #2049	; 0x801
 800a5a0:	f004 fef6 	bl	800f390 <chSysHalt>

  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 800a5a4:	9b01      	ldr	r3, [sp, #4]
 800a5a6:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a5aa:	681a      	ldr	r2, [r3, #0]
 800a5ac:	9b01      	ldr	r3, [sp, #4]
 800a5ae:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a5b2:	795b      	ldrb	r3, [r3, #5]
 800a5b4:	4610      	mov	r0, r2
 800a5b6:	4619      	mov	r1, r3
 800a5b8:	9a03      	ldr	r2, [sp, #12]
 800a5ba:	f44f 7380 	mov.w	r3, #256	; 0x100
 800a5be:	f7fe f997 	bl	80088f0 <usbStartReceiveI>
                   buf, SERIAL_USB_BUFFERS_SIZE);
}
 800a5c2:	b005      	add	sp, #20
 800a5c4:	f85d fb04 	ldr.w	pc, [sp], #4
 800a5c8:	f3af 8000 	nop.w
 800a5cc:	f3af 8000 	nop.w

0800a5d0 <sduRequestsHook>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The hook status.
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {
 800a5d0:	b082      	sub	sp, #8
 800a5d2:	9001      	str	r0, [sp, #4]

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 800a5d4:	9b01      	ldr	r3, [sp, #4]
 800a5d6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800a5da:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800a5de:	2b20      	cmp	r3, #32
 800a5e0:	d132      	bne.n	800a648 <sduRequestsHook+0x78>
    switch (usbp->setup[1]) {
 800a5e2:	9b01      	ldr	r3, [sp, #4]
 800a5e4:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 800a5e8:	2b21      	cmp	r3, #33	; 0x21
 800a5ea:	d004      	beq.n	800a5f6 <sduRequestsHook+0x26>
 800a5ec:	2b22      	cmp	r3, #34	; 0x22
 800a5ee:	d01e      	beq.n	800a62e <sduRequestsHook+0x5e>
 800a5f0:	2b20      	cmp	r3, #32
 800a5f2:	d00e      	beq.n	800a612 <sduRequestsHook+0x42>
 800a5f4:	e026      	b.n	800a644 <sduRequestsHook+0x74>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800a5f6:	9a01      	ldr	r2, [sp, #4]
 800a5f8:	f640 0300 	movw	r3, #2048	; 0x800
 800a5fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a600:	6513      	str	r3, [r2, #80]	; 0x50
 800a602:	9b01      	ldr	r3, [sp, #4]
 800a604:	2207      	movs	r2, #7
 800a606:	655a      	str	r2, [r3, #84]	; 0x54
 800a608:	9b01      	ldr	r3, [sp, #4]
 800a60a:	2200      	movs	r2, #0
 800a60c:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800a60e:	2301      	movs	r3, #1
 800a610:	e01b      	b.n	800a64a <sduRequestsHook+0x7a>
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 800a612:	9a01      	ldr	r2, [sp, #4]
 800a614:	f640 0300 	movw	r3, #2048	; 0x800
 800a618:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a61c:	6513      	str	r3, [r2, #80]	; 0x50
 800a61e:	9b01      	ldr	r3, [sp, #4]
 800a620:	2207      	movs	r2, #7
 800a622:	655a      	str	r2, [r3, #84]	; 0x54
 800a624:	9b01      	ldr	r3, [sp, #4]
 800a626:	2200      	movs	r2, #0
 800a628:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800a62a:	2301      	movs	r3, #1
 800a62c:	e00d      	b.n	800a64a <sduRequestsHook+0x7a>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800a62e:	9b01      	ldr	r3, [sp, #4]
 800a630:	2200      	movs	r2, #0
 800a632:	651a      	str	r2, [r3, #80]	; 0x50
 800a634:	9b01      	ldr	r3, [sp, #4]
 800a636:	2200      	movs	r2, #0
 800a638:	655a      	str	r2, [r3, #84]	; 0x54
 800a63a:	9b01      	ldr	r3, [sp, #4]
 800a63c:	2200      	movs	r2, #0
 800a63e:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800a640:	2301      	movs	r3, #1
 800a642:	e002      	b.n	800a64a <sduRequestsHook+0x7a>
    default:
      return false;
 800a644:	2300      	movs	r3, #0
 800a646:	e000      	b.n	800a64a <sduRequestsHook+0x7a>
    }
  }
  return false;
 800a648:	2300      	movs	r3, #0
}
 800a64a:	4618      	mov	r0, r3
 800a64c:	b002      	add	sp, #8
 800a64e:	4770      	bx	lr

0800a650 <sduSOFHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduSOFHookI(SerialUSBDriver *sdup) {
 800a650:	b500      	push	{lr}
 800a652:	b085      	sub	sp, #20
 800a654:	9001      	str	r0, [sp, #4]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a656:	9b01      	ldr	r3, [sp, #4]
 800a658:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a65c:	681b      	ldr	r3, [r3, #0]
 800a65e:	781b      	ldrb	r3, [r3, #0]
 800a660:	2b04      	cmp	r3, #4
 800a662:	d13c      	bne.n	800a6de <sduSOFHookI+0x8e>
      (sdup->state != SDU_READY)) {
 800a664:	9b01      	ldr	r3, [sp, #4]
 800a666:	7a1b      	ldrb	r3, [r3, #8]
 */
void sduSOFHookI(SerialUSBDriver *sdup) {

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800a668:	2b02      	cmp	r3, #2
 800a66a:	d138      	bne.n	800a6de <sduSOFHookI+0x8e>
    return;
  }

  /* If there is already a transaction ongoing then another one cannot be
     started.*/
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800a66c:	9b01      	ldr	r3, [sp, #4]
 800a66e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a672:	681b      	ldr	r3, [r3, #0]
 800a674:	891a      	ldrh	r2, [r3, #8]
 800a676:	9b01      	ldr	r3, [sp, #4]
 800a678:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a67c:	791b      	ldrb	r3, [r3, #4]
 800a67e:	2101      	movs	r1, #1
 800a680:	fa01 f303 	lsl.w	r3, r1, r3
 800a684:	b29b      	uxth	r3, r3
 800a686:	4013      	ands	r3, r2
 800a688:	b29b      	uxth	r3, r3
 800a68a:	2b00      	cmp	r3, #0
 800a68c:	d127      	bne.n	800a6de <sduSOFHookI+0x8e>
    return;
  }

  /* Checking if there only a buffer partially filled, if so then it is
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
 800a68e:	9b01      	ldr	r3, [sp, #4]
 800a690:	3340      	adds	r3, #64	; 0x40
 800a692:	4618      	mov	r0, r3
 800a694:	f7ff fc34 	bl	8009f00 <obqTryFlushI.4537>
 800a698:	4603      	mov	r3, r0
 800a69a:	2b00      	cmp	r3, #0
 800a69c:	d01f      	beq.n	800a6de <sduSOFHookI+0x8e>
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800a69e:	9b01      	ldr	r3, [sp, #4]
 800a6a0:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800a6a4:	ab02      	add	r3, sp, #8
 800a6a6:	4610      	mov	r0, r2
 800a6a8:	4619      	mov	r1, r3
 800a6aa:	f001 fdb9 	bl	800c220 <obqGetFullBufferI>
 800a6ae:	9003      	str	r0, [sp, #12]

    osalDbgAssert(buf != NULL, "queue is empty");
 800a6b0:	9b03      	ldr	r3, [sp, #12]
 800a6b2:	2b00      	cmp	r3, #0
 800a6b4:	d105      	bne.n	800a6c2 <sduSOFHookI+0x72>
 800a6b6:	f641 5030 	movw	r0, #7472	; 0x1d30
 800a6ba:	f6c0 0001 	movt	r0, #2049	; 0x801
 800a6be:	f004 fe67 	bl	800f390 <chSysHalt>

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 800a6c2:	9b01      	ldr	r3, [sp, #4]
 800a6c4:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a6c8:	6819      	ldr	r1, [r3, #0]
 800a6ca:	9b01      	ldr	r3, [sp, #4]
 800a6cc:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a6d0:	791a      	ldrb	r2, [r3, #4]
 800a6d2:	9b02      	ldr	r3, [sp, #8]
 800a6d4:	4608      	mov	r0, r1
 800a6d6:	4611      	mov	r1, r2
 800a6d8:	9a03      	ldr	r2, [sp, #12]
 800a6da:	f7fe f959 	bl	8008990 <usbStartTransmitI>
  }
}
 800a6de:	b005      	add	sp, #20
 800a6e0:	f85d fb04 	ldr.w	pc, [sp], #4
 800a6e4:	f3af 8000 	nop.w
 800a6e8:	f3af 8000 	nop.w
 800a6ec:	f3af 8000 	nop.w

0800a6f0 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800a6f0:	b500      	push	{lr}
 800a6f2:	b087      	sub	sp, #28
 800a6f4:	9001      	str	r0, [sp, #4]
 800a6f6:	460b      	mov	r3, r1
 800a6f8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800a6fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a700:	3b01      	subs	r3, #1
 800a702:	9a01      	ldr	r2, [sp, #4]
 800a704:	3308      	adds	r3, #8
 800a706:	009b      	lsls	r3, r3, #2
 800a708:	4413      	add	r3, r2
 800a70a:	685b      	ldr	r3, [r3, #4]
 800a70c:	9305      	str	r3, [sp, #20]

  if (sdup == NULL) {
 800a70e:	9b05      	ldr	r3, [sp, #20]
 800a710:	2b00      	cmp	r3, #0
 800a712:	d059      	beq.n	800a7c8 <sduDataTransmitted+0xd8>
    return;
  }

  osalSysLockFromISR();
 800a714:	f7ff fcbc 	bl	800a090 <osalSysLockFromISR.9390.4469>

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);
 800a718:	9b05      	ldr	r3, [sp, #20]
 800a71a:	3304      	adds	r3, #4
 800a71c:	4618      	mov	r0, r3
 800a71e:	2108      	movs	r1, #8
 800a720:	f7ff fcd6 	bl	800a0d0 <osalEventBroadcastFlagsI.9384.4458>

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 800a724:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a728:	9a01      	ldr	r2, [sp, #4]
 800a72a:	3302      	adds	r3, #2
 800a72c:	009b      	lsls	r3, r3, #2
 800a72e:	4413      	add	r3, r2
 800a730:	685b      	ldr	r3, [r3, #4]
 800a732:	695b      	ldr	r3, [r3, #20]
 800a734:	681b      	ldr	r3, [r3, #0]
 800a736:	2b00      	cmp	r3, #0
 800a738:	d004      	beq.n	800a744 <sduDataTransmitted+0x54>
    obqReleaseEmptyBufferI(&sdup->obqueue);
 800a73a:	9b05      	ldr	r3, [sp, #20]
 800a73c:	3340      	adds	r3, #64	; 0x40
 800a73e:	4618      	mov	r0, r3
 800a740:	f001 fd96 	bl	800c270 <obqReleaseEmptyBufferI>
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800a744:	9b05      	ldr	r3, [sp, #20]
 800a746:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800a74a:	ab03      	add	r3, sp, #12
 800a74c:	4610      	mov	r0, r2
 800a74e:	4619      	mov	r1, r3
 800a750:	f001 fd66 	bl	800c220 <obqGetFullBufferI>
 800a754:	9004      	str	r0, [sp, #16]

  if (buf != NULL) {
 800a756:	9b04      	ldr	r3, [sp, #16]
 800a758:	2b00      	cmp	r3, #0
 800a75a:	d008      	beq.n	800a76e <sduDataTransmitted+0x7e>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 800a75c:	9b03      	ldr	r3, [sp, #12]
 800a75e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800a762:	9801      	ldr	r0, [sp, #4]
 800a764:	4611      	mov	r1, r2
 800a766:	9a04      	ldr	r2, [sp, #16]
 800a768:	f7fe f912 	bl	8008990 <usbStartTransmitI>
 800a76c:	e029      	b.n	800a7c2 <sduDataTransmitted+0xd2>
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800a76e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a772:	9a01      	ldr	r2, [sp, #4]
 800a774:	3302      	adds	r3, #2
 800a776:	009b      	lsls	r3, r3, #2
 800a778:	4413      	add	r3, r2
 800a77a:	685b      	ldr	r3, [r3, #4]
 800a77c:	695b      	ldr	r3, [r3, #20]
 800a77e:	681b      	ldr	r3, [r3, #0]
 800a780:	2b00      	cmp	r3, #0
 800a782:	d01e      	beq.n	800a7c2 <sduDataTransmitted+0xd2>
           ((usbp->epc[ep]->in_state->txsize &
 800a784:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a788:	9a01      	ldr	r2, [sp, #4]
 800a78a:	3302      	adds	r3, #2
 800a78c:	009b      	lsls	r3, r3, #2
 800a78e:	4413      	add	r3, r2
 800a790:	685b      	ldr	r3, [r3, #4]
 800a792:	695b      	ldr	r3, [r3, #20]
 800a794:	681a      	ldr	r2, [r3, #0]
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 800a796:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a79a:	9901      	ldr	r1, [sp, #4]
 800a79c:	3302      	adds	r3, #2
 800a79e:	009b      	lsls	r3, r3, #2
 800a7a0:	440b      	add	r3, r1
 800a7a2:	685b      	ldr	r3, [r3, #4]
 800a7a4:	8a1b      	ldrh	r3, [r3, #16]
 800a7a6:	3b01      	subs	r3, #1
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
           ((usbp->epc[ep]->in_state->txsize &
 800a7a8:	4013      	ands	r3, r2
  if (buf != NULL) {
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800a7aa:	2b00      	cmp	r3, #0
 800a7ac:	d109      	bne.n	800a7c2 <sduDataTransmitted+0xd2>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
    /* Transmit zero sized packet in case the last one has maximum allowed
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 800a7ae:	9b01      	ldr	r3, [sp, #4]
 800a7b0:	335c      	adds	r3, #92	; 0x5c
 800a7b2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800a7b6:	9801      	ldr	r0, [sp, #4]
 800a7b8:	4611      	mov	r1, r2
 800a7ba:	461a      	mov	r2, r3
 800a7bc:	2300      	movs	r3, #0
 800a7be:	f7fe f8e7 	bl	8008990 <usbStartTransmitI>
  }
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
 800a7c2:	f7ff fc6d 	bl	800a0a0 <osalSysUnlockFromISR.9394.4467>
 800a7c6:	e000      	b.n	800a7ca <sduDataTransmitted+0xda>
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];

  if (sdup == NULL) {
    return;
 800a7c8:	bf00      	nop
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
}
 800a7ca:	b007      	add	sp, #28
 800a7cc:	f85d fb04 	ldr.w	pc, [sp], #4

0800a7d0 <sduDataReceived>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 800a7d0:	b500      	push	{lr}
 800a7d2:	b085      	sub	sp, #20
 800a7d4:	9001      	str	r0, [sp, #4]
 800a7d6:	460b      	mov	r3, r1
 800a7d8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint8_t *buf;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 800a7dc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a7e0:	1e5a      	subs	r2, r3, #1
 800a7e2:	9b01      	ldr	r3, [sp, #4]
 800a7e4:	320e      	adds	r2, #14
 800a7e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800a7ea:	9303      	str	r3, [sp, #12]

  if (sdup == NULL) {
 800a7ec:	9b03      	ldr	r3, [sp, #12]
 800a7ee:	2b00      	cmp	r3, #0
 800a7f0:	d036      	beq.n	800a860 <sduDataReceived+0x90>
    return;
  }

  osalSysLockFromISR();
 800a7f2:	f7ff fc4d 	bl	800a090 <osalSysLockFromISR.9390.4469>

  /* Signaling that data is available in the input queue.*/
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
 800a7f6:	9b03      	ldr	r3, [sp, #12]
 800a7f8:	3304      	adds	r3, #4
 800a7fa:	4618      	mov	r0, r3
 800a7fc:	2104      	movs	r1, #4
 800a7fe:	f7ff fc67 	bl	800a0d0 <osalEventBroadcastFlagsI.9384.4458>

  /* Posting the filled buffer in the queue.*/
  ibqPostFullBufferI(&sdup->ibqueue,
 800a802:	9b03      	ldr	r3, [sp, #12]
 800a804:	f103 020c 	add.w	r2, r3, #12
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 800a808:	9b03      	ldr	r3, [sp, #12]
 800a80a:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a80e:	6819      	ldr	r1, [r3, #0]
 800a810:	9b03      	ldr	r3, [sp, #12]
 800a812:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a816:	795b      	ldrb	r3, [r3, #5]
 800a818:	3302      	adds	r3, #2
 800a81a:	009b      	lsls	r3, r3, #2
 800a81c:	440b      	add	r3, r1
 800a81e:	685b      	ldr	r3, [r3, #4]
 800a820:	699b      	ldr	r3, [r3, #24]

  /* Signaling that data is available in the input queue.*/
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Posting the filled buffer in the queue.*/
  ibqPostFullBufferI(&sdup->ibqueue,
 800a822:	685b      	ldr	r3, [r3, #4]
 800a824:	4610      	mov	r0, r2
 800a826:	4619      	mov	r1, r3
 800a828:	f001 fb12 	bl	800be50 <ibqPostFullBufferI>
                                                   sdup->config->bulk_out));

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 800a82c:	9b03      	ldr	r3, [sp, #12]
 800a82e:	330c      	adds	r3, #12
 800a830:	4618      	mov	r0, r3
 800a832:	f001 faed 	bl	800be10 <ibqGetEmptyBufferI>
 800a836:	9002      	str	r0, [sp, #8]
  if (buf != NULL) {
 800a838:	9b02      	ldr	r3, [sp, #8]
 800a83a:	2b00      	cmp	r3, #0
 800a83c:	d00e      	beq.n	800a85c <sduDataReceived+0x8c>
    /* Buffer found, starting a new transaction.*/
    usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 800a83e:	9b03      	ldr	r3, [sp, #12]
 800a840:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a844:	681a      	ldr	r2, [r3, #0]
 800a846:	9b03      	ldr	r3, [sp, #12]
 800a848:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800a84c:	795b      	ldrb	r3, [r3, #5]
 800a84e:	4610      	mov	r0, r2
 800a850:	4619      	mov	r1, r3
 800a852:	9a02      	ldr	r2, [sp, #8]
 800a854:	f44f 7380 	mov.w	r3, #256	; 0x100
 800a858:	f7fe f84a 	bl	80088f0 <usbStartReceiveI>
                     buf, SERIAL_USB_BUFFERS_SIZE);
  }
  osalSysUnlockFromISR();
 800a85c:	f7ff fc20 	bl	800a0a0 <osalSysUnlockFromISR.9394.4467>
}
 800a860:	b005      	add	sp, #20
 800a862:	f85d fb04 	ldr.w	pc, [sp], #4
 800a866:	bf00      	nop
 800a868:	f3af 8000 	nop.w
 800a86c:	f3af 8000 	nop.w

0800a870 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 800a870:	b082      	sub	sp, #8
 800a872:	9001      	str	r0, [sp, #4]
 800a874:	460b      	mov	r3, r1
 800a876:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)usbp;
  (void)ep;
}
 800a87a:	b002      	add	sp, #8
 800a87c:	4770      	bx	lr
 800a87e:	bf00      	nop

0800a880 <port_lock.9746.4317>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a880:	b082      	sub	sp, #8
 800a882:	2320      	movs	r3, #32
 800a884:	9301      	str	r3, [sp, #4]
 800a886:	9b01      	ldr	r3, [sp, #4]
 800a888:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a88c:	b002      	add	sp, #8
 800a88e:	4770      	bx	lr

0800a890 <port_unlock.9749.4315>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a890:	b082      	sub	sp, #8
 800a892:	2300      	movs	r3, #0
 800a894:	9301      	str	r3, [sp, #4]
 800a896:	9b01      	ldr	r3, [sp, #4]
 800a898:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a89c:	b002      	add	sp, #8
 800a89e:	4770      	bx	lr

0800a8a0 <port_lock_from_isr.9751.4313>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800a8a0:	b508      	push	{r3, lr}

  port_lock();
 800a8a2:	f7ff ffed 	bl	800a880 <port_lock.9746.4317>
}
 800a8a6:	bd08      	pop	{r3, pc}
 800a8a8:	f3af 8000 	nop.w
 800a8ac:	f3af 8000 	nop.w

0800a8b0 <port_unlock_from_isr.9753.4311>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800a8b0:	b508      	push	{r3, lr}

  port_unlock();
 800a8b2:	f7ff ffed 	bl	800a890 <port_unlock.9749.4315>
}
 800a8b6:	bd08      	pop	{r3, pc}
 800a8b8:	f3af 8000 	nop.w
 800a8bc:	f3af 8000 	nop.w

0800a8c0 <chSysLock.9755.4309>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a8c0:	b508      	push	{r3, lr}

  port_lock();
 800a8c2:	f7ff ffdd 	bl	800a880 <port_lock.9746.4317>
  _stats_start_measure_crit_thd();
 800a8c6:	f003 fb5b 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800a8ca:	f004 ff09 	bl	800f6e0 <_dbg_check_lock>
}
 800a8ce:	bd08      	pop	{r3, pc}

0800a8d0 <chSysUnlock.9759.4307>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a8d0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800a8d2:	f004 ff25 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800a8d6:	f003 fb5b 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800a8da:	f640 5350 	movw	r3, #3408	; 0xd50
 800a8de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a8e2:	681a      	ldr	r2, [r3, #0]
 800a8e4:	f640 5350 	movw	r3, #3408	; 0xd50
 800a8e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a8ec:	429a      	cmp	r2, r3
 800a8ee:	d013      	beq.n	800a918 <chSysUnlock.9759.4307+0x48>
 800a8f0:	f640 5350 	movw	r3, #3408	; 0xd50
 800a8f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a8f8:	699b      	ldr	r3, [r3, #24]
 800a8fa:	689a      	ldr	r2, [r3, #8]
 800a8fc:	f640 5350 	movw	r3, #3408	; 0xd50
 800a900:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800a904:	681b      	ldr	r3, [r3, #0]
 800a906:	689b      	ldr	r3, [r3, #8]
 800a908:	429a      	cmp	r2, r3
 800a90a:	d205      	bcs.n	800a918 <chSysUnlock.9759.4307+0x48>
 800a90c:	f641 5080 	movw	r0, #7552	; 0x1d80
 800a910:	f6c0 0001 	movt	r0, #2049	; 0x801
 800a914:	f004 fd3c 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800a918:	f7ff ffba 	bl	800a890 <port_unlock.9749.4315>
}
 800a91c:	bd08      	pop	{r3, pc}
 800a91e:	bf00      	nop

0800a920 <chSysLockFromISR.9765.4305>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800a920:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800a922:	f7ff ffbd 	bl	800a8a0 <port_lock_from_isr.9751.4313>
  _stats_start_measure_crit_isr();
 800a926:	f003 fb3b 	bl	800dfa0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800a92a:	f004 ff19 	bl	800f760 <_dbg_check_lock_from_isr>
}
 800a92e:	bd08      	pop	{r3, pc}

0800a930 <chSysUnlockFromISR.9769.4303>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800a930:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 800a932:	f004 ff35 	bl	800f7a0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 800a936:	f003 fb3b 	bl	800dfb0 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800a93a:	f7ff ffb9 	bl	800a8b0 <port_unlock_from_isr.9753.4311>
}
 800a93e:	bd08      	pop	{r3, pc}

0800a940 <osalSysLock.9757.4301>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 800a940:	b508      	push	{r3, lr}

  chSysLock();
 800a942:	f7ff ffbd 	bl	800a8c0 <chSysLock.9755.4309>
}
 800a946:	bd08      	pop	{r3, pc}
 800a948:	f3af 8000 	nop.w
 800a94c:	f3af 8000 	nop.w

0800a950 <osalSysUnlock.9761.4299>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 800a950:	b508      	push	{r3, lr}

  chSysUnlock();
 800a952:	f7ff ffbd 	bl	800a8d0 <chSysUnlock.9759.4307>
}
 800a956:	bd08      	pop	{r3, pc}
 800a958:	f3af 8000 	nop.w
 800a95c:	f3af 8000 	nop.w

0800a960 <osalSysLockFromISR.9767>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800a960:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800a962:	f7ff ffdd 	bl	800a920 <chSysLockFromISR.9765.4305>
}
 800a966:	bd08      	pop	{r3, pc}
 800a968:	f3af 8000 	nop.w
 800a96c:	f3af 8000 	nop.w

0800a970 <osalSysUnlockFromISR.9771>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800a970:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800a972:	f7ff ffdd 	bl	800a930 <chSysUnlockFromISR.9769.4303>
}
 800a976:	bd08      	pop	{r3, pc}
 800a978:	f3af 8000 	nop.w
 800a97c:	f3af 8000 	nop.w

0800a980 <get_hword.9773>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 800a980:	b084      	sub	sp, #16
 800a982:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 800a984:	9b01      	ldr	r3, [sp, #4]
 800a986:	1c5a      	adds	r2, r3, #1
 800a988:	9201      	str	r2, [sp, #4]
 800a98a:	781b      	ldrb	r3, [r3, #0]
 800a98c:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 800a990:	9b01      	ldr	r3, [sp, #4]
 800a992:	781b      	ldrb	r3, [r3, #0]
 800a994:	021b      	lsls	r3, r3, #8
 800a996:	b29a      	uxth	r2, r3
 800a998:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800a99c:	4313      	orrs	r3, r2
 800a99e:	b29b      	uxth	r3, r3
 800a9a0:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 800a9a4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 800a9a8:	4618      	mov	r0, r3
 800a9aa:	b004      	add	sp, #16
 800a9ac:	4770      	bx	lr
 800a9ae:	bf00      	nop

0800a9b0 <set_address.9780.4287>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 800a9b0:	b500      	push	{lr}
 800a9b2:	b083      	sub	sp, #12
 800a9b4:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 800a9b6:	9b01      	ldr	r3, [sp, #4]
 800a9b8:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 800a9bc:	9b01      	ldr	r3, [sp, #4]
 800a9be:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usb_lld_set_address(usbp);
 800a9c2:	9801      	ldr	r0, [sp, #4]
 800a9c4:	f7fc ffd4 	bl	8007970 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 800a9c8:	9b01      	ldr	r3, [sp, #4]
 800a9ca:	685b      	ldr	r3, [r3, #4]
 800a9cc:	681b      	ldr	r3, [r3, #0]
 800a9ce:	2b00      	cmp	r3, #0
 800a9d0:	d005      	beq.n	800a9de <set_address.9780.4287+0x2e>
 800a9d2:	9b01      	ldr	r3, [sp, #4]
 800a9d4:	685b      	ldr	r3, [r3, #4]
 800a9d6:	681b      	ldr	r3, [r3, #0]
 800a9d8:	9801      	ldr	r0, [sp, #4]
 800a9da:	2101      	movs	r1, #1
 800a9dc:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800a9de:	9b01      	ldr	r3, [sp, #4]
 800a9e0:	2203      	movs	r2, #3
 800a9e2:	701a      	strb	r2, [r3, #0]
}
 800a9e4:	b003      	add	sp, #12
 800a9e6:	f85d fb04 	ldr.w	pc, [sp], #4
 800a9ea:	bf00      	nop
 800a9ec:	f3af 8000 	nop.w

0800a9f0 <default_handler.10033>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 800a9f0:	b570      	push	{r4, r5, r6, lr}
 800a9f2:	b084      	sub	sp, #16
 800a9f4:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800a9f6:	9b01      	ldr	r3, [sp, #4]
 800a9f8:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800a9fc:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 800aa00:	9b01      	ldr	r3, [sp, #4]
 800aa02:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 800aa06:	021b      	lsls	r3, r3, #8
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
 800aa08:	4313      	orrs	r3, r2
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800aa0a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800aa0e:	d05a      	beq.n	800aac6 <default_handler.10033+0xd6>
 800aa10:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800aa14:	d812      	bhi.n	800aa3c <default_handler.10033+0x4c>
 800aa16:	2b02      	cmp	r3, #2
 800aa18:	f000 80f1 	beq.w	800abfe <default_handler.10033+0x20e>
 800aa1c:	2b02      	cmp	r3, #2
 800aa1e:	d805      	bhi.n	800aa2c <default_handler.10033+0x3c>
 800aa20:	2b00      	cmp	r3, #0
 800aa22:	d028      	beq.n	800aa76 <default_handler.10033+0x86>
 800aa24:	2b01      	cmp	r3, #1
 800aa26:	f000 80dc 	beq.w	800abe2 <default_handler.10033+0x1f2>
 800aa2a:	e1b5      	b.n	800ad98 <default_handler.10033+0x3a8>
 800aa2c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800aa30:	d02e      	beq.n	800aa90 <default_handler.10033+0xa0>
 800aa32:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 800aa36:	f000 8145 	beq.w	800acc4 <default_handler.10033+0x2d4>
 800aa3a:	e1ad      	b.n	800ad98 <default_handler.10033+0x3a8>
 800aa3c:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 800aa40:	d074      	beq.n	800ab2c <default_handler.10033+0x13c>
 800aa42:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 800aa46:	d808      	bhi.n	800aa5a <default_handler.10033+0x6a>
 800aa48:	f240 3202 	movw	r2, #770	; 0x302
 800aa4c:	4293      	cmp	r3, r2
 800aa4e:	f000 816e 	beq.w	800ad2e <default_handler.10033+0x33e>
 800aa52:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800aa56:	d051      	beq.n	800aafc <default_handler.10033+0x10c>
 800aa58:	e19e      	b.n	800ad98 <default_handler.10033+0x3a8>
 800aa5a:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 800aa5e:	f000 8098 	beq.w	800ab92 <default_handler.10033+0x1a2>
 800aa62:	f640 4202 	movw	r2, #3074	; 0xc02
 800aa66:	4293      	cmp	r3, r2
 800aa68:	f000 80bb 	beq.w	800abe2 <default_handler.10033+0x1f2>
 800aa6c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800aa70:	f000 8082 	beq.w	800ab78 <default_handler.10033+0x188>
 800aa74:	e190      	b.n	800ad98 <default_handler.10033+0x3a8>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 800aa76:	9b01      	ldr	r3, [sp, #4]
 800aa78:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800aa7c:	9b01      	ldr	r3, [sp, #4]
 800aa7e:	651a      	str	r2, [r3, #80]	; 0x50
 800aa80:	9b01      	ldr	r3, [sp, #4]
 800aa82:	2202      	movs	r2, #2
 800aa84:	655a      	str	r2, [r3, #84]	; 0x54
 800aa86:	9b01      	ldr	r3, [sp, #4]
 800aa88:	2200      	movs	r2, #0
 800aa8a:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800aa8c:	2301      	movs	r3, #1
 800aa8e:	e184      	b.n	800ad9a <default_handler.10033+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800aa90:	9b01      	ldr	r3, [sp, #4]
 800aa92:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800aa96:	2b01      	cmp	r3, #1
 800aa98:	d113      	bne.n	800aac2 <default_handler.10033+0xd2>
      usbp->status &= ~2U;
 800aa9a:	9b01      	ldr	r3, [sp, #4]
 800aa9c:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 800aaa0:	f023 0302 	bic.w	r3, r3, #2
 800aaa4:	b29a      	uxth	r2, r3
 800aaa6:	9b01      	ldr	r3, [sp, #4]
 800aaa8:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800aaac:	9b01      	ldr	r3, [sp, #4]
 800aaae:	2200      	movs	r2, #0
 800aab0:	651a      	str	r2, [r3, #80]	; 0x50
 800aab2:	9b01      	ldr	r3, [sp, #4]
 800aab4:	2200      	movs	r2, #0
 800aab6:	655a      	str	r2, [r3, #84]	; 0x54
 800aab8:	9b01      	ldr	r3, [sp, #4]
 800aaba:	2200      	movs	r2, #0
 800aabc:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800aabe:	2301      	movs	r3, #1
 800aac0:	e16b      	b.n	800ad9a <default_handler.10033+0x3aa>
    }
    return false;
 800aac2:	2300      	movs	r3, #0
 800aac4:	e169      	b.n	800ad9a <default_handler.10033+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800aac6:	9b01      	ldr	r3, [sp, #4]
 800aac8:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800aacc:	2b01      	cmp	r3, #1
 800aace:	d113      	bne.n	800aaf8 <default_handler.10033+0x108>
      usbp->status |= 2U;
 800aad0:	9b01      	ldr	r3, [sp, #4]
 800aad2:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 800aad6:	f043 0302 	orr.w	r3, r3, #2
 800aada:	b29a      	uxth	r2, r3
 800aadc:	9b01      	ldr	r3, [sp, #4]
 800aade:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800aae2:	9b01      	ldr	r3, [sp, #4]
 800aae4:	2200      	movs	r2, #0
 800aae6:	651a      	str	r2, [r3, #80]	; 0x50
 800aae8:	9b01      	ldr	r3, [sp, #4]
 800aaea:	2200      	movs	r2, #0
 800aaec:	655a      	str	r2, [r3, #84]	; 0x54
 800aaee:	9b01      	ldr	r3, [sp, #4]
 800aaf0:	2200      	movs	r2, #0
 800aaf2:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800aaf4:	2301      	movs	r3, #1
 800aaf6:	e150      	b.n	800ad9a <default_handler.10033+0x3aa>
    }
    return false;
 800aaf8:	2300      	movs	r3, #0
 800aafa:	e14e      	b.n	800ad9a <default_handler.10033+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800aafc:	9b01      	ldr	r3, [sp, #4]
 800aafe:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800ab02:	2b00      	cmp	r3, #0
 800ab04:	d107      	bne.n	800ab16 <default_handler.10033+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 800ab06:	9b01      	ldr	r3, [sp, #4]
 800ab08:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800ab0c:	2b05      	cmp	r3, #5
 800ab0e:	d102      	bne.n	800ab16 <default_handler.10033+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
      set_address(usbp);
 800ab10:	9801      	ldr	r0, [sp, #4]
 800ab12:	f7ff ff4d 	bl	800a9b0 <set_address.9780.4287>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800ab16:	9b01      	ldr	r3, [sp, #4]
 800ab18:	2200      	movs	r2, #0
 800ab1a:	651a      	str	r2, [r3, #80]	; 0x50
 800ab1c:	9b01      	ldr	r3, [sp, #4]
 800ab1e:	2200      	movs	r2, #0
 800ab20:	655a      	str	r2, [r3, #84]	; 0x54
 800ab22:	9b01      	ldr	r3, [sp, #4]
 800ab24:	2200      	movs	r2, #0
 800ab26:	659a      	str	r2, [r3, #88]	; 0x58
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 800ab28:	2301      	movs	r3, #1
 800ab2a:	e136      	b.n	800ad9a <default_handler.10033+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800ab2c:	9b01      	ldr	r3, [sp, #4]
 800ab2e:	685b      	ldr	r3, [r3, #4]
 800ab30:	685c      	ldr	r4, [r3, #4]
 800ab32:	9b01      	ldr	r3, [sp, #4]
 800ab34:	f893 605f 	ldrb.w	r6, [r3, #95]	; 0x5f
 800ab38:	9b01      	ldr	r3, [sp, #4]
 800ab3a:	f893 505e 	ldrb.w	r5, [r3, #94]	; 0x5e
 800ab3e:	9b01      	ldr	r3, [sp, #4]
 800ab40:	3360      	adds	r3, #96	; 0x60
 800ab42:	4618      	mov	r0, r3
 800ab44:	f7ff ff1c 	bl	800a980 <get_hword.9773>
 800ab48:	4603      	mov	r3, r0
 800ab4a:	9801      	ldr	r0, [sp, #4]
 800ab4c:	4631      	mov	r1, r6
 800ab4e:	462a      	mov	r2, r5
 800ab50:	47a0      	blx	r4
 800ab52:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 800ab54:	9b03      	ldr	r3, [sp, #12]
 800ab56:	2b00      	cmp	r3, #0
 800ab58:	d101      	bne.n	800ab5e <default_handler.10033+0x16e>
      return false;
 800ab5a:	2300      	movs	r3, #0
 800ab5c:	e11d      	b.n	800ad9a <default_handler.10033+0x3aa>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800ab5e:	9b03      	ldr	r3, [sp, #12]
 800ab60:	685a      	ldr	r2, [r3, #4]
 800ab62:	9b01      	ldr	r3, [sp, #4]
 800ab64:	651a      	str	r2, [r3, #80]	; 0x50
 800ab66:	9b03      	ldr	r3, [sp, #12]
 800ab68:	681a      	ldr	r2, [r3, #0]
 800ab6a:	9b01      	ldr	r3, [sp, #4]
 800ab6c:	655a      	str	r2, [r3, #84]	; 0x54
 800ab6e:	9b01      	ldr	r3, [sp, #4]
 800ab70:	2200      	movs	r2, #0
 800ab72:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 800ab74:	2301      	movs	r3, #1
 800ab76:	e110      	b.n	800ad9a <default_handler.10033+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 800ab78:	9b01      	ldr	r3, [sp, #4]
 800ab7a:	f103 0267 	add.w	r2, r3, #103	; 0x67
 800ab7e:	9b01      	ldr	r3, [sp, #4]
 800ab80:	651a      	str	r2, [r3, #80]	; 0x50
 800ab82:	9b01      	ldr	r3, [sp, #4]
 800ab84:	2201      	movs	r2, #1
 800ab86:	655a      	str	r2, [r3, #84]	; 0x54
 800ab88:	9b01      	ldr	r3, [sp, #4]
 800ab8a:	2200      	movs	r2, #0
 800ab8c:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800ab8e:	2301      	movs	r3, #1
 800ab90:	e103      	b.n	800ad9a <default_handler.10033+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host.*/
    usbp->configuration = usbp->setup[2];
 800ab92:	9b01      	ldr	r3, [sp, #4]
 800ab94:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 800ab98:	9b01      	ldr	r3, [sp, #4]
 800ab9a:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
    if (usbp->configuration == 0U) {
 800ab9e:	9b01      	ldr	r3, [sp, #4]
 800aba0:	f893 3067 	ldrb.w	r3, [r3, #103]	; 0x67
 800aba4:	2b00      	cmp	r3, #0
 800aba6:	d103      	bne.n	800abb0 <default_handler.10033+0x1c0>
      usbp->state = USB_SELECTED;
 800aba8:	9b01      	ldr	r3, [sp, #4]
 800abaa:	2203      	movs	r2, #3
 800abac:	701a      	strb	r2, [r3, #0]
 800abae:	e002      	b.n	800abb6 <default_handler.10033+0x1c6>
    }
    else {
      usbp->state = USB_ACTIVE;
 800abb0:	9b01      	ldr	r3, [sp, #4]
 800abb2:	2204      	movs	r2, #4
 800abb4:	701a      	strb	r2, [r3, #0]
    }
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800abb6:	9b01      	ldr	r3, [sp, #4]
 800abb8:	685b      	ldr	r3, [r3, #4]
 800abba:	681b      	ldr	r3, [r3, #0]
 800abbc:	2b00      	cmp	r3, #0
 800abbe:	d005      	beq.n	800abcc <default_handler.10033+0x1dc>
 800abc0:	9b01      	ldr	r3, [sp, #4]
 800abc2:	685b      	ldr	r3, [r3, #4]
 800abc4:	681b      	ldr	r3, [r3, #0]
 800abc6:	9801      	ldr	r0, [sp, #4]
 800abc8:	2102      	movs	r1, #2
 800abca:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800abcc:	9b01      	ldr	r3, [sp, #4]
 800abce:	2200      	movs	r2, #0
 800abd0:	651a      	str	r2, [r3, #80]	; 0x50
 800abd2:	9b01      	ldr	r3, [sp, #4]
 800abd4:	2200      	movs	r2, #0
 800abd6:	655a      	str	r2, [r3, #84]	; 0x54
 800abd8:	9b01      	ldr	r3, [sp, #4]
 800abda:	2200      	movs	r2, #0
 800abdc:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800abde:	2301      	movs	r3, #1
 800abe0:	e0db      	b.n	800ad9a <default_handler.10033+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 800abe2:	9a01      	ldr	r2, [sp, #4]
 800abe4:	f641 5340 	movw	r3, #7488	; 0x1d40
 800abe8:	f6c0 0301 	movt	r3, #2049	; 0x801
 800abec:	6513      	str	r3, [r2, #80]	; 0x50
 800abee:	9b01      	ldr	r3, [sp, #4]
 800abf0:	2202      	movs	r2, #2
 800abf2:	655a      	str	r2, [r3, #84]	; 0x54
 800abf4:	9b01      	ldr	r3, [sp, #4]
 800abf6:	2200      	movs	r2, #0
 800abf8:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 800abfa:	2301      	movs	r3, #1
 800abfc:	e0cd      	b.n	800ad9a <default_handler.10033+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 800abfe:	9b01      	ldr	r3, [sp, #4]
 800ac00:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800ac04:	b2db      	uxtb	r3, r3
 800ac06:	b25b      	sxtb	r3, r3
 800ac08:	2b00      	cmp	r3, #0
 800ac0a:	da2d      	bge.n	800ac68 <default_handler.10033+0x278>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800ac0c:	9b01      	ldr	r3, [sp, #4]
 800ac0e:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800ac12:	f003 030f 	and.w	r3, r3, #15
 800ac16:	b2db      	uxtb	r3, r3
 800ac18:	9801      	ldr	r0, [sp, #4]
 800ac1a:	4619      	mov	r1, r3
 800ac1c:	f7fd f810 	bl	8007c40 <usb_lld_get_status_in>
 800ac20:	4603      	mov	r3, r0
 800ac22:	2b01      	cmp	r3, #1
 800ac24:	d002      	beq.n	800ac2c <default_handler.10033+0x23c>
 800ac26:	2b02      	cmp	r3, #2
 800ac28:	d00e      	beq.n	800ac48 <default_handler.10033+0x258>
 800ac2a:	e01b      	b.n	800ac64 <default_handler.10033+0x274>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800ac2c:	9a01      	ldr	r2, [sp, #4]
 800ac2e:	f641 5360 	movw	r3, #7520	; 0x1d60
 800ac32:	f6c0 0301 	movt	r3, #2049	; 0x801
 800ac36:	6513      	str	r3, [r2, #80]	; 0x50
 800ac38:	9b01      	ldr	r3, [sp, #4]
 800ac3a:	2202      	movs	r2, #2
 800ac3c:	655a      	str	r2, [r3, #84]	; 0x54
 800ac3e:	9b01      	ldr	r3, [sp, #4]
 800ac40:	2200      	movs	r2, #0
 800ac42:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800ac44:	2301      	movs	r3, #1
 800ac46:	e0a8      	b.n	800ad9a <default_handler.10033+0x3aa>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 800ac48:	9a01      	ldr	r2, [sp, #4]
 800ac4a:	f641 5350 	movw	r3, #7504	; 0x1d50
 800ac4e:	f6c0 0301 	movt	r3, #2049	; 0x801
 800ac52:	6513      	str	r3, [r2, #80]	; 0x50
 800ac54:	9b01      	ldr	r3, [sp, #4]
 800ac56:	2202      	movs	r2, #2
 800ac58:	655a      	str	r2, [r3, #84]	; 0x54
 800ac5a:	9b01      	ldr	r3, [sp, #4]
 800ac5c:	2200      	movs	r2, #0
 800ac5e:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800ac60:	2301      	movs	r3, #1
 800ac62:	e09a      	b.n	800ad9a <default_handler.10033+0x3aa>
      case EP_STATUS_DISABLED:
      default:
        return false;
 800ac64:	2300      	movs	r3, #0
 800ac66:	e098      	b.n	800ad9a <default_handler.10033+0x3aa>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 800ac68:	9b01      	ldr	r3, [sp, #4]
 800ac6a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800ac6e:	f003 030f 	and.w	r3, r3, #15
 800ac72:	b2db      	uxtb	r3, r3
 800ac74:	9801      	ldr	r0, [sp, #4]
 800ac76:	4619      	mov	r1, r3
 800ac78:	f7fc ffc2 	bl	8007c00 <usb_lld_get_status_out>
 800ac7c:	4603      	mov	r3, r0
 800ac7e:	2b01      	cmp	r3, #1
 800ac80:	d002      	beq.n	800ac88 <default_handler.10033+0x298>
 800ac82:	2b02      	cmp	r3, #2
 800ac84:	d00e      	beq.n	800aca4 <default_handler.10033+0x2b4>
 800ac86:	e01b      	b.n	800acc0 <default_handler.10033+0x2d0>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800ac88:	9a01      	ldr	r2, [sp, #4]
 800ac8a:	f641 5360 	movw	r3, #7520	; 0x1d60
 800ac8e:	f6c0 0301 	movt	r3, #2049	; 0x801
 800ac92:	6513      	str	r3, [r2, #80]	; 0x50
 800ac94:	9b01      	ldr	r3, [sp, #4]
 800ac96:	2202      	movs	r2, #2
 800ac98:	655a      	str	r2, [r3, #84]	; 0x54
 800ac9a:	9b01      	ldr	r3, [sp, #4]
 800ac9c:	2200      	movs	r2, #0
 800ac9e:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800aca0:	2301      	movs	r3, #1
 800aca2:	e07a      	b.n	800ad9a <default_handler.10033+0x3aa>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 800aca4:	9a01      	ldr	r2, [sp, #4]
 800aca6:	f641 5350 	movw	r3, #7504	; 0x1d50
 800acaa:	f6c0 0301 	movt	r3, #2049	; 0x801
 800acae:	6513      	str	r3, [r2, #80]	; 0x50
 800acb0:	9b01      	ldr	r3, [sp, #4]
 800acb2:	2202      	movs	r2, #2
 800acb4:	655a      	str	r2, [r3, #84]	; 0x54
 800acb6:	9b01      	ldr	r3, [sp, #4]
 800acb8:	2200      	movs	r2, #0
 800acba:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 800acbc:	2301      	movs	r3, #1
 800acbe:	e06c      	b.n	800ad9a <default_handler.10033+0x3aa>
      case EP_STATUS_DISABLED:
      default:
        return false;
 800acc0:	2300      	movs	r3, #0
 800acc2:	e06a      	b.n	800ad9a <default_handler.10033+0x3aa>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800acc4:	9b01      	ldr	r3, [sp, #4]
 800acc6:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800acca:	2b00      	cmp	r3, #0
 800accc:	d001      	beq.n	800acd2 <default_handler.10033+0x2e2>
      return false;
 800acce:	2300      	movs	r3, #0
 800acd0:	e063      	b.n	800ad9a <default_handler.10033+0x3aa>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800acd2:	9b01      	ldr	r3, [sp, #4]
 800acd4:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800acd8:	f003 030f 	and.w	r3, r3, #15
 800acdc:	2b00      	cmp	r3, #0
 800acde:	d01b      	beq.n	800ad18 <default_handler.10033+0x328>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800ace0:	9b01      	ldr	r3, [sp, #4]
 800ace2:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800ace6:	b2db      	uxtb	r3, r3
 800ace8:	b25b      	sxtb	r3, r3
 800acea:	2b00      	cmp	r3, #0
 800acec:	da0a      	bge.n	800ad04 <default_handler.10033+0x314>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 800acee:	9b01      	ldr	r3, [sp, #4]
 800acf0:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800acf4:	f003 030f 	and.w	r3, r3, #15
 800acf8:	b2db      	uxtb	r3, r3
 800acfa:	9801      	ldr	r0, [sp, #4]
 800acfc:	4619      	mov	r1, r3
 800acfe:	f7fd f987 	bl	8008010 <usb_lld_clear_in>
 800ad02:	e009      	b.n	800ad18 <default_handler.10033+0x328>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 800ad04:	9b01      	ldr	r3, [sp, #4]
 800ad06:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800ad0a:	f003 030f 	and.w	r3, r3, #15
 800ad0e:	b2db      	uxtb	r3, r3
 800ad10:	9801      	ldr	r0, [sp, #4]
 800ad12:	4619      	mov	r1, r3
 800ad14:	f7fd f95c 	bl	8007fd0 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800ad18:	9b01      	ldr	r3, [sp, #4]
 800ad1a:	2200      	movs	r2, #0
 800ad1c:	651a      	str	r2, [r3, #80]	; 0x50
 800ad1e:	9b01      	ldr	r3, [sp, #4]
 800ad20:	2200      	movs	r2, #0
 800ad22:	655a      	str	r2, [r3, #84]	; 0x54
 800ad24:	9b01      	ldr	r3, [sp, #4]
 800ad26:	2200      	movs	r2, #0
 800ad28:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800ad2a:	2301      	movs	r3, #1
 800ad2c:	e035      	b.n	800ad9a <default_handler.10033+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800ad2e:	9b01      	ldr	r3, [sp, #4]
 800ad30:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800ad34:	2b00      	cmp	r3, #0
 800ad36:	d001      	beq.n	800ad3c <default_handler.10033+0x34c>
      return false;
 800ad38:	2300      	movs	r3, #0
 800ad3a:	e02e      	b.n	800ad9a <default_handler.10033+0x3aa>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800ad3c:	9b01      	ldr	r3, [sp, #4]
 800ad3e:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800ad42:	f003 030f 	and.w	r3, r3, #15
 800ad46:	2b00      	cmp	r3, #0
 800ad48:	d01b      	beq.n	800ad82 <default_handler.10033+0x392>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 800ad4a:	9b01      	ldr	r3, [sp, #4]
 800ad4c:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800ad50:	b2db      	uxtb	r3, r3
 800ad52:	b25b      	sxtb	r3, r3
 800ad54:	2b00      	cmp	r3, #0
 800ad56:	da0a      	bge.n	800ad6e <default_handler.10033+0x37e>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 800ad58:	9b01      	ldr	r3, [sp, #4]
 800ad5a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800ad5e:	f003 030f 	and.w	r3, r3, #15
 800ad62:	b2db      	uxtb	r3, r3
 800ad64:	9801      	ldr	r0, [sp, #4]
 800ad66:	4619      	mov	r1, r3
 800ad68:	f7fd f912 	bl	8007f90 <usb_lld_stall_in>
 800ad6c:	e009      	b.n	800ad82 <default_handler.10033+0x392>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 800ad6e:	9b01      	ldr	r3, [sp, #4]
 800ad70:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800ad74:	f003 030f 	and.w	r3, r3, #15
 800ad78:	b2db      	uxtb	r3, r3
 800ad7a:	9801      	ldr	r0, [sp, #4]
 800ad7c:	4619      	mov	r1, r3
 800ad7e:	f7fd f8e7 	bl	8007f50 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800ad82:	9b01      	ldr	r3, [sp, #4]
 800ad84:	2200      	movs	r2, #0
 800ad86:	651a      	str	r2, [r3, #80]	; 0x50
 800ad88:	9b01      	ldr	r3, [sp, #4]
 800ad8a:	2200      	movs	r2, #0
 800ad8c:	655a      	str	r2, [r3, #84]	; 0x54
 800ad8e:	9b01      	ldr	r3, [sp, #4]
 800ad90:	2200      	movs	r2, #0
 800ad92:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800ad94:	2301      	movs	r3, #1
 800ad96:	e000      	b.n	800ad9a <default_handler.10033+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 800ad98:	2300      	movs	r3, #0
  }
}
 800ad9a:	4618      	mov	r0, r3
 800ad9c:	b004      	add	sp, #16
 800ad9e:	bd70      	pop	{r4, r5, r6, pc}

0800ada0 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 800ada0:	b508      	push	{r3, lr}

  usb_lld_init();
 800ada2:	f7fc fbe5 	bl	8007570 <usb_lld_init>
}
 800ada6:	bd08      	pop	{r3, pc}
 800ada8:	f3af 8000 	nop.w
 800adac:	f3af 8000 	nop.w

0800adb0 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 800adb0:	b084      	sub	sp, #16
 800adb2:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 800adb4:	9b01      	ldr	r3, [sp, #4]
 800adb6:	2201      	movs	r2, #1
 800adb8:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 800adba:	9b01      	ldr	r3, [sp, #4]
 800adbc:	2200      	movs	r2, #0
 800adbe:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 800adc0:	2300      	movs	r3, #0
 800adc2:	9303      	str	r3, [sp, #12]
 800adc4:	e00f      	b.n	800ade6 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 800adc6:	9a01      	ldr	r2, [sp, #4]
 800adc8:	9b03      	ldr	r3, [sp, #12]
 800adca:	3308      	adds	r3, #8
 800adcc:	009b      	lsls	r3, r3, #2
 800adce:	4413      	add	r3, r2
 800add0:	2200      	movs	r2, #0
 800add2:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 800add4:	9b01      	ldr	r3, [sp, #4]
 800add6:	9a03      	ldr	r2, [sp, #12]
 800add8:	320e      	adds	r2, #14
 800adda:	2100      	movs	r1, #0
 800addc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 800ade0:	9b03      	ldr	r3, [sp, #12]
 800ade2:	3301      	adds	r3, #1
 800ade4:	9303      	str	r3, [sp, #12]
 800ade6:	9b03      	ldr	r3, [sp, #12]
 800ade8:	2b04      	cmp	r3, #4
 800adea:	d9ec      	bls.n	800adc6 <usbObjectInit+0x16>
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 800adec:	9b01      	ldr	r3, [sp, #4]
 800adee:	2200      	movs	r2, #0
 800adf0:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 800adf2:	9b01      	ldr	r3, [sp, #4]
 800adf4:	2200      	movs	r2, #0
 800adf6:	815a      	strh	r2, [r3, #10]
}
 800adf8:	b004      	add	sp, #16
 800adfa:	4770      	bx	lr
 800adfc:	f3af 8000 	nop.w

0800ae00 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 800ae00:	b500      	push	{lr}
 800ae02:	b085      	sub	sp, #20
 800ae04:	9001      	str	r0, [sp, #4]
 800ae06:	9100      	str	r1, [sp, #0]
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));
 800ae08:	9b01      	ldr	r3, [sp, #4]
 800ae0a:	2b00      	cmp	r3, #0
 800ae0c:	d002      	beq.n	800ae14 <usbStart+0x14>
 800ae0e:	9b00      	ldr	r3, [sp, #0]
 800ae10:	2b00      	cmp	r3, #0
 800ae12:	d105      	bne.n	800ae20 <usbStart+0x20>
 800ae14:	f641 5070 	movw	r0, #7536	; 0x1d70
 800ae18:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ae1c:	f004 fab8 	bl	800f390 <chSysHalt>

  osalSysLock();
 800ae20:	f7ff fd8e 	bl	800a940 <osalSysLock.9757.4301>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 800ae24:	9b01      	ldr	r3, [sp, #4]
 800ae26:	781b      	ldrb	r3, [r3, #0]
 800ae28:	2b01      	cmp	r3, #1
 800ae2a:	d009      	beq.n	800ae40 <usbStart+0x40>
 800ae2c:	9b01      	ldr	r3, [sp, #4]
 800ae2e:	781b      	ldrb	r3, [r3, #0]
 800ae30:	2b02      	cmp	r3, #2
 800ae32:	d005      	beq.n	800ae40 <usbStart+0x40>
 800ae34:	f641 5070 	movw	r0, #7536	; 0x1d70
 800ae38:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ae3c:	f004 faa8 	bl	800f390 <chSysHalt>
                "invalid state");
  usbp->config = config;
 800ae40:	9b01      	ldr	r3, [sp, #4]
 800ae42:	9a00      	ldr	r2, [sp, #0]
 800ae44:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800ae46:	2300      	movs	r3, #0
 800ae48:	9303      	str	r3, [sp, #12]
 800ae4a:	e009      	b.n	800ae60 <usbStart+0x60>
    usbp->epc[i] = NULL;
 800ae4c:	9a01      	ldr	r2, [sp, #4]
 800ae4e:	9b03      	ldr	r3, [sp, #12]
 800ae50:	3302      	adds	r3, #2
 800ae52:	009b      	lsls	r3, r3, #2
 800ae54:	4413      	add	r3, r2
 800ae56:	2200      	movs	r2, #0
 800ae58:	605a      	str	r2, [r3, #4]

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 800ae5a:	9b03      	ldr	r3, [sp, #12]
 800ae5c:	3301      	adds	r3, #1
 800ae5e:	9303      	str	r3, [sp, #12]
 800ae60:	9b03      	ldr	r3, [sp, #12]
 800ae62:	2b05      	cmp	r3, #5
 800ae64:	d9f2      	bls.n	800ae4c <usbStart+0x4c>
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
 800ae66:	9801      	ldr	r0, [sp, #4]
 800ae68:	f7fc fbfa 	bl	8007660 <usb_lld_start>
  usbp->state = USB_READY;
 800ae6c:	9b01      	ldr	r3, [sp, #4]
 800ae6e:	2202      	movs	r2, #2
 800ae70:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 800ae72:	f7ff fd6d 	bl	800a950 <osalSysUnlock.9761.4299>
}
 800ae76:	b005      	add	sp, #20
 800ae78:	f85d fb04 	ldr.w	pc, [sp], #4
 800ae7c:	f3af 8000 	nop.w

0800ae80 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 800ae80:	b500      	push	{lr}
 800ae82:	b085      	sub	sp, #20
 800ae84:	9003      	str	r0, [sp, #12]
 800ae86:	9102      	str	r1, [sp, #8]
 800ae88:	9201      	str	r2, [sp, #4]
 800ae8a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 800ae8c:	9b03      	ldr	r3, [sp, #12]
 800ae8e:	4618      	mov	r0, r3
 800ae90:	f002 fcfe 	bl	800d890 <chThdQueueObjectInit.7943>
  iqp->q_counter = 0;
 800ae94:	9b03      	ldr	r3, [sp, #12]
 800ae96:	2200      	movs	r2, #0
 800ae98:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800ae9a:	9b03      	ldr	r3, [sp, #12]
 800ae9c:	9a02      	ldr	r2, [sp, #8]
 800ae9e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 800aea0:	9b03      	ldr	r3, [sp, #12]
 800aea2:	9a02      	ldr	r2, [sp, #8]
 800aea4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 800aea6:	9b03      	ldr	r3, [sp, #12]
 800aea8:	9a02      	ldr	r2, [sp, #8]
 800aeaa:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800aeac:	9a02      	ldr	r2, [sp, #8]
 800aeae:	9b01      	ldr	r3, [sp, #4]
 800aeb0:	441a      	add	r2, r3
 800aeb2:	9b03      	ldr	r3, [sp, #12]
 800aeb4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 800aeb6:	9b03      	ldr	r3, [sp, #12]
 800aeb8:	9a00      	ldr	r2, [sp, #0]
 800aeba:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800aebc:	9b03      	ldr	r3, [sp, #12]
 800aebe:	9a06      	ldr	r2, [sp, #24]
 800aec0:	621a      	str	r2, [r3, #32]
}
 800aec2:	b005      	add	sp, #20
 800aec4:	f85d fb04 	ldr.w	pc, [sp], #4
 800aec8:	f3af 8000 	nop.w
 800aecc:	f3af 8000 	nop.w

0800aed0 <chIQResetI>:
 *
 * @param[in] iqp       pointer to an @p input_queue_t structure
 *
 * @iclass
 */
void chIQResetI(input_queue_t *iqp) {
 800aed0:	b500      	push	{lr}
 800aed2:	b083      	sub	sp, #12
 800aed4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800aed6:	f004 fcd3 	bl	800f880 <chDbgCheckClassI>

  iqp->q_rdptr = iqp->q_buffer;
 800aeda:	9b01      	ldr	r3, [sp, #4]
 800aedc:	68da      	ldr	r2, [r3, #12]
 800aede:	9b01      	ldr	r3, [sp, #4]
 800aee0:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr = iqp->q_buffer;
 800aee2:	9b01      	ldr	r3, [sp, #4]
 800aee4:	68da      	ldr	r2, [r3, #12]
 800aee6:	9b01      	ldr	r3, [sp, #4]
 800aee8:	615a      	str	r2, [r3, #20]
  iqp->q_counter = 0;
 800aeea:	9b01      	ldr	r3, [sp, #4]
 800aeec:	2200      	movs	r2, #0
 800aeee:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 800aef0:	9b01      	ldr	r3, [sp, #4]
 800aef2:	4618      	mov	r0, r3
 800aef4:	f06f 0101 	mvn.w	r1, #1
 800aef8:	f002 fefa 	bl	800dcf0 <chThdDequeueAllI>
}
 800aefc:	b003      	add	sp, #12
 800aefe:	f85d fb04 	ldr.w	pc, [sp], #4
 800af02:	bf00      	nop
 800af04:	f3af 8000 	nop.w
 800af08:	f3af 8000 	nop.w
 800af0c:	f3af 8000 	nop.w

0800af10 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 800af10:	b500      	push	{lr}
 800af12:	b083      	sub	sp, #12
 800af14:	9001      	str	r0, [sp, #4]
 800af16:	460b      	mov	r3, r1
 800af18:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();
 800af1c:	f004 fcb0 	bl	800f880 <chDbgCheckClassI>

  if (chIQIsFullI(iqp)) {
 800af20:	9801      	ldr	r0, [sp, #4]
 800af22:	f002 fcd5 	bl	800d8d0 <chIQIsFullI.7946>
 800af26:	4603      	mov	r3, r0
 800af28:	2b00      	cmp	r3, #0
 800af2a:	d002      	beq.n	800af32 <chIQPutI+0x22>
    return Q_FULL;
 800af2c:	f06f 0303 	mvn.w	r3, #3
 800af30:	e01c      	b.n	800af6c <chIQPutI+0x5c>
  }

  iqp->q_counter++;
 800af32:	9b01      	ldr	r3, [sp, #4]
 800af34:	689b      	ldr	r3, [r3, #8]
 800af36:	1c5a      	adds	r2, r3, #1
 800af38:	9b01      	ldr	r3, [sp, #4]
 800af3a:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 800af3c:	9b01      	ldr	r3, [sp, #4]
 800af3e:	695b      	ldr	r3, [r3, #20]
 800af40:	1c59      	adds	r1, r3, #1
 800af42:	9a01      	ldr	r2, [sp, #4]
 800af44:	6151      	str	r1, [r2, #20]
 800af46:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800af4a:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 800af4c:	9b01      	ldr	r3, [sp, #4]
 800af4e:	695a      	ldr	r2, [r3, #20]
 800af50:	9b01      	ldr	r3, [sp, #4]
 800af52:	691b      	ldr	r3, [r3, #16]
 800af54:	429a      	cmp	r2, r3
 800af56:	d303      	bcc.n	800af60 <chIQPutI+0x50>
    iqp->q_wrptr = iqp->q_buffer;
 800af58:	9b01      	ldr	r3, [sp, #4]
 800af5a:	68da      	ldr	r2, [r3, #12]
 800af5c:	9b01      	ldr	r3, [sp, #4]
 800af5e:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 800af60:	9b01      	ldr	r3, [sp, #4]
 800af62:	4618      	mov	r0, r3
 800af64:	2100      	movs	r1, #0
 800af66:	f002 feab 	bl	800dcc0 <chThdDequeueNextI>

  return Q_OK;
 800af6a:	2300      	movs	r3, #0
}
 800af6c:	4618      	mov	r0, r3
 800af6e:	b003      	add	sp, #12
 800af70:	f85d fb04 	ldr.w	pc, [sp], #4
 800af74:	f3af 8000 	nop.w
 800af78:	f3af 8000 	nop.w
 800af7c:	f3af 8000 	nop.w

0800af80 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 800af80:	b500      	push	{lr}
 800af82:	b085      	sub	sp, #20
 800af84:	9001      	str	r0, [sp, #4]
 800af86:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 800af88:	f002 fc52 	bl	800d830 <chSysLock.7973>
  if (iqp->q_notify != NULL) {
 800af8c:	9b01      	ldr	r3, [sp, #4]
 800af8e:	69db      	ldr	r3, [r3, #28]
 800af90:	2b00      	cmp	r3, #0
 800af92:	d011      	beq.n	800afb8 <chIQGetTimeout+0x38>
    iqp->q_notify(iqp);
 800af94:	9b01      	ldr	r3, [sp, #4]
 800af96:	69db      	ldr	r3, [r3, #28]
 800af98:	9801      	ldr	r0, [sp, #4]
 800af9a:	4798      	blx	r3
 800af9c:	e00c      	b.n	800afb8 <chIQGetTimeout+0x38>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800af9e:	9b01      	ldr	r3, [sp, #4]
 800afa0:	4618      	mov	r0, r3
 800afa2:	9900      	ldr	r1, [sp, #0]
 800afa4:	f002 fe6c 	bl	800dc80 <chThdEnqueueTimeoutS>
 800afa8:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
 800afaa:	9b03      	ldr	r3, [sp, #12]
 800afac:	2b00      	cmp	r3, #0
 800afae:	da03      	bge.n	800afb8 <chIQGetTimeout+0x38>
      chSysUnlock();
 800afb0:	f002 fc46 	bl	800d840 <chSysUnlock.7975>
      return msg;
 800afb4:	9b03      	ldr	r3, [sp, #12]
 800afb6:	e020      	b.n	800affa <chIQGetTimeout+0x7a>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 800afb8:	9801      	ldr	r0, [sp, #4]
 800afba:	f002 fc79 	bl	800d8b0 <chIQIsEmptyI.7963>
 800afbe:	4603      	mov	r3, r0
 800afc0:	2b00      	cmp	r3, #0
 800afc2:	d1ec      	bne.n	800af9e <chIQGetTimeout+0x1e>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800afc4:	9b01      	ldr	r3, [sp, #4]
 800afc6:	689b      	ldr	r3, [r3, #8]
 800afc8:	1e5a      	subs	r2, r3, #1
 800afca:	9b01      	ldr	r3, [sp, #4]
 800afcc:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800afce:	9b01      	ldr	r3, [sp, #4]
 800afd0:	699b      	ldr	r3, [r3, #24]
 800afd2:	1c59      	adds	r1, r3, #1
 800afd4:	9a01      	ldr	r2, [sp, #4]
 800afd6:	6191      	str	r1, [r2, #24]
 800afd8:	781b      	ldrb	r3, [r3, #0]
 800afda:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 800afde:	9b01      	ldr	r3, [sp, #4]
 800afe0:	699a      	ldr	r2, [r3, #24]
 800afe2:	9b01      	ldr	r3, [sp, #4]
 800afe4:	691b      	ldr	r3, [r3, #16]
 800afe6:	429a      	cmp	r2, r3
 800afe8:	d303      	bcc.n	800aff2 <chIQGetTimeout+0x72>
    iqp->q_rdptr = iqp->q_buffer;
 800afea:	9b01      	ldr	r3, [sp, #4]
 800afec:	68da      	ldr	r2, [r3, #12]
 800afee:	9b01      	ldr	r3, [sp, #4]
 800aff0:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 800aff2:	f002 fc25 	bl	800d840 <chSysUnlock.7975>

  return (msg_t)b;
 800aff6:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800affa:	4618      	mov	r0, r3
 800affc:	b005      	add	sp, #20
 800affe:	f85d fb04 	ldr.w	pc, [sp], #4
 800b002:	bf00      	nop
 800b004:	f3af 8000 	nop.w
 800b008:	f3af 8000 	nop.w
 800b00c:	f3af 8000 	nop.w

0800b010 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 800b010:	b500      	push	{lr}
 800b012:	b087      	sub	sp, #28
 800b014:	9003      	str	r0, [sp, #12]
 800b016:	9102      	str	r1, [sp, #8]
 800b018:	9201      	str	r2, [sp, #4]
 800b01a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 800b01c:	9b03      	ldr	r3, [sp, #12]
 800b01e:	69db      	ldr	r3, [r3, #28]
 800b020:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 800b022:	2300      	movs	r3, #0
 800b024:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
 800b026:	9b01      	ldr	r3, [sp, #4]
 800b028:	2b00      	cmp	r3, #0
 800b02a:	d105      	bne.n	800b038 <chIQReadTimeout+0x28>
 800b02c:	f641 20f0 	movw	r0, #6896	; 0x1af0
 800b030:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b034:	f004 f9ac 	bl	800f390 <chSysHalt>

  chSysLock();
 800b038:	f002 fbfa 	bl	800d830 <chSysLock.7973>
  while (true) {
    if (nfy != NULL) {
 800b03c:	9b04      	ldr	r3, [sp, #16]
 800b03e:	2b00      	cmp	r3, #0
 800b040:	d00f      	beq.n	800b062 <chIQReadTimeout+0x52>
      nfy(iqp);
 800b042:	9b04      	ldr	r3, [sp, #16]
 800b044:	9803      	ldr	r0, [sp, #12]
 800b046:	4798      	blx	r3
 800b048:	e00b      	b.n	800b062 <chIQReadTimeout+0x52>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800b04a:	9b03      	ldr	r3, [sp, #12]
 800b04c:	4618      	mov	r0, r3
 800b04e:	9900      	ldr	r1, [sp, #0]
 800b050:	f002 fe16 	bl	800dc80 <chThdEnqueueTimeoutS>
 800b054:	4603      	mov	r3, r0
 800b056:	2b00      	cmp	r3, #0
 800b058:	d003      	beq.n	800b062 <chIQReadTimeout+0x52>
        chSysUnlock();
 800b05a:	f002 fbf1 	bl	800d840 <chSysUnlock.7975>
        return r;
 800b05e:	9b05      	ldr	r3, [sp, #20]
 800b060:	e02e      	b.n	800b0c0 <chIQReadTimeout+0xb0>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 800b062:	9803      	ldr	r0, [sp, #12]
 800b064:	f002 fc24 	bl	800d8b0 <chIQIsEmptyI.7963>
 800b068:	4603      	mov	r3, r0
 800b06a:	2b00      	cmp	r3, #0
 800b06c:	d1ed      	bne.n	800b04a <chIQReadTimeout+0x3a>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800b06e:	9b03      	ldr	r3, [sp, #12]
 800b070:	689b      	ldr	r3, [r3, #8]
 800b072:	1e5a      	subs	r2, r3, #1
 800b074:	9b03      	ldr	r3, [sp, #12]
 800b076:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 800b078:	9b02      	ldr	r3, [sp, #8]
 800b07a:	1c5a      	adds	r2, r3, #1
 800b07c:	9202      	str	r2, [sp, #8]
 800b07e:	9a03      	ldr	r2, [sp, #12]
 800b080:	6992      	ldr	r2, [r2, #24]
 800b082:	1c50      	adds	r0, r2, #1
 800b084:	9903      	ldr	r1, [sp, #12]
 800b086:	6188      	str	r0, [r1, #24]
 800b088:	7812      	ldrb	r2, [r2, #0]
 800b08a:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 800b08c:	9b03      	ldr	r3, [sp, #12]
 800b08e:	699a      	ldr	r2, [r3, #24]
 800b090:	9b03      	ldr	r3, [sp, #12]
 800b092:	691b      	ldr	r3, [r3, #16]
 800b094:	429a      	cmp	r2, r3
 800b096:	d303      	bcc.n	800b0a0 <chIQReadTimeout+0x90>
      iqp->q_rdptr = iqp->q_buffer;
 800b098:	9b03      	ldr	r3, [sp, #12]
 800b09a:	68da      	ldr	r2, [r3, #12]
 800b09c:	9b03      	ldr	r3, [sp, #12]
 800b09e:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 800b0a0:	f002 fbce 	bl	800d840 <chSysUnlock.7975>

    r++;
 800b0a4:	9b05      	ldr	r3, [sp, #20]
 800b0a6:	3301      	adds	r3, #1
 800b0a8:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 800b0aa:	9b01      	ldr	r3, [sp, #4]
 800b0ac:	3b01      	subs	r3, #1
 800b0ae:	9301      	str	r3, [sp, #4]
 800b0b0:	9b01      	ldr	r3, [sp, #4]
 800b0b2:	2b00      	cmp	r3, #0
 800b0b4:	d101      	bne.n	800b0ba <chIQReadTimeout+0xaa>
      return r;
 800b0b6:	9b05      	ldr	r3, [sp, #20]
 800b0b8:	e002      	b.n	800b0c0 <chIQReadTimeout+0xb0>
    }

    chSysLock();
 800b0ba:	f002 fbb9 	bl	800d830 <chSysLock.7973>
 800b0be:	e7bd      	b.n	800b03c <chIQReadTimeout+0x2c>
  }
}
 800b0c0:	4618      	mov	r0, r3
 800b0c2:	b007      	add	sp, #28
 800b0c4:	f85d fb04 	ldr.w	pc, [sp], #4
 800b0c8:	f3af 8000 	nop.w
 800b0cc:	f3af 8000 	nop.w

0800b0d0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 800b0d0:	b500      	push	{lr}
 800b0d2:	b085      	sub	sp, #20
 800b0d4:	9003      	str	r0, [sp, #12]
 800b0d6:	9102      	str	r1, [sp, #8]
 800b0d8:	9201      	str	r2, [sp, #4]
 800b0da:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 800b0dc:	9b03      	ldr	r3, [sp, #12]
 800b0de:	4618      	mov	r0, r3
 800b0e0:	f002 fbd6 	bl	800d890 <chThdQueueObjectInit.7943>
  oqp->q_counter = size;
 800b0e4:	9b03      	ldr	r3, [sp, #12]
 800b0e6:	9a01      	ldr	r2, [sp, #4]
 800b0e8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800b0ea:	9b03      	ldr	r3, [sp, #12]
 800b0ec:	9a02      	ldr	r2, [sp, #8]
 800b0ee:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 800b0f0:	9b03      	ldr	r3, [sp, #12]
 800b0f2:	9a02      	ldr	r2, [sp, #8]
 800b0f4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 800b0f6:	9b03      	ldr	r3, [sp, #12]
 800b0f8:	9a02      	ldr	r2, [sp, #8]
 800b0fa:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800b0fc:	9a02      	ldr	r2, [sp, #8]
 800b0fe:	9b01      	ldr	r3, [sp, #4]
 800b100:	441a      	add	r2, r3
 800b102:	9b03      	ldr	r3, [sp, #12]
 800b104:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 800b106:	9b03      	ldr	r3, [sp, #12]
 800b108:	9a00      	ldr	r2, [sp, #0]
 800b10a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800b10c:	9b03      	ldr	r3, [sp, #12]
 800b10e:	9a06      	ldr	r2, [sp, #24]
 800b110:	621a      	str	r2, [r3, #32]
}
 800b112:	b005      	add	sp, #20
 800b114:	f85d fb04 	ldr.w	pc, [sp], #4
 800b118:	f3af 8000 	nop.w
 800b11c:	f3af 8000 	nop.w

0800b120 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {
 800b120:	b500      	push	{lr}
 800b122:	b083      	sub	sp, #12
 800b124:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800b126:	f004 fbab 	bl	800f880 <chDbgCheckClassI>

  oqp->q_rdptr = oqp->q_buffer;
 800b12a:	9b01      	ldr	r3, [sp, #4]
 800b12c:	68da      	ldr	r2, [r3, #12]
 800b12e:	9b01      	ldr	r3, [sp, #4]
 800b130:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr = oqp->q_buffer;
 800b132:	9b01      	ldr	r3, [sp, #4]
 800b134:	68da      	ldr	r2, [r3, #12]
 800b136:	9b01      	ldr	r3, [sp, #4]
 800b138:	615a      	str	r2, [r3, #20]
  oqp->q_counter = chQSizeX(oqp);
 800b13a:	9b01      	ldr	r3, [sp, #4]
 800b13c:	691b      	ldr	r3, [r3, #16]
 800b13e:	461a      	mov	r2, r3
 800b140:	9b01      	ldr	r3, [sp, #4]
 800b142:	68db      	ldr	r3, [r3, #12]
 800b144:	1ad3      	subs	r3, r2, r3
 800b146:	461a      	mov	r2, r3
 800b148:	9b01      	ldr	r3, [sp, #4]
 800b14a:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 800b14c:	9b01      	ldr	r3, [sp, #4]
 800b14e:	4618      	mov	r0, r3
 800b150:	f06f 0101 	mvn.w	r1, #1
 800b154:	f002 fdcc 	bl	800dcf0 <chThdDequeueAllI>
}
 800b158:	b003      	add	sp, #12
 800b15a:	f85d fb04 	ldr.w	pc, [sp], #4
 800b15e:	bf00      	nop

0800b160 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 800b160:	b500      	push	{lr}
 800b162:	b087      	sub	sp, #28
 800b164:	9003      	str	r0, [sp, #12]
 800b166:	460b      	mov	r3, r1
 800b168:	9201      	str	r2, [sp, #4]
 800b16a:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
 800b16e:	f002 fb5f 	bl	800d830 <chSysLock.7973>
 800b172:	e00c      	b.n	800b18e <chOQPutTimeout+0x2e>
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 800b174:	9b03      	ldr	r3, [sp, #12]
 800b176:	4618      	mov	r0, r3
 800b178:	9901      	ldr	r1, [sp, #4]
 800b17a:	f002 fd81 	bl	800dc80 <chThdEnqueueTimeoutS>
 800b17e:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
 800b180:	9b05      	ldr	r3, [sp, #20]
 800b182:	2b00      	cmp	r3, #0
 800b184:	da03      	bge.n	800b18e <chOQPutTimeout+0x2e>
      chSysUnlock();
 800b186:	f002 fb5b 	bl	800d840 <chSysUnlock.7975>
      return msg;
 800b18a:	9b05      	ldr	r3, [sp, #20]
 800b18c:	e027      	b.n	800b1de <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800b18e:	9803      	ldr	r0, [sp, #12]
 800b190:	f002 fbde 	bl	800d950 <chOQIsFullI.7966>
 800b194:	4603      	mov	r3, r0
 800b196:	2b00      	cmp	r3, #0
 800b198:	d1ec      	bne.n	800b174 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800b19a:	9b03      	ldr	r3, [sp, #12]
 800b19c:	689b      	ldr	r3, [r3, #8]
 800b19e:	1e5a      	subs	r2, r3, #1
 800b1a0:	9b03      	ldr	r3, [sp, #12]
 800b1a2:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 800b1a4:	9b03      	ldr	r3, [sp, #12]
 800b1a6:	695b      	ldr	r3, [r3, #20]
 800b1a8:	1c59      	adds	r1, r3, #1
 800b1aa:	9a03      	ldr	r2, [sp, #12]
 800b1ac:	6151      	str	r1, [r2, #20]
 800b1ae:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800b1b2:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 800b1b4:	9b03      	ldr	r3, [sp, #12]
 800b1b6:	695a      	ldr	r2, [r3, #20]
 800b1b8:	9b03      	ldr	r3, [sp, #12]
 800b1ba:	691b      	ldr	r3, [r3, #16]
 800b1bc:	429a      	cmp	r2, r3
 800b1be:	d303      	bcc.n	800b1c8 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
 800b1c0:	9b03      	ldr	r3, [sp, #12]
 800b1c2:	68da      	ldr	r2, [r3, #12]
 800b1c4:	9b03      	ldr	r3, [sp, #12]
 800b1c6:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 800b1c8:	9b03      	ldr	r3, [sp, #12]
 800b1ca:	69db      	ldr	r3, [r3, #28]
 800b1cc:	2b00      	cmp	r3, #0
 800b1ce:	d003      	beq.n	800b1d8 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
 800b1d0:	9b03      	ldr	r3, [sp, #12]
 800b1d2:	69db      	ldr	r3, [r3, #28]
 800b1d4:	9803      	ldr	r0, [sp, #12]
 800b1d6:	4798      	blx	r3
  }
  chSysUnlock();
 800b1d8:	f002 fb32 	bl	800d840 <chSysUnlock.7975>

  return Q_OK;
 800b1dc:	2300      	movs	r3, #0
}
 800b1de:	4618      	mov	r0, r3
 800b1e0:	b007      	add	sp, #28
 800b1e2:	f85d fb04 	ldr.w	pc, [sp], #4
 800b1e6:	bf00      	nop
 800b1e8:	f3af 8000 	nop.w
 800b1ec:	f3af 8000 	nop.w

0800b1f0 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 800b1f0:	b500      	push	{lr}
 800b1f2:	b085      	sub	sp, #20
 800b1f4:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();
 800b1f6:	f004 fb43 	bl	800f880 <chDbgCheckClassI>

  if (chOQIsEmptyI(oqp)) {
 800b1fa:	9801      	ldr	r0, [sp, #4]
 800b1fc:	f002 fb88 	bl	800d910 <chOQIsEmptyI.7970>
 800b200:	4603      	mov	r3, r0
 800b202:	2b00      	cmp	r3, #0
 800b204:	d002      	beq.n	800b20c <chOQGetI+0x1c>
    return Q_EMPTY;
 800b206:	f06f 0302 	mvn.w	r3, #2
 800b20a:	e01d      	b.n	800b248 <chOQGetI+0x58>
  }

  oqp->q_counter++;
 800b20c:	9b01      	ldr	r3, [sp, #4]
 800b20e:	689b      	ldr	r3, [r3, #8]
 800b210:	1c5a      	adds	r2, r3, #1
 800b212:	9b01      	ldr	r3, [sp, #4]
 800b214:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 800b216:	9b01      	ldr	r3, [sp, #4]
 800b218:	699b      	ldr	r3, [r3, #24]
 800b21a:	1c59      	adds	r1, r3, #1
 800b21c:	9a01      	ldr	r2, [sp, #4]
 800b21e:	6191      	str	r1, [r2, #24]
 800b220:	781b      	ldrb	r3, [r3, #0]
 800b222:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 800b226:	9b01      	ldr	r3, [sp, #4]
 800b228:	699a      	ldr	r2, [r3, #24]
 800b22a:	9b01      	ldr	r3, [sp, #4]
 800b22c:	691b      	ldr	r3, [r3, #16]
 800b22e:	429a      	cmp	r2, r3
 800b230:	d303      	bcc.n	800b23a <chOQGetI+0x4a>
    oqp->q_rdptr = oqp->q_buffer;
 800b232:	9b01      	ldr	r3, [sp, #4]
 800b234:	68da      	ldr	r2, [r3, #12]
 800b236:	9b01      	ldr	r3, [sp, #4]
 800b238:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 800b23a:	9b01      	ldr	r3, [sp, #4]
 800b23c:	4618      	mov	r0, r3
 800b23e:	2100      	movs	r1, #0
 800b240:	f002 fd3e 	bl	800dcc0 <chThdDequeueNextI>

  return (msg_t)b;
 800b244:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800b248:	4618      	mov	r0, r3
 800b24a:	b005      	add	sp, #20
 800b24c:	f85d fb04 	ldr.w	pc, [sp], #4

0800b250 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 800b250:	b500      	push	{lr}
 800b252:	b087      	sub	sp, #28
 800b254:	9003      	str	r0, [sp, #12]
 800b256:	9102      	str	r1, [sp, #8]
 800b258:	9201      	str	r2, [sp, #4]
 800b25a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 800b25c:	9b03      	ldr	r3, [sp, #12]
 800b25e:	69db      	ldr	r3, [r3, #28]
 800b260:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 800b262:	2300      	movs	r3, #0
 800b264:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
 800b266:	9b01      	ldr	r3, [sp, #4]
 800b268:	2b00      	cmp	r3, #0
 800b26a:	d105      	bne.n	800b278 <chOQWriteTimeout+0x28>
 800b26c:	f641 3000 	movw	r0, #6912	; 0x1b00
 800b270:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b274:	f004 f88c 	bl	800f390 <chSysHalt>

  chSysLock();
 800b278:	f002 fada 	bl	800d830 <chSysLock.7973>
 800b27c:	e00b      	b.n	800b296 <chOQWriteTimeout+0x46>
  while (true) {
    while (chOQIsFullI(oqp)) {
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 800b27e:	9b03      	ldr	r3, [sp, #12]
 800b280:	4618      	mov	r0, r3
 800b282:	9900      	ldr	r1, [sp, #0]
 800b284:	f002 fcfc 	bl	800dc80 <chThdEnqueueTimeoutS>
 800b288:	4603      	mov	r3, r0
 800b28a:	2b00      	cmp	r3, #0
 800b28c:	d003      	beq.n	800b296 <chOQWriteTimeout+0x46>
        chSysUnlock();
 800b28e:	f002 fad7 	bl	800d840 <chSysUnlock.7975>
        return w;
 800b292:	9b05      	ldr	r3, [sp, #20]
 800b294:	e034      	b.n	800b300 <chOQWriteTimeout+0xb0>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800b296:	9803      	ldr	r0, [sp, #12]
 800b298:	f002 fb5a 	bl	800d950 <chOQIsFullI.7966>
 800b29c:	4603      	mov	r3, r0
 800b29e:	2b00      	cmp	r3, #0
 800b2a0:	d1ed      	bne.n	800b27e <chOQWriteTimeout+0x2e>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800b2a2:	9b03      	ldr	r3, [sp, #12]
 800b2a4:	689b      	ldr	r3, [r3, #8]
 800b2a6:	1e5a      	subs	r2, r3, #1
 800b2a8:	9b03      	ldr	r3, [sp, #12]
 800b2aa:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 800b2ac:	9b03      	ldr	r3, [sp, #12]
 800b2ae:	695b      	ldr	r3, [r3, #20]
 800b2b0:	1c59      	adds	r1, r3, #1
 800b2b2:	9a03      	ldr	r2, [sp, #12]
 800b2b4:	6151      	str	r1, [r2, #20]
 800b2b6:	9a02      	ldr	r2, [sp, #8]
 800b2b8:	1c51      	adds	r1, r2, #1
 800b2ba:	9102      	str	r1, [sp, #8]
 800b2bc:	7812      	ldrb	r2, [r2, #0]
 800b2be:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800b2c0:	9b03      	ldr	r3, [sp, #12]
 800b2c2:	695a      	ldr	r2, [r3, #20]
 800b2c4:	9b03      	ldr	r3, [sp, #12]
 800b2c6:	691b      	ldr	r3, [r3, #16]
 800b2c8:	429a      	cmp	r2, r3
 800b2ca:	d303      	bcc.n	800b2d4 <chOQWriteTimeout+0x84>
      oqp->q_wrptr = oqp->q_buffer;
 800b2cc:	9b03      	ldr	r3, [sp, #12]
 800b2ce:	68da      	ldr	r2, [r3, #12]
 800b2d0:	9b03      	ldr	r3, [sp, #12]
 800b2d2:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 800b2d4:	9b04      	ldr	r3, [sp, #16]
 800b2d6:	2b00      	cmp	r3, #0
 800b2d8:	d002      	beq.n	800b2e0 <chOQWriteTimeout+0x90>
      nfy(oqp);
 800b2da:	9b04      	ldr	r3, [sp, #16]
 800b2dc:	9803      	ldr	r0, [sp, #12]
 800b2de:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 800b2e0:	f002 faae 	bl	800d840 <chSysUnlock.7975>

    w++;
 800b2e4:	9b05      	ldr	r3, [sp, #20]
 800b2e6:	3301      	adds	r3, #1
 800b2e8:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 800b2ea:	9b01      	ldr	r3, [sp, #4]
 800b2ec:	3b01      	subs	r3, #1
 800b2ee:	9301      	str	r3, [sp, #4]
 800b2f0:	9b01      	ldr	r3, [sp, #4]
 800b2f2:	2b00      	cmp	r3, #0
 800b2f4:	d101      	bne.n	800b2fa <chOQWriteTimeout+0xaa>
      return w;
 800b2f6:	9b05      	ldr	r3, [sp, #20]
 800b2f8:	e002      	b.n	800b300 <chOQWriteTimeout+0xb0>
    }
    chSysLock();
 800b2fa:	f002 fa99 	bl	800d830 <chSysLock.7973>
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  chDbgCheck(n > 0U);

  chSysLock();
 800b2fe:	e7ca      	b.n	800b296 <chOQWriteTimeout+0x46>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 800b300:	4618      	mov	r0, r3
 800b302:	b007      	add	sp, #28
 800b304:	f85d fb04 	ldr.w	pc, [sp], #4
 800b308:	f3af 8000 	nop.w
 800b30c:	f3af 8000 	nop.w

0800b310 <port_lock.8109.4376>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b310:	b082      	sub	sp, #8
 800b312:	2320      	movs	r3, #32
 800b314:	9301      	str	r3, [sp, #4]
 800b316:	9b01      	ldr	r3, [sp, #4]
 800b318:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b31c:	b002      	add	sp, #8
 800b31e:	4770      	bx	lr

0800b320 <port_unlock.8112.4374>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b320:	b082      	sub	sp, #8
 800b322:	2300      	movs	r3, #0
 800b324:	9301      	str	r3, [sp, #4]
 800b326:	9b01      	ldr	r3, [sp, #4]
 800b328:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b32c:	b002      	add	sp, #8
 800b32e:	4770      	bx	lr

0800b330 <chSysLock.8114.4372>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800b330:	b508      	push	{r3, lr}

  port_lock();
 800b332:	f7ff ffed 	bl	800b310 <port_lock.8109.4376>
  _stats_start_measure_crit_thd();
 800b336:	f002 fe23 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800b33a:	f004 f9d1 	bl	800f6e0 <_dbg_check_lock>
}
 800b33e:	bd08      	pop	{r3, pc}

0800b340 <chSysUnlock.8116.4370>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800b340:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800b342:	f004 f9ed 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800b346:	f002 fe23 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800b34a:	f640 5350 	movw	r3, #3408	; 0xd50
 800b34e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b352:	681a      	ldr	r2, [r3, #0]
 800b354:	f640 5350 	movw	r3, #3408	; 0xd50
 800b358:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b35c:	429a      	cmp	r2, r3
 800b35e:	d013      	beq.n	800b388 <chSysUnlock.8116.4370+0x48>
 800b360:	f640 5350 	movw	r3, #3408	; 0xd50
 800b364:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b368:	699b      	ldr	r3, [r3, #24]
 800b36a:	689a      	ldr	r2, [r3, #8]
 800b36c:	f640 5350 	movw	r3, #3408	; 0xd50
 800b370:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b374:	681b      	ldr	r3, [r3, #0]
 800b376:	689b      	ldr	r3, [r3, #8]
 800b378:	429a      	cmp	r2, r3
 800b37a:	d205      	bcs.n	800b388 <chSysUnlock.8116.4370+0x48>
 800b37c:	f641 3020 	movw	r0, #6944	; 0x1b20
 800b380:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b384:	f004 f804 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800b388:	f7ff ffca 	bl	800b320 <port_unlock.8112.4374>
}
 800b38c:	bd08      	pop	{r3, pc}
 800b38e:	bf00      	nop

0800b390 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 800b390:	f242 5378 	movw	r3, #9592	; 0x2578
 800b394:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b398:	3307      	adds	r3, #7
 800b39a:	f023 0307 	bic.w	r3, r3, #7
 800b39e:	461a      	mov	r2, r3
 800b3a0:	f241 3328 	movw	r3, #4904	; 0x1328
 800b3a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b3a8:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800b3aa:	f240 0300 	movw	r3, #0
 800b3ae:	f2c2 0302 	movt	r3, #8194	; 0x2002
 800b3b2:	f023 0307 	bic.w	r3, r3, #7
 800b3b6:	461a      	mov	r2, r3
 800b3b8:	f241 332c 	movw	r3, #4908	; 0x132c
 800b3bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b3c0:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 800b3c2:	4770      	bx	lr
 800b3c4:	f3af 8000 	nop.w
 800b3c8:	f3af 8000 	nop.w
 800b3cc:	f3af 8000 	nop.w

0800b3d0 <chCoreAlloc.4359>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 800b3d0:	b500      	push	{lr}
 800b3d2:	b085      	sub	sp, #20
 800b3d4:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 800b3d6:	f7ff ffab 	bl	800b330 <chSysLock.8114.4372>
  p = chCoreAllocI(size);
 800b3da:	9801      	ldr	r0, [sp, #4]
 800b3dc:	f000 f808 	bl	800b3f0 <chCoreAllocI.4365>
 800b3e0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 800b3e2:	f7ff ffad 	bl	800b340 <chSysUnlock.8116.4370>

  return p;
 800b3e6:	9b03      	ldr	r3, [sp, #12]
}
 800b3e8:	4618      	mov	r0, r3
 800b3ea:	b005      	add	sp, #20
 800b3ec:	f85d fb04 	ldr.w	pc, [sp], #4

0800b3f0 <chCoreAllocI.4365>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 800b3f0:	b500      	push	{lr}
 800b3f2:	b085      	sub	sp, #20
 800b3f4:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();
 800b3f6:	f004 fa43 	bl	800f880 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
 800b3fa:	9b01      	ldr	r3, [sp, #4]
 800b3fc:	3307      	adds	r3, #7
 800b3fe:	f023 0307 	bic.w	r3, r3, #7
 800b402:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800b404:	f241 332c 	movw	r3, #4908	; 0x132c
 800b408:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b40c:	681b      	ldr	r3, [r3, #0]
 800b40e:	461a      	mov	r2, r3
 800b410:	f241 3328 	movw	r3, #4904	; 0x1328
 800b414:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b418:	681b      	ldr	r3, [r3, #0]
 800b41a:	1ad3      	subs	r3, r2, r3
 800b41c:	461a      	mov	r2, r3
 800b41e:	9b01      	ldr	r3, [sp, #4]
 800b420:	429a      	cmp	r2, r3
 800b422:	d201      	bcs.n	800b428 <chCoreAllocI.4365+0x38>
  /*lint -restore*/
    return NULL;
 800b424:	2300      	movs	r3, #0
 800b426:	e012      	b.n	800b44e <chCoreAllocI.4365+0x5e>
  }
  p = nextmem;
 800b428:	f241 3328 	movw	r3, #4904	; 0x1328
 800b42c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b430:	681b      	ldr	r3, [r3, #0]
 800b432:	9303      	str	r3, [sp, #12]
  nextmem += size;
 800b434:	f241 3328 	movw	r3, #4904	; 0x1328
 800b438:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b43c:	681a      	ldr	r2, [r3, #0]
 800b43e:	9b01      	ldr	r3, [sp, #4]
 800b440:	441a      	add	r2, r3
 800b442:	f241 3328 	movw	r3, #4904	; 0x1328
 800b446:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b44a:	601a      	str	r2, [r3, #0]

  return p;
 800b44c:	9b03      	ldr	r3, [sp, #12]
}
 800b44e:	4618      	mov	r0, r3
 800b450:	b005      	add	sp, #20
 800b452:	f85d fb04 	ldr.w	pc, [sp], #4
 800b456:	bf00      	nop
 800b458:	f3af 8000 	nop.w
 800b45c:	f3af 8000 	nop.w

0800b460 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 800b460:	f241 332c 	movw	r3, #4908	; 0x132c
 800b464:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b468:	681b      	ldr	r3, [r3, #0]
 800b46a:	461a      	mov	r2, r3
 800b46c:	f241 3328 	movw	r3, #4904	; 0x1328
 800b470:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b474:	681b      	ldr	r3, [r3, #0]
 800b476:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 800b478:	4618      	mov	r0, r3
 800b47a:	4770      	bx	lr
 800b47c:	f3af 8000 	nop.w

0800b480 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 800b480:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 800b482:	f241 3330 	movw	r3, #4912	; 0x1330
 800b486:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b48a:	f24b 32d1 	movw	r2, #46033	; 0xb3d1
 800b48e:	f6c0 0200 	movt	r2, #2048	; 0x800
 800b492:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 800b494:	f241 3330 	movw	r3, #4912	; 0x1330
 800b498:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b49c:	2200      	movs	r2, #0
 800b49e:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 800b4a0:	f241 3330 	movw	r3, #4912	; 0x1330
 800b4a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b4a8:	2200      	movs	r2, #0
 800b4aa:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 800b4ac:	4801      	ldr	r0, [pc, #4]	; (800b4b4 <_heap_init+0x34>)
 800b4ae:	f003 fbcf 	bl	800ec50 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 800b4b2:	bd08      	pop	{r3, pc}
 800b4b4:	20001340 	.word	0x20001340
 800b4b8:	f3af 8000 	nop.w
 800b4bc:	f3af 8000 	nop.w

0800b4c0 <chHeapObjectInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
 800b4c0:	b500      	push	{lr}
 800b4c2:	b087      	sub	sp, #28
 800b4c4:	9003      	str	r0, [sp, #12]
 800b4c6:	9102      	str	r1, [sp, #8]
 800b4c8:	9201      	str	r2, [sp, #4]
  union heap_header *hp = buf;
 800b4ca:	9b02      	ldr	r3, [sp, #8]
 800b4cc:	9305      	str	r3, [sp, #20]

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));
 800b4ce:	9b02      	ldr	r3, [sp, #8]
 800b4d0:	f003 0307 	and.w	r3, r3, #7
 800b4d4:	2b00      	cmp	r3, #0
 800b4d6:	d104      	bne.n	800b4e2 <chHeapObjectInit+0x22>
 800b4d8:	9b01      	ldr	r3, [sp, #4]
 800b4da:	f003 0307 	and.w	r3, r3, #7
 800b4de:	2b00      	cmp	r3, #0
 800b4e0:	d005      	beq.n	800b4ee <chHeapObjectInit+0x2e>
 800b4e2:	f641 3030 	movw	r0, #6960	; 0x1b30
 800b4e6:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b4ea:	f003 ff51 	bl	800f390 <chSysHalt>

  heapp->h_provider = NULL;
 800b4ee:	9b03      	ldr	r3, [sp, #12]
 800b4f0:	2200      	movs	r2, #0
 800b4f2:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
 800b4f4:	9b03      	ldr	r3, [sp, #12]
 800b4f6:	9a05      	ldr	r2, [sp, #20]
 800b4f8:	609a      	str	r2, [r3, #8]
  heapp->h_free.h.size = 0;
 800b4fa:	9b03      	ldr	r3, [sp, #12]
 800b4fc:	2200      	movs	r2, #0
 800b4fe:	60da      	str	r2, [r3, #12]
  hp->h.u.next = NULL;
 800b500:	9b05      	ldr	r3, [sp, #20]
 800b502:	2200      	movs	r2, #0
 800b504:	601a      	str	r2, [r3, #0]
  hp->h.size = size - sizeof(union heap_header);
 800b506:	9b01      	ldr	r3, [sp, #4]
 800b508:	f1a3 0208 	sub.w	r2, r3, #8
 800b50c:	9b05      	ldr	r3, [sp, #20]
 800b50e:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 800b510:	9b03      	ldr	r3, [sp, #12]
 800b512:	3310      	adds	r3, #16
 800b514:	4618      	mov	r0, r3
 800b516:	f003 fb9b 	bl	800ec50 <chMtxObjectInit>
#else
  chSemObjectInit(&heapp->h_sem, (cnt_t)1);
#endif
}
 800b51a:	b007      	add	sp, #28
 800b51c:	f85d fb04 	ldr.w	pc, [sp], #4

0800b520 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 800b520:	b500      	push	{lr}
 800b522:	b087      	sub	sp, #28
 800b524:	9001      	str	r0, [sp, #4]
 800b526:	9100      	str	r1, [sp, #0]
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
 800b528:	9b01      	ldr	r3, [sp, #4]
 800b52a:	2b00      	cmp	r3, #0
 800b52c:	d104      	bne.n	800b538 <chHeapAlloc+0x18>
    heapp = &default_heap;
 800b52e:	f241 3330 	movw	r3, #4912	; 0x1330
 800b532:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b536:	9301      	str	r3, [sp, #4]
  }

  size = MEM_ALIGN_NEXT(size);
 800b538:	9b00      	ldr	r3, [sp, #0]
 800b53a:	3307      	adds	r3, #7
 800b53c:	f023 0307 	bic.w	r3, r3, #7
 800b540:	9300      	str	r3, [sp, #0]
  qp = &heapp->h_free;
 800b542:	9b01      	ldr	r3, [sp, #4]
 800b544:	3308      	adds	r3, #8
 800b546:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 800b548:	9b01      	ldr	r3, [sp, #4]
 800b54a:	3310      	adds	r3, #16
 800b54c:	4618      	mov	r0, r3
 800b54e:	f003 fb97 	bl	800ec80 <chMtxLock>
 800b552:	e036      	b.n	800b5c2 <chHeapAlloc+0xa2>
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
 800b554:	9b05      	ldr	r3, [sp, #20]
 800b556:	681b      	ldr	r3, [r3, #0]
 800b558:	9304      	str	r3, [sp, #16]
    if (hp->h.size >= size) {
 800b55a:	9b04      	ldr	r3, [sp, #16]
 800b55c:	685a      	ldr	r2, [r3, #4]
 800b55e:	9b00      	ldr	r3, [sp, #0]
 800b560:	429a      	cmp	r2, r3
 800b562:	d32c      	bcc.n	800b5be <chHeapAlloc+0x9e>
      if (hp->h.size < (size + sizeof(union heap_header))) {
 800b564:	9b04      	ldr	r3, [sp, #16]
 800b566:	685a      	ldr	r2, [r3, #4]
 800b568:	9b00      	ldr	r3, [sp, #0]
 800b56a:	3308      	adds	r3, #8
 800b56c:	429a      	cmp	r2, r3
 800b56e:	d204      	bcs.n	800b57a <chHeapAlloc+0x5a>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 800b570:	9b04      	ldr	r3, [sp, #16]
 800b572:	681a      	ldr	r2, [r3, #0]
 800b574:	9b05      	ldr	r3, [sp, #20]
 800b576:	601a      	str	r2, [r3, #0]
 800b578:	e016      	b.n	800b5a8 <chHeapAlloc+0x88>
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 800b57a:	9b00      	ldr	r3, [sp, #0]
 800b57c:	3308      	adds	r3, #8
 800b57e:	9a04      	ldr	r2, [sp, #16]
 800b580:	4413      	add	r3, r2
 800b582:	9303      	str	r3, [sp, #12]
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 800b584:	9b04      	ldr	r3, [sp, #16]
 800b586:	681a      	ldr	r2, [r3, #0]
 800b588:	9b03      	ldr	r3, [sp, #12]
 800b58a:	601a      	str	r2, [r3, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 800b58c:	9b04      	ldr	r3, [sp, #16]
 800b58e:	685a      	ldr	r2, [r3, #4]
 800b590:	9b00      	ldr	r3, [sp, #0]
 800b592:	1ad3      	subs	r3, r2, r3
 800b594:	f1a3 0208 	sub.w	r2, r3, #8
 800b598:	9b03      	ldr	r3, [sp, #12]
 800b59a:	605a      	str	r2, [r3, #4]
        qp->h.u.next = fp;
 800b59c:	9b05      	ldr	r3, [sp, #20]
 800b59e:	9a03      	ldr	r2, [sp, #12]
 800b5a0:	601a      	str	r2, [r3, #0]
        hp->h.size = size;
 800b5a2:	9b04      	ldr	r3, [sp, #16]
 800b5a4:	9a00      	ldr	r2, [sp, #0]
 800b5a6:	605a      	str	r2, [r3, #4]
      }
      hp->h.u.heap = heapp;
 800b5a8:	9b04      	ldr	r3, [sp, #16]
 800b5aa:	9a01      	ldr	r2, [sp, #4]
 800b5ac:	601a      	str	r2, [r3, #0]
      H_UNLOCK(heapp);
 800b5ae:	9b01      	ldr	r3, [sp, #4]
 800b5b0:	3310      	adds	r3, #16
 800b5b2:	4618      	mov	r0, r3
 800b5b4:	f000 ff04 	bl	800c3c0 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)(hp + 1);
 800b5b8:	9b04      	ldr	r3, [sp, #16]
 800b5ba:	3308      	adds	r3, #8
 800b5bc:	e024      	b.n	800b608 <chHeapAlloc+0xe8>
      /*lint -restore*/
    }
    qp = hp;
 800b5be:	9b04      	ldr	r3, [sp, #16]
 800b5c0:	9305      	str	r3, [sp, #20]

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 800b5c2:	9b05      	ldr	r3, [sp, #20]
 800b5c4:	681b      	ldr	r3, [r3, #0]
 800b5c6:	2b00      	cmp	r3, #0
 800b5c8:	d1c4      	bne.n	800b554 <chHeapAlloc+0x34>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 800b5ca:	9b01      	ldr	r3, [sp, #4]
 800b5cc:	3310      	adds	r3, #16
 800b5ce:	4618      	mov	r0, r3
 800b5d0:	f000 fef6 	bl	800c3c0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 800b5d4:	9b01      	ldr	r3, [sp, #4]
 800b5d6:	681b      	ldr	r3, [r3, #0]
 800b5d8:	2b00      	cmp	r3, #0
 800b5da:	d014      	beq.n	800b606 <chHeapAlloc+0xe6>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 800b5dc:	9b01      	ldr	r3, [sp, #4]
 800b5de:	681b      	ldr	r3, [r3, #0]
 800b5e0:	9a00      	ldr	r2, [sp, #0]
 800b5e2:	3208      	adds	r2, #8
 800b5e4:	4610      	mov	r0, r2
 800b5e6:	4798      	blx	r3
 800b5e8:	9004      	str	r0, [sp, #16]
    if (hp != NULL) {
 800b5ea:	9b04      	ldr	r3, [sp, #16]
 800b5ec:	2b00      	cmp	r3, #0
 800b5ee:	d00a      	beq.n	800b606 <chHeapAlloc+0xe6>
      hp->h.u.heap = heapp;
 800b5f0:	9b04      	ldr	r3, [sp, #16]
 800b5f2:	9a01      	ldr	r2, [sp, #4]
 800b5f4:	601a      	str	r2, [r3, #0]
      hp->h.size = size;
 800b5f6:	9b04      	ldr	r3, [sp, #16]
 800b5f8:	9a00      	ldr	r2, [sp, #0]
 800b5fa:	605a      	str	r2, [r3, #4]
      hp++;
 800b5fc:	9b04      	ldr	r3, [sp, #16]
 800b5fe:	3308      	adds	r3, #8
 800b600:	9304      	str	r3, [sp, #16]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)hp;
 800b602:	9b04      	ldr	r3, [sp, #16]
 800b604:	e000      	b.n	800b608 <chHeapAlloc+0xe8>
      /*lint -restore*/
    }
  }

  return NULL;
 800b606:	2300      	movs	r3, #0
}
 800b608:	4618      	mov	r0, r3
 800b60a:	b007      	add	sp, #28
 800b60c:	f85d fb04 	ldr.w	pc, [sp], #4

0800b610 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 800b610:	b500      	push	{lr}
 800b612:	b087      	sub	sp, #28
 800b614:	9001      	str	r0, [sp, #4]
  union heap_header *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);
 800b616:	9b01      	ldr	r3, [sp, #4]
 800b618:	2b00      	cmp	r3, #0
 800b61a:	d105      	bne.n	800b628 <chHeapFree+0x18>
 800b61c:	f641 3050 	movw	r0, #6992	; 0x1b50
 800b620:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b624:	f003 feb4 	bl	800f390 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 800b628:	9b01      	ldr	r3, [sp, #4]
 800b62a:	3b08      	subs	r3, #8
 800b62c:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = hp->h.u.heap;
 800b62e:	9b04      	ldr	r3, [sp, #16]
 800b630:	681b      	ldr	r3, [r3, #0]
 800b632:	9303      	str	r3, [sp, #12]
  qp = &heapp->h_free;
 800b634:	9b03      	ldr	r3, [sp, #12]
 800b636:	3308      	adds	r3, #8
 800b638:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 800b63a:	9b03      	ldr	r3, [sp, #12]
 800b63c:	3310      	adds	r3, #16
 800b63e:	4618      	mov	r0, r3
 800b640:	f003 fb1e 	bl	800ec80 <chMtxLock>
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");
 800b644:	9a04      	ldr	r2, [sp, #16]
 800b646:	9b05      	ldr	r3, [sp, #20]
 800b648:	429a      	cmp	r2, r3
 800b64a:	d30d      	bcc.n	800b668 <chHeapFree+0x58>
 800b64c:	9b05      	ldr	r3, [sp, #20]
 800b64e:	685b      	ldr	r3, [r3, #4]
 800b650:	3308      	adds	r3, #8
 800b652:	9a05      	ldr	r2, [sp, #20]
 800b654:	441a      	add	r2, r3
 800b656:	9b04      	ldr	r3, [sp, #16]
 800b658:	429a      	cmp	r2, r3
 800b65a:	d905      	bls.n	800b668 <chHeapFree+0x58>
 800b65c:	f641 3050 	movw	r0, #6992	; 0x1b50
 800b660:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b664:	f003 fe94 	bl	800f390 <chSysHalt>

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 800b668:	9b03      	ldr	r3, [sp, #12]
 800b66a:	f103 0208 	add.w	r2, r3, #8
 800b66e:	9b05      	ldr	r3, [sp, #20]
 800b670:	429a      	cmp	r2, r3
 800b672:	d003      	beq.n	800b67c <chHeapFree+0x6c>
 800b674:	9a04      	ldr	r2, [sp, #16]
 800b676:	9b05      	ldr	r3, [sp, #20]
 800b678:	429a      	cmp	r2, r3
 800b67a:	d93d      	bls.n	800b6f8 <chHeapFree+0xe8>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 800b67c:	9b05      	ldr	r3, [sp, #20]
 800b67e:	681b      	ldr	r3, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 800b680:	2b00      	cmp	r3, #0
 800b682:	d004      	beq.n	800b68e <chHeapFree+0x7e>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 800b684:	9b05      	ldr	r3, [sp, #20]
 800b686:	681a      	ldr	r2, [r3, #0]
 800b688:	9b04      	ldr	r3, [sp, #16]
 800b68a:	429a      	cmp	r2, r3
 800b68c:	d934      	bls.n	800b6f8 <chHeapFree+0xe8>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 800b68e:	9b05      	ldr	r3, [sp, #20]
 800b690:	681a      	ldr	r2, [r3, #0]
 800b692:	9b04      	ldr	r3, [sp, #16]
 800b694:	601a      	str	r2, [r3, #0]
      qp->h.u.next = hp;
 800b696:	9b05      	ldr	r3, [sp, #20]
 800b698:	9a04      	ldr	r2, [sp, #16]
 800b69a:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 800b69c:	9b04      	ldr	r3, [sp, #16]
 800b69e:	685b      	ldr	r3, [r3, #4]
 800b6a0:	3308      	adds	r3, #8
 800b6a2:	9a04      	ldr	r2, [sp, #16]
 800b6a4:	441a      	add	r2, r3
 800b6a6:	9b04      	ldr	r3, [sp, #16]
 800b6a8:	681b      	ldr	r3, [r3, #0]
 800b6aa:	429a      	cmp	r2, r3
 800b6ac:	d10e      	bne.n	800b6cc <chHeapFree+0xbc>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 800b6ae:	9b04      	ldr	r3, [sp, #16]
 800b6b0:	685a      	ldr	r2, [r3, #4]
 800b6b2:	9b04      	ldr	r3, [sp, #16]
 800b6b4:	681b      	ldr	r3, [r3, #0]
 800b6b6:	685b      	ldr	r3, [r3, #4]
 800b6b8:	4413      	add	r3, r2
 800b6ba:	f103 0208 	add.w	r2, r3, #8
 800b6be:	9b04      	ldr	r3, [sp, #16]
 800b6c0:	605a      	str	r2, [r3, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 800b6c2:	9b04      	ldr	r3, [sp, #16]
 800b6c4:	681b      	ldr	r3, [r3, #0]
 800b6c6:	681a      	ldr	r2, [r3, #0]
 800b6c8:	9b04      	ldr	r3, [sp, #16]
 800b6ca:	601a      	str	r2, [r3, #0]
      }
      if ((LIMIT(qp) == hp)) {
 800b6cc:	9b05      	ldr	r3, [sp, #20]
 800b6ce:	685b      	ldr	r3, [r3, #4]
 800b6d0:	3308      	adds	r3, #8
 800b6d2:	9a05      	ldr	r2, [sp, #20]
 800b6d4:	441a      	add	r2, r3
 800b6d6:	9b04      	ldr	r3, [sp, #16]
 800b6d8:	429a      	cmp	r2, r3
 800b6da:	d111      	bne.n	800b700 <chHeapFree+0xf0>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 800b6dc:	9b05      	ldr	r3, [sp, #20]
 800b6de:	685a      	ldr	r2, [r3, #4]
 800b6e0:	9b04      	ldr	r3, [sp, #16]
 800b6e2:	685b      	ldr	r3, [r3, #4]
 800b6e4:	4413      	add	r3, r2
 800b6e6:	f103 0208 	add.w	r2, r3, #8
 800b6ea:	9b05      	ldr	r3, [sp, #20]
 800b6ec:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 800b6ee:	9b04      	ldr	r3, [sp, #16]
 800b6f0:	681a      	ldr	r2, [r3, #0]
 800b6f2:	9b05      	ldr	r3, [sp, #20]
 800b6f4:	601a      	str	r2, [r3, #0]
 800b6f6:	e003      	b.n	800b700 <chHeapFree+0xf0>
      }
      break;
    }
    qp = qp->h.u.next;
 800b6f8:	9b05      	ldr	r3, [sp, #20]
 800b6fa:	681b      	ldr	r3, [r3, #0]
 800b6fc:	9305      	str	r3, [sp, #20]
 800b6fe:	e7a1      	b.n	800b644 <chHeapFree+0x34>
  }
  H_UNLOCK(heapp);
 800b700:	9b03      	ldr	r3, [sp, #12]
 800b702:	3310      	adds	r3, #16
 800b704:	4618      	mov	r0, r3
 800b706:	f000 fe5b 	bl	800c3c0 <chMtxUnlock>

  return;
}
 800b70a:	b007      	add	sp, #28
 800b70c:	f85d fb04 	ldr.w	pc, [sp], #4

0800b710 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 800b710:	b500      	push	{lr}
 800b712:	b087      	sub	sp, #28
 800b714:	9001      	str	r0, [sp, #4]
 800b716:	9100      	str	r1, [sp, #0]
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
 800b718:	9b01      	ldr	r3, [sp, #4]
 800b71a:	2b00      	cmp	r3, #0
 800b71c:	d104      	bne.n	800b728 <chHeapStatus+0x18>
    heapp = &default_heap;
 800b71e:	f241 3330 	movw	r3, #4912	; 0x1330
 800b722:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b726:	9301      	str	r3, [sp, #4]
  }

  H_LOCK(heapp);
 800b728:	9b01      	ldr	r3, [sp, #4]
 800b72a:	3310      	adds	r3, #16
 800b72c:	4618      	mov	r0, r3
 800b72e:	f003 faa7 	bl	800ec80 <chMtxLock>
  sz = 0;
 800b732:	2300      	movs	r3, #0
 800b734:	9303      	str	r3, [sp, #12]
  n = 0;
 800b736:	2300      	movs	r3, #0
 800b738:	9304      	str	r3, [sp, #16]
  qp = &heapp->h_free;
 800b73a:	9b01      	ldr	r3, [sp, #4]
 800b73c:	3308      	adds	r3, #8
 800b73e:	9305      	str	r3, [sp, #20]
 800b740:	e00b      	b.n	800b75a <chHeapStatus+0x4a>
  while (qp->h.u.next != NULL) {
    sz += qp->h.u.next->h.size;
 800b742:	9b05      	ldr	r3, [sp, #20]
 800b744:	681b      	ldr	r3, [r3, #0]
 800b746:	685b      	ldr	r3, [r3, #4]
 800b748:	9a03      	ldr	r2, [sp, #12]
 800b74a:	4413      	add	r3, r2
 800b74c:	9303      	str	r3, [sp, #12]
    n++;
 800b74e:	9b04      	ldr	r3, [sp, #16]
 800b750:	3301      	adds	r3, #1
 800b752:	9304      	str	r3, [sp, #16]
    qp = qp->h.u.next;
 800b754:	9b05      	ldr	r3, [sp, #20]
 800b756:	681b      	ldr	r3, [r3, #0]
 800b758:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 800b75a:	9b05      	ldr	r3, [sp, #20]
 800b75c:	681b      	ldr	r3, [r3, #0]
 800b75e:	2b00      	cmp	r3, #0
 800b760:	d1ef      	bne.n	800b742 <chHeapStatus+0x32>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 800b762:	9b00      	ldr	r3, [sp, #0]
 800b764:	2b00      	cmp	r3, #0
 800b766:	d002      	beq.n	800b76e <chHeapStatus+0x5e>
    *sizep = sz;
 800b768:	9b00      	ldr	r3, [sp, #0]
 800b76a:	9a03      	ldr	r2, [sp, #12]
 800b76c:	601a      	str	r2, [r3, #0]
  }
  H_UNLOCK(heapp);
 800b76e:	9b01      	ldr	r3, [sp, #4]
 800b770:	3310      	adds	r3, #16
 800b772:	4618      	mov	r0, r3
 800b774:	f000 fe24 	bl	800c3c0 <chMtxUnlock>

  return n;
 800b778:	9b04      	ldr	r3, [sp, #16]
}
 800b77a:	4618      	mov	r0, r3
 800b77c:	b007      	add	sp, #28
 800b77e:	f85d fb04 	ldr.w	pc, [sp], #4
 800b782:	bf00      	nop
 800b784:	f3af 8000 	nop.w
 800b788:	f3af 8000 	nop.w
 800b78c:	f3af 8000 	nop.w

0800b790 <port_lock.8423.4324>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b790:	b082      	sub	sp, #8
 800b792:	2320      	movs	r3, #32
 800b794:	9301      	str	r3, [sp, #4]
 800b796:	9b01      	ldr	r3, [sp, #4]
 800b798:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b79c:	b002      	add	sp, #8
 800b79e:	4770      	bx	lr

0800b7a0 <port_unlock.8426.4322>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b7a0:	b082      	sub	sp, #8
 800b7a2:	2300      	movs	r3, #0
 800b7a4:	9301      	str	r3, [sp, #4]
 800b7a6:	9b01      	ldr	r3, [sp, #4]
 800b7a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b7ac:	b002      	add	sp, #8
 800b7ae:	4770      	bx	lr

0800b7b0 <chSysLock.8428.4320>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800b7b0:	b508      	push	{r3, lr}

  port_lock();
 800b7b2:	f7ff ffed 	bl	800b790 <port_lock.8423.4324>
  _stats_start_measure_crit_thd();
 800b7b6:	f002 fbe3 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800b7ba:	f003 ff91 	bl	800f6e0 <_dbg_check_lock>
}
 800b7be:	bd08      	pop	{r3, pc}

0800b7c0 <chSysUnlock.8430.4318>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800b7c0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800b7c2:	f003 ffad 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800b7c6:	f002 fbe3 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800b7ca:	f640 5350 	movw	r3, #3408	; 0xd50
 800b7ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7d2:	681a      	ldr	r2, [r3, #0]
 800b7d4:	f640 5350 	movw	r3, #3408	; 0xd50
 800b7d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7dc:	429a      	cmp	r2, r3
 800b7de:	d013      	beq.n	800b808 <chSysUnlock.8430.4318+0x48>
 800b7e0:	f640 5350 	movw	r3, #3408	; 0xd50
 800b7e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7e8:	699b      	ldr	r3, [r3, #24]
 800b7ea:	689a      	ldr	r2, [r3, #8]
 800b7ec:	f640 5350 	movw	r3, #3408	; 0xd50
 800b7f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800b7f4:	681b      	ldr	r3, [r3, #0]
 800b7f6:	689b      	ldr	r3, [r3, #8]
 800b7f8:	429a      	cmp	r2, r3
 800b7fa:	d205      	bcs.n	800b808 <chSysUnlock.8430.4318+0x48>
 800b7fc:	f641 30a0 	movw	r0, #7072	; 0x1ba0
 800b800:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b804:	f003 fdc4 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800b808:	f7ff ffca 	bl	800b7a0 <port_unlock.8426.4322>
}
 800b80c:	bd08      	pop	{r3, pc}
 800b80e:	bf00      	nop

0800b810 <chPoolAdd.8460.4314>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 800b810:	b500      	push	{lr}
 800b812:	b083      	sub	sp, #12
 800b814:	9001      	str	r0, [sp, #4]
 800b816:	9100      	str	r1, [sp, #0]

  chPoolFree(mp, objp);
 800b818:	9801      	ldr	r0, [sp, #4]
 800b81a:	9900      	ldr	r1, [sp, #0]
 800b81c:	f000 f8b0 	bl	800b980 <chPoolFree>
}
 800b820:	b003      	add	sp, #12
 800b822:	f85d fb04 	ldr.w	pc, [sp], #4
 800b826:	bf00      	nop
 800b828:	f3af 8000 	nop.w
 800b82c:	f3af 8000 	nop.w

0800b830 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
 800b830:	b500      	push	{lr}
 800b832:	b085      	sub	sp, #20
 800b834:	9003      	str	r0, [sp, #12]
 800b836:	9102      	str	r1, [sp, #8]
 800b838:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
 800b83a:	9b03      	ldr	r3, [sp, #12]
 800b83c:	2b00      	cmp	r3, #0
 800b83e:	d002      	beq.n	800b846 <chPoolObjectInit+0x16>
 800b840:	9b02      	ldr	r3, [sp, #8]
 800b842:	2b03      	cmp	r3, #3
 800b844:	d805      	bhi.n	800b852 <chPoolObjectInit+0x22>
 800b846:	f641 3060 	movw	r0, #7008	; 0x1b60
 800b84a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b84e:	f003 fd9f 	bl	800f390 <chSysHalt>

  mp->mp_next = NULL;
 800b852:	9b03      	ldr	r3, [sp, #12]
 800b854:	2200      	movs	r2, #0
 800b856:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 800b858:	9b03      	ldr	r3, [sp, #12]
 800b85a:	9a02      	ldr	r2, [sp, #8]
 800b85c:	605a      	str	r2, [r3, #4]
  mp->mp_provider = provider;
 800b85e:	9b03      	ldr	r3, [sp, #12]
 800b860:	9a01      	ldr	r2, [sp, #4]
 800b862:	609a      	str	r2, [r3, #8]
}
 800b864:	b005      	add	sp, #20
 800b866:	f85d fb04 	ldr.w	pc, [sp], #4
 800b86a:	bf00      	nop
 800b86c:	f3af 8000 	nop.w

0800b870 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 800b870:	b500      	push	{lr}
 800b872:	b085      	sub	sp, #20
 800b874:	9003      	str	r0, [sp, #12]
 800b876:	9102      	str	r1, [sp, #8]
 800b878:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));
 800b87a:	9b03      	ldr	r3, [sp, #12]
 800b87c:	2b00      	cmp	r3, #0
 800b87e:	d002      	beq.n	800b886 <chPoolLoadArray+0x16>
 800b880:	9b01      	ldr	r3, [sp, #4]
 800b882:	2b00      	cmp	r3, #0
 800b884:	d112      	bne.n	800b8ac <chPoolLoadArray+0x3c>
 800b886:	f641 3080 	movw	r0, #7040	; 0x1b80
 800b88a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b88e:	f003 fd7f 	bl	800f390 <chSysHalt>
 800b892:	e00b      	b.n	800b8ac <chPoolLoadArray+0x3c>

  while (n != 0U) {
    chPoolAdd(mp, p);
 800b894:	9803      	ldr	r0, [sp, #12]
 800b896:	9902      	ldr	r1, [sp, #8]
 800b898:	f7ff ffba 	bl	800b810 <chPoolAdd.8460.4314>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 800b89c:	9b03      	ldr	r3, [sp, #12]
 800b89e:	685b      	ldr	r3, [r3, #4]
 800b8a0:	9a02      	ldr	r2, [sp, #8]
 800b8a2:	4413      	add	r3, r2
 800b8a4:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 800b8a6:	9b01      	ldr	r3, [sp, #4]
 800b8a8:	3b01      	subs	r3, #1
 800b8aa:	9301      	str	r3, [sp, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 800b8ac:	9b01      	ldr	r3, [sp, #4]
 800b8ae:	2b00      	cmp	r3, #0
 800b8b0:	d1f0      	bne.n	800b894 <chPoolLoadArray+0x24>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    /*lint -restore*/
    n--;
  }
}
 800b8b2:	b005      	add	sp, #20
 800b8b4:	f85d fb04 	ldr.w	pc, [sp], #4
 800b8b8:	f3af 8000 	nop.w
 800b8bc:	f3af 8000 	nop.w

0800b8c0 <chPoolAllocI.4301>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 800b8c0:	b500      	push	{lr}
 800b8c2:	b085      	sub	sp, #20
 800b8c4:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
 800b8c6:	f003 ffdb 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 800b8ca:	9b01      	ldr	r3, [sp, #4]
 800b8cc:	2b00      	cmp	r3, #0
 800b8ce:	d105      	bne.n	800b8dc <chPoolAllocI.4301+0x1c>
 800b8d0:	f641 3090 	movw	r0, #7056	; 0x1b90
 800b8d4:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b8d8:	f003 fd5a 	bl	800f390 <chSysHalt>

  objp = mp->mp_next;
 800b8dc:	9b01      	ldr	r3, [sp, #4]
 800b8de:	681b      	ldr	r3, [r3, #0]
 800b8e0:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 800b8e2:	9b03      	ldr	r3, [sp, #12]
 800b8e4:	2b00      	cmp	r3, #0
 800b8e6:	d005      	beq.n	800b8f4 <chPoolAllocI.4301+0x34>
    mp->mp_next = mp->mp_next->ph_next;
 800b8e8:	9b01      	ldr	r3, [sp, #4]
 800b8ea:	681b      	ldr	r3, [r3, #0]
 800b8ec:	681a      	ldr	r2, [r3, #0]
 800b8ee:	9b01      	ldr	r3, [sp, #4]
 800b8f0:	601a      	str	r2, [r3, #0]
 800b8f2:	e00a      	b.n	800b90a <chPoolAllocI.4301+0x4a>
  }
  else if (mp->mp_provider != NULL) {
 800b8f4:	9b01      	ldr	r3, [sp, #4]
 800b8f6:	689b      	ldr	r3, [r3, #8]
 800b8f8:	2b00      	cmp	r3, #0
 800b8fa:	d006      	beq.n	800b90a <chPoolAllocI.4301+0x4a>
    objp = mp->mp_provider(mp->mp_object_size);
 800b8fc:	9b01      	ldr	r3, [sp, #4]
 800b8fe:	689b      	ldr	r3, [r3, #8]
 800b900:	9a01      	ldr	r2, [sp, #4]
 800b902:	6852      	ldr	r2, [r2, #4]
 800b904:	4610      	mov	r0, r2
 800b906:	4798      	blx	r3
 800b908:	9003      	str	r0, [sp, #12]
  }
  /*lint -restore*/

  return objp;
 800b90a:	9b03      	ldr	r3, [sp, #12]
}
 800b90c:	4618      	mov	r0, r3
 800b90e:	b005      	add	sp, #20
 800b910:	f85d fb04 	ldr.w	pc, [sp], #4
 800b914:	f3af 8000 	nop.w
 800b918:	f3af 8000 	nop.w
 800b91c:	f3af 8000 	nop.w

0800b920 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 800b920:	b500      	push	{lr}
 800b922:	b085      	sub	sp, #20
 800b924:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
 800b926:	f7ff ff43 	bl	800b7b0 <chSysLock.8428.4320>
  objp = chPoolAllocI(mp);
 800b92a:	9801      	ldr	r0, [sp, #4]
 800b92c:	f7ff ffc8 	bl	800b8c0 <chPoolAllocI.4301>
 800b930:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 800b932:	f7ff ff45 	bl	800b7c0 <chSysUnlock.8430.4318>

  return objp;
 800b936:	9b03      	ldr	r3, [sp, #12]
}
 800b938:	4618      	mov	r0, r3
 800b93a:	b005      	add	sp, #20
 800b93c:	f85d fb04 	ldr.w	pc, [sp], #4

0800b940 <chPoolFreeI.4294>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 800b940:	b500      	push	{lr}
 800b942:	b085      	sub	sp, #20
 800b944:	9001      	str	r0, [sp, #4]
 800b946:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 800b948:	9b00      	ldr	r3, [sp, #0]
 800b94a:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 800b94c:	f003 ff98 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 800b950:	9b01      	ldr	r3, [sp, #4]
 800b952:	2b00      	cmp	r3, #0
 800b954:	d002      	beq.n	800b95c <chPoolFreeI.4294+0x1c>
 800b956:	9b00      	ldr	r3, [sp, #0]
 800b958:	2b00      	cmp	r3, #0
 800b95a:	d105      	bne.n	800b968 <chPoolFreeI.4294+0x28>
 800b95c:	f641 30b0 	movw	r0, #7088	; 0x1bb0
 800b960:	f6c0 0001 	movt	r0, #2049	; 0x801
 800b964:	f003 fd14 	bl	800f390 <chSysHalt>

  php->ph_next = mp->mp_next;
 800b968:	9b01      	ldr	r3, [sp, #4]
 800b96a:	681a      	ldr	r2, [r3, #0]
 800b96c:	9b03      	ldr	r3, [sp, #12]
 800b96e:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
 800b970:	9b01      	ldr	r3, [sp, #4]
 800b972:	9a03      	ldr	r2, [sp, #12]
 800b974:	601a      	str	r2, [r3, #0]
}
 800b976:	b005      	add	sp, #20
 800b978:	f85d fb04 	ldr.w	pc, [sp], #4
 800b97c:	f3af 8000 	nop.w

0800b980 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 800b980:	b500      	push	{lr}
 800b982:	b083      	sub	sp, #12
 800b984:	9001      	str	r0, [sp, #4]
 800b986:	9100      	str	r1, [sp, #0]

  chSysLock();
 800b988:	f7ff ff12 	bl	800b7b0 <chSysLock.8428.4320>
  chPoolFreeI(mp, objp);
 800b98c:	9801      	ldr	r0, [sp, #4]
 800b98e:	9900      	ldr	r1, [sp, #0]
 800b990:	f7ff ffd6 	bl	800b940 <chPoolFreeI.4294>
  chSysUnlock();
 800b994:	f7ff ff14 	bl	800b7c0 <chSysUnlock.8430.4318>
}
 800b998:	b003      	add	sp, #12
 800b99a:	f85d fb04 	ldr.w	pc, [sp], #4
 800b99e:	bf00      	nop

0800b9a0 <port_lock.8630.4278>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b9a0:	b082      	sub	sp, #8
 800b9a2:	2320      	movs	r3, #32
 800b9a4:	9301      	str	r3, [sp, #4]
 800b9a6:	9b01      	ldr	r3, [sp, #4]
 800b9a8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b9ac:	b002      	add	sp, #8
 800b9ae:	4770      	bx	lr

0800b9b0 <port_unlock.8633.4276>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b9b0:	b082      	sub	sp, #8
 800b9b2:	2300      	movs	r3, #0
 800b9b4:	9301      	str	r3, [sp, #4]
 800b9b6:	9b01      	ldr	r3, [sp, #4]
 800b9b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b9bc:	b002      	add	sp, #8
 800b9be:	4770      	bx	lr

0800b9c0 <port_lock_from_isr.8635.4274>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800b9c0:	b508      	push	{r3, lr}

  port_lock();
 800b9c2:	f7ff ffed 	bl	800b9a0 <port_lock.8630.4278>
}
 800b9c6:	bd08      	pop	{r3, pc}
 800b9c8:	f3af 8000 	nop.w
 800b9cc:	f3af 8000 	nop.w

0800b9d0 <port_unlock_from_isr.8637.4272>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800b9d0:	b508      	push	{r3, lr}

  port_unlock();
 800b9d2:	f7ff ffed 	bl	800b9b0 <port_unlock.8633.4276>
}
 800b9d6:	bd08      	pop	{r3, pc}
 800b9d8:	f3af 8000 	nop.w
 800b9dc:	f3af 8000 	nop.w

0800b9e0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 800b9e0:	b510      	push	{r4, lr}
 800b9e2:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800b9e4:	f3ef 8309 	mrs	r3, PSP
 800b9e8:	461c      	mov	r4, r3
  return(result);
 800b9ea:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 800b9ec:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800b9ee:	9b01      	ldr	r3, [sp, #4]
 800b9f0:	3320      	adds	r3, #32
 800b9f2:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 800b9f4:	9b01      	ldr	r3, [sp, #4]
 800b9f6:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800b9f8:	9b00      	ldr	r3, [sp, #0]
 800b9fa:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 800b9fe:	f7ff ffe7 	bl	800b9d0 <port_unlock_from_isr.8637.4272>
}
 800ba02:	b002      	add	sp, #8
 800ba04:	bd10      	pop	{r4, pc}
 800ba06:	bf00      	nop
 800ba08:	f3af 8000 	nop.w
 800ba0c:	f3af 8000 	nop.w

0800ba10 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 800ba10:	b510      	push	{r4, lr}
 800ba12:	b082      	sub	sp, #8

  port_lock_from_isr();
 800ba14:	f7ff ffd4 	bl	800b9c0 <port_lock_from_isr.8635.4274>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 800ba18:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800ba1c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800ba20:	685b      	ldr	r3, [r3, #4]
 800ba22:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800ba26:	2b00      	cmp	r3, #0
 800ba28:	d023      	beq.n	800ba72 <_port_irq_epilogue+0x62>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800ba2a:	f3ef 8309 	mrs	r3, PSP
 800ba2e:	461c      	mov	r4, r3
  return(result);
 800ba30:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 800ba32:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 800ba34:	9b01      	ldr	r3, [sp, #4]
 800ba36:	3b20      	subs	r3, #32
 800ba38:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800ba3a:	9b01      	ldr	r3, [sp, #4]
 800ba3c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800ba40:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 800ba42:	9b01      	ldr	r3, [sp, #4]
 800ba44:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800ba46:	9b00      	ldr	r3, [sp, #0]
 800ba48:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800ba4c:	f004 fb98 	bl	8010180 <chSchIsPreemptionRequired>
 800ba50:	4603      	mov	r3, r0
 800ba52:	2b00      	cmp	r3, #0
 800ba54:	d006      	beq.n	800ba64 <_port_irq_epilogue+0x54>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800ba56:	9a01      	ldr	r2, [sp, #4]
 800ba58:	f240 23f9 	movw	r3, #761	; 0x2f9
 800ba5c:	f6c0 0300 	movt	r3, #2048	; 0x800
 800ba60:	6193      	str	r3, [r2, #24]
 800ba62:	e008      	b.n	800ba76 <_port_irq_epilogue+0x66>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800ba64:	9a01      	ldr	r2, [sp, #4]
 800ba66:	f240 330c 	movw	r3, #780	; 0x30c
 800ba6a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800ba6e:	6193      	str	r3, [r2, #24]
 800ba70:	e001      	b.n	800ba76 <_port_irq_epilogue+0x66>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 800ba72:	f7ff ffad 	bl	800b9d0 <port_unlock_from_isr.8637.4272>
}
 800ba76:	b002      	add	sp, #8
 800ba78:	bd10      	pop	{r4, pc}
 800ba7a:	bf00      	nop
 800ba7c:	f3af 8000 	nop.w

0800ba80 <osalInit.8696.4263>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 800ba80:	4770      	bx	lr
 800ba82:	bf00      	nop
 800ba84:	f3af 8000 	nop.w
 800ba88:	f3af 8000 	nop.w
 800ba8c:	f3af 8000 	nop.w

0800ba90 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 800ba90:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 800ba92:	f7ff fff5 	bl	800ba80 <osalInit.8696.4263>

  /* Platform low level initializations.*/
  hal_lld_init();
 800ba96:	f7fd fa3b 	bl	8008f10 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 800ba9a:	f641 60b0 	movw	r0, #7856	; 0x1eb0
 800ba9e:	f6c0 0001 	movt	r0, #2049	; 0x801
 800baa2:	f7fd fc45 	bl	8009330 <_pal_lld_init>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 800baa6:	f7ff f97b 	bl	800ada0 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 800baaa:	f7fe fca9 	bl	800a400 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 800baae:	f7fc fb5f 	bl	8008170 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800bab2:	f000 f835 	bl	800bb20 <stInit.4245>
#endif
}
 800bab6:	bd08      	pop	{r3, pc}
 800bab8:	f3af 8000 	nop.w
 800babc:	f3af 8000 	nop.w

0800bac0 <st_lld_start_alarm.8730.4257>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 800bac0:	b082      	sub	sp, #8
 800bac2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800bac4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800bac8:	9a01      	ldr	r2, [sp, #4]
 800baca:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800bacc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800bad0:	2200      	movs	r2, #0
 800bad2:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800bad4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800bad8:	2202      	movs	r2, #2
 800bada:	60da      	str	r2, [r3, #12]
}
 800badc:	b002      	add	sp, #8
 800bade:	4770      	bx	lr

0800bae0 <st_lld_stop_alarm.8737.4255>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800bae0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800bae4:	2200      	movs	r2, #0
 800bae6:	60da      	str	r2, [r3, #12]
}
 800bae8:	4770      	bx	lr
 800baea:	bf00      	nop
 800baec:	f3af 8000 	nop.w

0800baf0 <st_lld_set_alarm.8739.4252>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 800baf0:	b082      	sub	sp, #8
 800baf2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800baf4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800baf8:	9a01      	ldr	r2, [sp, #4]
 800bafa:	635a      	str	r2, [r3, #52]	; 0x34
}
 800bafc:	b002      	add	sp, #8
 800bafe:	4770      	bx	lr

0800bb00 <st_lld_is_alarm_active.8744.4247>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 800bb00:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800bb04:	68db      	ldr	r3, [r3, #12]
 800bb06:	f003 0302 	and.w	r3, r3, #2
 800bb0a:	2b00      	cmp	r3, #0
 800bb0c:	bf0c      	ite	eq
 800bb0e:	2300      	moveq	r3, #0
 800bb10:	2301      	movne	r3, #1
 800bb12:	b2db      	uxtb	r3, r3
}
 800bb14:	4618      	mov	r0, r3
 800bb16:	4770      	bx	lr
 800bb18:	f3af 8000 	nop.w
 800bb1c:	f3af 8000 	nop.w

0800bb20 <stInit.4245>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 800bb20:	b508      	push	{r3, lr}

  st_lld_init();
 800bb22:	f7fd fb9d 	bl	8009260 <st_lld_init>
}
 800bb26:	bd08      	pop	{r3, pc}
 800bb28:	f3af 8000 	nop.w
 800bb2c:	f3af 8000 	nop.w

0800bb30 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 800bb30:	b500      	push	{lr}
 800bb32:	b083      	sub	sp, #12
 800bb34:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800bb36:	f7ff ffe3 	bl	800bb00 <st_lld_is_alarm_active.8744.4247>
 800bb3a:	4603      	mov	r3, r0
 800bb3c:	2b00      	cmp	r3, #0
 800bb3e:	d005      	beq.n	800bb4c <stStartAlarm+0x1c>
 800bb40:	f641 30c0 	movw	r0, #7104	; 0x1bc0
 800bb44:	f6c0 0001 	movt	r0, #2049	; 0x801
 800bb48:	f003 fc22 	bl	800f390 <chSysHalt>

  st_lld_start_alarm(abstime);
 800bb4c:	9801      	ldr	r0, [sp, #4]
 800bb4e:	f7ff ffb7 	bl	800bac0 <st_lld_start_alarm.8730.4257>
}
 800bb52:	b003      	add	sp, #12
 800bb54:	f85d fb04 	ldr.w	pc, [sp], #4
 800bb58:	f3af 8000 	nop.w
 800bb5c:	f3af 8000 	nop.w

0800bb60 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 800bb60:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 800bb62:	f7ff ffbd 	bl	800bae0 <st_lld_stop_alarm.8737.4255>
}
 800bb66:	bd08      	pop	{r3, pc}
 800bb68:	f3af 8000 	nop.w
 800bb6c:	f3af 8000 	nop.w

0800bb70 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 800bb70:	b500      	push	{lr}
 800bb72:	b083      	sub	sp, #12
 800bb74:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800bb76:	f7ff ffc3 	bl	800bb00 <st_lld_is_alarm_active.8744.4247>
 800bb7a:	4603      	mov	r3, r0
 800bb7c:	f083 0301 	eor.w	r3, r3, #1
 800bb80:	b2db      	uxtb	r3, r3
 800bb82:	2b00      	cmp	r3, #0
 800bb84:	d005      	beq.n	800bb92 <stSetAlarm+0x22>
 800bb86:	f641 30d0 	movw	r0, #7120	; 0x1bd0
 800bb8a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800bb8e:	f003 fbff 	bl	800f390 <chSysHalt>

  st_lld_set_alarm(abstime);
 800bb92:	9801      	ldr	r0, [sp, #4]
 800bb94:	f7ff ffac 	bl	800baf0 <st_lld_set_alarm.8739.4252>
}
 800bb98:	b003      	add	sp, #12
 800bb9a:	f85d fb04 	ldr.w	pc, [sp], #4
 800bb9e:	bf00      	nop

0800bba0 <port_lock.8790.4232>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800bba0:	b082      	sub	sp, #8
 800bba2:	2320      	movs	r3, #32
 800bba4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800bba6:	9b01      	ldr	r3, [sp, #4]
 800bba8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bbac:	b002      	add	sp, #8
 800bbae:	4770      	bx	lr

0800bbb0 <port_unlock.8793.4230>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800bbb0:	b082      	sub	sp, #8
 800bbb2:	2300      	movs	r3, #0
 800bbb4:	9301      	str	r3, [sp, #4]
 800bbb6:	9b01      	ldr	r3, [sp, #4]
 800bbb8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bbbc:	b002      	add	sp, #8
 800bbbe:	4770      	bx	lr

0800bbc0 <st_lld_get_counter.8795.4228>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800bbc0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800bbc4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800bbc6:	4618      	mov	r0, r3
 800bbc8:	4770      	bx	lr
 800bbca:	bf00      	nop
 800bbcc:	f3af 8000 	nop.w

0800bbd0 <port_timer_get_time.8800.4226>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800bbd0:	b508      	push	{r3, lr}

  return stGetCounter();
 800bbd2:	f7ff fff5 	bl	800bbc0 <st_lld_get_counter.8795.4228>
 800bbd6:	4603      	mov	r3, r0
}
 800bbd8:	4618      	mov	r0, r3
 800bbda:	bd08      	pop	{r3, pc}
 800bbdc:	f3af 8000 	nop.w

0800bbe0 <queue_init.8802.4223>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800bbe0:	b082      	sub	sp, #8
 800bbe2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800bbe4:	9b01      	ldr	r3, [sp, #4]
 800bbe6:	9a01      	ldr	r2, [sp, #4]
 800bbe8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800bbea:	9b01      	ldr	r3, [sp, #4]
 800bbec:	9a01      	ldr	r2, [sp, #4]
 800bbee:	605a      	str	r2, [r3, #4]
}
 800bbf0:	b002      	add	sp, #8
 800bbf2:	4770      	bx	lr
 800bbf4:	f3af 8000 	nop.w
 800bbf8:	f3af 8000 	nop.w
 800bbfc:	f3af 8000 	nop.w

0800bc00 <chSysLock.8907.4221>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800bc00:	b508      	push	{r3, lr}

  port_lock();
 800bc02:	f7ff ffcd 	bl	800bba0 <port_lock.8790.4232>
  _stats_start_measure_crit_thd();
 800bc06:	f002 f9bb 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800bc0a:	f003 fd69 	bl	800f6e0 <_dbg_check_lock>
}
 800bc0e:	bd08      	pop	{r3, pc}

0800bc10 <chSysUnlock.8911.4219>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800bc10:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800bc12:	f003 fd85 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800bc16:	f002 f9bb 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800bc1a:	f640 5350 	movw	r3, #3408	; 0xd50
 800bc1e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bc22:	681a      	ldr	r2, [r3, #0]
 800bc24:	f640 5350 	movw	r3, #3408	; 0xd50
 800bc28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bc2c:	429a      	cmp	r2, r3
 800bc2e:	d013      	beq.n	800bc58 <chSysUnlock.8911.4219+0x48>
 800bc30:	f640 5350 	movw	r3, #3408	; 0xd50
 800bc34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bc38:	699b      	ldr	r3, [r3, #24]
 800bc3a:	689a      	ldr	r2, [r3, #8]
 800bc3c:	f640 5350 	movw	r3, #3408	; 0xd50
 800bc40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800bc44:	681b      	ldr	r3, [r3, #0]
 800bc46:	689b      	ldr	r3, [r3, #8]
 800bc48:	429a      	cmp	r2, r3
 800bc4a:	d205      	bcs.n	800bc58 <chSysUnlock.8911.4219+0x48>
 800bc4c:	f641 4010 	movw	r0, #7184	; 0x1c10
 800bc50:	f6c0 0001 	movt	r0, #2049	; 0x801
 800bc54:	f003 fb9c 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800bc58:	f7ff ffaa 	bl	800bbb0 <port_unlock.8793.4230>
}
 800bc5c:	bd08      	pop	{r3, pc}
 800bc5e:	bf00      	nop

0800bc60 <chVTGetSystemTimeX.8889.4217>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800bc60:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800bc62:	f7ff ffb5 	bl	800bbd0 <port_timer_get_time.8800.4226>
 800bc66:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800bc68:	4618      	mov	r0, r3
 800bc6a:	bd08      	pop	{r3, pc}
 800bc6c:	f3af 8000 	nop.w

0800bc70 <chThdQueueObjectInit.8891.4214>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 800bc70:	b500      	push	{lr}
 800bc72:	b083      	sub	sp, #12
 800bc74:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 800bc76:	9801      	ldr	r0, [sp, #4]
 800bc78:	f7ff ffb2 	bl	800bbe0 <queue_init.8802.4223>
}
 800bc7c:	b003      	add	sp, #12
 800bc7e:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc82:	bf00      	nop
 800bc84:	f3af 8000 	nop.w
 800bc88:	f3af 8000 	nop.w
 800bc8c:	f3af 8000 	nop.w

0800bc90 <osalSysLock.8909>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 800bc90:	b508      	push	{r3, lr}

  chSysLock();
 800bc92:	f7ff ffb5 	bl	800bc00 <chSysLock.8907.4221>
}
 800bc96:	bd08      	pop	{r3, pc}
 800bc98:	f3af 8000 	nop.w
 800bc9c:	f3af 8000 	nop.w

0800bca0 <osalSysUnlock.8913>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 800bca0:	b508      	push	{r3, lr}

  chSysUnlock();
 800bca2:	f7ff ffb5 	bl	800bc10 <chSysUnlock.8911.4219>
}
 800bca6:	bd08      	pop	{r3, pc}
 800bca8:	f3af 8000 	nop.w
 800bcac:	f3af 8000 	nop.w

0800bcb0 <osalOsGetSystemTimeX.8894>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 800bcb0:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 800bcb2:	f7ff ffd5 	bl	800bc60 <chVTGetSystemTimeX.8889.4217>
 800bcb6:	4603      	mov	r3, r0
}
 800bcb8:	4618      	mov	r0, r3
 800bcba:	bd08      	pop	{r3, pc}
 800bcbc:	f3af 8000 	nop.w

0800bcc0 <osalThreadQueueObjectInit.8896.4205>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 800bcc0:	b500      	push	{lr}
 800bcc2:	b083      	sub	sp, #12
 800bcc4:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 800bcc6:	9801      	ldr	r0, [sp, #4]
 800bcc8:	f7ff ffd2 	bl	800bc70 <chThdQueueObjectInit.8891.4214>
}
 800bccc:	b003      	add	sp, #12
 800bcce:	f85d fb04 	ldr.w	pc, [sp], #4
 800bcd2:	bf00      	nop
 800bcd4:	f3af 8000 	nop.w
 800bcd8:	f3af 8000 	nop.w
 800bcdc:	f3af 8000 	nop.w

0800bce0 <osalThreadEnqueueTimeoutS.8915.4201>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 800bce0:	b500      	push	{lr}
 800bce2:	b083      	sub	sp, #12
 800bce4:	9001      	str	r0, [sp, #4]
 800bce6:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 800bce8:	9801      	ldr	r0, [sp, #4]
 800bcea:	9900      	ldr	r1, [sp, #0]
 800bcec:	f001 ffc8 	bl	800dc80 <chThdEnqueueTimeoutS>
 800bcf0:	4603      	mov	r3, r0
}
 800bcf2:	4618      	mov	r0, r3
 800bcf4:	b003      	add	sp, #12
 800bcf6:	f85d fb04 	ldr.w	pc, [sp], #4
 800bcfa:	bf00      	nop
 800bcfc:	f3af 8000 	nop.w

0800bd00 <osalThreadDequeueNextI.8903.4197>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 800bd00:	b500      	push	{lr}
 800bd02:	b083      	sub	sp, #12
 800bd04:	9001      	str	r0, [sp, #4]
 800bd06:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 800bd08:	9801      	ldr	r0, [sp, #4]
 800bd0a:	9900      	ldr	r1, [sp, #0]
 800bd0c:	f001 ffd8 	bl	800dcc0 <chThdDequeueNextI>
}
 800bd10:	b003      	add	sp, #12
 800bd12:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd16:	bf00      	nop
 800bd18:	f3af 8000 	nop.w
 800bd1c:	f3af 8000 	nop.w

0800bd20 <osalThreadDequeueAllI.8899.4193>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 800bd20:	b500      	push	{lr}
 800bd22:	b083      	sub	sp, #12
 800bd24:	9001      	str	r0, [sp, #4]
 800bd26:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 800bd28:	9801      	ldr	r0, [sp, #4]
 800bd2a:	9900      	ldr	r1, [sp, #0]
 800bd2c:	f001 ffe0 	bl	800dcf0 <chThdDequeueAllI>
}
 800bd30:	b003      	add	sp, #12
 800bd32:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd36:	bf00      	nop
 800bd38:	f3af 8000 	nop.w
 800bd3c:	f3af 8000 	nop.w

0800bd40 <ibqObjectInit>:
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t infy, void *link) {
 800bd40:	b500      	push	{lr}
 800bd42:	b085      	sub	sp, #20
 800bd44:	9003      	str	r0, [sp, #12]
 800bd46:	9102      	str	r1, [sp, #8]
 800bd48:	9201      	str	r2, [sp, #4]
 800bd4a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));
 800bd4c:	9b03      	ldr	r3, [sp, #12]
 800bd4e:	2b00      	cmp	r3, #0
 800bd50:	d005      	beq.n	800bd5e <ibqObjectInit+0x1e>
 800bd52:	9b02      	ldr	r3, [sp, #8]
 800bd54:	2b00      	cmp	r3, #0
 800bd56:	d002      	beq.n	800bd5e <ibqObjectInit+0x1e>
 800bd58:	9b01      	ldr	r3, [sp, #4]
 800bd5a:	2b01      	cmp	r3, #1
 800bd5c:	d805      	bhi.n	800bd6a <ibqObjectInit+0x2a>
 800bd5e:	f641 30e0 	movw	r0, #7136	; 0x1be0
 800bd62:	f6c0 0001 	movt	r0, #2049	; 0x801
 800bd66:	f003 fb13 	bl	800f390 <chSysHalt>

  osalThreadQueueObjectInit(&ibqp->waiting);
 800bd6a:	9b03      	ldr	r3, [sp, #12]
 800bd6c:	4618      	mov	r0, r3
 800bd6e:	f7ff ffa7 	bl	800bcc0 <osalThreadQueueObjectInit.8896.4205>
  ibqp->bcounter = 0;
 800bd72:	9b03      	ldr	r3, [sp, #12]
 800bd74:	2200      	movs	r2, #0
 800bd76:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = bp;
 800bd78:	9b03      	ldr	r3, [sp, #12]
 800bd7a:	9a02      	ldr	r2, [sp, #8]
 800bd7c:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = bp;
 800bd7e:	9b03      	ldr	r3, [sp, #12]
 800bd80:	9a02      	ldr	r2, [sp, #8]
 800bd82:	60da      	str	r2, [r3, #12]
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 800bd84:	9b01      	ldr	r3, [sp, #4]
 800bd86:	3304      	adds	r3, #4
 800bd88:	9a00      	ldr	r2, [sp, #0]
 800bd8a:	fb02 f303 	mul.w	r3, r2, r3
 800bd8e:	9a02      	ldr	r2, [sp, #8]
 800bd90:	441a      	add	r2, r3
 800bd92:	9b03      	ldr	r3, [sp, #12]
 800bd94:	615a      	str	r2, [r3, #20]
  ibqp->bsize    = size + sizeof (size_t);
 800bd96:	9b01      	ldr	r3, [sp, #4]
 800bd98:	1d1a      	adds	r2, r3, #4
 800bd9a:	9b03      	ldr	r3, [sp, #12]
 800bd9c:	619a      	str	r2, [r3, #24]
  ibqp->bn       = n;
 800bd9e:	9b03      	ldr	r3, [sp, #12]
 800bda0:	9a00      	ldr	r2, [sp, #0]
 800bda2:	61da      	str	r2, [r3, #28]
  ibqp->buffers  = bp;
 800bda4:	9b03      	ldr	r3, [sp, #12]
 800bda6:	9a02      	ldr	r2, [sp, #8]
 800bda8:	621a      	str	r2, [r3, #32]
  ibqp->ptr      = NULL;
 800bdaa:	9b03      	ldr	r3, [sp, #12]
 800bdac:	2200      	movs	r2, #0
 800bdae:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 800bdb0:	9b03      	ldr	r3, [sp, #12]
 800bdb2:	2200      	movs	r2, #0
 800bdb4:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->notify   = infy;
 800bdb6:	9b03      	ldr	r3, [sp, #12]
 800bdb8:	9a06      	ldr	r2, [sp, #24]
 800bdba:	62da      	str	r2, [r3, #44]	; 0x2c
  ibqp->link     = link;
 800bdbc:	9b03      	ldr	r3, [sp, #12]
 800bdbe:	9a07      	ldr	r2, [sp, #28]
 800bdc0:	631a      	str	r2, [r3, #48]	; 0x30
}
 800bdc2:	b005      	add	sp, #20
 800bdc4:	f85d fb04 	ldr.w	pc, [sp], #4
 800bdc8:	f3af 8000 	nop.w
 800bdcc:	f3af 8000 	nop.w

0800bdd0 <ibqResetI>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {
 800bdd0:	b500      	push	{lr}
 800bdd2:	b083      	sub	sp, #12
 800bdd4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 800bdd6:	f003 fd53 	bl	800f880 <chDbgCheckClassI>

  ibqp->bcounter = 0;
 800bdda:	9b01      	ldr	r3, [sp, #4]
 800bddc:	2200      	movs	r2, #0
 800bdde:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = ibqp->buffers;
 800bde0:	9b01      	ldr	r3, [sp, #4]
 800bde2:	6a1a      	ldr	r2, [r3, #32]
 800bde4:	9b01      	ldr	r3, [sp, #4]
 800bde6:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = ibqp->buffers;
 800bde8:	9b01      	ldr	r3, [sp, #4]
 800bdea:	6a1a      	ldr	r2, [r3, #32]
 800bdec:	9b01      	ldr	r3, [sp, #4]
 800bdee:	60da      	str	r2, [r3, #12]
  ibqp->ptr      = NULL;
 800bdf0:	9b01      	ldr	r3, [sp, #4]
 800bdf2:	2200      	movs	r2, #0
 800bdf4:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 800bdf6:	9b01      	ldr	r3, [sp, #4]
 800bdf8:	2200      	movs	r2, #0
 800bdfa:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 800bdfc:	9b01      	ldr	r3, [sp, #4]
 800bdfe:	4618      	mov	r0, r3
 800be00:	f06f 0101 	mvn.w	r1, #1
 800be04:	f7ff ff8c 	bl	800bd20 <osalThreadDequeueAllI.8899.4193>
}
 800be08:	b003      	add	sp, #12
 800be0a:	f85d fb04 	ldr.w	pc, [sp], #4
 800be0e:	bf00      	nop

0800be10 <ibqGetEmptyBufferI>:
 * @return              A pointer to the next buffer to be filled.
 * @retval NULL         if the queue is full.
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {
 800be10:	b500      	push	{lr}
 800be12:	b083      	sub	sp, #12
 800be14:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 800be16:	f003 fd33 	bl	800f880 <chDbgCheckClassI>

  if (ibqIsFullI(ibqp)) {
 800be1a:	9b01      	ldr	r3, [sp, #4]
 800be1c:	68da      	ldr	r2, [r3, #12]
 800be1e:	9b01      	ldr	r3, [sp, #4]
 800be20:	691b      	ldr	r3, [r3, #16]
 800be22:	429a      	cmp	r2, r3
 800be24:	d105      	bne.n	800be32 <ibqGetEmptyBufferI+0x22>
 800be26:	9b01      	ldr	r3, [sp, #4]
 800be28:	689b      	ldr	r3, [r3, #8]
 800be2a:	2b00      	cmp	r3, #0
 800be2c:	d001      	beq.n	800be32 <ibqGetEmptyBufferI+0x22>
 800be2e:	2301      	movs	r3, #1
 800be30:	e000      	b.n	800be34 <ibqGetEmptyBufferI+0x24>
 800be32:	2300      	movs	r3, #0
 800be34:	f003 0301 	and.w	r3, r3, #1
 800be38:	b2db      	uxtb	r3, r3
 800be3a:	2b00      	cmp	r3, #0
 800be3c:	d001      	beq.n	800be42 <ibqGetEmptyBufferI+0x32>
    return NULL;
 800be3e:	2300      	movs	r3, #0
 800be40:	e002      	b.n	800be48 <ibqGetEmptyBufferI+0x38>
  }

  return ibqp->bwrptr + sizeof (size_t);
 800be42:	9b01      	ldr	r3, [sp, #4]
 800be44:	68db      	ldr	r3, [r3, #12]
 800be46:	3304      	adds	r3, #4
}
 800be48:	4618      	mov	r0, r3
 800be4a:	b003      	add	sp, #12
 800be4c:	f85d fb04 	ldr.w	pc, [sp], #4

0800be50 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 800be50:	b500      	push	{lr}
 800be52:	b083      	sub	sp, #12
 800be54:	9001      	str	r0, [sp, #4]
 800be56:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 800be58:	f003 fd12 	bl	800f880 <chDbgCheckClassI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 800be5c:	9b00      	ldr	r3, [sp, #0]
 800be5e:	2b00      	cmp	r3, #0
 800be60:	d005      	beq.n	800be6e <ibqPostFullBufferI+0x1e>
 800be62:	9b01      	ldr	r3, [sp, #4]
 800be64:	699b      	ldr	r3, [r3, #24]
 800be66:	1f1a      	subs	r2, r3, #4
 800be68:	9b00      	ldr	r3, [sp, #0]
 800be6a:	429a      	cmp	r2, r3
 800be6c:	d205      	bcs.n	800be7a <ibqPostFullBufferI+0x2a>
 800be6e:	f641 30f0 	movw	r0, #7152	; 0x1bf0
 800be72:	f6c0 0001 	movt	r0, #2049	; 0x801
 800be76:	f003 fa8b 	bl	800f390 <chSysHalt>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 800be7a:	9b01      	ldr	r3, [sp, #4]
 800be7c:	68da      	ldr	r2, [r3, #12]
 800be7e:	9b01      	ldr	r3, [sp, #4]
 800be80:	691b      	ldr	r3, [r3, #16]
 800be82:	429a      	cmp	r2, r3
 800be84:	d105      	bne.n	800be92 <ibqPostFullBufferI+0x42>
 800be86:	9b01      	ldr	r3, [sp, #4]
 800be88:	689b      	ldr	r3, [r3, #8]
 800be8a:	2b00      	cmp	r3, #0
 800be8c:	d001      	beq.n	800be92 <ibqPostFullBufferI+0x42>
 800be8e:	2301      	movs	r3, #1
 800be90:	e000      	b.n	800be94 <ibqPostFullBufferI+0x44>
 800be92:	2300      	movs	r3, #0
 800be94:	f003 0301 	and.w	r3, r3, #1
 800be98:	b2db      	uxtb	r3, r3
 800be9a:	2b00      	cmp	r3, #0
 800be9c:	d005      	beq.n	800beaa <ibqPostFullBufferI+0x5a>
 800be9e:	f641 30f0 	movw	r0, #7152	; 0x1bf0
 800bea2:	f6c0 0001 	movt	r0, #2049	; 0x801
 800bea6:	f003 fa73 	bl	800f390 <chSysHalt>

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 800beaa:	9b01      	ldr	r3, [sp, #4]
 800beac:	68db      	ldr	r3, [r3, #12]
 800beae:	9a00      	ldr	r2, [sp, #0]
 800beb0:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 800beb2:	9b01      	ldr	r3, [sp, #4]
 800beb4:	689b      	ldr	r3, [r3, #8]
 800beb6:	1c5a      	adds	r2, r3, #1
 800beb8:	9b01      	ldr	r3, [sp, #4]
 800beba:	609a      	str	r2, [r3, #8]
  ibqp->bwrptr += ibqp->bsize;
 800bebc:	9b01      	ldr	r3, [sp, #4]
 800bebe:	68da      	ldr	r2, [r3, #12]
 800bec0:	9b01      	ldr	r3, [sp, #4]
 800bec2:	699b      	ldr	r3, [r3, #24]
 800bec4:	441a      	add	r2, r3
 800bec6:	9b01      	ldr	r3, [sp, #4]
 800bec8:	60da      	str	r2, [r3, #12]
  if (ibqp->bwrptr >= ibqp->btop) {
 800beca:	9b01      	ldr	r3, [sp, #4]
 800becc:	68da      	ldr	r2, [r3, #12]
 800bece:	9b01      	ldr	r3, [sp, #4]
 800bed0:	695b      	ldr	r3, [r3, #20]
 800bed2:	429a      	cmp	r2, r3
 800bed4:	d303      	bcc.n	800bede <ibqPostFullBufferI+0x8e>
    ibqp->bwrptr = ibqp->buffers;
 800bed6:	9b01      	ldr	r3, [sp, #4]
 800bed8:	6a1a      	ldr	r2, [r3, #32]
 800beda:	9b01      	ldr	r3, [sp, #4]
 800bedc:	60da      	str	r2, [r3, #12]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 800bede:	9b01      	ldr	r3, [sp, #4]
 800bee0:	4618      	mov	r0, r3
 800bee2:	2100      	movs	r1, #0
 800bee4:	f7ff ff0c 	bl	800bd00 <osalThreadDequeueNextI.8903.4197>
}
 800bee8:	b003      	add	sp, #12
 800beea:	f85d fb04 	ldr.w	pc, [sp], #4
 800beee:	bf00      	nop

0800bef0 <ibqGetFullBufferTimeoutS.4167>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 800bef0:	b500      	push	{lr}
 800bef2:	b085      	sub	sp, #20
 800bef4:	9001      	str	r0, [sp, #4]
 800bef6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 800bef8:	f003 fcda 	bl	800f8b0 <chDbgCheckClassS>
 800befc:	e00a      	b.n	800bf14 <ibqGetFullBufferTimeoutS.4167+0x24>

  while (ibqIsEmptyI(ibqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 800befe:	9b01      	ldr	r3, [sp, #4]
 800bf00:	4618      	mov	r0, r3
 800bf02:	9900      	ldr	r1, [sp, #0]
 800bf04:	f7ff feec 	bl	800bce0 <osalThreadEnqueueTimeoutS.8915.4201>
 800bf08:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 800bf0a:	9b03      	ldr	r3, [sp, #12]
 800bf0c:	2b00      	cmp	r3, #0
 800bf0e:	da01      	bge.n	800bf14 <ibqGetFullBufferTimeoutS.4167+0x24>
       return msg;
 800bf10:	9b03      	ldr	r3, [sp, #12]
 800bf12:	e01b      	b.n	800bf4c <ibqGetFullBufferTimeoutS.4167+0x5c>
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 800bf14:	9b01      	ldr	r3, [sp, #4]
 800bf16:	689b      	ldr	r3, [r3, #8]
 800bf18:	2b00      	cmp	r3, #0
 800bf1a:	d0f0      	beq.n	800befe <ibqGetFullBufferTimeoutS.4167+0xe>
    if (msg < MSG_OK) {
       return msg;
    }
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 800bf1c:	9b01      	ldr	r3, [sp, #4]
 800bf1e:	689b      	ldr	r3, [r3, #8]
 800bf20:	2b00      	cmp	r3, #0
 800bf22:	d105      	bne.n	800bf30 <ibqGetFullBufferTimeoutS.4167+0x40>
 800bf24:	f641 4020 	movw	r0, #7200	; 0x1c20
 800bf28:	f6c0 0001 	movt	r0, #2049	; 0x801
 800bf2c:	f003 fa30 	bl	800f390 <chSysHalt>

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 800bf30:	9b01      	ldr	r3, [sp, #4]
 800bf32:	691b      	ldr	r3, [r3, #16]
 800bf34:	1d1a      	adds	r2, r3, #4
 800bf36:	9b01      	ldr	r3, [sp, #4]
 800bf38:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 800bf3a:	9b01      	ldr	r3, [sp, #4]
 800bf3c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800bf3e:	9b01      	ldr	r3, [sp, #4]
 800bf40:	691b      	ldr	r3, [r3, #16]
 800bf42:	681b      	ldr	r3, [r3, #0]
 800bf44:	441a      	add	r2, r3
 800bf46:	9b01      	ldr	r3, [sp, #4]
 800bf48:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 800bf4a:	2300      	movs	r3, #0
}
 800bf4c:	4618      	mov	r0, r3
 800bf4e:	b005      	add	sp, #20
 800bf50:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf54:	f3af 8000 	nop.w
 800bf58:	f3af 8000 	nop.w
 800bf5c:	f3af 8000 	nop.w

0800bf60 <ibqReleaseEmptyBufferS.4161>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 800bf60:	b500      	push	{lr}
 800bf62:	b083      	sub	sp, #12
 800bf64:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassS();
 800bf66:	f003 fca3 	bl	800f8b0 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 800bf6a:	9b01      	ldr	r3, [sp, #4]
 800bf6c:	689b      	ldr	r3, [r3, #8]
 800bf6e:	2b00      	cmp	r3, #0
 800bf70:	d105      	bne.n	800bf7e <ibqReleaseEmptyBufferS.4161+0x1e>
 800bf72:	f641 4040 	movw	r0, #7232	; 0x1c40
 800bf76:	f6c0 0001 	movt	r0, #2049	; 0x801
 800bf7a:	f003 fa09 	bl	800f390 <chSysHalt>

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 800bf7e:	9b01      	ldr	r3, [sp, #4]
 800bf80:	689b      	ldr	r3, [r3, #8]
 800bf82:	1e5a      	subs	r2, r3, #1
 800bf84:	9b01      	ldr	r3, [sp, #4]
 800bf86:	609a      	str	r2, [r3, #8]
  ibqp->brdptr += ibqp->bsize;
 800bf88:	9b01      	ldr	r3, [sp, #4]
 800bf8a:	691a      	ldr	r2, [r3, #16]
 800bf8c:	9b01      	ldr	r3, [sp, #4]
 800bf8e:	699b      	ldr	r3, [r3, #24]
 800bf90:	441a      	add	r2, r3
 800bf92:	9b01      	ldr	r3, [sp, #4]
 800bf94:	611a      	str	r2, [r3, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 800bf96:	9b01      	ldr	r3, [sp, #4]
 800bf98:	691a      	ldr	r2, [r3, #16]
 800bf9a:	9b01      	ldr	r3, [sp, #4]
 800bf9c:	695b      	ldr	r3, [r3, #20]
 800bf9e:	429a      	cmp	r2, r3
 800bfa0:	d303      	bcc.n	800bfaa <ibqReleaseEmptyBufferS.4161+0x4a>
    ibqp->brdptr = ibqp->buffers;
 800bfa2:	9b01      	ldr	r3, [sp, #4]
 800bfa4:	6a1a      	ldr	r2, [r3, #32]
 800bfa6:	9b01      	ldr	r3, [sp, #4]
 800bfa8:	611a      	str	r2, [r3, #16]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 800bfaa:	9b01      	ldr	r3, [sp, #4]
 800bfac:	2200      	movs	r2, #0
 800bfae:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 800bfb0:	9b01      	ldr	r3, [sp, #4]
 800bfb2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bfb4:	2b00      	cmp	r3, #0
 800bfb6:	d003      	beq.n	800bfc0 <ibqReleaseEmptyBufferS.4161+0x60>
    ibqp->notify(ibqp);
 800bfb8:	9b01      	ldr	r3, [sp, #4]
 800bfba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bfbc:	9801      	ldr	r0, [sp, #4]
 800bfbe:	4798      	blx	r3
  }
}
 800bfc0:	b003      	add	sp, #12
 800bfc2:	f85d fb04 	ldr.w	pc, [sp], #4
 800bfc6:	bf00      	nop
 800bfc8:	f3af 8000 	nop.w
 800bfcc:	f3af 8000 	nop.w

0800bfd0 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 800bfd0:	b500      	push	{lr}
 800bfd2:	b085      	sub	sp, #20
 800bfd4:	9001      	str	r0, [sp, #4]
 800bfd6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 800bfd8:	f7ff fe5a 	bl	800bc90 <osalSysLock.8909>

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 800bfdc:	9b01      	ldr	r3, [sp, #4]
 800bfde:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800bfe0:	2b00      	cmp	r3, #0
 800bfe2:	d10b      	bne.n	800bffc <ibqGetTimeout+0x2c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 800bfe4:	9801      	ldr	r0, [sp, #4]
 800bfe6:	9900      	ldr	r1, [sp, #0]
 800bfe8:	f7ff ff82 	bl	800bef0 <ibqGetFullBufferTimeoutS.4167>
 800bfec:	9003      	str	r0, [sp, #12]
    if (msg != MSG_OK) {
 800bfee:	9b03      	ldr	r3, [sp, #12]
 800bff0:	2b00      	cmp	r3, #0
 800bff2:	d003      	beq.n	800bffc <ibqGetTimeout+0x2c>
      osalSysUnlock();
 800bff4:	f7ff fe54 	bl	800bca0 <osalSysUnlock.8913>
      return msg;
 800bff8:	9b03      	ldr	r3, [sp, #12]
 800bffa:	e014      	b.n	800c026 <ibqGetTimeout+0x56>
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 800bffc:	9b01      	ldr	r3, [sp, #4]
 800bffe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c000:	781b      	ldrb	r3, [r3, #0]
 800c002:	9303      	str	r3, [sp, #12]
  ibqp->ptr++;
 800c004:	9b01      	ldr	r3, [sp, #4]
 800c006:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c008:	1c5a      	adds	r2, r3, #1
 800c00a:	9b01      	ldr	r3, [sp, #4]
 800c00c:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 800c00e:	9b01      	ldr	r3, [sp, #4]
 800c010:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800c012:	9b01      	ldr	r3, [sp, #4]
 800c014:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c016:	429a      	cmp	r2, r3
 800c018:	d302      	bcc.n	800c020 <ibqGetTimeout+0x50>
    ibqReleaseEmptyBufferS(ibqp);
 800c01a:	9801      	ldr	r0, [sp, #4]
 800c01c:	f7ff ffa0 	bl	800bf60 <ibqReleaseEmptyBufferS.4161>
  }

  osalSysUnlock();
 800c020:	f7ff fe3e 	bl	800bca0 <osalSysUnlock.8913>
  return msg;
 800c024:	9b03      	ldr	r3, [sp, #12]
}
 800c026:	4618      	mov	r0, r3
 800c028:	b005      	add	sp, #20
 800c02a:	f85d fb04 	ldr.w	pc, [sp], #4
 800c02e:	bf00      	nop

0800c030 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 800c030:	b500      	push	{lr}
 800c032:	b08b      	sub	sp, #44	; 0x2c
 800c034:	9003      	str	r0, [sp, #12]
 800c036:	9102      	str	r1, [sp, #8]
 800c038:	9201      	str	r2, [sp, #4]
 800c03a:	9300      	str	r3, [sp, #0]
  size_t r = 0;
 800c03c:	2300      	movs	r3, #0
 800c03e:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 800c040:	f7ff fe26 	bl	800bc90 <osalSysLock.8909>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800c044:	f7ff fe34 	bl	800bcb0 <osalOsGetSystemTimeX.8894>
 800c048:	4602      	mov	r2, r0
 800c04a:	9b00      	ldr	r3, [sp, #0]
 800c04c:	4413      	add	r3, r2
 800c04e:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 800c050:	9b03      	ldr	r3, [sp, #12]
 800c052:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c054:	2b00      	cmp	r3, #0
 800c056:	d126      	bne.n	800c0a6 <ibqReadTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 800c058:	9b00      	ldr	r3, [sp, #0]
 800c05a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800c05e:	d002      	beq.n	800c066 <ibqReadTimeout+0x36>
 800c060:	9b00      	ldr	r3, [sp, #0]
 800c062:	2b00      	cmp	r3, #0
 800c064:	d105      	bne.n	800c072 <ibqReadTimeout+0x42>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 800c066:	9803      	ldr	r0, [sp, #12]
 800c068:	9900      	ldr	r1, [sp, #0]
 800c06a:	f7ff ff41 	bl	800bef0 <ibqGetFullBufferTimeoutS.4167>
 800c06e:	9007      	str	r0, [sp, #28]
 800c070:	e012      	b.n	800c098 <ibqReadTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 800c072:	f7ff fe1d 	bl	800bcb0 <osalOsGetSystemTimeX.8894>
 800c076:	4603      	mov	r3, r0
 800c078:	9a06      	ldr	r2, [sp, #24]
 800c07a:	1ad3      	subs	r3, r2, r3
 800c07c:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 800c07e:	9a05      	ldr	r2, [sp, #20]
 800c080:	9b00      	ldr	r3, [sp, #0]
 800c082:	429a      	cmp	r2, r3
 800c084:	d903      	bls.n	800c08e <ibqReadTimeout+0x5e>
          osalSysUnlock();
 800c086:	f7ff fe0b 	bl	800bca0 <osalSysUnlock.8913>
          return r;
 800c08a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c08c:	e05c      	b.n	800c148 <ibqReadTimeout+0x118>
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 800c08e:	9803      	ldr	r0, [sp, #12]
 800c090:	9905      	ldr	r1, [sp, #20]
 800c092:	f7ff ff2d 	bl	800bef0 <ibqGetFullBufferTimeoutS.4167>
 800c096:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 800c098:	9b07      	ldr	r3, [sp, #28]
 800c09a:	2b00      	cmp	r3, #0
 800c09c:	d003      	beq.n	800c0a6 <ibqReadTimeout+0x76>
        osalSysUnlock();
 800c09e:	f7ff fdff 	bl	800bca0 <osalSysUnlock.8913>
        return r;
 800c0a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c0a4:	e050      	b.n	800c148 <ibqReadTimeout+0x118>
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 800c0a6:	9b03      	ldr	r3, [sp, #12]
 800c0a8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c0aa:	461a      	mov	r2, r3
 800c0ac:	9b03      	ldr	r3, [sp, #12]
 800c0ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c0b0:	1ad3      	subs	r3, r2, r3
 800c0b2:	9308      	str	r3, [sp, #32]
    if (size > (n - r)) {
 800c0b4:	9a01      	ldr	r2, [sp, #4]
 800c0b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c0b8:	1ad2      	subs	r2, r2, r3
 800c0ba:	9b08      	ldr	r3, [sp, #32]
 800c0bc:	429a      	cmp	r2, r3
 800c0be:	d203      	bcs.n	800c0c8 <ibqReadTimeout+0x98>
      size = n - r;
 800c0c0:	9a01      	ldr	r2, [sp, #4]
 800c0c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c0c4:	1ad3      	subs	r3, r2, r3
 800c0c6:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 800c0c8:	9b08      	ldr	r3, [sp, #32]
 800c0ca:	2b40      	cmp	r3, #64	; 0x40
 800c0cc:	d913      	bls.n	800c0f6 <ibqReadTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 800c0ce:	9b03      	ldr	r3, [sp, #12]
 800c0d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c0d2:	9802      	ldr	r0, [sp, #8]
 800c0d4:	4619      	mov	r1, r3
 800c0d6:	2240      	movs	r2, #64	; 0x40
 800c0d8:	f7f4 f91a 	bl	8000310 <memcpy>
      bp        += 64U;
 800c0dc:	9b02      	ldr	r3, [sp, #8]
 800c0de:	3340      	adds	r3, #64	; 0x40
 800c0e0:	9302      	str	r3, [sp, #8]
      ibqp->ptr += 64U;
 800c0e2:	9b03      	ldr	r3, [sp, #12]
 800c0e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c0e6:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800c0ea:	9b03      	ldr	r3, [sp, #12]
 800c0ec:	625a      	str	r2, [r3, #36]	; 0x24
      r         += 64U;
 800c0ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c0f0:	3340      	adds	r3, #64	; 0x40
 800c0f2:	9309      	str	r3, [sp, #36]	; 0x24
 800c0f4:	e014      	b.n	800c120 <ibqReadTimeout+0xf0>
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 800c0f6:	9b03      	ldr	r3, [sp, #12]
 800c0f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c0fa:	9802      	ldr	r0, [sp, #8]
 800c0fc:	4619      	mov	r1, r3
 800c0fe:	9a08      	ldr	r2, [sp, #32]
 800c100:	f7f4 f906 	bl	8000310 <memcpy>
      bp        += size;
 800c104:	9a02      	ldr	r2, [sp, #8]
 800c106:	9b08      	ldr	r3, [sp, #32]
 800c108:	4413      	add	r3, r2
 800c10a:	9302      	str	r3, [sp, #8]
      ibqp->ptr += size;
 800c10c:	9b03      	ldr	r3, [sp, #12]
 800c10e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800c110:	9b08      	ldr	r3, [sp, #32]
 800c112:	441a      	add	r2, r3
 800c114:	9b03      	ldr	r3, [sp, #12]
 800c116:	625a      	str	r2, [r3, #36]	; 0x24
      r         += size;
 800c118:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c11a:	9b08      	ldr	r3, [sp, #32]
 800c11c:	4413      	add	r3, r2
 800c11e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 800c120:	9b03      	ldr	r3, [sp, #12]
 800c122:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800c124:	9b03      	ldr	r3, [sp, #12]
 800c126:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c128:	429a      	cmp	r2, r3
 800c12a:	d302      	bcc.n	800c132 <ibqReadTimeout+0x102>
      ibqReleaseEmptyBufferS(ibqp);
 800c12c:	9803      	ldr	r0, [sp, #12]
 800c12e:	f7ff ff17 	bl	800bf60 <ibqReleaseEmptyBufferS.4161>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 800c132:	f7ff fdb5 	bl	800bca0 <osalSysUnlock.8913>
    if (r >= n) {
 800c136:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c138:	9b01      	ldr	r3, [sp, #4]
 800c13a:	429a      	cmp	r2, r3
 800c13c:	d301      	bcc.n	800c142 <ibqReadTimeout+0x112>
      return r;
 800c13e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c140:	e002      	b.n	800c148 <ibqReadTimeout+0x118>
    }
    osalSysLock();
 800c142:	f7ff fda5 	bl	800bc90 <osalSysLock.8909>
 800c146:	e783      	b.n	800c050 <ibqReadTimeout+0x20>
  }
}
 800c148:	4618      	mov	r0, r3
 800c14a:	b00b      	add	sp, #44	; 0x2c
 800c14c:	f85d fb04 	ldr.w	pc, [sp], #4

0800c150 <obqObjectInit>:
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t onfy, void *link) {
 800c150:	b500      	push	{lr}
 800c152:	b085      	sub	sp, #20
 800c154:	9003      	str	r0, [sp, #12]
 800c156:	9102      	str	r1, [sp, #8]
 800c158:	9201      	str	r2, [sp, #4]
 800c15a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));
 800c15c:	9b03      	ldr	r3, [sp, #12]
 800c15e:	2b00      	cmp	r3, #0
 800c160:	d005      	beq.n	800c16e <obqObjectInit+0x1e>
 800c162:	9b02      	ldr	r3, [sp, #8]
 800c164:	2b00      	cmp	r3, #0
 800c166:	d002      	beq.n	800c16e <obqObjectInit+0x1e>
 800c168:	9b01      	ldr	r3, [sp, #4]
 800c16a:	2b01      	cmp	r3, #1
 800c16c:	d805      	bhi.n	800c17a <obqObjectInit+0x2a>
 800c16e:	f641 4060 	movw	r0, #7264	; 0x1c60
 800c172:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c176:	f003 f90b 	bl	800f390 <chSysHalt>

  osalThreadQueueObjectInit(&obqp->waiting);
 800c17a:	9b03      	ldr	r3, [sp, #12]
 800c17c:	4618      	mov	r0, r3
 800c17e:	f7ff fd9f 	bl	800bcc0 <osalThreadQueueObjectInit.8896.4205>
  obqp->bcounter = n;
 800c182:	9b03      	ldr	r3, [sp, #12]
 800c184:	9a00      	ldr	r2, [sp, #0]
 800c186:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = bp;
 800c188:	9b03      	ldr	r3, [sp, #12]
 800c18a:	9a02      	ldr	r2, [sp, #8]
 800c18c:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = bp;
 800c18e:	9b03      	ldr	r3, [sp, #12]
 800c190:	9a02      	ldr	r2, [sp, #8]
 800c192:	60da      	str	r2, [r3, #12]
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 800c194:	9b01      	ldr	r3, [sp, #4]
 800c196:	3304      	adds	r3, #4
 800c198:	9a00      	ldr	r2, [sp, #0]
 800c19a:	fb02 f303 	mul.w	r3, r2, r3
 800c19e:	9a02      	ldr	r2, [sp, #8]
 800c1a0:	441a      	add	r2, r3
 800c1a2:	9b03      	ldr	r3, [sp, #12]
 800c1a4:	615a      	str	r2, [r3, #20]
  obqp->bsize    = size + sizeof (size_t);
 800c1a6:	9b01      	ldr	r3, [sp, #4]
 800c1a8:	1d1a      	adds	r2, r3, #4
 800c1aa:	9b03      	ldr	r3, [sp, #12]
 800c1ac:	619a      	str	r2, [r3, #24]
  obqp->bn       = n;
 800c1ae:	9b03      	ldr	r3, [sp, #12]
 800c1b0:	9a00      	ldr	r2, [sp, #0]
 800c1b2:	61da      	str	r2, [r3, #28]
  obqp->buffers  = bp;
 800c1b4:	9b03      	ldr	r3, [sp, #12]
 800c1b6:	9a02      	ldr	r2, [sp, #8]
 800c1b8:	621a      	str	r2, [r3, #32]
  obqp->ptr      = NULL;
 800c1ba:	9b03      	ldr	r3, [sp, #12]
 800c1bc:	2200      	movs	r2, #0
 800c1be:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 800c1c0:	9b03      	ldr	r3, [sp, #12]
 800c1c2:	2200      	movs	r2, #0
 800c1c4:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->notify   = onfy;
 800c1c6:	9b03      	ldr	r3, [sp, #12]
 800c1c8:	9a06      	ldr	r2, [sp, #24]
 800c1ca:	62da      	str	r2, [r3, #44]	; 0x2c
  obqp->link     = link;
 800c1cc:	9b03      	ldr	r3, [sp, #12]
 800c1ce:	9a07      	ldr	r2, [sp, #28]
 800c1d0:	631a      	str	r2, [r3, #48]	; 0x30
}
 800c1d2:	b005      	add	sp, #20
 800c1d4:	f85d fb04 	ldr.w	pc, [sp], #4
 800c1d8:	f3af 8000 	nop.w
 800c1dc:	f3af 8000 	nop.w

0800c1e0 <obqResetI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 800c1e0:	b500      	push	{lr}
 800c1e2:	b083      	sub	sp, #12
 800c1e4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 800c1e6:	f003 fb4b 	bl	800f880 <chDbgCheckClassI>

  obqp->bcounter = bqSizeX(obqp);
 800c1ea:	9b01      	ldr	r3, [sp, #4]
 800c1ec:	69da      	ldr	r2, [r3, #28]
 800c1ee:	9b01      	ldr	r3, [sp, #4]
 800c1f0:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = obqp->buffers;
 800c1f2:	9b01      	ldr	r3, [sp, #4]
 800c1f4:	6a1a      	ldr	r2, [r3, #32]
 800c1f6:	9b01      	ldr	r3, [sp, #4]
 800c1f8:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = obqp->buffers;
 800c1fa:	9b01      	ldr	r3, [sp, #4]
 800c1fc:	6a1a      	ldr	r2, [r3, #32]
 800c1fe:	9b01      	ldr	r3, [sp, #4]
 800c200:	60da      	str	r2, [r3, #12]
  obqp->ptr      = NULL;
 800c202:	9b01      	ldr	r3, [sp, #4]
 800c204:	2200      	movs	r2, #0
 800c206:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 800c208:	9b01      	ldr	r3, [sp, #4]
 800c20a:	2200      	movs	r2, #0
 800c20c:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800c20e:	9b01      	ldr	r3, [sp, #4]
 800c210:	4618      	mov	r0, r3
 800c212:	f06f 0101 	mvn.w	r1, #1
 800c216:	f7ff fd83 	bl	800bd20 <osalThreadDequeueAllI.8899.4193>
}
 800c21a:	b003      	add	sp, #12
 800c21c:	f85d fb04 	ldr.w	pc, [sp], #4

0800c220 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 800c220:	b500      	push	{lr}
 800c222:	b083      	sub	sp, #12
 800c224:	9001      	str	r0, [sp, #4]
 800c226:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 800c228:	f003 fb2a 	bl	800f880 <chDbgCheckClassI>

  if (obqIsEmptyI(obqp)) {
 800c22c:	9b01      	ldr	r3, [sp, #4]
 800c22e:	68da      	ldr	r2, [r3, #12]
 800c230:	9b01      	ldr	r3, [sp, #4]
 800c232:	691b      	ldr	r3, [r3, #16]
 800c234:	429a      	cmp	r2, r3
 800c236:	d105      	bne.n	800c244 <obqGetFullBufferI+0x24>
 800c238:	9b01      	ldr	r3, [sp, #4]
 800c23a:	689b      	ldr	r3, [r3, #8]
 800c23c:	2b00      	cmp	r3, #0
 800c23e:	d001      	beq.n	800c244 <obqGetFullBufferI+0x24>
 800c240:	2301      	movs	r3, #1
 800c242:	e000      	b.n	800c246 <obqGetFullBufferI+0x26>
 800c244:	2300      	movs	r3, #0
 800c246:	f003 0301 	and.w	r3, r3, #1
 800c24a:	b2db      	uxtb	r3, r3
 800c24c:	2b00      	cmp	r3, #0
 800c24e:	d001      	beq.n	800c254 <obqGetFullBufferI+0x34>
    return NULL;
 800c250:	2300      	movs	r3, #0
 800c252:	e007      	b.n	800c264 <obqGetFullBufferI+0x44>
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 800c254:	9b01      	ldr	r3, [sp, #4]
 800c256:	691b      	ldr	r3, [r3, #16]
 800c258:	681a      	ldr	r2, [r3, #0]
 800c25a:	9b00      	ldr	r3, [sp, #0]
 800c25c:	601a      	str	r2, [r3, #0]

  return obqp->brdptr + sizeof (size_t);
 800c25e:	9b01      	ldr	r3, [sp, #4]
 800c260:	691b      	ldr	r3, [r3, #16]
 800c262:	3304      	adds	r3, #4
}
 800c264:	4618      	mov	r0, r3
 800c266:	b003      	add	sp, #12
 800c268:	f85d fb04 	ldr.w	pc, [sp], #4
 800c26c:	f3af 8000 	nop.w

0800c270 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 800c270:	b500      	push	{lr}
 800c272:	b083      	sub	sp, #12
 800c274:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 800c276:	f003 fb03 	bl	800f880 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 800c27a:	9b01      	ldr	r3, [sp, #4]
 800c27c:	68da      	ldr	r2, [r3, #12]
 800c27e:	9b01      	ldr	r3, [sp, #4]
 800c280:	691b      	ldr	r3, [r3, #16]
 800c282:	429a      	cmp	r2, r3
 800c284:	d105      	bne.n	800c292 <obqReleaseEmptyBufferI+0x22>
 800c286:	9b01      	ldr	r3, [sp, #4]
 800c288:	689b      	ldr	r3, [r3, #8]
 800c28a:	2b00      	cmp	r3, #0
 800c28c:	d001      	beq.n	800c292 <obqReleaseEmptyBufferI+0x22>
 800c28e:	2301      	movs	r3, #1
 800c290:	e000      	b.n	800c294 <obqReleaseEmptyBufferI+0x24>
 800c292:	2300      	movs	r3, #0
 800c294:	f003 0301 	and.w	r3, r3, #1
 800c298:	b2db      	uxtb	r3, r3
 800c29a:	2b00      	cmp	r3, #0
 800c29c:	d005      	beq.n	800c2aa <obqReleaseEmptyBufferI+0x3a>
 800c29e:	f641 4070 	movw	r0, #7280	; 0x1c70
 800c2a2:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c2a6:	f003 f873 	bl	800f390 <chSysHalt>

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 800c2aa:	9b01      	ldr	r3, [sp, #4]
 800c2ac:	689b      	ldr	r3, [r3, #8]
 800c2ae:	1c5a      	adds	r2, r3, #1
 800c2b0:	9b01      	ldr	r3, [sp, #4]
 800c2b2:	609a      	str	r2, [r3, #8]
  obqp->brdptr += obqp->bsize;
 800c2b4:	9b01      	ldr	r3, [sp, #4]
 800c2b6:	691a      	ldr	r2, [r3, #16]
 800c2b8:	9b01      	ldr	r3, [sp, #4]
 800c2ba:	699b      	ldr	r3, [r3, #24]
 800c2bc:	441a      	add	r2, r3
 800c2be:	9b01      	ldr	r3, [sp, #4]
 800c2c0:	611a      	str	r2, [r3, #16]
  if (obqp->brdptr >= obqp->btop) {
 800c2c2:	9b01      	ldr	r3, [sp, #4]
 800c2c4:	691a      	ldr	r2, [r3, #16]
 800c2c6:	9b01      	ldr	r3, [sp, #4]
 800c2c8:	695b      	ldr	r3, [r3, #20]
 800c2ca:	429a      	cmp	r2, r3
 800c2cc:	d303      	bcc.n	800c2d6 <obqReleaseEmptyBufferI+0x66>
    obqp->brdptr = obqp->buffers;
 800c2ce:	9b01      	ldr	r3, [sp, #4]
 800c2d0:	6a1a      	ldr	r2, [r3, #32]
 800c2d2:	9b01      	ldr	r3, [sp, #4]
 800c2d4:	611a      	str	r2, [r3, #16]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 800c2d6:	9b01      	ldr	r3, [sp, #4]
 800c2d8:	4618      	mov	r0, r3
 800c2da:	2100      	movs	r1, #0
 800c2dc:	f7ff fd10 	bl	800bd00 <osalThreadDequeueNextI.8903.4197>
}
 800c2e0:	b003      	add	sp, #12
 800c2e2:	f85d fb04 	ldr.w	pc, [sp], #4
 800c2e6:	bf00      	nop
 800c2e8:	f3af 8000 	nop.w
 800c2ec:	f3af 8000 	nop.w

0800c2f0 <obqGetEmptyBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {
 800c2f0:	b500      	push	{lr}
 800c2f2:	b085      	sub	sp, #20
 800c2f4:	9001      	str	r0, [sp, #4]
 800c2f6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 800c2f8:	f003 fada 	bl	800f8b0 <chDbgCheckClassS>
 800c2fc:	e00a      	b.n	800c314 <obqGetEmptyBufferTimeoutS+0x24>

  while (obqIsFullI(obqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 800c2fe:	9b01      	ldr	r3, [sp, #4]
 800c300:	4618      	mov	r0, r3
 800c302:	9900      	ldr	r1, [sp, #0]
 800c304:	f7ff fcec 	bl	800bce0 <osalThreadEnqueueTimeoutS.8915.4201>
 800c308:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 800c30a:	9b03      	ldr	r3, [sp, #12]
 800c30c:	2b00      	cmp	r3, #0
 800c30e:	da01      	bge.n	800c314 <obqGetEmptyBufferTimeoutS+0x24>
      return msg;
 800c310:	9b03      	ldr	r3, [sp, #12]
 800c312:	e01a      	b.n	800c34a <obqGetEmptyBufferTimeoutS+0x5a>
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 800c314:	9b01      	ldr	r3, [sp, #4]
 800c316:	689b      	ldr	r3, [r3, #8]
 800c318:	2b00      	cmp	r3, #0
 800c31a:	d0f0      	beq.n	800c2fe <obqGetEmptyBufferTimeoutS+0xe>
    if (msg < MSG_OK) {
      return msg;
    }
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");
 800c31c:	9b01      	ldr	r3, [sp, #4]
 800c31e:	689b      	ldr	r3, [r3, #8]
 800c320:	2b00      	cmp	r3, #0
 800c322:	d105      	bne.n	800c330 <obqGetEmptyBufferTimeoutS+0x40>
 800c324:	f641 4090 	movw	r0, #7312	; 0x1c90
 800c328:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c32c:	f003 f830 	bl	800f390 <chSysHalt>

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800c330:	9b01      	ldr	r3, [sp, #4]
 800c332:	68db      	ldr	r3, [r3, #12]
 800c334:	1d1a      	adds	r2, r3, #4
 800c336:	9b01      	ldr	r3, [sp, #4]
 800c338:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top = obqp->bwrptr + obqp->bsize;
 800c33a:	9b01      	ldr	r3, [sp, #4]
 800c33c:	68da      	ldr	r2, [r3, #12]
 800c33e:	9b01      	ldr	r3, [sp, #4]
 800c340:	699b      	ldr	r3, [r3, #24]
 800c342:	441a      	add	r2, r3
 800c344:	9b01      	ldr	r3, [sp, #4]
 800c346:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 800c348:	2300      	movs	r3, #0
}
 800c34a:	4618      	mov	r0, r3
 800c34c:	b005      	add	sp, #20
 800c34e:	f85d fb04 	ldr.w	pc, [sp], #4
 800c352:	bf00      	nop
 800c354:	f3af 8000 	nop.w
 800c358:	f3af 8000 	nop.w
 800c35c:	f3af 8000 	nop.w

0800c360 <chMtxTryLockS>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @sclass
 */
bool chMtxTryLockS(mutex_t *mp) {
 800c360:	b500      	push	{lr}
 800c362:	b083      	sub	sp, #12
 800c364:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 800c366:	f003 faa3 	bl	800f8b0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800c36a:	9b01      	ldr	r3, [sp, #4]
 800c36c:	2b00      	cmp	r3, #0
 800c36e:	d105      	bne.n	800c37c <chMtxTryLockS+0x1c>
 800c370:	f641 00c0 	movw	r0, #6336	; 0x18c0
 800c374:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c378:	f003 f80a 	bl	800f390 <chSysHalt>

  if (mp->m_owner != NULL) {
 800c37c:	9b01      	ldr	r3, [sp, #4]
 800c37e:	689b      	ldr	r3, [r3, #8]
 800c380:	2b00      	cmp	r3, #0
 800c382:	d001      	beq.n	800c388 <chMtxTryLockS+0x28>
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 800c384:	2300      	movs	r3, #0
 800c386:	e016      	b.n	800c3b6 <chMtxTryLockS+0x56>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 800c388:	f640 5350 	movw	r3, #3408	; 0xd50
 800c38c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c390:	699a      	ldr	r2, [r3, #24]
 800c392:	9b01      	ldr	r3, [sp, #4]
 800c394:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
 800c396:	f640 5350 	movw	r3, #3408	; 0xd50
 800c39a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c39e:	699b      	ldr	r3, [r3, #24]
 800c3a0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c3a2:	9b01      	ldr	r3, [sp, #4]
 800c3a4:	60da      	str	r2, [r3, #12]
  currp->p_mtxlist = mp;
 800c3a6:	f640 5350 	movw	r3, #3408	; 0xd50
 800c3aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c3ae:	699b      	ldr	r3, [r3, #24]
 800c3b0:	9a01      	ldr	r2, [sp, #4]
 800c3b2:	63da      	str	r2, [r3, #60]	; 0x3c
  return true;
 800c3b4:	2301      	movs	r3, #1
}
 800c3b6:	4618      	mov	r0, r3
 800c3b8:	b003      	add	sp, #12
 800c3ba:	f85d fb04 	ldr.w	pc, [sp], #4
 800c3be:	bf00      	nop

0800c3c0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 800c3c0:	b500      	push	{lr}
 800c3c2:	b087      	sub	sp, #28
 800c3c4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 800c3c6:	f640 5350 	movw	r3, #3408	; 0xd50
 800c3ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c3ce:	699b      	ldr	r3, [r3, #24]
 800c3d0:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800c3d2:	9b01      	ldr	r3, [sp, #4]
 800c3d4:	2b00      	cmp	r3, #0
 800c3d6:	d105      	bne.n	800c3e4 <chMtxUnlock+0x24>
 800c3d8:	f641 00d0 	movw	r0, #6352	; 0x18d0
 800c3dc:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c3e0:	f002 ffd6 	bl	800f390 <chSysHalt>

  chSysLock();
 800c3e4:	f002 fbf4 	bl	800ebd0 <chSysLock.6781>

  chDbgAssert(ctp->p_mtxlist != NULL, "owned mutexes list empty");
 800c3e8:	9b03      	ldr	r3, [sp, #12]
 800c3ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c3ec:	2b00      	cmp	r3, #0
 800c3ee:	d105      	bne.n	800c3fc <chMtxUnlock+0x3c>
 800c3f0:	f641 00d0 	movw	r0, #6352	; 0x18d0
 800c3f4:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c3f8:	f002 ffca 	bl	800f390 <chSysHalt>
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp, "ownership failure");
 800c3fc:	9b03      	ldr	r3, [sp, #12]
 800c3fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c400:	689a      	ldr	r2, [r3, #8]
 800c402:	9b03      	ldr	r3, [sp, #12]
 800c404:	429a      	cmp	r2, r3
 800c406:	d005      	beq.n	800c414 <chMtxUnlock+0x54>
 800c408:	f641 00d0 	movw	r0, #6352	; 0x18d0
 800c40c:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c410:	f002 ffbe 	bl	800f390 <chSysHalt>
  chDbgAssert(mp->m_cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->m_cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");
 800c414:	9b03      	ldr	r3, [sp, #12]
 800c416:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c418:	9b01      	ldr	r3, [sp, #4]
 800c41a:	429a      	cmp	r2, r3
 800c41c:	d005      	beq.n	800c42a <chMtxUnlock+0x6a>
 800c41e:	f641 00d0 	movw	r0, #6352	; 0x18d0
 800c422:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c426:	f002 ffb3 	bl	800f390 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800c42a:	9b01      	ldr	r3, [sp, #4]
 800c42c:	68da      	ldr	r2, [r3, #12]
 800c42e:	9b03      	ldr	r3, [sp, #12]
 800c430:	63da      	str	r2, [r3, #60]	; 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800c432:	9801      	ldr	r0, [sp, #4]
 800c434:	f002 fbfc 	bl	800ec30 <chMtxQueueNotEmptyS.6785>
 800c438:	4603      	mov	r3, r0
 800c43a:	2b00      	cmp	r3, #0
 800c43c:	d034      	beq.n	800c4a8 <chMtxUnlock+0xe8>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 800c43e:	9b03      	ldr	r3, [sp, #12]
 800c440:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c442:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 800c444:	9b03      	ldr	r3, [sp, #12]
 800c446:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c448:	9305      	str	r3, [sp, #20]
 800c44a:	e012      	b.n	800c472 <chMtxUnlock+0xb2>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800c44c:	9805      	ldr	r0, [sp, #20]
 800c44e:	f002 fbef 	bl	800ec30 <chMtxQueueNotEmptyS.6785>
 800c452:	4603      	mov	r3, r0
 800c454:	2b00      	cmp	r3, #0
 800c456:	d009      	beq.n	800c46c <chMtxUnlock+0xac>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800c458:	9b05      	ldr	r3, [sp, #20]
 800c45a:	681b      	ldr	r3, [r3, #0]
 800c45c:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800c45e:	9b04      	ldr	r3, [sp, #16]
 800c460:	429a      	cmp	r2, r3
 800c462:	d903      	bls.n	800c46c <chMtxUnlock+0xac>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 800c464:	9b05      	ldr	r3, [sp, #20]
 800c466:	681b      	ldr	r3, [r3, #0]
 800c468:	689b      	ldr	r3, [r3, #8]
 800c46a:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 800c46c:	9b05      	ldr	r3, [sp, #20]
 800c46e:	68db      	ldr	r3, [r3, #12]
 800c470:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800c472:	9b05      	ldr	r3, [sp, #20]
 800c474:	2b00      	cmp	r3, #0
 800c476:	d1e9      	bne.n	800c44c <chMtxUnlock+0x8c>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800c478:	9b03      	ldr	r3, [sp, #12]
 800c47a:	9a04      	ldr	r2, [sp, #16]
 800c47c:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 800c47e:	9b01      	ldr	r3, [sp, #4]
 800c480:	4618      	mov	r0, r3
 800c482:	f002 fb7d 	bl	800eb80 <queue_fifo_remove.6775>
 800c486:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 800c488:	9b01      	ldr	r3, [sp, #4]
 800c48a:	9a02      	ldr	r2, [sp, #8]
 800c48c:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 800c48e:	9b02      	ldr	r3, [sp, #8]
 800c490:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c492:	9b01      	ldr	r3, [sp, #4]
 800c494:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 800c496:	9b02      	ldr	r3, [sp, #8]
 800c498:	9a01      	ldr	r2, [sp, #4]
 800c49a:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800c49c:	9802      	ldr	r0, [sp, #8]
 800c49e:	f003 fcdf 	bl	800fe60 <chSchReadyI>
      chSchRescheduleS();
 800c4a2:	f003 fe5d 	bl	8010160 <chSchRescheduleS>
 800c4a6:	e002      	b.n	800c4ae <chMtxUnlock+0xee>
    }
    else {
      mp->m_owner = NULL;
 800c4a8:	9b01      	ldr	r3, [sp, #4]
 800c4aa:	2200      	movs	r2, #0
 800c4ac:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 800c4ae:	f002 fb97 	bl	800ebe0 <chSysUnlock.6783>
}
 800c4b2:	b007      	add	sp, #28
 800c4b4:	f85d fb04 	ldr.w	pc, [sp], #4
 800c4b8:	f3af 8000 	nop.w
 800c4bc:	f3af 8000 	nop.w

0800c4c0 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 800c4c0:	b500      	push	{lr}
 800c4c2:	b087      	sub	sp, #28
 800c4c4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 800c4c6:	f640 5350 	movw	r3, #3408	; 0xd50
 800c4ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c4ce:	699b      	ldr	r3, [r3, #24]
 800c4d0:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheckClassS();
 800c4d2:	f003 f9ed 	bl	800f8b0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800c4d6:	9b01      	ldr	r3, [sp, #4]
 800c4d8:	2b00      	cmp	r3, #0
 800c4da:	d105      	bne.n	800c4e8 <chMtxUnlockS+0x28>
 800c4dc:	f641 00e0 	movw	r0, #6368	; 0x18e0
 800c4e0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c4e4:	f002 ff54 	bl	800f390 <chSysHalt>

  chDbgAssert(ctp->p_mtxlist != NULL, "owned mutexes list empty");
 800c4e8:	9b03      	ldr	r3, [sp, #12]
 800c4ea:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c4ec:	2b00      	cmp	r3, #0
 800c4ee:	d105      	bne.n	800c4fc <chMtxUnlockS+0x3c>
 800c4f0:	f641 00e0 	movw	r0, #6368	; 0x18e0
 800c4f4:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c4f8:	f002 ff4a 	bl	800f390 <chSysHalt>
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp, "ownership failure");
 800c4fc:	9b03      	ldr	r3, [sp, #12]
 800c4fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c500:	689a      	ldr	r2, [r3, #8]
 800c502:	9b03      	ldr	r3, [sp, #12]
 800c504:	429a      	cmp	r2, r3
 800c506:	d005      	beq.n	800c514 <chMtxUnlockS+0x54>
 800c508:	f641 00e0 	movw	r0, #6368	; 0x18e0
 800c50c:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c510:	f002 ff3e 	bl	800f390 <chSysHalt>
  chDbgAssert(mp->m_cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->m_cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");
 800c514:	9b03      	ldr	r3, [sp, #12]
 800c516:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c518:	9b01      	ldr	r3, [sp, #4]
 800c51a:	429a      	cmp	r2, r3
 800c51c:	d005      	beq.n	800c52a <chMtxUnlockS+0x6a>
 800c51e:	f641 00e0 	movw	r0, #6368	; 0x18e0
 800c522:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c526:	f002 ff33 	bl	800f390 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800c52a:	9b01      	ldr	r3, [sp, #4]
 800c52c:	68da      	ldr	r2, [r3, #12]
 800c52e:	9b03      	ldr	r3, [sp, #12]
 800c530:	63da      	str	r2, [r3, #60]	; 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800c532:	9801      	ldr	r0, [sp, #4]
 800c534:	f002 fb7c 	bl	800ec30 <chMtxQueueNotEmptyS.6785>
 800c538:	4603      	mov	r3, r0
 800c53a:	2b00      	cmp	r3, #0
 800c53c:	d032      	beq.n	800c5a4 <chMtxUnlockS+0xe4>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 800c53e:	9b03      	ldr	r3, [sp, #12]
 800c540:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800c542:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 800c544:	9b03      	ldr	r3, [sp, #12]
 800c546:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c548:	9305      	str	r3, [sp, #20]
 800c54a:	e012      	b.n	800c572 <chMtxUnlockS+0xb2>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800c54c:	9805      	ldr	r0, [sp, #20]
 800c54e:	f002 fb6f 	bl	800ec30 <chMtxQueueNotEmptyS.6785>
 800c552:	4603      	mov	r3, r0
 800c554:	2b00      	cmp	r3, #0
 800c556:	d009      	beq.n	800c56c <chMtxUnlockS+0xac>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800c558:	9b05      	ldr	r3, [sp, #20]
 800c55a:	681b      	ldr	r3, [r3, #0]
 800c55c:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800c55e:	9b04      	ldr	r3, [sp, #16]
 800c560:	429a      	cmp	r2, r3
 800c562:	d903      	bls.n	800c56c <chMtxUnlockS+0xac>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 800c564:	9b05      	ldr	r3, [sp, #20]
 800c566:	681b      	ldr	r3, [r3, #0]
 800c568:	689b      	ldr	r3, [r3, #8]
 800c56a:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 800c56c:	9b05      	ldr	r3, [sp, #20]
 800c56e:	68db      	ldr	r3, [r3, #12]
 800c570:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800c572:	9b05      	ldr	r3, [sp, #20]
 800c574:	2b00      	cmp	r3, #0
 800c576:	d1e9      	bne.n	800c54c <chMtxUnlockS+0x8c>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800c578:	9b03      	ldr	r3, [sp, #12]
 800c57a:	9a04      	ldr	r2, [sp, #16]
 800c57c:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 800c57e:	9b01      	ldr	r3, [sp, #4]
 800c580:	4618      	mov	r0, r3
 800c582:	f002 fafd 	bl	800eb80 <queue_fifo_remove.6775>
 800c586:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 800c588:	9b01      	ldr	r3, [sp, #4]
 800c58a:	9a02      	ldr	r2, [sp, #8]
 800c58c:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 800c58e:	9b02      	ldr	r3, [sp, #8]
 800c590:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c592:	9b01      	ldr	r3, [sp, #4]
 800c594:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 800c596:	9b02      	ldr	r3, [sp, #8]
 800c598:	9a01      	ldr	r2, [sp, #4]
 800c59a:	63da      	str	r2, [r3, #60]	; 0x3c
      (void) chSchReadyI(tp);
 800c59c:	9802      	ldr	r0, [sp, #8]
 800c59e:	f003 fc5f 	bl	800fe60 <chSchReadyI>
 800c5a2:	e002      	b.n	800c5aa <chMtxUnlockS+0xea>
    }
    else {
      mp->m_owner = NULL;
 800c5a4:	9b01      	ldr	r3, [sp, #4]
 800c5a6:	2200      	movs	r2, #0
 800c5a8:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800c5aa:	b007      	add	sp, #28
 800c5ac:	f85d fb04 	ldr.w	pc, [sp], #4

0800c5b0 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 800c5b0:	b500      	push	{lr}
 800c5b2:	b085      	sub	sp, #20
  thread_t *ctp = currp;
 800c5b4:	f640 5350 	movw	r3, #3408	; 0xd50
 800c5b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c5bc:	699b      	ldr	r3, [r3, #24]
 800c5be:	9303      	str	r3, [sp, #12]

  chSysLock();
 800c5c0:	f002 fb06 	bl	800ebd0 <chSysLock.6781>
  if (ctp->p_mtxlist != NULL) {
 800c5c4:	9b03      	ldr	r3, [sp, #12]
 800c5c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c5c8:	2b00      	cmp	r3, #0
 800c5ca:	d02c      	beq.n	800c626 <chMtxUnlockAll+0x76>
    do {
      mutex_t *mp = ctp->p_mtxlist;
 800c5cc:	9b03      	ldr	r3, [sp, #12]
 800c5ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c5d0:	9302      	str	r3, [sp, #8]
      ctp->p_mtxlist = mp->m_next;
 800c5d2:	9b02      	ldr	r3, [sp, #8]
 800c5d4:	68da      	ldr	r2, [r3, #12]
 800c5d6:	9b03      	ldr	r3, [sp, #12]
 800c5d8:	63da      	str	r2, [r3, #60]	; 0x3c
      if (chMtxQueueNotEmptyS(mp)) {
 800c5da:	9802      	ldr	r0, [sp, #8]
 800c5dc:	f002 fb28 	bl	800ec30 <chMtxQueueNotEmptyS.6785>
 800c5e0:	4603      	mov	r3, r0
 800c5e2:	2b00      	cmp	r3, #0
 800c5e4:	d012      	beq.n	800c60c <chMtxUnlockAll+0x5c>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
 800c5e6:	9b02      	ldr	r3, [sp, #8]
 800c5e8:	4618      	mov	r0, r3
 800c5ea:	f002 fac9 	bl	800eb80 <queue_fifo_remove.6775>
 800c5ee:	9001      	str	r0, [sp, #4]
        mp->m_owner = tp;
 800c5f0:	9b02      	ldr	r3, [sp, #8]
 800c5f2:	9a01      	ldr	r2, [sp, #4]
 800c5f4:	609a      	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 800c5f6:	9b01      	ldr	r3, [sp, #4]
 800c5f8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c5fa:	9b02      	ldr	r3, [sp, #8]
 800c5fc:	60da      	str	r2, [r3, #12]
        tp->p_mtxlist = mp;
 800c5fe:	9b01      	ldr	r3, [sp, #4]
 800c600:	9a02      	ldr	r2, [sp, #8]
 800c602:	63da      	str	r2, [r3, #60]	; 0x3c
        (void) chSchReadyI(tp);
 800c604:	9801      	ldr	r0, [sp, #4]
 800c606:	f003 fc2b 	bl	800fe60 <chSchReadyI>
 800c60a:	e002      	b.n	800c612 <chMtxUnlockAll+0x62>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 800c60c:	9b02      	ldr	r3, [sp, #8]
 800c60e:	2200      	movs	r2, #0
 800c610:	609a      	str	r2, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 800c612:	9b03      	ldr	r3, [sp, #12]
 800c614:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c616:	2b00      	cmp	r3, #0
 800c618:	d1d8      	bne.n	800c5cc <chMtxUnlockAll+0x1c>
    ctp->p_prio = ctp->p_realprio;
 800c61a:	9b03      	ldr	r3, [sp, #12]
 800c61c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800c61e:	9b03      	ldr	r3, [sp, #12]
 800c620:	609a      	str	r2, [r3, #8]
    chSchRescheduleS();
 800c622:	f003 fd9d 	bl	8010160 <chSchRescheduleS>
  }
  chSysUnlock();
 800c626:	f002 fadb 	bl	800ebe0 <chSysUnlock.6783>
}
 800c62a:	b005      	add	sp, #20
 800c62c:	f85d fb04 	ldr.w	pc, [sp], #4

0800c630 <port_lock.6898.4398>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c630:	b082      	sub	sp, #8
 800c632:	2320      	movs	r3, #32
 800c634:	9301      	str	r3, [sp, #4]
 800c636:	9b01      	ldr	r3, [sp, #4]
 800c638:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c63c:	b002      	add	sp, #8
 800c63e:	4770      	bx	lr

0800c640 <port_unlock.6901.4396>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c640:	b082      	sub	sp, #8
 800c642:	2300      	movs	r3, #0
 800c644:	9301      	str	r3, [sp, #4]
 800c646:	9b01      	ldr	r3, [sp, #4]
 800c648:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c64c:	b002      	add	sp, #8
 800c64e:	4770      	bx	lr

0800c650 <queue_init.6903.4393>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800c650:	b082      	sub	sp, #8
 800c652:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800c654:	9b01      	ldr	r3, [sp, #4]
 800c656:	9a01      	ldr	r2, [sp, #4]
 800c658:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800c65a:	9b01      	ldr	r3, [sp, #4]
 800c65c:	9a01      	ldr	r2, [sp, #4]
 800c65e:	605a      	str	r2, [r3, #4]
}
 800c660:	b002      	add	sp, #8
 800c662:	4770      	bx	lr
 800c664:	f3af 8000 	nop.w
 800c668:	f3af 8000 	nop.w
 800c66c:	f3af 8000 	nop.w

0800c670 <queue_notempty.6992.4388>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 800c670:	b082      	sub	sp, #8
 800c672:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800c674:	9b01      	ldr	r3, [sp, #4]
 800c676:	681a      	ldr	r2, [r3, #0]
 800c678:	9b01      	ldr	r3, [sp, #4]
 800c67a:	429a      	cmp	r2, r3
 800c67c:	bf0c      	ite	eq
 800c67e:	2300      	moveq	r3, #0
 800c680:	2301      	movne	r3, #1
 800c682:	b2db      	uxtb	r3, r3
}
 800c684:	4618      	mov	r0, r3
 800c686:	b002      	add	sp, #8
 800c688:	4770      	bx	lr
 800c68a:	bf00      	nop
 800c68c:	f3af 8000 	nop.w

0800c690 <queue_prio_insert.6996.4384>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 800c690:	b084      	sub	sp, #16
 800c692:	9001      	str	r0, [sp, #4]
 800c694:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 800c696:	9b00      	ldr	r3, [sp, #0]
 800c698:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800c69a:	9b03      	ldr	r3, [sp, #12]
 800c69c:	681b      	ldr	r3, [r3, #0]
 800c69e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800c6a0:	9a03      	ldr	r2, [sp, #12]
 800c6a2:	9b00      	ldr	r3, [sp, #0]
 800c6a4:	429a      	cmp	r2, r3
 800c6a6:	d005      	beq.n	800c6b4 <queue_prio_insert.6996.4384+0x24>
 800c6a8:	9b03      	ldr	r3, [sp, #12]
 800c6aa:	689a      	ldr	r2, [r3, #8]
 800c6ac:	9b01      	ldr	r3, [sp, #4]
 800c6ae:	689b      	ldr	r3, [r3, #8]
 800c6b0:	429a      	cmp	r2, r3
 800c6b2:	d2f2      	bcs.n	800c69a <queue_prio_insert.6996.4384+0xa>
  tp->p_next = cp;
 800c6b4:	9b01      	ldr	r3, [sp, #4]
 800c6b6:	9a03      	ldr	r2, [sp, #12]
 800c6b8:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 800c6ba:	9b03      	ldr	r3, [sp, #12]
 800c6bc:	685a      	ldr	r2, [r3, #4]
 800c6be:	9b01      	ldr	r3, [sp, #4]
 800c6c0:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800c6c2:	9b01      	ldr	r3, [sp, #4]
 800c6c4:	685b      	ldr	r3, [r3, #4]
 800c6c6:	9a01      	ldr	r2, [sp, #4]
 800c6c8:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 800c6ca:	9b03      	ldr	r3, [sp, #12]
 800c6cc:	9a01      	ldr	r2, [sp, #4]
 800c6ce:	605a      	str	r2, [r3, #4]
}
 800c6d0:	b004      	add	sp, #16
 800c6d2:	4770      	bx	lr
 800c6d4:	f3af 8000 	nop.w
 800c6d8:	f3af 8000 	nop.w
 800c6dc:	f3af 8000 	nop.w

0800c6e0 <queue_fifo_remove.7000.4381>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800c6e0:	b084      	sub	sp, #16
 800c6e2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 800c6e4:	9b01      	ldr	r3, [sp, #4]
 800c6e6:	681b      	ldr	r3, [r3, #0]
 800c6e8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800c6ea:	9b03      	ldr	r3, [sp, #12]
 800c6ec:	681a      	ldr	r2, [r3, #0]
 800c6ee:	9b01      	ldr	r3, [sp, #4]
 800c6f0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800c6f2:	9b01      	ldr	r3, [sp, #4]
 800c6f4:	681b      	ldr	r3, [r3, #0]
 800c6f6:	9a01      	ldr	r2, [sp, #4]
 800c6f8:	605a      	str	r2, [r3, #4]

  return tp;
 800c6fa:	9b03      	ldr	r3, [sp, #12]
}
 800c6fc:	4618      	mov	r0, r3
 800c6fe:	b004      	add	sp, #16
 800c700:	4770      	bx	lr
 800c702:	bf00      	nop
 800c704:	f3af 8000 	nop.w
 800c708:	f3af 8000 	nop.w
 800c70c:	f3af 8000 	nop.w

0800c710 <chSysLock.7007.4379>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800c710:	b508      	push	{r3, lr}

  port_lock();
 800c712:	f7ff ff8d 	bl	800c630 <port_lock.6898.4398>
  _stats_start_measure_crit_thd();
 800c716:	f001 fc33 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800c71a:	f002 ffe1 	bl	800f6e0 <_dbg_check_lock>
}
 800c71e:	bd08      	pop	{r3, pc}

0800c720 <chSysUnlock.7009.4377>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800c720:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800c722:	f002 fffd 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800c726:	f001 fc33 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800c72a:	f640 5350 	movw	r3, #3408	; 0xd50
 800c72e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c732:	681a      	ldr	r2, [r3, #0]
 800c734:	f640 5350 	movw	r3, #3408	; 0xd50
 800c738:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c73c:	429a      	cmp	r2, r3
 800c73e:	d013      	beq.n	800c768 <chSysUnlock.7009.4377+0x48>
 800c740:	f640 5350 	movw	r3, #3408	; 0xd50
 800c744:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c748:	699b      	ldr	r3, [r3, #24]
 800c74a:	689a      	ldr	r2, [r3, #8]
 800c74c:	f640 5350 	movw	r3, #3408	; 0xd50
 800c750:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c754:	681b      	ldr	r3, [r3, #0]
 800c756:	689b      	ldr	r3, [r3, #8]
 800c758:	429a      	cmp	r2, r3
 800c75a:	d205      	bcs.n	800c768 <chSysUnlock.7009.4377+0x48>
 800c75c:	f641 1020 	movw	r0, #6432	; 0x1920
 800c760:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c764:	f002 fe14 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800c768:	f7ff ff6a 	bl	800c640 <port_unlock.6901.4396>
}
 800c76c:	bd08      	pop	{r3, pc}
 800c76e:	bf00      	nop

0800c770 <chThdGetSelfX.7003.4375>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800c770:	f640 5350 	movw	r3, #3408	; 0xd50
 800c774:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c778:	699b      	ldr	r3, [r3, #24]
}
 800c77a:	4618      	mov	r0, r3
 800c77c:	4770      	bx	lr
 800c77e:	bf00      	nop

0800c780 <chMtxGetNextMutexS.7005.4373>:
 * @return              A pointer to the next mutex in the stack.
 * @retval NULL         if the stack is empty.
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {
 800c780:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_mtxlist;
 800c782:	f7ff fff5 	bl	800c770 <chThdGetSelfX.7003.4375>
 800c786:	4603      	mov	r3, r0
 800c788:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
}
 800c78a:	4618      	mov	r0, r3
 800c78c:	bd08      	pop	{r3, pc}
 800c78e:	bf00      	nop

0800c790 <chCondObjectInit>:
 *
 * @param[out] cp       pointer to a @p condition_variable_t structure
 *
 * @init
 */
void chCondObjectInit(condition_variable_t *cp) {
 800c790:	b500      	push	{lr}
 800c792:	b083      	sub	sp, #12
 800c794:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);
 800c796:	9b01      	ldr	r3, [sp, #4]
 800c798:	2b00      	cmp	r3, #0
 800c79a:	d105      	bne.n	800c7a8 <chCondObjectInit+0x18>
 800c79c:	f641 00f0 	movw	r0, #6384	; 0x18f0
 800c7a0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c7a4:	f002 fdf4 	bl	800f390 <chSysHalt>

  queue_init(&cp->c_queue);
 800c7a8:	9b01      	ldr	r3, [sp, #4]
 800c7aa:	4618      	mov	r0, r3
 800c7ac:	f7ff ff50 	bl	800c650 <queue_init.6903.4393>
}
 800c7b0:	b003      	add	sp, #12
 800c7b2:	f85d fb04 	ldr.w	pc, [sp], #4
 800c7b6:	bf00      	nop
 800c7b8:	f3af 8000 	nop.w
 800c7bc:	f3af 8000 	nop.w

0800c7c0 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 800c7c0:	b500      	push	{lr}
 800c7c2:	b083      	sub	sp, #12
 800c7c4:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);
 800c7c6:	9b01      	ldr	r3, [sp, #4]
 800c7c8:	2b00      	cmp	r3, #0
 800c7ca:	d105      	bne.n	800c7d8 <chCondSignal+0x18>
 800c7cc:	f641 1010 	movw	r0, #6416	; 0x1910
 800c7d0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c7d4:	f002 fddc 	bl	800f390 <chSysHalt>

  chSysLock();
 800c7d8:	f7ff ff9a 	bl	800c710 <chSysLock.7007.4379>
  if (queue_notempty(&cp->c_queue)) {
 800c7dc:	9b01      	ldr	r3, [sp, #4]
 800c7de:	4618      	mov	r0, r3
 800c7e0:	f7ff ff46 	bl	800c670 <queue_notempty.6992.4388>
 800c7e4:	4603      	mov	r3, r0
 800c7e6:	2b00      	cmp	r3, #0
 800c7e8:	d008      	beq.n	800c7fc <chCondSignal+0x3c>
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 800c7ea:	9b01      	ldr	r3, [sp, #4]
 800c7ec:	4618      	mov	r0, r3
 800c7ee:	f7ff ff77 	bl	800c6e0 <queue_fifo_remove.7000.4381>
 800c7f2:	4603      	mov	r3, r0
 800c7f4:	4618      	mov	r0, r3
 800c7f6:	2100      	movs	r1, #0
 800c7f8:	f003 fc4a 	bl	8010090 <chSchWakeupS>
  }
  chSysUnlock();
 800c7fc:	f7ff ff90 	bl	800c720 <chSysUnlock.7009.4377>
}
 800c800:	b003      	add	sp, #12
 800c802:	f85d fb04 	ldr.w	pc, [sp], #4
 800c806:	bf00      	nop
 800c808:	f3af 8000 	nop.w
 800c80c:	f3af 8000 	nop.w

0800c810 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 800c810:	b500      	push	{lr}
 800c812:	b085      	sub	sp, #20
 800c814:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800c816:	f003 f833 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(cp != NULL);
 800c81a:	9b01      	ldr	r3, [sp, #4]
 800c81c:	2b00      	cmp	r3, #0
 800c81e:	d105      	bne.n	800c82c <chCondSignalI+0x1c>
 800c820:	f641 1030 	movw	r0, #6448	; 0x1930
 800c824:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c828:	f002 fdb2 	bl	800f390 <chSysHalt>

  if (queue_notempty(&cp->c_queue)) {
 800c82c:	9b01      	ldr	r3, [sp, #4]
 800c82e:	4618      	mov	r0, r3
 800c830:	f7ff ff1e 	bl	800c670 <queue_notempty.6992.4388>
 800c834:	4603      	mov	r3, r0
 800c836:	2b00      	cmp	r3, #0
 800c838:	d00a      	beq.n	800c850 <chCondSignalI+0x40>
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
 800c83a:	9b01      	ldr	r3, [sp, #4]
 800c83c:	4618      	mov	r0, r3
 800c83e:	f7ff ff4f 	bl	800c6e0 <queue_fifo_remove.7000.4381>
 800c842:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 800c844:	9b03      	ldr	r3, [sp, #12]
 800c846:	2200      	movs	r2, #0
 800c848:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800c84a:	9803      	ldr	r0, [sp, #12]
 800c84c:	f003 fb08 	bl	800fe60 <chSchReadyI>
  }
}
 800c850:	b005      	add	sp, #20
 800c852:	f85d fb04 	ldr.w	pc, [sp], #4
 800c856:	bf00      	nop
 800c858:	f3af 8000 	nop.w
 800c85c:	f3af 8000 	nop.w

0800c860 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 800c860:	b500      	push	{lr}
 800c862:	b083      	sub	sp, #12
 800c864:	9001      	str	r0, [sp, #4]

  chSysLock();
 800c866:	f7ff ff53 	bl	800c710 <chSysLock.7007.4379>
  chCondBroadcastI(cp);
 800c86a:	9801      	ldr	r0, [sp, #4]
 800c86c:	f000 f808 	bl	800c880 <chCondBroadcastI.4358>
  chSchRescheduleS();
 800c870:	f003 fc76 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 800c874:	f7ff ff54 	bl	800c720 <chSysUnlock.7009.4377>
}
 800c878:	b003      	add	sp, #12
 800c87a:	f85d fb04 	ldr.w	pc, [sp], #4
 800c87e:	bf00      	nop

0800c880 <chCondBroadcastI.4358>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 800c880:	b500      	push	{lr}
 800c882:	b083      	sub	sp, #12
 800c884:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800c886:	f002 fffb 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(cp != NULL);
 800c88a:	9b01      	ldr	r3, [sp, #4]
 800c88c:	2b00      	cmp	r3, #0
 800c88e:	d112      	bne.n	800c8b6 <chCondBroadcastI.4358+0x36>
 800c890:	f641 1040 	movw	r0, #6464	; 0x1940
 800c894:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c898:	f002 fd7a 	bl	800f390 <chSysHalt>
 800c89c:	e00b      	b.n	800c8b6 <chCondBroadcastI.4358+0x36>

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 800c89e:	9b01      	ldr	r3, [sp, #4]
 800c8a0:	4618      	mov	r0, r3
 800c8a2:	f7ff ff1d 	bl	800c6e0 <queue_fifo_remove.7000.4381>
 800c8a6:	4603      	mov	r3, r0
 800c8a8:	4618      	mov	r0, r3
 800c8aa:	f003 fad9 	bl	800fe60 <chSchReadyI>
 800c8ae:	4603      	mov	r3, r0
 800c8b0:	f06f 0201 	mvn.w	r2, #1
 800c8b4:	625a      	str	r2, [r3, #36]	; 0x24
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 800c8b6:	9b01      	ldr	r3, [sp, #4]
 800c8b8:	4618      	mov	r0, r3
 800c8ba:	f7ff fed9 	bl	800c670 <queue_notempty.6992.4388>
 800c8be:	4603      	mov	r3, r0
 800c8c0:	2b00      	cmp	r3, #0
 800c8c2:	d1ec      	bne.n	800c89e <chCondBroadcastI.4358+0x1e>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 800c8c4:	b003      	add	sp, #12
 800c8c6:	f85d fb04 	ldr.w	pc, [sp], #4
 800c8ca:	bf00      	nop
 800c8cc:	f3af 8000 	nop.w

0800c8d0 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 800c8d0:	b500      	push	{lr}
 800c8d2:	b085      	sub	sp, #20
 800c8d4:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 800c8d6:	f7ff ff1b 	bl	800c710 <chSysLock.7007.4379>
  msg = chCondWaitS(cp);
 800c8da:	9801      	ldr	r0, [sp, #4]
 800c8dc:	f000 f808 	bl	800c8f0 <chCondWaitS.4352>
 800c8e0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 800c8e2:	f7ff ff1d 	bl	800c720 <chSysUnlock.7009.4377>
  return msg;
 800c8e6:	9b03      	ldr	r3, [sp, #12]
}
 800c8e8:	4618      	mov	r0, r3
 800c8ea:	b005      	add	sp, #20
 800c8ec:	f85d fb04 	ldr.w	pc, [sp], #4

0800c8f0 <chCondWaitS.4352>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 800c8f0:	b500      	push	{lr}
 800c8f2:	b087      	sub	sp, #28
 800c8f4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 800c8f6:	f640 5350 	movw	r3, #3408	; 0xd50
 800c8fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c8fe:	699b      	ldr	r3, [r3, #24]
 800c900:	9305      	str	r3, [sp, #20]
  mutex_t *mp;
  msg_t msg;

  chDbgCheckClassS();
 800c902:	f002 ffd5 	bl	800f8b0 <chDbgCheckClassS>
  chDbgCheck(cp != NULL);
 800c906:	9b01      	ldr	r3, [sp, #4]
 800c908:	2b00      	cmp	r3, #0
 800c90a:	d105      	bne.n	800c918 <chCondWaitS.4352+0x28>
 800c90c:	f641 1060 	movw	r0, #6496	; 0x1960
 800c910:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c914:	f002 fd3c 	bl	800f390 <chSysHalt>
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");
 800c918:	9b05      	ldr	r3, [sp, #20]
 800c91a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c91c:	2b00      	cmp	r3, #0
 800c91e:	d105      	bne.n	800c92c <chCondWaitS.4352+0x3c>
 800c920:	f641 1060 	movw	r0, #6496	; 0x1960
 800c924:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c928:	f002 fd32 	bl	800f390 <chSysHalt>

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 800c92c:	f7ff ff28 	bl	800c780 <chMtxGetNextMutexS.7005.4373>
 800c930:	9004      	str	r0, [sp, #16]
  chMtxUnlockS(mp);
 800c932:	9804      	ldr	r0, [sp, #16]
 800c934:	f7ff fdc4 	bl	800c4c0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 800c938:	9b05      	ldr	r3, [sp, #20]
 800c93a:	9a01      	ldr	r2, [sp, #4]
 800c93c:	625a      	str	r2, [r3, #36]	; 0x24
  queue_prio_insert(ctp, &cp->c_queue);
 800c93e:	9b01      	ldr	r3, [sp, #4]
 800c940:	9805      	ldr	r0, [sp, #20]
 800c942:	4619      	mov	r1, r3
 800c944:	f7ff fea4 	bl	800c690 <queue_prio_insert.6996.4384>
  chSchGoSleepS(CH_STATE_WTCOND);
 800c948:	2007      	movs	r0, #7
 800c94a:	f003 fad1 	bl	800fef0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 800c94e:	9b05      	ldr	r3, [sp, #20]
 800c950:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c952:	9303      	str	r3, [sp, #12]
  chMtxLockS(mp);
 800c954:	9804      	ldr	r0, [sp, #16]
 800c956:	f002 f9a3 	bl	800eca0 <chMtxLockS>

  return msg;
 800c95a:	9b03      	ldr	r3, [sp, #12]
}
 800c95c:	4618      	mov	r0, r3
 800c95e:	b007      	add	sp, #28
 800c960:	f85d fb04 	ldr.w	pc, [sp], #4
 800c964:	f3af 8000 	nop.w
 800c968:	f3af 8000 	nop.w
 800c96c:	f3af 8000 	nop.w

0800c970 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, systime_t time) {
 800c970:	b500      	push	{lr}
 800c972:	b085      	sub	sp, #20
 800c974:	9001      	str	r0, [sp, #4]
 800c976:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 800c978:	f7ff feca 	bl	800c710 <chSysLock.7007.4379>
  msg = chCondWaitTimeoutS(cp, time);
 800c97c:	9801      	ldr	r0, [sp, #4]
 800c97e:	9900      	ldr	r1, [sp, #0]
 800c980:	f000 f80e 	bl	800c9a0 <chCondWaitTimeoutS.4340>
 800c984:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 800c986:	f7ff fecb 	bl	800c720 <chSysUnlock.7009.4377>

  return msg;
 800c98a:	9b03      	ldr	r3, [sp, #12]
}
 800c98c:	4618      	mov	r0, r3
 800c98e:	b005      	add	sp, #20
 800c990:	f85d fb04 	ldr.w	pc, [sp], #4
 800c994:	f3af 8000 	nop.w
 800c998:	f3af 8000 	nop.w
 800c99c:	f3af 8000 	nop.w

0800c9a0 <chCondWaitTimeoutS.4340>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 800c9a0:	b500      	push	{lr}
 800c9a2:	b085      	sub	sp, #20
 800c9a4:	9001      	str	r0, [sp, #4]
 800c9a6:	9100      	str	r1, [sp, #0]
  mutex_t *mp;
  msg_t msg;

  chDbgCheckClassS();
 800c9a8:	f002 ff82 	bl	800f8b0 <chDbgCheckClassS>
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
 800c9ac:	9b01      	ldr	r3, [sp, #4]
 800c9ae:	2b00      	cmp	r3, #0
 800c9b0:	d002      	beq.n	800c9b8 <chCondWaitTimeoutS.4340+0x18>
 800c9b2:	9b00      	ldr	r3, [sp, #0]
 800c9b4:	2b00      	cmp	r3, #0
 800c9b6:	d105      	bne.n	800c9c4 <chCondWaitTimeoutS.4340+0x24>
 800c9b8:	f641 1070 	movw	r0, #6512	; 0x1970
 800c9bc:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c9c0:	f002 fce6 	bl	800f390 <chSysHalt>
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");
 800c9c4:	f640 5350 	movw	r3, #3408	; 0xd50
 800c9c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c9cc:	699b      	ldr	r3, [r3, #24]
 800c9ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c9d0:	2b00      	cmp	r3, #0
 800c9d2:	d105      	bne.n	800c9e0 <chCondWaitTimeoutS.4340+0x40>
 800c9d4:	f641 1070 	movw	r0, #6512	; 0x1970
 800c9d8:	f6c0 0001 	movt	r0, #2049	; 0x801
 800c9dc:	f002 fcd8 	bl	800f390 <chSysHalt>

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 800c9e0:	f7ff fece 	bl	800c780 <chMtxGetNextMutexS.7005.4373>
 800c9e4:	9003      	str	r0, [sp, #12]
  chMtxUnlockS(mp);
 800c9e6:	9803      	ldr	r0, [sp, #12]
 800c9e8:	f7ff fd6a 	bl	800c4c0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 800c9ec:	f640 5350 	movw	r3, #3408	; 0xd50
 800c9f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c9f4:	699b      	ldr	r3, [r3, #24]
 800c9f6:	9a01      	ldr	r2, [sp, #4]
 800c9f8:	625a      	str	r2, [r3, #36]	; 0x24
  queue_prio_insert(currp, &cp->c_queue);
 800c9fa:	f640 5350 	movw	r3, #3408	; 0xd50
 800c9fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ca02:	699a      	ldr	r2, [r3, #24]
 800ca04:	9b01      	ldr	r3, [sp, #4]
 800ca06:	4610      	mov	r0, r2
 800ca08:	4619      	mov	r1, r3
 800ca0a:	f7ff fe41 	bl	800c690 <queue_prio_insert.6996.4384>
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 800ca0e:	2007      	movs	r0, #7
 800ca10:	9900      	ldr	r1, [sp, #0]
 800ca12:	f003 fafd 	bl	8010010 <chSchGoSleepTimeoutS>
 800ca16:	9002      	str	r0, [sp, #8]
  if (msg != MSG_TIMEOUT) {
 800ca18:	9b02      	ldr	r3, [sp, #8]
 800ca1a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800ca1e:	d002      	beq.n	800ca26 <chCondWaitTimeoutS.4340+0x86>
    chMtxLockS(mp);
 800ca20:	9803      	ldr	r0, [sp, #12]
 800ca22:	f002 f93d 	bl	800eca0 <chMtxLockS>
  }

  return msg;
 800ca26:	9b02      	ldr	r3, [sp, #8]
}
 800ca28:	4618      	mov	r0, r3
 800ca2a:	b005      	add	sp, #20
 800ca2c:	f85d fb04 	ldr.w	pc, [sp], #4

0800ca30 <port_lock.7134.4338>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800ca30:	b082      	sub	sp, #8
 800ca32:	2320      	movs	r3, #32
 800ca34:	9301      	str	r3, [sp, #4]
 800ca36:	9b01      	ldr	r3, [sp, #4]
 800ca38:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ca3c:	b002      	add	sp, #8
 800ca3e:	4770      	bx	lr

0800ca40 <port_unlock.7137.4336>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800ca40:	b082      	sub	sp, #8
 800ca42:	2300      	movs	r3, #0
 800ca44:	9301      	str	r3, [sp, #4]
 800ca46:	9b01      	ldr	r3, [sp, #4]
 800ca48:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ca4c:	b002      	add	sp, #8
 800ca4e:	4770      	bx	lr

0800ca50 <chSysLock.7139.4334>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800ca50:	b508      	push	{r3, lr}

  port_lock();
 800ca52:	f7ff ffed 	bl	800ca30 <port_lock.7134.4338>
  _stats_start_measure_crit_thd();
 800ca56:	f001 fa93 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800ca5a:	f002 fe41 	bl	800f6e0 <_dbg_check_lock>
}
 800ca5e:	bd08      	pop	{r3, pc}

0800ca60 <chSysUnlock.7141.4332>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800ca60:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800ca62:	f002 fe5d 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800ca66:	f001 fa93 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800ca6a:	f640 5350 	movw	r3, #3408	; 0xd50
 800ca6e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ca72:	681a      	ldr	r2, [r3, #0]
 800ca74:	f640 5350 	movw	r3, #3408	; 0xd50
 800ca78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ca7c:	429a      	cmp	r2, r3
 800ca7e:	d013      	beq.n	800caa8 <chSysUnlock.7141.4332+0x48>
 800ca80:	f640 5350 	movw	r3, #3408	; 0xd50
 800ca84:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ca88:	699b      	ldr	r3, [r3, #24]
 800ca8a:	689a      	ldr	r2, [r3, #8]
 800ca8c:	f640 5350 	movw	r3, #3408	; 0xd50
 800ca90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ca94:	681b      	ldr	r3, [r3, #0]
 800ca96:	689b      	ldr	r3, [r3, #8]
 800ca98:	429a      	cmp	r2, r3
 800ca9a:	d205      	bcs.n	800caa8 <chSysUnlock.7141.4332+0x48>
 800ca9c:	f641 10b0 	movw	r0, #6576	; 0x19b0
 800caa0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800caa4:	f002 fc74 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800caa8:	f7ff ffca 	bl	800ca40 <port_unlock.7137.4336>
}
 800caac:	bd08      	pop	{r3, pc}
 800caae:	bf00      	nop

0800cab0 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 800cab0:	b500      	push	{lr}
 800cab2:	b085      	sub	sp, #20
 800cab4:	9003      	str	r0, [sp, #12]
 800cab6:	9102      	str	r1, [sp, #8]
 800cab8:	9201      	str	r2, [sp, #4]
 800caba:	9300      	str	r3, [sp, #0]

  chDbgCheck((esp != NULL) && (elp != NULL));
 800cabc:	9b03      	ldr	r3, [sp, #12]
 800cabe:	2b00      	cmp	r3, #0
 800cac0:	d002      	beq.n	800cac8 <chEvtRegisterMaskWithFlags+0x18>
 800cac2:	9b02      	ldr	r3, [sp, #8]
 800cac4:	2b00      	cmp	r3, #0
 800cac6:	d105      	bne.n	800cad4 <chEvtRegisterMaskWithFlags+0x24>
 800cac8:	f641 1090 	movw	r0, #6544	; 0x1990
 800cacc:	f6c0 0001 	movt	r0, #2049	; 0x801
 800cad0:	f002 fc5e 	bl	800f390 <chSysHalt>

  chSysLock();
 800cad4:	f7ff ffbc 	bl	800ca50 <chSysLock.7139.4334>
  elp->el_next     = esp->es_next;
 800cad8:	9b03      	ldr	r3, [sp, #12]
 800cada:	681a      	ldr	r2, [r3, #0]
 800cadc:	9b02      	ldr	r3, [sp, #8]
 800cade:	601a      	str	r2, [r3, #0]
  esp->es_next     = elp;
 800cae0:	9b03      	ldr	r3, [sp, #12]
 800cae2:	9a02      	ldr	r2, [sp, #8]
 800cae4:	601a      	str	r2, [r3, #0]
  elp->el_listener = currp;
 800cae6:	f640 5350 	movw	r3, #3408	; 0xd50
 800caea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800caee:	699a      	ldr	r2, [r3, #24]
 800caf0:	9b02      	ldr	r3, [sp, #8]
 800caf2:	605a      	str	r2, [r3, #4]
  elp->el_events   = events;
 800caf4:	9b02      	ldr	r3, [sp, #8]
 800caf6:	9a01      	ldr	r2, [sp, #4]
 800caf8:	609a      	str	r2, [r3, #8]
  elp->el_flags    = (eventflags_t)0;
 800cafa:	9b02      	ldr	r3, [sp, #8]
 800cafc:	2200      	movs	r2, #0
 800cafe:	60da      	str	r2, [r3, #12]
  elp->el_wflags   = wflags;
 800cb00:	9b02      	ldr	r3, [sp, #8]
 800cb02:	9a00      	ldr	r2, [sp, #0]
 800cb04:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 800cb06:	f7ff ffab 	bl	800ca60 <chSysUnlock.7141.4332>
}
 800cb0a:	b005      	add	sp, #20
 800cb0c:	f85d fb04 	ldr.w	pc, [sp], #4

0800cb10 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p event_source_t structure
 * @param[in] elp       pointer to the @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 800cb10:	b500      	push	{lr}
 800cb12:	b085      	sub	sp, #20
 800cb14:	9001      	str	r0, [sp, #4]
 800cb16:	9100      	str	r1, [sp, #0]
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));
 800cb18:	9b01      	ldr	r3, [sp, #4]
 800cb1a:	2b00      	cmp	r3, #0
 800cb1c:	d002      	beq.n	800cb24 <chEvtUnregister+0x14>
 800cb1e:	9b00      	ldr	r3, [sp, #0]
 800cb20:	2b00      	cmp	r3, #0
 800cb22:	d105      	bne.n	800cb30 <chEvtUnregister+0x20>
 800cb24:	f641 10c0 	movw	r0, #6592	; 0x19c0
 800cb28:	f6c0 0001 	movt	r0, #2049	; 0x801
 800cb2c:	f002 fc30 	bl	800f390 <chSysHalt>

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 800cb30:	9b01      	ldr	r3, [sp, #4]
 800cb32:	9303      	str	r3, [sp, #12]
  /*lint -restore*/
  chSysLock();
 800cb34:	f7ff ff8c 	bl	800ca50 <chSysLock.7139.4334>
 800cb38:	e00c      	b.n	800cb54 <chEvtUnregister+0x44>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
 800cb3a:	9b03      	ldr	r3, [sp, #12]
 800cb3c:	681a      	ldr	r2, [r3, #0]
 800cb3e:	9b00      	ldr	r3, [sp, #0]
 800cb40:	429a      	cmp	r2, r3
 800cb42:	d104      	bne.n	800cb4e <chEvtUnregister+0x3e>
      p->el_next = elp->el_next;
 800cb44:	9b00      	ldr	r3, [sp, #0]
 800cb46:	681a      	ldr	r2, [r3, #0]
 800cb48:	9b03      	ldr	r3, [sp, #12]
 800cb4a:	601a      	str	r2, [r3, #0]
 800cb4c:	e007      	b.n	800cb5e <chEvtUnregister+0x4e>
      break;
    }
    p = p->el_next;
 800cb4e:	9b03      	ldr	r3, [sp, #12]
 800cb50:	681b      	ldr	r3, [r3, #0]
 800cb52:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 800cb54:	9b03      	ldr	r3, [sp, #12]
 800cb56:	681a      	ldr	r2, [r3, #0]
 800cb58:	9b01      	ldr	r3, [sp, #4]
 800cb5a:	429a      	cmp	r2, r3
 800cb5c:	d1ed      	bne.n	800cb3a <chEvtUnregister+0x2a>
      p->el_next = elp->el_next;
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
 800cb5e:	f7ff ff7f 	bl	800ca60 <chSysUnlock.7141.4332>
}
 800cb62:	b005      	add	sp, #20
 800cb64:	f85d fb04 	ldr.w	pc, [sp], #4
 800cb68:	f3af 8000 	nop.w
 800cb6c:	f3af 8000 	nop.w

0800cb70 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 800cb70:	b500      	push	{lr}
 800cb72:	b085      	sub	sp, #20
 800cb74:	9001      	str	r0, [sp, #4]
  eventmask_t m;

  chSysLock();
 800cb76:	f7ff ff6b 	bl	800ca50 <chSysLock.7139.4334>
  m = currp->p_epending & events;
 800cb7a:	f640 5350 	movw	r3, #3408	; 0xd50
 800cb7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cb82:	699b      	ldr	r3, [r3, #24]
 800cb84:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cb86:	9b01      	ldr	r3, [sp, #4]
 800cb88:	4013      	ands	r3, r2
 800cb8a:	9303      	str	r3, [sp, #12]
  currp->p_epending &= ~events;
 800cb8c:	f640 5350 	movw	r3, #3408	; 0xd50
 800cb90:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cb94:	699a      	ldr	r2, [r3, #24]
 800cb96:	f640 5350 	movw	r3, #3408	; 0xd50
 800cb9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cb9e:	699b      	ldr	r3, [r3, #24]
 800cba0:	6b99      	ldr	r1, [r3, #56]	; 0x38
 800cba2:	9b01      	ldr	r3, [sp, #4]
 800cba4:	43db      	mvns	r3, r3
 800cba6:	400b      	ands	r3, r1
 800cba8:	6393      	str	r3, [r2, #56]	; 0x38
  chSysUnlock();
 800cbaa:	f7ff ff59 	bl	800ca60 <chSysUnlock.7141.4332>

  return m;
 800cbae:	9b03      	ldr	r3, [sp, #12]
}
 800cbb0:	4618      	mov	r0, r3
 800cbb2:	b005      	add	sp, #20
 800cbb4:	f85d fb04 	ldr.w	pc, [sp], #4
 800cbb8:	f3af 8000 	nop.w
 800cbbc:	f3af 8000 	nop.w

0800cbc0 <chEvtAddEvents>:
 * @param[in] events    the events to be added
 * @return              The current pending events.
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {
 800cbc0:	b500      	push	{lr}
 800cbc2:	b083      	sub	sp, #12
 800cbc4:	9001      	str	r0, [sp, #4]

  chSysLock();
 800cbc6:	f7ff ff43 	bl	800ca50 <chSysLock.7139.4334>
  currp->p_epending |= events;
 800cbca:	f640 5350 	movw	r3, #3408	; 0xd50
 800cbce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cbd2:	699a      	ldr	r2, [r3, #24]
 800cbd4:	f640 5350 	movw	r3, #3408	; 0xd50
 800cbd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cbdc:	699b      	ldr	r3, [r3, #24]
 800cbde:	6b99      	ldr	r1, [r3, #56]	; 0x38
 800cbe0:	9b01      	ldr	r3, [sp, #4]
 800cbe2:	430b      	orrs	r3, r1
 800cbe4:	6393      	str	r3, [r2, #56]	; 0x38
  events = currp->p_epending;
 800cbe6:	f640 5350 	movw	r3, #3408	; 0xd50
 800cbea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cbee:	699b      	ldr	r3, [r3, #24]
 800cbf0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800cbf2:	9301      	str	r3, [sp, #4]
  chSysUnlock();
 800cbf4:	f7ff ff34 	bl	800ca60 <chSysUnlock.7141.4332>

  return events;
 800cbf8:	9b01      	ldr	r3, [sp, #4]
}
 800cbfa:	4618      	mov	r0, r3
 800cbfc:	b003      	add	sp, #12
 800cbfe:	f85d fb04 	ldr.w	pc, [sp], #4
 800cc02:	bf00      	nop
 800cc04:	f3af 8000 	nop.w
 800cc08:	f3af 8000 	nop.w
 800cc0c:	f3af 8000 	nop.w

0800cc10 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 800cc10:	b500      	push	{lr}
 800cc12:	b085      	sub	sp, #20
 800cc14:	9001      	str	r0, [sp, #4]
 800cc16:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
 800cc18:	f002 fe32 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 800cc1c:	9b01      	ldr	r3, [sp, #4]
 800cc1e:	2b00      	cmp	r3, #0
 800cc20:	d105      	bne.n	800cc2e <chEvtBroadcastFlagsI+0x1e>
 800cc22:	f641 10d0 	movw	r0, #6608	; 0x19d0
 800cc26:	f6c0 0001 	movt	r0, #2049	; 0x801
 800cc2a:	f002 fbb1 	bl	800f390 <chSysHalt>

  elp = esp->es_next;
 800cc2e:	9b01      	ldr	r3, [sp, #4]
 800cc30:	681b      	ldr	r3, [r3, #0]
 800cc32:	9303      	str	r3, [sp, #12]
 800cc34:	e01a      	b.n	800cc6c <chEvtBroadcastFlagsI+0x5c>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
 800cc36:	9b03      	ldr	r3, [sp, #12]
 800cc38:	68da      	ldr	r2, [r3, #12]
 800cc3a:	9b00      	ldr	r3, [sp, #0]
 800cc3c:	431a      	orrs	r2, r3
 800cc3e:	9b03      	ldr	r3, [sp, #12]
 800cc40:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800cc42:	9b00      	ldr	r3, [sp, #0]
 800cc44:	2b00      	cmp	r3, #0
 800cc46:	d006      	beq.n	800cc56 <chEvtBroadcastFlagsI+0x46>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 800cc48:	9b03      	ldr	r3, [sp, #12]
 800cc4a:	68da      	ldr	r2, [r3, #12]
 800cc4c:	9b03      	ldr	r3, [sp, #12]
 800cc4e:	691b      	ldr	r3, [r3, #16]
 800cc50:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800cc52:	2b00      	cmp	r3, #0
 800cc54:	d007      	beq.n	800cc66 <chEvtBroadcastFlagsI+0x56>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 800cc56:	9b03      	ldr	r3, [sp, #12]
 800cc58:	685a      	ldr	r2, [r3, #4]
 800cc5a:	9b03      	ldr	r3, [sp, #12]
 800cc5c:	689b      	ldr	r3, [r3, #8]
 800cc5e:	4610      	mov	r0, r2
 800cc60:	4619      	mov	r1, r3
 800cc62:	f000 f82d 	bl	800ccc0 <chEvtSignalI.4301>
    }
    elp = elp->el_next;
 800cc66:	9b03      	ldr	r3, [sp, #12]
 800cc68:	681b      	ldr	r3, [r3, #0]
 800cc6a:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800cc6c:	9a03      	ldr	r2, [sp, #12]
 800cc6e:	9b01      	ldr	r3, [sp, #4]
 800cc70:	429a      	cmp	r2, r3
 800cc72:	d1e0      	bne.n	800cc36 <chEvtBroadcastFlagsI+0x26>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 800cc74:	b005      	add	sp, #20
 800cc76:	f85d fb04 	ldr.w	pc, [sp], #4
 800cc7a:	bf00      	nop
 800cc7c:	f3af 8000 	nop.w

0800cc80 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 800cc80:	b500      	push	{lr}
 800cc82:	b083      	sub	sp, #12
 800cc84:	9001      	str	r0, [sp, #4]
 800cc86:	9100      	str	r1, [sp, #0]

  chDbgCheck(tp != NULL);
 800cc88:	9b01      	ldr	r3, [sp, #4]
 800cc8a:	2b00      	cmp	r3, #0
 800cc8c:	d105      	bne.n	800cc9a <chEvtSignal+0x1a>
 800cc8e:	f641 10f0 	movw	r0, #6640	; 0x19f0
 800cc92:	f6c0 0001 	movt	r0, #2049	; 0x801
 800cc96:	f002 fb7b 	bl	800f390 <chSysHalt>

  chSysLock();
 800cc9a:	f7ff fed9 	bl	800ca50 <chSysLock.7139.4334>
  chEvtSignalI(tp, events);
 800cc9e:	9801      	ldr	r0, [sp, #4]
 800cca0:	9900      	ldr	r1, [sp, #0]
 800cca2:	f000 f80d 	bl	800ccc0 <chEvtSignalI.4301>
  chSchRescheduleS();
 800cca6:	f003 fa5b 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 800ccaa:	f7ff fed9 	bl	800ca60 <chSysUnlock.7141.4332>
}
 800ccae:	b003      	add	sp, #12
 800ccb0:	f85d fb04 	ldr.w	pc, [sp], #4
 800ccb4:	f3af 8000 	nop.w
 800ccb8:	f3af 8000 	nop.w
 800ccbc:	f3af 8000 	nop.w

0800ccc0 <chEvtSignalI.4301>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 800ccc0:	b500      	push	{lr}
 800ccc2:	b083      	sub	sp, #12
 800ccc4:	9001      	str	r0, [sp, #4]
 800ccc6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 800ccc8:	f002 fdda 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800cccc:	9b01      	ldr	r3, [sp, #4]
 800ccce:	2b00      	cmp	r3, #0
 800ccd0:	d105      	bne.n	800ccde <chEvtSignalI.4301+0x1e>
 800ccd2:	f641 2000 	movw	r0, #6656	; 0x1a00
 800ccd6:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ccda:	f002 fb59 	bl	800f390 <chSysHalt>

  tp->p_epending |= events;
 800ccde:	9b01      	ldr	r3, [sp, #4]
 800cce0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cce2:	9b00      	ldr	r3, [sp, #0]
 800cce4:	431a      	orrs	r2, r3
 800cce6:	9b01      	ldr	r3, [sp, #4]
 800cce8:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800ccea:	9b01      	ldr	r3, [sp, #4]
 800ccec:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ccf0:	2b0a      	cmp	r3, #10
 800ccf2:	d106      	bne.n	800cd02 <chEvtSignalI.4301+0x42>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800ccf4:	9b01      	ldr	r3, [sp, #4]
 800ccf6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ccf8:	9b01      	ldr	r3, [sp, #4]
 800ccfa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ccfc:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800ccfe:	2b00      	cmp	r3, #0
 800cd00:	d10d      	bne.n	800cd1e <chEvtSignalI.4301+0x5e>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800cd02:	9b01      	ldr	r3, [sp, #4]
 800cd04:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800cd08:	2b0b      	cmp	r3, #11
 800cd0a:	d10e      	bne.n	800cd2a <chEvtSignalI.4301+0x6a>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 800cd0c:	9b01      	ldr	r3, [sp, #4]
 800cd0e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cd10:	9b01      	ldr	r3, [sp, #4]
 800cd12:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800cd14:	401a      	ands	r2, r3
 800cd16:	9b01      	ldr	r3, [sp, #4]
 800cd18:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800cd1a:	429a      	cmp	r2, r3
 800cd1c:	d105      	bne.n	800cd2a <chEvtSignalI.4301+0x6a>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800cd1e:	9b01      	ldr	r3, [sp, #4]
 800cd20:	2200      	movs	r2, #0
 800cd22:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800cd24:	9801      	ldr	r0, [sp, #4]
 800cd26:	f003 f89b 	bl	800fe60 <chSchReadyI>
  }
}
 800cd2a:	b003      	add	sp, #12
 800cd2c:	f85d fb04 	ldr.w	pc, [sp], #4

0800cd30 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 800cd30:	b500      	push	{lr}
 800cd32:	b083      	sub	sp, #12
 800cd34:	9001      	str	r0, [sp, #4]
 800cd36:	9100      	str	r1, [sp, #0]

  chSysLock();
 800cd38:	f7ff fe8a 	bl	800ca50 <chSysLock.7139.4334>
  chEvtBroadcastFlagsI(esp, flags);
 800cd3c:	9801      	ldr	r0, [sp, #4]
 800cd3e:	9900      	ldr	r1, [sp, #0]
 800cd40:	f7ff ff66 	bl	800cc10 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 800cd44:	f003 fa0c 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 800cd48:	f7ff fe8a 	bl	800ca60 <chSysUnlock.7141.4332>
}
 800cd4c:	b003      	add	sp, #12
 800cd4e:	f85d fb04 	ldr.w	pc, [sp], #4
 800cd52:	bf00      	nop
 800cd54:	f3af 8000 	nop.w
 800cd58:	f3af 8000 	nop.w
 800cd5c:	f3af 8000 	nop.w

0800cd60 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 800cd60:	b500      	push	{lr}
 800cd62:	b085      	sub	sp, #20
 800cd64:	9001      	str	r0, [sp, #4]
 800cd66:	9100      	str	r1, [sp, #0]
  eventid_t eid;

  chDbgCheck(handlers != NULL);
 800cd68:	9b01      	ldr	r3, [sp, #4]
 800cd6a:	2b00      	cmp	r3, #0
 800cd6c:	d105      	bne.n	800cd7a <chEvtDispatch+0x1a>
 800cd6e:	f641 2010 	movw	r0, #6672	; 0x1a10
 800cd72:	f6c0 0001 	movt	r0, #2049	; 0x801
 800cd76:	f002 fb0b 	bl	800f390 <chSysHalt>

  eid = (eventid_t)0;
 800cd7a:	2300      	movs	r3, #0
 800cd7c:	9303      	str	r3, [sp, #12]
 800cd7e:	e026      	b.n	800cdce <chEvtDispatch+0x6e>
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 800cd80:	9a00      	ldr	r2, [sp, #0]
 800cd82:	9b03      	ldr	r3, [sp, #12]
 800cd84:	fa22 f303 	lsr.w	r3, r2, r3
 800cd88:	f003 0301 	and.w	r3, r3, #1
 800cd8c:	2b00      	cmp	r3, #0
 800cd8e:	d01b      	beq.n	800cdc8 <chEvtDispatch+0x68>
      chDbgAssert(handlers[eid] != NULL, "null handler");
 800cd90:	9b03      	ldr	r3, [sp, #12]
 800cd92:	009b      	lsls	r3, r3, #2
 800cd94:	9a01      	ldr	r2, [sp, #4]
 800cd96:	4413      	add	r3, r2
 800cd98:	681b      	ldr	r3, [r3, #0]
 800cd9a:	2b00      	cmp	r3, #0
 800cd9c:	d105      	bne.n	800cdaa <chEvtDispatch+0x4a>
 800cd9e:	f641 2010 	movw	r0, #6672	; 0x1a10
 800cda2:	f6c0 0001 	movt	r0, #2049	; 0x801
 800cda6:	f002 faf3 	bl	800f390 <chSysHalt>
      events &= ~EVENT_MASK(eid);
 800cdaa:	2201      	movs	r2, #1
 800cdac:	9b03      	ldr	r3, [sp, #12]
 800cdae:	fa02 f303 	lsl.w	r3, r2, r3
 800cdb2:	43db      	mvns	r3, r3
 800cdb4:	9a00      	ldr	r2, [sp, #0]
 800cdb6:	4013      	ands	r3, r2
 800cdb8:	9300      	str	r3, [sp, #0]
      handlers[eid](eid);
 800cdba:	9b03      	ldr	r3, [sp, #12]
 800cdbc:	009b      	lsls	r3, r3, #2
 800cdbe:	9a01      	ldr	r2, [sp, #4]
 800cdc0:	4413      	add	r3, r2
 800cdc2:	681b      	ldr	r3, [r3, #0]
 800cdc4:	9803      	ldr	r0, [sp, #12]
 800cdc6:	4798      	blx	r3
    }
    eid++;
 800cdc8:	9b03      	ldr	r3, [sp, #12]
 800cdca:	3301      	adds	r3, #1
 800cdcc:	9303      	str	r3, [sp, #12]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 800cdce:	9b00      	ldr	r3, [sp, #0]
 800cdd0:	2b00      	cmp	r3, #0
 800cdd2:	d1d5      	bne.n	800cd80 <chEvtDispatch+0x20>
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
 800cdd4:	b005      	add	sp, #20
 800cdd6:	f85d fb04 	ldr.w	pc, [sp], #4
 800cdda:	bf00      	nop
 800cddc:	f3af 8000 	nop.w

0800cde0 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 800cde0:	b500      	push	{lr}
 800cde2:	b085      	sub	sp, #20
 800cde4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 800cde6:	f640 5350 	movw	r3, #3408	; 0xd50
 800cdea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cdee:	699b      	ldr	r3, [r3, #24]
 800cdf0:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800cdf2:	f7ff fe2d 	bl	800ca50 <chSysLock.7139.4334>
  m = ctp->p_epending & events;
 800cdf6:	9b02      	ldr	r3, [sp, #8]
 800cdf8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cdfa:	9b01      	ldr	r3, [sp, #4]
 800cdfc:	4013      	ands	r3, r2
 800cdfe:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800ce00:	9b03      	ldr	r3, [sp, #12]
 800ce02:	2b00      	cmp	r3, #0
 800ce04:	d10a      	bne.n	800ce1c <chEvtWaitOne+0x3c>
    ctp->p_u.ewmask = events;
 800ce06:	9b02      	ldr	r3, [sp, #8]
 800ce08:	9a01      	ldr	r2, [sp, #4]
 800ce0a:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 800ce0c:	200a      	movs	r0, #10
 800ce0e:	f003 f86f 	bl	800fef0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800ce12:	9b02      	ldr	r3, [sp, #8]
 800ce14:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ce16:	9b01      	ldr	r3, [sp, #4]
 800ce18:	4013      	ands	r3, r2
 800ce1a:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 800ce1c:	9b03      	ldr	r3, [sp, #12]
 800ce1e:	425b      	negs	r3, r3
 800ce20:	9a03      	ldr	r2, [sp, #12]
 800ce22:	4013      	ands	r3, r2
 800ce24:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 800ce26:	9b02      	ldr	r3, [sp, #8]
 800ce28:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ce2a:	9b03      	ldr	r3, [sp, #12]
 800ce2c:	43db      	mvns	r3, r3
 800ce2e:	401a      	ands	r2, r3
 800ce30:	9b02      	ldr	r3, [sp, #8]
 800ce32:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 800ce34:	f7ff fe14 	bl	800ca60 <chSysUnlock.7141.4332>

  return m;
 800ce38:	9b03      	ldr	r3, [sp, #12]
}
 800ce3a:	4618      	mov	r0, r3
 800ce3c:	b005      	add	sp, #20
 800ce3e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ce42:	bf00      	nop
 800ce44:	f3af 8000 	nop.w
 800ce48:	f3af 8000 	nop.w
 800ce4c:	f3af 8000 	nop.w

0800ce50 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 800ce50:	b500      	push	{lr}
 800ce52:	b085      	sub	sp, #20
 800ce54:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 800ce56:	f640 5350 	movw	r3, #3408	; 0xd50
 800ce5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ce5e:	699b      	ldr	r3, [r3, #24]
 800ce60:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800ce62:	f7ff fdf5 	bl	800ca50 <chSysLock.7139.4334>
  m = ctp->p_epending & events;
 800ce66:	9b02      	ldr	r3, [sp, #8]
 800ce68:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ce6a:	9b01      	ldr	r3, [sp, #4]
 800ce6c:	4013      	ands	r3, r2
 800ce6e:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800ce70:	9b03      	ldr	r3, [sp, #12]
 800ce72:	2b00      	cmp	r3, #0
 800ce74:	d10a      	bne.n	800ce8c <chEvtWaitAny+0x3c>
    ctp->p_u.ewmask = events;
 800ce76:	9b02      	ldr	r3, [sp, #8]
 800ce78:	9a01      	ldr	r2, [sp, #4]
 800ce7a:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 800ce7c:	200a      	movs	r0, #10
 800ce7e:	f003 f837 	bl	800fef0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800ce82:	9b02      	ldr	r3, [sp, #8]
 800ce84:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ce86:	9b01      	ldr	r3, [sp, #4]
 800ce88:	4013      	ands	r3, r2
 800ce8a:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 800ce8c:	9b02      	ldr	r3, [sp, #8]
 800ce8e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ce90:	9b03      	ldr	r3, [sp, #12]
 800ce92:	43db      	mvns	r3, r3
 800ce94:	401a      	ands	r2, r3
 800ce96:	9b02      	ldr	r3, [sp, #8]
 800ce98:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 800ce9a:	f7ff fde1 	bl	800ca60 <chSysUnlock.7141.4332>

  return m;
 800ce9e:	9b03      	ldr	r3, [sp, #12]
}
 800cea0:	4618      	mov	r0, r3
 800cea2:	b005      	add	sp, #20
 800cea4:	f85d fb04 	ldr.w	pc, [sp], #4
 800cea8:	f3af 8000 	nop.w
 800ceac:	f3af 8000 	nop.w

0800ceb0 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 800ceb0:	b500      	push	{lr}
 800ceb2:	b085      	sub	sp, #20
 800ceb4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 800ceb6:	f640 5350 	movw	r3, #3408	; 0xd50
 800ceba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cebe:	699b      	ldr	r3, [r3, #24]
 800cec0:	9303      	str	r3, [sp, #12]

  chSysLock();
 800cec2:	f7ff fdc5 	bl	800ca50 <chSysLock.7139.4334>
  if ((ctp->p_epending & events) != events) {
 800cec6:	9b03      	ldr	r3, [sp, #12]
 800cec8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ceca:	9b01      	ldr	r3, [sp, #4]
 800cecc:	401a      	ands	r2, r3
 800cece:	9b01      	ldr	r3, [sp, #4]
 800ced0:	429a      	cmp	r2, r3
 800ced2:	d005      	beq.n	800cee0 <chEvtWaitAll+0x30>
    ctp->p_u.ewmask = events;
 800ced4:	9b03      	ldr	r3, [sp, #12]
 800ced6:	9a01      	ldr	r2, [sp, #4]
 800ced8:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 800ceda:	200b      	movs	r0, #11
 800cedc:	f003 f808 	bl	800fef0 <chSchGoSleepS>
  }
  ctp->p_epending &= ~events;
 800cee0:	9b03      	ldr	r3, [sp, #12]
 800cee2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cee4:	9b01      	ldr	r3, [sp, #4]
 800cee6:	43db      	mvns	r3, r3
 800cee8:	401a      	ands	r2, r3
 800ceea:	9b03      	ldr	r3, [sp, #12]
 800ceec:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 800ceee:	f7ff fdb7 	bl	800ca60 <chSysUnlock.7141.4332>

  return events;
 800cef2:	9b01      	ldr	r3, [sp, #4]
}
 800cef4:	4618      	mov	r0, r3
 800cef6:	b005      	add	sp, #20
 800cef8:	f85d fb04 	ldr.w	pc, [sp], #4
 800cefc:	f3af 8000 	nop.w

0800cf00 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 800cf00:	b500      	push	{lr}
 800cf02:	b085      	sub	sp, #20
 800cf04:	9001      	str	r0, [sp, #4]
 800cf06:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 800cf08:	f640 5350 	movw	r3, #3408	; 0xd50
 800cf0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cf10:	699b      	ldr	r3, [r3, #24]
 800cf12:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800cf14:	f7ff fd9c 	bl	800ca50 <chSysLock.7139.4334>
  m = ctp->p_epending & events;
 800cf18:	9b02      	ldr	r3, [sp, #8]
 800cf1a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cf1c:	9b01      	ldr	r3, [sp, #4]
 800cf1e:	4013      	ands	r3, r2
 800cf20:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800cf22:	9b03      	ldr	r3, [sp, #12]
 800cf24:	2b00      	cmp	r3, #0
 800cf26:	d119      	bne.n	800cf5c <chEvtWaitOneTimeout+0x5c>
    if (TIME_IMMEDIATE == time) {
 800cf28:	9b00      	ldr	r3, [sp, #0]
 800cf2a:	2b00      	cmp	r3, #0
 800cf2c:	d103      	bne.n	800cf36 <chEvtWaitOneTimeout+0x36>
      chSysUnlock();
 800cf2e:	f7ff fd97 	bl	800ca60 <chSysUnlock.7141.4332>
      return (eventmask_t)0;
 800cf32:	2300      	movs	r3, #0
 800cf34:	e021      	b.n	800cf7a <chEvtWaitOneTimeout+0x7a>
    }
    ctp->p_u.ewmask = events;
 800cf36:	9b02      	ldr	r3, [sp, #8]
 800cf38:	9a01      	ldr	r2, [sp, #4]
 800cf3a:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 800cf3c:	200a      	movs	r0, #10
 800cf3e:	9900      	ldr	r1, [sp, #0]
 800cf40:	f003 f866 	bl	8010010 <chSchGoSleepTimeoutS>
 800cf44:	4603      	mov	r3, r0
 800cf46:	2b00      	cmp	r3, #0
 800cf48:	da03      	bge.n	800cf52 <chEvtWaitOneTimeout+0x52>
      chSysUnlock();
 800cf4a:	f7ff fd89 	bl	800ca60 <chSysUnlock.7141.4332>
      return (eventmask_t)0;
 800cf4e:	2300      	movs	r3, #0
 800cf50:	e013      	b.n	800cf7a <chEvtWaitOneTimeout+0x7a>
    }
    m = ctp->p_epending & events;
 800cf52:	9b02      	ldr	r3, [sp, #8]
 800cf54:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cf56:	9b01      	ldr	r3, [sp, #4]
 800cf58:	4013      	ands	r3, r2
 800cf5a:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 800cf5c:	9b03      	ldr	r3, [sp, #12]
 800cf5e:	425b      	negs	r3, r3
 800cf60:	9a03      	ldr	r2, [sp, #12]
 800cf62:	4013      	ands	r3, r2
 800cf64:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 800cf66:	9b02      	ldr	r3, [sp, #8]
 800cf68:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cf6a:	9b03      	ldr	r3, [sp, #12]
 800cf6c:	43db      	mvns	r3, r3
 800cf6e:	401a      	ands	r2, r3
 800cf70:	9b02      	ldr	r3, [sp, #8]
 800cf72:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 800cf74:	f7ff fd74 	bl	800ca60 <chSysUnlock.7141.4332>

  return m;
 800cf78:	9b03      	ldr	r3, [sp, #12]
}
 800cf7a:	4618      	mov	r0, r3
 800cf7c:	b005      	add	sp, #20
 800cf7e:	f85d fb04 	ldr.w	pc, [sp], #4
 800cf82:	bf00      	nop
 800cf84:	f3af 8000 	nop.w
 800cf88:	f3af 8000 	nop.w
 800cf8c:	f3af 8000 	nop.w

0800cf90 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 800cf90:	b500      	push	{lr}
 800cf92:	b085      	sub	sp, #20
 800cf94:	9001      	str	r0, [sp, #4]
 800cf96:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 800cf98:	f640 5350 	movw	r3, #3408	; 0xd50
 800cf9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800cfa0:	699b      	ldr	r3, [r3, #24]
 800cfa2:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800cfa4:	f7ff fd54 	bl	800ca50 <chSysLock.7139.4334>
  m = ctp->p_epending & events;
 800cfa8:	9b02      	ldr	r3, [sp, #8]
 800cfaa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cfac:	9b01      	ldr	r3, [sp, #4]
 800cfae:	4013      	ands	r3, r2
 800cfb0:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800cfb2:	9b03      	ldr	r3, [sp, #12]
 800cfb4:	2b00      	cmp	r3, #0
 800cfb6:	d119      	bne.n	800cfec <chEvtWaitAnyTimeout+0x5c>
    if (TIME_IMMEDIATE == time) {
 800cfb8:	9b00      	ldr	r3, [sp, #0]
 800cfba:	2b00      	cmp	r3, #0
 800cfbc:	d103      	bne.n	800cfc6 <chEvtWaitAnyTimeout+0x36>
      chSysUnlock();
 800cfbe:	f7ff fd4f 	bl	800ca60 <chSysUnlock.7141.4332>
      return (eventmask_t)0;
 800cfc2:	2300      	movs	r3, #0
 800cfc4:	e01c      	b.n	800d000 <chEvtWaitAnyTimeout+0x70>
    }
    ctp->p_u.ewmask = events;
 800cfc6:	9b02      	ldr	r3, [sp, #8]
 800cfc8:	9a01      	ldr	r2, [sp, #4]
 800cfca:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 800cfcc:	200a      	movs	r0, #10
 800cfce:	9900      	ldr	r1, [sp, #0]
 800cfd0:	f003 f81e 	bl	8010010 <chSchGoSleepTimeoutS>
 800cfd4:	4603      	mov	r3, r0
 800cfd6:	2b00      	cmp	r3, #0
 800cfd8:	da03      	bge.n	800cfe2 <chEvtWaitAnyTimeout+0x52>
      chSysUnlock();
 800cfda:	f7ff fd41 	bl	800ca60 <chSysUnlock.7141.4332>
      return (eventmask_t)0;
 800cfde:	2300      	movs	r3, #0
 800cfe0:	e00e      	b.n	800d000 <chEvtWaitAnyTimeout+0x70>
    }
    m = ctp->p_epending & events;
 800cfe2:	9b02      	ldr	r3, [sp, #8]
 800cfe4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cfe6:	9b01      	ldr	r3, [sp, #4]
 800cfe8:	4013      	ands	r3, r2
 800cfea:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 800cfec:	9b02      	ldr	r3, [sp, #8]
 800cfee:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cff0:	9b03      	ldr	r3, [sp, #12]
 800cff2:	43db      	mvns	r3, r3
 800cff4:	401a      	ands	r2, r3
 800cff6:	9b02      	ldr	r3, [sp, #8]
 800cff8:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 800cffa:	f7ff fd31 	bl	800ca60 <chSysUnlock.7141.4332>

  return m;
 800cffe:	9b03      	ldr	r3, [sp, #12]
}
 800d000:	4618      	mov	r0, r3
 800d002:	b005      	add	sp, #20
 800d004:	f85d fb04 	ldr.w	pc, [sp], #4
 800d008:	f3af 8000 	nop.w
 800d00c:	f3af 8000 	nop.w

0800d010 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 800d010:	b500      	push	{lr}
 800d012:	b085      	sub	sp, #20
 800d014:	9001      	str	r0, [sp, #4]
 800d016:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 800d018:	f640 5350 	movw	r3, #3408	; 0xd50
 800d01c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d020:	699b      	ldr	r3, [r3, #24]
 800d022:	9303      	str	r3, [sp, #12]

  chSysLock();
 800d024:	f7ff fd14 	bl	800ca50 <chSysLock.7139.4334>
  if ((ctp->p_epending & events) != events) {
 800d028:	9b03      	ldr	r3, [sp, #12]
 800d02a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d02c:	9b01      	ldr	r3, [sp, #4]
 800d02e:	401a      	ands	r2, r3
 800d030:	9b01      	ldr	r3, [sp, #4]
 800d032:	429a      	cmp	r2, r3
 800d034:	d014      	beq.n	800d060 <chEvtWaitAllTimeout+0x50>
    if (TIME_IMMEDIATE == time) {
 800d036:	9b00      	ldr	r3, [sp, #0]
 800d038:	2b00      	cmp	r3, #0
 800d03a:	d103      	bne.n	800d044 <chEvtWaitAllTimeout+0x34>
      chSysUnlock();
 800d03c:	f7ff fd10 	bl	800ca60 <chSysUnlock.7141.4332>
      return (eventmask_t)0;
 800d040:	2300      	movs	r3, #0
 800d042:	e017      	b.n	800d074 <chEvtWaitAllTimeout+0x64>
    }
    ctp->p_u.ewmask = events;
 800d044:	9b03      	ldr	r3, [sp, #12]
 800d046:	9a01      	ldr	r2, [sp, #4]
 800d048:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 800d04a:	200b      	movs	r0, #11
 800d04c:	9900      	ldr	r1, [sp, #0]
 800d04e:	f002 ffdf 	bl	8010010 <chSchGoSleepTimeoutS>
 800d052:	4603      	mov	r3, r0
 800d054:	2b00      	cmp	r3, #0
 800d056:	da03      	bge.n	800d060 <chEvtWaitAllTimeout+0x50>
      chSysUnlock();
 800d058:	f7ff fd02 	bl	800ca60 <chSysUnlock.7141.4332>
      return (eventmask_t)0;
 800d05c:	2300      	movs	r3, #0
 800d05e:	e009      	b.n	800d074 <chEvtWaitAllTimeout+0x64>
    }
  }
  ctp->p_epending &= ~events;
 800d060:	9b03      	ldr	r3, [sp, #12]
 800d062:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d064:	9b01      	ldr	r3, [sp, #4]
 800d066:	43db      	mvns	r3, r3
 800d068:	401a      	ands	r2, r3
 800d06a:	9b03      	ldr	r3, [sp, #12]
 800d06c:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 800d06e:	f7ff fcf7 	bl	800ca60 <chSysUnlock.7141.4332>

  return events;
 800d072:	9b01      	ldr	r3, [sp, #4]
}
 800d074:	4618      	mov	r0, r3
 800d076:	b005      	add	sp, #20
 800d078:	f85d fb04 	ldr.w	pc, [sp], #4
 800d07c:	f3af 8000 	nop.w

0800d080 <port_lock.7394.4253>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800d080:	b082      	sub	sp, #8
 800d082:	2320      	movs	r3, #32
 800d084:	9301      	str	r3, [sp, #4]
 800d086:	9b01      	ldr	r3, [sp, #4]
 800d088:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d08c:	b002      	add	sp, #8
 800d08e:	4770      	bx	lr

0800d090 <port_unlock.7397.4251>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800d090:	b082      	sub	sp, #8
 800d092:	2300      	movs	r3, #0
 800d094:	9301      	str	r3, [sp, #4]
 800d096:	9b01      	ldr	r3, [sp, #4]
 800d098:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d09c:	b002      	add	sp, #8
 800d09e:	4770      	bx	lr

0800d0a0 <queue_insert.7399.4247>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 800d0a0:	b082      	sub	sp, #8
 800d0a2:	9001      	str	r0, [sp, #4]
 800d0a4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 800d0a6:	9b01      	ldr	r3, [sp, #4]
 800d0a8:	9a00      	ldr	r2, [sp, #0]
 800d0aa:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 800d0ac:	9b00      	ldr	r3, [sp, #0]
 800d0ae:	685a      	ldr	r2, [r3, #4]
 800d0b0:	9b01      	ldr	r3, [sp, #4]
 800d0b2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800d0b4:	9b01      	ldr	r3, [sp, #4]
 800d0b6:	685b      	ldr	r3, [r3, #4]
 800d0b8:	9a01      	ldr	r2, [sp, #4]
 800d0ba:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 800d0bc:	9b00      	ldr	r3, [sp, #0]
 800d0be:	9a01      	ldr	r2, [sp, #4]
 800d0c0:	605a      	str	r2, [r3, #4]
}
 800d0c2:	b002      	add	sp, #8
 800d0c4:	4770      	bx	lr
 800d0c6:	bf00      	nop
 800d0c8:	f3af 8000 	nop.w
 800d0cc:	f3af 8000 	nop.w

0800d0d0 <queue_fifo_remove.7489.4244>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800d0d0:	b084      	sub	sp, #16
 800d0d2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 800d0d4:	9b01      	ldr	r3, [sp, #4]
 800d0d6:	681b      	ldr	r3, [r3, #0]
 800d0d8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800d0da:	9b03      	ldr	r3, [sp, #12]
 800d0dc:	681a      	ldr	r2, [r3, #0]
 800d0de:	9b01      	ldr	r3, [sp, #4]
 800d0e0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800d0e2:	9b01      	ldr	r3, [sp, #4]
 800d0e4:	681b      	ldr	r3, [r3, #0]
 800d0e6:	9a01      	ldr	r2, [sp, #4]
 800d0e8:	605a      	str	r2, [r3, #4]

  return tp;
 800d0ea:	9b03      	ldr	r3, [sp, #12]
}
 800d0ec:	4618      	mov	r0, r3
 800d0ee:	b004      	add	sp, #16
 800d0f0:	4770      	bx	lr
 800d0f2:	bf00      	nop
 800d0f4:	f3af 8000 	nop.w
 800d0f8:	f3af 8000 	nop.w
 800d0fc:	f3af 8000 	nop.w

0800d100 <chSysLock.7492.4242>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800d100:	b508      	push	{r3, lr}

  port_lock();
 800d102:	f7ff ffbd 	bl	800d080 <port_lock.7394.4253>
  _stats_start_measure_crit_thd();
 800d106:	f000 ff3b 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800d10a:	f002 fae9 	bl	800f6e0 <_dbg_check_lock>
}
 800d10e:	bd08      	pop	{r3, pc}

0800d110 <chSysUnlock.7494.4240>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800d110:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800d112:	f002 fb05 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800d116:	f000 ff3b 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800d11a:	f640 5350 	movw	r3, #3408	; 0xd50
 800d11e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d122:	681a      	ldr	r2, [r3, #0]
 800d124:	f640 5350 	movw	r3, #3408	; 0xd50
 800d128:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d12c:	429a      	cmp	r2, r3
 800d12e:	d013      	beq.n	800d158 <chSysUnlock.7494.4240+0x48>
 800d130:	f640 5350 	movw	r3, #3408	; 0xd50
 800d134:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d138:	699b      	ldr	r3, [r3, #24]
 800d13a:	689a      	ldr	r2, [r3, #8]
 800d13c:	f640 5350 	movw	r3, #3408	; 0xd50
 800d140:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d144:	681b      	ldr	r3, [r3, #0]
 800d146:	689b      	ldr	r3, [r3, #8]
 800d148:	429a      	cmp	r2, r3
 800d14a:	d205      	bcs.n	800d158 <chSysUnlock.7494.4240+0x48>
 800d14c:	f641 2030 	movw	r0, #6704	; 0x1a30
 800d150:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d154:	f002 f91c 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800d158:	f7ff ff9a 	bl	800d090 <port_unlock.7397.4251>
}
 800d15c:	bd08      	pop	{r3, pc}
 800d15e:	bf00      	nop

0800d160 <chMsgIsPendingI.7496.4237>:
 * @param[in] tp        pointer to the thread
 * @return              The pending messages status.
 *
 * @iclass
 */
static inline bool chMsgIsPendingI(thread_t *tp) {
 800d160:	b500      	push	{lr}
 800d162:	b083      	sub	sp, #12
 800d164:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800d166:	f002 fb8b 	bl	800f880 <chDbgCheckClassI>

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 800d16a:	9b01      	ldr	r3, [sp, #4]
 800d16c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d16e:	9b01      	ldr	r3, [sp, #4]
 800d170:	332c      	adds	r3, #44	; 0x2c
 800d172:	429a      	cmp	r2, r3
 800d174:	bf0c      	ite	eq
 800d176:	2300      	moveq	r3, #0
 800d178:	2301      	movne	r3, #1
 800d17a:	b2db      	uxtb	r3, r3
}
 800d17c:	4618      	mov	r0, r3
 800d17e:	b003      	add	sp, #12
 800d180:	f85d fb04 	ldr.w	pc, [sp], #4
 800d184:	f3af 8000 	nop.w
 800d188:	f3af 8000 	nop.w
 800d18c:	f3af 8000 	nop.w

0800d190 <chMsgReleaseS.7500.4233>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {
 800d190:	b500      	push	{lr}
 800d192:	b083      	sub	sp, #12
 800d194:	9001      	str	r0, [sp, #4]
 800d196:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 800d198:	f002 fb8a 	bl	800f8b0 <chDbgCheckClassS>

  chSchWakeupS(tp, msg);
 800d19c:	9801      	ldr	r0, [sp, #4]
 800d19e:	9900      	ldr	r1, [sp, #0]
 800d1a0:	f002 ff76 	bl	8010090 <chSchWakeupS>
}
 800d1a4:	b003      	add	sp, #12
 800d1a6:	f85d fb04 	ldr.w	pc, [sp], #4
 800d1aa:	bf00      	nop
 800d1ac:	f3af 8000 	nop.w

0800d1b0 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 800d1b0:	b500      	push	{lr}
 800d1b2:	b085      	sub	sp, #20
 800d1b4:	9001      	str	r0, [sp, #4]
 800d1b6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 800d1b8:	f640 5350 	movw	r3, #3408	; 0xd50
 800d1bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d1c0:	699b      	ldr	r3, [r3, #24]
 800d1c2:	9303      	str	r3, [sp, #12]

  chDbgCheck(tp != NULL);
 800d1c4:	9b01      	ldr	r3, [sp, #4]
 800d1c6:	2b00      	cmp	r3, #0
 800d1c8:	d105      	bne.n	800d1d6 <chMsgSend+0x26>
 800d1ca:	f641 2020 	movw	r0, #6688	; 0x1a20
 800d1ce:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d1d2:	f002 f8dd 	bl	800f390 <chSysHalt>

  chSysLock();
 800d1d6:	f7ff ff93 	bl	800d100 <chSysLock.7492.4242>
  ctp->p_msg = msg;
 800d1da:	9b03      	ldr	r3, [sp, #12]
 800d1dc:	9a00      	ldr	r2, [sp, #0]
 800d1de:	635a      	str	r2, [r3, #52]	; 0x34
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 800d1e0:	9b01      	ldr	r3, [sp, #4]
 800d1e2:	f103 022c 	add.w	r2, r3, #44	; 0x2c
 800d1e6:	9b03      	ldr	r3, [sp, #12]
 800d1e8:	625a      	str	r2, [r3, #36]	; 0x24
  msg_insert(ctp, &tp->p_msgqueue);
 800d1ea:	9b01      	ldr	r3, [sp, #4]
 800d1ec:	332c      	adds	r3, #44	; 0x2c
 800d1ee:	9803      	ldr	r0, [sp, #12]
 800d1f0:	4619      	mov	r1, r3
 800d1f2:	f7ff ff55 	bl	800d0a0 <queue_insert.7399.4247>
  if (tp->p_state == CH_STATE_WTMSG) {
 800d1f6:	9b01      	ldr	r3, [sp, #4]
 800d1f8:	f893 3020 	ldrb.w	r3, [r3, #32]
 800d1fc:	2b0e      	cmp	r3, #14
 800d1fe:	d102      	bne.n	800d206 <chMsgSend+0x56>
    (void) chSchReadyI(tp);
 800d200:	9801      	ldr	r0, [sp, #4]
 800d202:	f002 fe2d 	bl	800fe60 <chSchReadyI>
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 800d206:	200c      	movs	r0, #12
 800d208:	f002 fe72 	bl	800fef0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 800d20c:	9b03      	ldr	r3, [sp, #12]
 800d20e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d210:	9300      	str	r3, [sp, #0]
  chSysUnlock();
 800d212:	f7ff ff7d 	bl	800d110 <chSysUnlock.7494.4240>

  return msg;
 800d216:	9b00      	ldr	r3, [sp, #0]
}
 800d218:	4618      	mov	r0, r3
 800d21a:	b005      	add	sp, #20
 800d21c:	f85d fb04 	ldr.w	pc, [sp], #4

0800d220 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 800d220:	b500      	push	{lr}
 800d222:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 800d224:	f7ff ff6c 	bl	800d100 <chSysLock.7492.4242>
  if (!chMsgIsPendingI(currp)) {
 800d228:	f640 5350 	movw	r3, #3408	; 0xd50
 800d22c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d230:	699b      	ldr	r3, [r3, #24]
 800d232:	4618      	mov	r0, r3
 800d234:	f7ff ff94 	bl	800d160 <chMsgIsPendingI.7496.4237>
 800d238:	4603      	mov	r3, r0
 800d23a:	f083 0301 	eor.w	r3, r3, #1
 800d23e:	b2db      	uxtb	r3, r3
 800d240:	2b00      	cmp	r3, #0
 800d242:	d002      	beq.n	800d24a <chMsgWait+0x2a>
    chSchGoSleepS(CH_STATE_WTMSG);
 800d244:	200e      	movs	r0, #14
 800d246:	f002 fe53 	bl	800fef0 <chSchGoSleepS>
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
 800d24a:	f640 5350 	movw	r3, #3408	; 0xd50
 800d24e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d252:	699b      	ldr	r3, [r3, #24]
 800d254:	332c      	adds	r3, #44	; 0x2c
 800d256:	4618      	mov	r0, r3
 800d258:	f7ff ff3a 	bl	800d0d0 <queue_fifo_remove.7489.4244>
 800d25c:	9001      	str	r0, [sp, #4]
  tp->p_state = CH_STATE_SNDMSG;
 800d25e:	9b01      	ldr	r3, [sp, #4]
 800d260:	220d      	movs	r2, #13
 800d262:	f883 2020 	strb.w	r2, [r3, #32]
  chSysUnlock();
 800d266:	f7ff ff53 	bl	800d110 <chSysUnlock.7494.4240>

  return tp;
 800d26a:	9b01      	ldr	r3, [sp, #4]
}
 800d26c:	4618      	mov	r0, r3
 800d26e:	b003      	add	sp, #12
 800d270:	f85d fb04 	ldr.w	pc, [sp], #4
 800d274:	f3af 8000 	nop.w
 800d278:	f3af 8000 	nop.w
 800d27c:	f3af 8000 	nop.w

0800d280 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 800d280:	b500      	push	{lr}
 800d282:	b083      	sub	sp, #12
 800d284:	9001      	str	r0, [sp, #4]
 800d286:	9100      	str	r1, [sp, #0]

  chSysLock();
 800d288:	f7ff ff3a 	bl	800d100 <chSysLock.7492.4242>
  chDbgAssert(tp->p_state == CH_STATE_SNDMSG, "invalid state");
 800d28c:	9b01      	ldr	r3, [sp, #4]
 800d28e:	f893 3020 	ldrb.w	r3, [r3, #32]
 800d292:	2b0d      	cmp	r3, #13
 800d294:	d005      	beq.n	800d2a2 <chMsgRelease+0x22>
 800d296:	f641 2040 	movw	r0, #6720	; 0x1a40
 800d29a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d29e:	f002 f877 	bl	800f390 <chSysHalt>
  chMsgReleaseS(tp, msg);
 800d2a2:	9801      	ldr	r0, [sp, #4]
 800d2a4:	9900      	ldr	r1, [sp, #0]
 800d2a6:	f7ff ff73 	bl	800d190 <chMsgReleaseS.7500.4233>
  chSysUnlock();
 800d2aa:	f7ff ff31 	bl	800d110 <chSysUnlock.7494.4240>
}
 800d2ae:	b003      	add	sp, #12
 800d2b0:	f85d fb04 	ldr.w	pc, [sp], #4
 800d2b4:	f3af 8000 	nop.w
 800d2b8:	f3af 8000 	nop.w
 800d2bc:	f3af 8000 	nop.w

0800d2c0 <port_lock.7593.4220>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800d2c0:	b082      	sub	sp, #8
 800d2c2:	2320      	movs	r3, #32
 800d2c4:	9301      	str	r3, [sp, #4]
 800d2c6:	9b01      	ldr	r3, [sp, #4]
 800d2c8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d2cc:	b002      	add	sp, #8
 800d2ce:	4770      	bx	lr

0800d2d0 <port_unlock.7596.4218>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800d2d0:	b082      	sub	sp, #8
 800d2d2:	2300      	movs	r3, #0
 800d2d4:	9301      	str	r3, [sp, #4]
 800d2d6:	9b01      	ldr	r3, [sp, #4]
 800d2d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d2dc:	b002      	add	sp, #8
 800d2de:	4770      	bx	lr

0800d2e0 <chSysLock.7598.4216>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800d2e0:	b508      	push	{r3, lr}

  port_lock();
 800d2e2:	f7ff ffed 	bl	800d2c0 <port_lock.7593.4220>
  _stats_start_measure_crit_thd();
 800d2e6:	f000 fe4b 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800d2ea:	f002 f9f9 	bl	800f6e0 <_dbg_check_lock>
}
 800d2ee:	bd08      	pop	{r3, pc}

0800d2f0 <chSysUnlock.7600.4214>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800d2f0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800d2f2:	f002 fa15 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800d2f6:	f000 fe4b 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800d2fa:	f640 5350 	movw	r3, #3408	; 0xd50
 800d2fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d302:	681a      	ldr	r2, [r3, #0]
 800d304:	f640 5350 	movw	r3, #3408	; 0xd50
 800d308:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d30c:	429a      	cmp	r2, r3
 800d30e:	d013      	beq.n	800d338 <chSysUnlock.7600.4214+0x48>
 800d310:	f640 5350 	movw	r3, #3408	; 0xd50
 800d314:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d318:	699b      	ldr	r3, [r3, #24]
 800d31a:	689a      	ldr	r2, [r3, #8]
 800d31c:	f640 5350 	movw	r3, #3408	; 0xd50
 800d320:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d324:	681b      	ldr	r3, [r3, #0]
 800d326:	689b      	ldr	r3, [r3, #8]
 800d328:	429a      	cmp	r2, r3
 800d32a:	d205      	bcs.n	800d338 <chSysUnlock.7600.4214+0x48>
 800d32c:	f641 2060 	movw	r0, #6752	; 0x1a60
 800d330:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d334:	f002 f82c 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800d338:	f7ff ffca 	bl	800d2d0 <port_unlock.7596.4218>
}
 800d33c:	bd08      	pop	{r3, pc}
 800d33e:	bf00      	nop

0800d340 <chSemFastWaitI.7692.4211>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastWaitI(semaphore_t *sp) {
 800d340:	b500      	push	{lr}
 800d342:	b083      	sub	sp, #12
 800d344:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800d346:	f002 fa9b 	bl	800f880 <chDbgCheckClassI>

  sp->s_cnt--;
 800d34a:	9b01      	ldr	r3, [sp, #4]
 800d34c:	689b      	ldr	r3, [r3, #8]
 800d34e:	1e5a      	subs	r2, r3, #1
 800d350:	9b01      	ldr	r3, [sp, #4]
 800d352:	609a      	str	r2, [r3, #8]
}
 800d354:	b003      	add	sp, #12
 800d356:	f85d fb04 	ldr.w	pc, [sp], #4
 800d35a:	bf00      	nop
 800d35c:	f3af 8000 	nop.w

0800d360 <chSemGetCounterI.7602.4208>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 800d360:	b500      	push	{lr}
 800d362:	b083      	sub	sp, #12
 800d364:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800d366:	f002 fa8b 	bl	800f880 <chDbgCheckClassI>

  return sp->s_cnt;
 800d36a:	9b01      	ldr	r3, [sp, #4]
 800d36c:	689b      	ldr	r3, [r3, #8]
}
 800d36e:	4618      	mov	r0, r3
 800d370:	b003      	add	sp, #12
 800d372:	f85d fb04 	ldr.w	pc, [sp], #4
 800d376:	bf00      	nop
 800d378:	f3af 8000 	nop.w
 800d37c:	f3af 8000 	nop.w

0800d380 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 800d380:	b500      	push	{lr}
 800d382:	b085      	sub	sp, #20
 800d384:	9003      	str	r0, [sp, #12]
 800d386:	9102      	str	r1, [sp, #8]
 800d388:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
 800d38a:	9b03      	ldr	r3, [sp, #12]
 800d38c:	2b00      	cmp	r3, #0
 800d38e:	d005      	beq.n	800d39c <chMBObjectInit+0x1c>
 800d390:	9b02      	ldr	r3, [sp, #8]
 800d392:	2b00      	cmp	r3, #0
 800d394:	d002      	beq.n	800d39c <chMBObjectInit+0x1c>
 800d396:	9b01      	ldr	r3, [sp, #4]
 800d398:	2b00      	cmp	r3, #0
 800d39a:	dc05      	bgt.n	800d3a8 <chMBObjectInit+0x28>
 800d39c:	f641 2050 	movw	r0, #6736	; 0x1a50
 800d3a0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d3a4:	f001 fff4 	bl	800f390 <chSysHalt>

  mbp->mb_buffer = buf;
 800d3a8:	9b03      	ldr	r3, [sp, #12]
 800d3aa:	9a02      	ldr	r2, [sp, #8]
 800d3ac:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
 800d3ae:	9b03      	ldr	r3, [sp, #12]
 800d3b0:	9a02      	ldr	r2, [sp, #8]
 800d3b2:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
 800d3b4:	9b03      	ldr	r3, [sp, #12]
 800d3b6:	9a02      	ldr	r2, [sp, #8]
 800d3b8:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
 800d3ba:	9b01      	ldr	r3, [sp, #4]
 800d3bc:	009b      	lsls	r3, r3, #2
 800d3be:	9a02      	ldr	r2, [sp, #8]
 800d3c0:	441a      	add	r2, r3
 800d3c2:	9b03      	ldr	r3, [sp, #12]
 800d3c4:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
 800d3c6:	9b03      	ldr	r3, [sp, #12]
 800d3c8:	331c      	adds	r3, #28
 800d3ca:	4618      	mov	r0, r3
 800d3cc:	9901      	ldr	r1, [sp, #4]
 800d3ce:	f001 f887 	bl	800e4e0 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
 800d3d2:	9b03      	ldr	r3, [sp, #12]
 800d3d4:	3310      	adds	r3, #16
 800d3d6:	4618      	mov	r0, r3
 800d3d8:	2100      	movs	r1, #0
 800d3da:	f001 f881 	bl	800e4e0 <chSemObjectInit>
}
 800d3de:	b005      	add	sp, #20
 800d3e0:	f85d fb04 	ldr.w	pc, [sp], #4
 800d3e4:	f3af 8000 	nop.w
 800d3e8:	f3af 8000 	nop.w
 800d3ec:	f3af 8000 	nop.w

0800d3f0 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 800d3f0:	b500      	push	{lr}
 800d3f2:	b083      	sub	sp, #12
 800d3f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 800d3f6:	f7ff ff73 	bl	800d2e0 <chSysLock.7598.4216>
  chMBResetI(mbp);
 800d3fa:	9801      	ldr	r0, [sp, #4]
 800d3fc:	f000 f808 	bl	800d410 <chMBResetI.4197>
  chSchRescheduleS();
 800d400:	f002 feae 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 800d404:	f7ff ff74 	bl	800d2f0 <chSysUnlock.7600.4214>
}
 800d408:	b003      	add	sp, #12
 800d40a:	f85d fb04 	ldr.w	pc, [sp], #4
 800d40e:	bf00      	nop

0800d410 <chMBResetI.4197>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 800d410:	b500      	push	{lr}
 800d412:	b083      	sub	sp, #12
 800d414:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800d416:	f002 fa33 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 800d41a:	9b01      	ldr	r3, [sp, #4]
 800d41c:	2b00      	cmp	r3, #0
 800d41e:	d105      	bne.n	800d42c <chMBResetI.4197+0x1c>
 800d420:	f641 2070 	movw	r0, #6768	; 0x1a70
 800d424:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d428:	f001 ffb2 	bl	800f390 <chSysHalt>

  mbp->mb_wrptr = mbp->mb_buffer;
 800d42c:	9b01      	ldr	r3, [sp, #4]
 800d42e:	681a      	ldr	r2, [r3, #0]
 800d430:	9b01      	ldr	r3, [sp, #4]
 800d432:	609a      	str	r2, [r3, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
 800d434:	9b01      	ldr	r3, [sp, #4]
 800d436:	681a      	ldr	r2, [r3, #0]
 800d438:	9b01      	ldr	r3, [sp, #4]
 800d43a:	60da      	str	r2, [r3, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 800d43c:	9b01      	ldr	r3, [sp, #4]
 800d43e:	f103 021c 	add.w	r2, r3, #28
 800d442:	9b01      	ldr	r3, [sp, #4]
 800d444:	685b      	ldr	r3, [r3, #4]
 800d446:	4619      	mov	r1, r3
 800d448:	9b01      	ldr	r3, [sp, #4]
 800d44a:	681b      	ldr	r3, [r3, #0]
 800d44c:	1acb      	subs	r3, r1, r3
 800d44e:	109b      	asrs	r3, r3, #2
 800d450:	4610      	mov	r0, r2
 800d452:	4619      	mov	r1, r3
 800d454:	f001 f87c 	bl	800e550 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 800d458:	9b01      	ldr	r3, [sp, #4]
 800d45a:	3310      	adds	r3, #16
 800d45c:	4618      	mov	r0, r3
 800d45e:	2100      	movs	r1, #0
 800d460:	f001 f876 	bl	800e550 <chSemResetI>
}
 800d464:	b003      	add	sp, #12
 800d466:	f85d fb04 	ldr.w	pc, [sp], #4
 800d46a:	bf00      	nop
 800d46c:	f3af 8000 	nop.w

0800d470 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 800d470:	b500      	push	{lr}
 800d472:	b087      	sub	sp, #28
 800d474:	9003      	str	r0, [sp, #12]
 800d476:	9102      	str	r1, [sp, #8]
 800d478:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 800d47a:	f7ff ff31 	bl	800d2e0 <chSysLock.7598.4216>
  rdymsg = chMBPostS(mbp, msg, timeout);
 800d47e:	9803      	ldr	r0, [sp, #12]
 800d480:	9902      	ldr	r1, [sp, #8]
 800d482:	9a01      	ldr	r2, [sp, #4]
 800d484:	f000 f80c 	bl	800d4a0 <chMBPostS.4187>
 800d488:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800d48a:	f7ff ff31 	bl	800d2f0 <chSysUnlock.7600.4214>

  return rdymsg;
 800d48e:	9b05      	ldr	r3, [sp, #20]
}
 800d490:	4618      	mov	r0, r3
 800d492:	b007      	add	sp, #28
 800d494:	f85d fb04 	ldr.w	pc, [sp], #4
 800d498:	f3af 8000 	nop.w
 800d49c:	f3af 8000 	nop.w

0800d4a0 <chMBPostS.4187>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 800d4a0:	b500      	push	{lr}
 800d4a2:	b087      	sub	sp, #28
 800d4a4:	9003      	str	r0, [sp, #12]
 800d4a6:	9102      	str	r1, [sp, #8]
 800d4a8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 800d4aa:	f002 fa01 	bl	800f8b0 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);
 800d4ae:	9b03      	ldr	r3, [sp, #12]
 800d4b0:	2b00      	cmp	r3, #0
 800d4b2:	d105      	bne.n	800d4c0 <chMBPostS.4187+0x20>
 800d4b4:	f641 2080 	movw	r0, #6784	; 0x1a80
 800d4b8:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d4bc:	f001 ff68 	bl	800f390 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 800d4c0:	9b03      	ldr	r3, [sp, #12]
 800d4c2:	331c      	adds	r3, #28
 800d4c4:	4618      	mov	r0, r3
 800d4c6:	9901      	ldr	r1, [sp, #4]
 800d4c8:	f001 f91a 	bl	800e700 <chSemWaitTimeoutS>
 800d4cc:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 800d4ce:	9b05      	ldr	r3, [sp, #20]
 800d4d0:	2b00      	cmp	r3, #0
 800d4d2:	d117      	bne.n	800d504 <chMBPostS.4187+0x64>
    *mbp->mb_wrptr++ = msg;
 800d4d4:	9b03      	ldr	r3, [sp, #12]
 800d4d6:	689b      	ldr	r3, [r3, #8]
 800d4d8:	1d19      	adds	r1, r3, #4
 800d4da:	9a03      	ldr	r2, [sp, #12]
 800d4dc:	6091      	str	r1, [r2, #8]
 800d4de:	9a02      	ldr	r2, [sp, #8]
 800d4e0:	601a      	str	r2, [r3, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 800d4e2:	9b03      	ldr	r3, [sp, #12]
 800d4e4:	689a      	ldr	r2, [r3, #8]
 800d4e6:	9b03      	ldr	r3, [sp, #12]
 800d4e8:	685b      	ldr	r3, [r3, #4]
 800d4ea:	429a      	cmp	r2, r3
 800d4ec:	d303      	bcc.n	800d4f6 <chMBPostS.4187+0x56>
      mbp->mb_wrptr = mbp->mb_buffer;
 800d4ee:	9b03      	ldr	r3, [sp, #12]
 800d4f0:	681a      	ldr	r2, [r3, #0]
 800d4f2:	9b03      	ldr	r3, [sp, #12]
 800d4f4:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 800d4f6:	9b03      	ldr	r3, [sp, #12]
 800d4f8:	3310      	adds	r3, #16
 800d4fa:	4618      	mov	r0, r3
 800d4fc:	f001 f9b0 	bl	800e860 <chSemSignalI>
    chSchRescheduleS();
 800d500:	f002 fe2e 	bl	8010160 <chSchRescheduleS>
  }

  return rdymsg;
 800d504:	9b05      	ldr	r3, [sp, #20]
}
 800d506:	4618      	mov	r0, r3
 800d508:	b007      	add	sp, #28
 800d50a:	f85d fb04 	ldr.w	pc, [sp], #4
 800d50e:	bf00      	nop

0800d510 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 800d510:	b500      	push	{lr}
 800d512:	b083      	sub	sp, #12
 800d514:	9001      	str	r0, [sp, #4]
 800d516:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 800d518:	f002 f9b2 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 800d51c:	9b01      	ldr	r3, [sp, #4]
 800d51e:	2b00      	cmp	r3, #0
 800d520:	d105      	bne.n	800d52e <chMBPostI+0x1e>
 800d522:	f641 2090 	movw	r0, #6800	; 0x1a90
 800d526:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d52a:	f001 ff31 	bl	800f390 <chSysHalt>

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 800d52e:	9b01      	ldr	r3, [sp, #4]
 800d530:	331c      	adds	r3, #28
 800d532:	4618      	mov	r0, r3
 800d534:	f7ff ff14 	bl	800d360 <chSemGetCounterI.7602.4208>
 800d538:	4603      	mov	r3, r0
 800d53a:	2b00      	cmp	r3, #0
 800d53c:	dc02      	bgt.n	800d544 <chMBPostI+0x34>
    return MSG_TIMEOUT;
 800d53e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800d542:	e01b      	b.n	800d57c <chMBPostI+0x6c>
  }

  chSemFastWaitI(&mbp->mb_emptysem);
 800d544:	9b01      	ldr	r3, [sp, #4]
 800d546:	331c      	adds	r3, #28
 800d548:	4618      	mov	r0, r3
 800d54a:	f7ff fef9 	bl	800d340 <chSemFastWaitI.7692.4211>
  *mbp->mb_wrptr++ = msg;
 800d54e:	9b01      	ldr	r3, [sp, #4]
 800d550:	689b      	ldr	r3, [r3, #8]
 800d552:	1d19      	adds	r1, r3, #4
 800d554:	9a01      	ldr	r2, [sp, #4]
 800d556:	6091      	str	r1, [r2, #8]
 800d558:	9a00      	ldr	r2, [sp, #0]
 800d55a:	601a      	str	r2, [r3, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 800d55c:	9b01      	ldr	r3, [sp, #4]
 800d55e:	689a      	ldr	r2, [r3, #8]
 800d560:	9b01      	ldr	r3, [sp, #4]
 800d562:	685b      	ldr	r3, [r3, #4]
 800d564:	429a      	cmp	r2, r3
 800d566:	d303      	bcc.n	800d570 <chMBPostI+0x60>
     mbp->mb_wrptr = mbp->mb_buffer;
 800d568:	9b01      	ldr	r3, [sp, #4]
 800d56a:	681a      	ldr	r2, [r3, #0]
 800d56c:	9b01      	ldr	r3, [sp, #4]
 800d56e:	609a      	str	r2, [r3, #8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 800d570:	9b01      	ldr	r3, [sp, #4]
 800d572:	3310      	adds	r3, #16
 800d574:	4618      	mov	r0, r3
 800d576:	f001 f973 	bl	800e860 <chSemSignalI>

  return MSG_OK;
 800d57a:	2300      	movs	r3, #0
}
 800d57c:	4618      	mov	r0, r3
 800d57e:	b003      	add	sp, #12
 800d580:	f85d fb04 	ldr.w	pc, [sp], #4
 800d584:	f3af 8000 	nop.w
 800d588:	f3af 8000 	nop.w
 800d58c:	f3af 8000 	nop.w

0800d590 <chMBPostAhead>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 800d590:	b500      	push	{lr}
 800d592:	b087      	sub	sp, #28
 800d594:	9003      	str	r0, [sp, #12]
 800d596:	9102      	str	r1, [sp, #8]
 800d598:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 800d59a:	f7ff fea1 	bl	800d2e0 <chSysLock.7598.4216>
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
 800d59e:	9803      	ldr	r0, [sp, #12]
 800d5a0:	9902      	ldr	r1, [sp, #8]
 800d5a2:	9a01      	ldr	r2, [sp, #4]
 800d5a4:	f000 f80c 	bl	800d5c0 <chMBPostAheadS.4173>
 800d5a8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800d5aa:	f7ff fea1 	bl	800d2f0 <chSysUnlock.7600.4214>

  return rdymsg;
 800d5ae:	9b05      	ldr	r3, [sp, #20]
}
 800d5b0:	4618      	mov	r0, r3
 800d5b2:	b007      	add	sp, #28
 800d5b4:	f85d fb04 	ldr.w	pc, [sp], #4
 800d5b8:	f3af 8000 	nop.w
 800d5bc:	f3af 8000 	nop.w

0800d5c0 <chMBPostAheadS.4173>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 800d5c0:	b500      	push	{lr}
 800d5c2:	b087      	sub	sp, #28
 800d5c4:	9003      	str	r0, [sp, #12]
 800d5c6:	9102      	str	r1, [sp, #8]
 800d5c8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 800d5ca:	f002 f971 	bl	800f8b0 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);
 800d5ce:	9b03      	ldr	r3, [sp, #12]
 800d5d0:	2b00      	cmp	r3, #0
 800d5d2:	d105      	bne.n	800d5e0 <chMBPostAheadS.4173+0x20>
 800d5d4:	f641 20a0 	movw	r0, #6816	; 0x1aa0
 800d5d8:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d5dc:	f001 fed8 	bl	800f390 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 800d5e0:	9b03      	ldr	r3, [sp, #12]
 800d5e2:	331c      	adds	r3, #28
 800d5e4:	4618      	mov	r0, r3
 800d5e6:	9901      	ldr	r1, [sp, #4]
 800d5e8:	f001 f88a 	bl	800e700 <chSemWaitTimeoutS>
 800d5ec:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 800d5ee:	9b05      	ldr	r3, [sp, #20]
 800d5f0:	2b00      	cmp	r3, #0
 800d5f2:	d11a      	bne.n	800d62a <chMBPostAheadS.4173+0x6a>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 800d5f4:	9b03      	ldr	r3, [sp, #12]
 800d5f6:	68db      	ldr	r3, [r3, #12]
 800d5f8:	1f1a      	subs	r2, r3, #4
 800d5fa:	9b03      	ldr	r3, [sp, #12]
 800d5fc:	60da      	str	r2, [r3, #12]
 800d5fe:	9b03      	ldr	r3, [sp, #12]
 800d600:	68da      	ldr	r2, [r3, #12]
 800d602:	9b03      	ldr	r3, [sp, #12]
 800d604:	681b      	ldr	r3, [r3, #0]
 800d606:	429a      	cmp	r2, r3
 800d608:	d204      	bcs.n	800d614 <chMBPostAheadS.4173+0x54>
      mbp->mb_rdptr = mbp->mb_top - 1;
 800d60a:	9b03      	ldr	r3, [sp, #12]
 800d60c:	685b      	ldr	r3, [r3, #4]
 800d60e:	1f1a      	subs	r2, r3, #4
 800d610:	9b03      	ldr	r3, [sp, #12]
 800d612:	60da      	str	r2, [r3, #12]
    }
    *mbp->mb_rdptr = msg;
 800d614:	9b03      	ldr	r3, [sp, #12]
 800d616:	68db      	ldr	r3, [r3, #12]
 800d618:	9a02      	ldr	r2, [sp, #8]
 800d61a:	601a      	str	r2, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 800d61c:	9b03      	ldr	r3, [sp, #12]
 800d61e:	3310      	adds	r3, #16
 800d620:	4618      	mov	r0, r3
 800d622:	f001 f91d 	bl	800e860 <chSemSignalI>
    chSchRescheduleS();
 800d626:	f002 fd9b 	bl	8010160 <chSchRescheduleS>
  }

  return rdymsg;
 800d62a:	9b05      	ldr	r3, [sp, #20]
}
 800d62c:	4618      	mov	r0, r3
 800d62e:	b007      	add	sp, #28
 800d630:	f85d fb04 	ldr.w	pc, [sp], #4
 800d634:	f3af 8000 	nop.w
 800d638:	f3af 8000 	nop.w
 800d63c:	f3af 8000 	nop.w

0800d640 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 800d640:	b500      	push	{lr}
 800d642:	b083      	sub	sp, #12
 800d644:	9001      	str	r0, [sp, #4]
 800d646:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 800d648:	f002 f91a 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 800d64c:	9b01      	ldr	r3, [sp, #4]
 800d64e:	2b00      	cmp	r3, #0
 800d650:	d105      	bne.n	800d65e <chMBPostAheadI+0x1e>
 800d652:	f641 20b0 	movw	r0, #6832	; 0x1ab0
 800d656:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d65a:	f001 fe99 	bl	800f390 <chSysHalt>

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 800d65e:	9b01      	ldr	r3, [sp, #4]
 800d660:	331c      	adds	r3, #28
 800d662:	4618      	mov	r0, r3
 800d664:	f7ff fe7c 	bl	800d360 <chSemGetCounterI.7602.4208>
 800d668:	4603      	mov	r3, r0
 800d66a:	2b00      	cmp	r3, #0
 800d66c:	dc02      	bgt.n	800d674 <chMBPostAheadI+0x34>
    return MSG_TIMEOUT;
 800d66e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800d672:	e01e      	b.n	800d6b2 <chMBPostAheadI+0x72>
  }
  chSemFastWaitI(&mbp->mb_emptysem);
 800d674:	9b01      	ldr	r3, [sp, #4]
 800d676:	331c      	adds	r3, #28
 800d678:	4618      	mov	r0, r3
 800d67a:	f7ff fe61 	bl	800d340 <chSemFastWaitI.7692.4211>
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 800d67e:	9b01      	ldr	r3, [sp, #4]
 800d680:	68db      	ldr	r3, [r3, #12]
 800d682:	1f1a      	subs	r2, r3, #4
 800d684:	9b01      	ldr	r3, [sp, #4]
 800d686:	60da      	str	r2, [r3, #12]
 800d688:	9b01      	ldr	r3, [sp, #4]
 800d68a:	68da      	ldr	r2, [r3, #12]
 800d68c:	9b01      	ldr	r3, [sp, #4]
 800d68e:	681b      	ldr	r3, [r3, #0]
 800d690:	429a      	cmp	r2, r3
 800d692:	d204      	bcs.n	800d69e <chMBPostAheadI+0x5e>
    mbp->mb_rdptr = mbp->mb_top - 1;
 800d694:	9b01      	ldr	r3, [sp, #4]
 800d696:	685b      	ldr	r3, [r3, #4]
 800d698:	1f1a      	subs	r2, r3, #4
 800d69a:	9b01      	ldr	r3, [sp, #4]
 800d69c:	60da      	str	r2, [r3, #12]
  }
  *mbp->mb_rdptr = msg;
 800d69e:	9b01      	ldr	r3, [sp, #4]
 800d6a0:	68db      	ldr	r3, [r3, #12]
 800d6a2:	9a00      	ldr	r2, [sp, #0]
 800d6a4:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->mb_fullsem);
 800d6a6:	9b01      	ldr	r3, [sp, #4]
 800d6a8:	3310      	adds	r3, #16
 800d6aa:	4618      	mov	r0, r3
 800d6ac:	f001 f8d8 	bl	800e860 <chSemSignalI>

  return MSG_OK;
 800d6b0:	2300      	movs	r3, #0
}
 800d6b2:	4618      	mov	r0, r3
 800d6b4:	b003      	add	sp, #12
 800d6b6:	f85d fb04 	ldr.w	pc, [sp], #4
 800d6ba:	bf00      	nop
 800d6bc:	f3af 8000 	nop.w

0800d6c0 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 800d6c0:	b500      	push	{lr}
 800d6c2:	b087      	sub	sp, #28
 800d6c4:	9003      	str	r0, [sp, #12]
 800d6c6:	9102      	str	r1, [sp, #8]
 800d6c8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 800d6ca:	f7ff fe09 	bl	800d2e0 <chSysLock.7598.4216>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 800d6ce:	9803      	ldr	r0, [sp, #12]
 800d6d0:	9902      	ldr	r1, [sp, #8]
 800d6d2:	9a01      	ldr	r2, [sp, #4]
 800d6d4:	f000 f80c 	bl	800d6f0 <chMBFetchS.4158>
 800d6d8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 800d6da:	f7ff fe09 	bl	800d2f0 <chSysUnlock.7600.4214>

  return rdymsg;
 800d6de:	9b05      	ldr	r3, [sp, #20]
}
 800d6e0:	4618      	mov	r0, r3
 800d6e2:	b007      	add	sp, #28
 800d6e4:	f85d fb04 	ldr.w	pc, [sp], #4
 800d6e8:	f3af 8000 	nop.w
 800d6ec:	f3af 8000 	nop.w

0800d6f0 <chMBFetchS.4158>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 800d6f0:	b500      	push	{lr}
 800d6f2:	b087      	sub	sp, #28
 800d6f4:	9003      	str	r0, [sp, #12]
 800d6f6:	9102      	str	r1, [sp, #8]
 800d6f8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 800d6fa:	f002 f8d9 	bl	800f8b0 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 800d6fe:	9b03      	ldr	r3, [sp, #12]
 800d700:	2b00      	cmp	r3, #0
 800d702:	d002      	beq.n	800d70a <chMBFetchS.4158+0x1a>
 800d704:	9b02      	ldr	r3, [sp, #8]
 800d706:	2b00      	cmp	r3, #0
 800d708:	d105      	bne.n	800d716 <chMBFetchS.4158+0x26>
 800d70a:	f641 20c0 	movw	r0, #6848	; 0x1ac0
 800d70e:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d712:	f001 fe3d 	bl	800f390 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 800d716:	9b03      	ldr	r3, [sp, #12]
 800d718:	3310      	adds	r3, #16
 800d71a:	4618      	mov	r0, r3
 800d71c:	9901      	ldr	r1, [sp, #4]
 800d71e:	f000 ffef 	bl	800e700 <chSemWaitTimeoutS>
 800d722:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 800d724:	9b05      	ldr	r3, [sp, #20]
 800d726:	2b00      	cmp	r3, #0
 800d728:	d118      	bne.n	800d75c <chMBFetchS.4158+0x6c>
    *msgp = *mbp->mb_rdptr++;
 800d72a:	9b03      	ldr	r3, [sp, #12]
 800d72c:	68db      	ldr	r3, [r3, #12]
 800d72e:	1d19      	adds	r1, r3, #4
 800d730:	9a03      	ldr	r2, [sp, #12]
 800d732:	60d1      	str	r1, [r2, #12]
 800d734:	681a      	ldr	r2, [r3, #0]
 800d736:	9b02      	ldr	r3, [sp, #8]
 800d738:	601a      	str	r2, [r3, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 800d73a:	9b03      	ldr	r3, [sp, #12]
 800d73c:	68da      	ldr	r2, [r3, #12]
 800d73e:	9b03      	ldr	r3, [sp, #12]
 800d740:	685b      	ldr	r3, [r3, #4]
 800d742:	429a      	cmp	r2, r3
 800d744:	d303      	bcc.n	800d74e <chMBFetchS.4158+0x5e>
      mbp->mb_rdptr = mbp->mb_buffer;
 800d746:	9b03      	ldr	r3, [sp, #12]
 800d748:	681a      	ldr	r2, [r3, #0]
 800d74a:	9b03      	ldr	r3, [sp, #12]
 800d74c:	60da      	str	r2, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 800d74e:	9b03      	ldr	r3, [sp, #12]
 800d750:	331c      	adds	r3, #28
 800d752:	4618      	mov	r0, r3
 800d754:	f001 f884 	bl	800e860 <chSemSignalI>
    chSchRescheduleS();
 800d758:	f002 fd02 	bl	8010160 <chSchRescheduleS>
  }

  return rdymsg;
 800d75c:	9b05      	ldr	r3, [sp, #20]
}
 800d75e:	4618      	mov	r0, r3
 800d760:	b007      	add	sp, #28
 800d762:	f85d fb04 	ldr.w	pc, [sp], #4
 800d766:	bf00      	nop
 800d768:	f3af 8000 	nop.w
 800d76c:	f3af 8000 	nop.w

0800d770 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 800d770:	b500      	push	{lr}
 800d772:	b083      	sub	sp, #12
 800d774:	9001      	str	r0, [sp, #4]
 800d776:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 800d778:	f002 f882 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 800d77c:	9b01      	ldr	r3, [sp, #4]
 800d77e:	2b00      	cmp	r3, #0
 800d780:	d002      	beq.n	800d788 <chMBFetchI+0x18>
 800d782:	9b00      	ldr	r3, [sp, #0]
 800d784:	2b00      	cmp	r3, #0
 800d786:	d105      	bne.n	800d794 <chMBFetchI+0x24>
 800d788:	f641 20d0 	movw	r0, #6864	; 0x1ad0
 800d78c:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d790:	f001 fdfe 	bl	800f390 <chSysHalt>

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 800d794:	9b01      	ldr	r3, [sp, #4]
 800d796:	3310      	adds	r3, #16
 800d798:	4618      	mov	r0, r3
 800d79a:	f7ff fde1 	bl	800d360 <chSemGetCounterI.7602.4208>
 800d79e:	4603      	mov	r3, r0
 800d7a0:	2b00      	cmp	r3, #0
 800d7a2:	dc02      	bgt.n	800d7aa <chMBFetchI+0x3a>
    return MSG_TIMEOUT;
 800d7a4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800d7a8:	e01c      	b.n	800d7e4 <chMBFetchI+0x74>
  }
  chSemFastWaitI(&mbp->mb_fullsem);
 800d7aa:	9b01      	ldr	r3, [sp, #4]
 800d7ac:	3310      	adds	r3, #16
 800d7ae:	4618      	mov	r0, r3
 800d7b0:	f7ff fdc6 	bl	800d340 <chSemFastWaitI.7692.4211>
  *msgp = *mbp->mb_rdptr++;
 800d7b4:	9b01      	ldr	r3, [sp, #4]
 800d7b6:	68db      	ldr	r3, [r3, #12]
 800d7b8:	1d19      	adds	r1, r3, #4
 800d7ba:	9a01      	ldr	r2, [sp, #4]
 800d7bc:	60d1      	str	r1, [r2, #12]
 800d7be:	681a      	ldr	r2, [r3, #0]
 800d7c0:	9b00      	ldr	r3, [sp, #0]
 800d7c2:	601a      	str	r2, [r3, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
 800d7c4:	9b01      	ldr	r3, [sp, #4]
 800d7c6:	68da      	ldr	r2, [r3, #12]
 800d7c8:	9b01      	ldr	r3, [sp, #4]
 800d7ca:	685b      	ldr	r3, [r3, #4]
 800d7cc:	429a      	cmp	r2, r3
 800d7ce:	d303      	bcc.n	800d7d8 <chMBFetchI+0x68>
    mbp->mb_rdptr = mbp->mb_buffer;
 800d7d0:	9b01      	ldr	r3, [sp, #4]
 800d7d2:	681a      	ldr	r2, [r3, #0]
 800d7d4:	9b01      	ldr	r3, [sp, #4]
 800d7d6:	60da      	str	r2, [r3, #12]
  }
  chSemSignalI(&mbp->mb_emptysem);
 800d7d8:	9b01      	ldr	r3, [sp, #4]
 800d7da:	331c      	adds	r3, #28
 800d7dc:	4618      	mov	r0, r3
 800d7de:	f001 f83f 	bl	800e860 <chSemSignalI>

  return MSG_OK;
 800d7e2:	2300      	movs	r3, #0
}
 800d7e4:	4618      	mov	r0, r3
 800d7e6:	b003      	add	sp, #12
 800d7e8:	f85d fb04 	ldr.w	pc, [sp], #4
 800d7ec:	f3af 8000 	nop.w

0800d7f0 <port_lock.7849.4140>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800d7f0:	b082      	sub	sp, #8
 800d7f2:	2320      	movs	r3, #32
 800d7f4:	9301      	str	r3, [sp, #4]
 800d7f6:	9b01      	ldr	r3, [sp, #4]
 800d7f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d7fc:	b002      	add	sp, #8
 800d7fe:	4770      	bx	lr

0800d800 <port_unlock.7852.4138>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800d800:	b082      	sub	sp, #8
 800d802:	2300      	movs	r3, #0
 800d804:	9301      	str	r3, [sp, #4]
 800d806:	9b01      	ldr	r3, [sp, #4]
 800d808:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d80c:	b002      	add	sp, #8
 800d80e:	4770      	bx	lr

0800d810 <queue_init.7854.4135>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800d810:	b082      	sub	sp, #8
 800d812:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800d814:	9b01      	ldr	r3, [sp, #4]
 800d816:	9a01      	ldr	r2, [sp, #4]
 800d818:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800d81a:	9b01      	ldr	r3, [sp, #4]
 800d81c:	9a01      	ldr	r2, [sp, #4]
 800d81e:	605a      	str	r2, [r3, #4]
}
 800d820:	b002      	add	sp, #8
 800d822:	4770      	bx	lr
 800d824:	f3af 8000 	nop.w
 800d828:	f3af 8000 	nop.w
 800d82c:	f3af 8000 	nop.w

0800d830 <chSysLock.7973>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800d830:	b508      	push	{r3, lr}

  port_lock();
 800d832:	f7ff ffdd 	bl	800d7f0 <port_lock.7849.4140>
  _stats_start_measure_crit_thd();
 800d836:	f000 fba3 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800d83a:	f001 ff51 	bl	800f6e0 <_dbg_check_lock>
}
 800d83e:	bd08      	pop	{r3, pc}

0800d840 <chSysUnlock.7975>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800d840:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800d842:	f001 ff6d 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800d846:	f000 fba3 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800d84a:	f640 5350 	movw	r3, #3408	; 0xd50
 800d84e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d852:	681a      	ldr	r2, [r3, #0]
 800d854:	f640 5350 	movw	r3, #3408	; 0xd50
 800d858:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d85c:	429a      	cmp	r2, r3
 800d85e:	d013      	beq.n	800d888 <chSysUnlock.7975+0x48>
 800d860:	f640 5350 	movw	r3, #3408	; 0xd50
 800d864:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d868:	699b      	ldr	r3, [r3, #24]
 800d86a:	689a      	ldr	r2, [r3, #8]
 800d86c:	f640 5350 	movw	r3, #3408	; 0xd50
 800d870:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d874:	681b      	ldr	r3, [r3, #0]
 800d876:	689b      	ldr	r3, [r3, #8]
 800d878:	429a      	cmp	r2, r3
 800d87a:	d205      	bcs.n	800d888 <chSysUnlock.7975+0x48>
 800d87c:	f641 20e0 	movw	r0, #6880	; 0x1ae0
 800d880:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d884:	f001 fd84 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800d888:	f7ff ffba 	bl	800d800 <port_unlock.7852.4138>
}
 800d88c:	bd08      	pop	{r3, pc}
 800d88e:	bf00      	nop

0800d890 <chThdQueueObjectInit.7943>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 800d890:	b500      	push	{lr}
 800d892:	b083      	sub	sp, #12
 800d894:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 800d896:	9801      	ldr	r0, [sp, #4]
 800d898:	f7ff ffba 	bl	800d810 <queue_init.7854.4135>
}
 800d89c:	b003      	add	sp, #12
 800d89e:	f85d fb04 	ldr.w	pc, [sp], #4
 800d8a2:	bf00      	nop
 800d8a4:	f3af 8000 	nop.w
 800d8a8:	f3af 8000 	nop.w
 800d8ac:	f3af 8000 	nop.w

0800d8b0 <chIQIsEmptyI.7963>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 800d8b0:	b500      	push	{lr}
 800d8b2:	b083      	sub	sp, #12
 800d8b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800d8b6:	f001 ffe3 	bl	800f880 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 800d8ba:	9b01      	ldr	r3, [sp, #4]
 800d8bc:	689b      	ldr	r3, [r3, #8]
 800d8be:	2b00      	cmp	r3, #0
 800d8c0:	bf14      	ite	ne
 800d8c2:	2300      	movne	r3, #0
 800d8c4:	2301      	moveq	r3, #1
 800d8c6:	b2db      	uxtb	r3, r3
}
 800d8c8:	4618      	mov	r0, r3
 800d8ca:	b003      	add	sp, #12
 800d8cc:	f85d fb04 	ldr.w	pc, [sp], #4

0800d8d0 <chIQIsFullI.7946>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 800d8d0:	b500      	push	{lr}
 800d8d2:	b083      	sub	sp, #12
 800d8d4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800d8d6:	f001 ffd3 	bl	800f880 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 800d8da:	9b01      	ldr	r3, [sp, #4]
 800d8dc:	695a      	ldr	r2, [r3, #20]
 800d8de:	9b01      	ldr	r3, [sp, #4]
 800d8e0:	699b      	ldr	r3, [r3, #24]
 800d8e2:	429a      	cmp	r2, r3
 800d8e4:	d105      	bne.n	800d8f2 <chIQIsFullI.7946+0x22>
 800d8e6:	9b01      	ldr	r3, [sp, #4]
 800d8e8:	689b      	ldr	r3, [r3, #8]
 800d8ea:	2b00      	cmp	r3, #0
 800d8ec:	d001      	beq.n	800d8f2 <chIQIsFullI.7946+0x22>
 800d8ee:	2301      	movs	r3, #1
 800d8f0:	e000      	b.n	800d8f4 <chIQIsFullI.7946+0x24>
 800d8f2:	2300      	movs	r3, #0
 800d8f4:	f003 0301 	and.w	r3, r3, #1
 800d8f8:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800d8fa:	4618      	mov	r0, r3
 800d8fc:	b003      	add	sp, #12
 800d8fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800d902:	bf00      	nop
 800d904:	f3af 8000 	nop.w
 800d908:	f3af 8000 	nop.w
 800d90c:	f3af 8000 	nop.w

0800d910 <chOQIsEmptyI.7970>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 800d910:	b500      	push	{lr}
 800d912:	b083      	sub	sp, #12
 800d914:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800d916:	f001 ffb3 	bl	800f880 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800d91a:	9b01      	ldr	r3, [sp, #4]
 800d91c:	695a      	ldr	r2, [r3, #20]
 800d91e:	9b01      	ldr	r3, [sp, #4]
 800d920:	699b      	ldr	r3, [r3, #24]
 800d922:	429a      	cmp	r2, r3
 800d924:	d105      	bne.n	800d932 <chOQIsEmptyI.7970+0x22>
 800d926:	9b01      	ldr	r3, [sp, #4]
 800d928:	689b      	ldr	r3, [r3, #8]
 800d92a:	2b00      	cmp	r3, #0
 800d92c:	d001      	beq.n	800d932 <chOQIsEmptyI.7970+0x22>
 800d92e:	2301      	movs	r3, #1
 800d930:	e000      	b.n	800d934 <chOQIsEmptyI.7970+0x24>
 800d932:	2300      	movs	r3, #0
 800d934:	f003 0301 	and.w	r3, r3, #1
 800d938:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800d93a:	4618      	mov	r0, r3
 800d93c:	b003      	add	sp, #12
 800d93e:	f85d fb04 	ldr.w	pc, [sp], #4
 800d942:	bf00      	nop
 800d944:	f3af 8000 	nop.w
 800d948:	f3af 8000 	nop.w
 800d94c:	f3af 8000 	nop.w

0800d950 <chOQIsFullI.7966>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 800d950:	b500      	push	{lr}
 800d952:	b083      	sub	sp, #12
 800d954:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800d956:	f001 ff93 	bl	800f880 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 800d95a:	9b01      	ldr	r3, [sp, #4]
 800d95c:	689b      	ldr	r3, [r3, #8]
 800d95e:	2b00      	cmp	r3, #0
 800d960:	bf14      	ite	ne
 800d962:	2300      	movne	r3, #0
 800d964:	2301      	moveq	r3, #1
 800d966:	b2db      	uxtb	r3, r3
}
 800d968:	4618      	mov	r0, r3
 800d96a:	b003      	add	sp, #12
 800d96c:	f85d fb04 	ldr.w	pc, [sp], #4

0800d970 <chThdStart>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdStart(thread_t *tp) {
 800d970:	b500      	push	{lr}
 800d972:	b083      	sub	sp, #12
 800d974:	9001      	str	r0, [sp, #4]

  chSysLock();
 800d976:	f002 fdab 	bl	80104d0 <chSysLock.5400>
  tp = chThdStartI(tp);
 800d97a:	9801      	ldr	r0, [sp, #4]
 800d97c:	f002 fde8 	bl	8010550 <chThdStartI.5404>
 800d980:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800d982:	f002 fdad 	bl	80104e0 <chSysUnlock.5402>

  return tp;
 800d986:	9b01      	ldr	r3, [sp, #4]
}
 800d988:	4618      	mov	r0, r3
 800d98a:	b003      	add	sp, #12
 800d98c:	f85d fb04 	ldr.w	pc, [sp], #4

0800d990 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 800d990:	b500      	push	{lr}
 800d992:	b085      	sub	sp, #20
 800d994:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
 800d996:	9b01      	ldr	r3, [sp, #4]
 800d998:	2b7f      	cmp	r3, #127	; 0x7f
 800d99a:	d905      	bls.n	800d9a8 <chThdSetPriority+0x18>
 800d99c:	f241 60c0 	movw	r0, #5824	; 0x16c0
 800d9a0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800d9a4:	f001 fcf4 	bl	800f390 <chSysHalt>

  chSysLock();
 800d9a8:	f002 fd92 	bl	80104d0 <chSysLock.5400>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 800d9ac:	f640 5350 	movw	r3, #3408	; 0xd50
 800d9b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9b4:	699b      	ldr	r3, [r3, #24]
 800d9b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d9b8:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 800d9ba:	f640 5350 	movw	r3, #3408	; 0xd50
 800d9be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9c2:	699b      	ldr	r3, [r3, #24]
 800d9c4:	689a      	ldr	r2, [r3, #8]
 800d9c6:	f640 5350 	movw	r3, #3408	; 0xd50
 800d9ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9ce:	699b      	ldr	r3, [r3, #24]
 800d9d0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d9d2:	429a      	cmp	r2, r3
 800d9d4:	d008      	beq.n	800d9e8 <chThdSetPriority+0x58>
 800d9d6:	f640 5350 	movw	r3, #3408	; 0xd50
 800d9da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9de:	699b      	ldr	r3, [r3, #24]
 800d9e0:	689a      	ldr	r2, [r3, #8]
 800d9e2:	9b01      	ldr	r3, [sp, #4]
 800d9e4:	429a      	cmp	r2, r3
 800d9e6:	d206      	bcs.n	800d9f6 <chThdSetPriority+0x66>
    currp->p_prio = newprio;
 800d9e8:	f640 5350 	movw	r3, #3408	; 0xd50
 800d9ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9f0:	699b      	ldr	r3, [r3, #24]
 800d9f2:	9a01      	ldr	r2, [sp, #4]
 800d9f4:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
 800d9f6:	f640 5350 	movw	r3, #3408	; 0xd50
 800d9fa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800d9fe:	699b      	ldr	r3, [r3, #24]
 800da00:	9a01      	ldr	r2, [sp, #4]
 800da02:	641a      	str	r2, [r3, #64]	; 0x40
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 800da04:	f002 fbac 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 800da08:	f002 fd6a 	bl	80104e0 <chSysUnlock.5402>

  return oldprio;
 800da0c:	9b03      	ldr	r3, [sp, #12]
}
 800da0e:	4618      	mov	r0, r3
 800da10:	b005      	add	sp, #20
 800da12:	f85d fb04 	ldr.w	pc, [sp], #4
 800da16:	bf00      	nop
 800da18:	f3af 8000 	nop.w
 800da1c:	f3af 8000 	nop.w

0800da20 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(thread_t *tp) {
 800da20:	b500      	push	{lr}
 800da22:	b083      	sub	sp, #12
 800da24:	9001      	str	r0, [sp, #4]

  chSysLock();
 800da26:	f002 fd53 	bl	80104d0 <chSysLock.5400>
  tp->p_flags |= CH_FLAG_TERMINATE;
 800da2a:	9b01      	ldr	r3, [sp, #4]
 800da2c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800da30:	f043 0304 	orr.w	r3, r3, #4
 800da34:	b2da      	uxtb	r2, r3
 800da36:	9b01      	ldr	r3, [sp, #4]
 800da38:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  chSysUnlock();
 800da3c:	f002 fd50 	bl	80104e0 <chSysUnlock.5402>
}
 800da40:	b003      	add	sp, #12
 800da42:	f85d fb04 	ldr.w	pc, [sp], #4
 800da46:	bf00      	nop
 800da48:	f3af 8000 	nop.w
 800da4c:	f3af 8000 	nop.w

0800da50 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 800da50:	b500      	push	{lr}
 800da52:	b083      	sub	sp, #12
 800da54:	9001      	str	r0, [sp, #4]

  chSysLock();
 800da56:	f002 fd3b 	bl	80104d0 <chSysLock.5400>
  chThdSleepS(time);
 800da5a:	9801      	ldr	r0, [sp, #4]
 800da5c:	f002 fd90 	bl	8010580 <chThdSleepS.5411>
  chSysUnlock();
 800da60:	f002 fd3e 	bl	80104e0 <chSysUnlock.5402>
}
 800da64:	b003      	add	sp, #12
 800da66:	f85d fb04 	ldr.w	pc, [sp], #4
 800da6a:	bf00      	nop
 800da6c:	f3af 8000 	nop.w

0800da70 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 800da70:	b500      	push	{lr}
 800da72:	b083      	sub	sp, #12
 800da74:	9001      	str	r0, [sp, #4]

  chSysLock();
 800da76:	f002 fd2b 	bl	80104d0 <chSysLock.5400>
  time -= chVTGetSystemTimeX();
 800da7a:	f002 fd59 	bl	8010530 <chVTGetSystemTimeX.5391>
 800da7e:	4603      	mov	r3, r0
 800da80:	9a01      	ldr	r2, [sp, #4]
 800da82:	1ad3      	subs	r3, r2, r3
 800da84:	9301      	str	r3, [sp, #4]
  if (time > (systime_t)0) {
 800da86:	9b01      	ldr	r3, [sp, #4]
 800da88:	2b00      	cmp	r3, #0
 800da8a:	d002      	beq.n	800da92 <chThdSleepUntil+0x22>
    chThdSleepS(time);
 800da8c:	9801      	ldr	r0, [sp, #4]
 800da8e:	f002 fd77 	bl	8010580 <chThdSleepS.5411>
  }
  chSysUnlock();
 800da92:	f002 fd25 	bl	80104e0 <chSysUnlock.5402>
}
 800da96:	b003      	add	sp, #12
 800da98:	f85d fb04 	ldr.w	pc, [sp], #4
 800da9c:	f3af 8000 	nop.w

0800daa0 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 800daa0:	b508      	push	{r3, lr}

  chSysLock();
 800daa2:	f002 fd15 	bl	80104d0 <chSysLock.5400>
  chSchDoYieldS();
 800daa6:	f002 fd03 	bl	80104b0 <chSchDoYieldS.5416>
  chSysUnlock();
 800daaa:	f002 fd19 	bl	80104e0 <chSysUnlock.5402>
}
 800daae:	bd08      	pop	{r3, pc}

0800dab0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 800dab0:	b500      	push	{lr}
 800dab2:	b083      	sub	sp, #12
 800dab4:	9001      	str	r0, [sp, #4]

  chSysLock();
 800dab6:	f002 fd0b 	bl	80104d0 <chSysLock.5400>
  chThdExitS(msg);
 800daba:	9801      	ldr	r0, [sp, #4]
 800dabc:	f000 f808 	bl	800dad0 <chThdExitS>
  /* The thread never returns here.*/
}
 800dac0:	b003      	add	sp, #12
 800dac2:	f85d fb04 	ldr.w	pc, [sp], #4
 800dac6:	bf00      	nop
 800dac8:	f3af 8000 	nop.w
 800dacc:	f3af 8000 	nop.w

0800dad0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 800dad0:	b500      	push	{lr}
 800dad2:	b085      	sub	sp, #20
 800dad4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 800dad6:	f640 5350 	movw	r3, #3408	; 0xd50
 800dada:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dade:	699b      	ldr	r3, [r3, #24]
 800dae0:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 800dae2:	9b03      	ldr	r3, [sp, #12]
 800dae4:	9a01      	ldr	r2, [sp, #4]
 800dae6:	625a      	str	r2, [r3, #36]	; 0x24
 800dae8:	e008      	b.n	800dafc <chThdExitS+0x2c>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 800daea:	9b03      	ldr	r3, [sp, #12]
 800daec:	3328      	adds	r3, #40	; 0x28
 800daee:	4618      	mov	r0, r3
 800daf0:	f002 fc86 	bl	8010400 <list_remove.5381>
 800daf4:	4603      	mov	r3, r0
 800daf6:	4618      	mov	r0, r3
 800daf8:	f002 f9b2 	bl	800fe60 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800dafc:	9b03      	ldr	r3, [sp, #12]
 800dafe:	3328      	adds	r3, #40	; 0x28
 800db00:	4618      	mov	r0, r3
 800db02:	f002 fc3d 	bl	8010380 <list_notempty.5367>
 800db06:	4603      	mov	r3, r0
 800db08:	2b00      	cmp	r3, #0
 800db0a:	d1ee      	bne.n	800daea <chThdExitS+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 800db0c:	9b03      	ldr	r3, [sp, #12]
 800db0e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800db12:	f003 0303 	and.w	r3, r3, #3
 800db16:	2b00      	cmp	r3, #0
 800db18:	d109      	bne.n	800db2e <chThdExitS+0x5e>
    REG_REMOVE(tp);
 800db1a:	9b03      	ldr	r3, [sp, #12]
 800db1c:	695b      	ldr	r3, [r3, #20]
 800db1e:	9a03      	ldr	r2, [sp, #12]
 800db20:	6912      	ldr	r2, [r2, #16]
 800db22:	611a      	str	r2, [r3, #16]
 800db24:	9b03      	ldr	r3, [sp, #12]
 800db26:	691b      	ldr	r3, [r3, #16]
 800db28:	9a03      	ldr	r2, [sp, #12]
 800db2a:	6952      	ldr	r2, [r2, #20]
 800db2c:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800db2e:	200f      	movs	r0, #15
 800db30:	f002 f9de 	bl	800fef0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800db34:	f241 60f0 	movw	r0, #5872	; 0x16f0
 800db38:	f6c0 0001 	movt	r0, #2049	; 0x801
 800db3c:	f001 fc28 	bl	800f390 <chSysHalt>
}
 800db40:	b005      	add	sp, #20
 800db42:	f85d fb04 	ldr.w	pc, [sp], #4
 800db46:	bf00      	nop
 800db48:	f3af 8000 	nop.w
 800db4c:	f3af 8000 	nop.w

0800db50 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 800db50:	b500      	push	{lr}
 800db52:	b085      	sub	sp, #20
 800db54:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);
 800db56:	9b01      	ldr	r3, [sp, #4]
 800db58:	2b00      	cmp	r3, #0
 800db5a:	d105      	bne.n	800db68 <chThdWait+0x18>
 800db5c:	f241 7000 	movw	r0, #5888	; 0x1700
 800db60:	f6c0 0001 	movt	r0, #2049	; 0x801
 800db64:	f001 fc14 	bl	800f390 <chSysHalt>

  chSysLock();
 800db68:	f002 fcb2 	bl	80104d0 <chSysLock.5400>
  chDbgAssert(tp != currp, "waiting self");
 800db6c:	f640 5350 	movw	r3, #3408	; 0xd50
 800db70:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800db74:	699a      	ldr	r2, [r3, #24]
 800db76:	9b01      	ldr	r3, [sp, #4]
 800db78:	429a      	cmp	r2, r3
 800db7a:	d105      	bne.n	800db88 <chThdWait+0x38>
 800db7c:	f241 7000 	movw	r0, #5888	; 0x1700
 800db80:	f6c0 0001 	movt	r0, #2049	; 0x801
 800db84:	f001 fc04 	bl	800f390 <chSysHalt>
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
 800db88:	9b01      	ldr	r3, [sp, #4]
 800db8a:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800db8e:	2b00      	cmp	r3, #0
 800db90:	d105      	bne.n	800db9e <chThdWait+0x4e>
 800db92:	f241 7000 	movw	r0, #5888	; 0x1700
 800db96:	f6c0 0001 	movt	r0, #2049	; 0x801
 800db9a:	f001 fbf9 	bl	800f390 <chSysHalt>
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 800db9e:	9b01      	ldr	r3, [sp, #4]
 800dba0:	f893 3020 	ldrb.w	r3, [r3, #32]
 800dba4:	2b0f      	cmp	r3, #15
 800dba6:	d00d      	beq.n	800dbc4 <chThdWait+0x74>
    list_insert(currp, &tp->p_waiting);
 800dba8:	f640 5350 	movw	r3, #3408	; 0xd50
 800dbac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dbb0:	699a      	ldr	r2, [r3, #24]
 800dbb2:	9b01      	ldr	r3, [sp, #4]
 800dbb4:	3328      	adds	r3, #40	; 0x28
 800dbb6:	4610      	mov	r0, r2
 800dbb8:	4619      	mov	r1, r3
 800dbba:	f002 fc11 	bl	80103e0 <list_insert.5377>
    chSchGoSleepS(CH_STATE_WTEXIT);
 800dbbe:	2009      	movs	r0, #9
 800dbc0:	f002 f996 	bl	800fef0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 800dbc4:	9b01      	ldr	r3, [sp, #4]
 800dbc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800dbc8:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 800dbca:	f002 fc89 	bl	80104e0 <chSysUnlock.5402>

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 800dbce:	9801      	ldr	r0, [sp, #4]
 800dbd0:	f000 fa56 	bl	800e080 <chThdRelease>
#endif

  return msg;
 800dbd4:	9b03      	ldr	r3, [sp, #12]
}
 800dbd6:	4618      	mov	r0, r3
 800dbd8:	b005      	add	sp, #20
 800dbda:	f85d fb04 	ldr.w	pc, [sp], #4
 800dbde:	bf00      	nop

0800dbe0 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 800dbe0:	b500      	push	{lr}
 800dbe2:	b085      	sub	sp, #20
 800dbe4:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 800dbe6:	f002 fcab 	bl	8010540 <chThdGetSelfX.5398>
 800dbea:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 800dbec:	9b01      	ldr	r3, [sp, #4]
 800dbee:	681b      	ldr	r3, [r3, #0]
 800dbf0:	2b00      	cmp	r3, #0
 800dbf2:	d005      	beq.n	800dc00 <chThdSuspendS+0x20>
 800dbf4:	f241 7010 	movw	r0, #5904	; 0x1710
 800dbf8:	f6c0 0001 	movt	r0, #2049	; 0x801
 800dbfc:	f001 fbc8 	bl	800f390 <chSysHalt>

  *trp = tp;
 800dc00:	9b01      	ldr	r3, [sp, #4]
 800dc02:	9a03      	ldr	r2, [sp, #12]
 800dc04:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 800dc06:	9b03      	ldr	r3, [sp, #12]
 800dc08:	9a01      	ldr	r2, [sp, #4]
 800dc0a:	625a      	str	r2, [r3, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 800dc0c:	2003      	movs	r0, #3
 800dc0e:	f002 f96f 	bl	800fef0 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 800dc12:	f002 fc95 	bl	8010540 <chThdGetSelfX.5398>
 800dc16:	4603      	mov	r3, r0
 800dc18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800dc1a:	4618      	mov	r0, r3
 800dc1c:	b005      	add	sp, #20
 800dc1e:	f85d fb04 	ldr.w	pc, [sp], #4
 800dc22:	bf00      	nop
 800dc24:	f3af 8000 	nop.w
 800dc28:	f3af 8000 	nop.w
 800dc2c:	f3af 8000 	nop.w

0800dc30 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 800dc30:	b500      	push	{lr}
 800dc32:	b085      	sub	sp, #20
 800dc34:	9001      	str	r0, [sp, #4]
 800dc36:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 800dc38:	9b01      	ldr	r3, [sp, #4]
 800dc3a:	681b      	ldr	r3, [r3, #0]
 800dc3c:	2b00      	cmp	r3, #0
 800dc3e:	d016      	beq.n	800dc6e <chThdResumeI+0x3e>
    thread_t *tp = *trp;
 800dc40:	9b01      	ldr	r3, [sp, #4]
 800dc42:	681b      	ldr	r3, [r3, #0]
 800dc44:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
 800dc46:	9b03      	ldr	r3, [sp, #12]
 800dc48:	f893 3020 	ldrb.w	r3, [r3, #32]
 800dc4c:	2b03      	cmp	r3, #3
 800dc4e:	d005      	beq.n	800dc5c <chThdResumeI+0x2c>
 800dc50:	f241 7020 	movw	r0, #5920	; 0x1720
 800dc54:	f6c0 0001 	movt	r0, #2049	; 0x801
 800dc58:	f001 fb9a 	bl	800f390 <chSysHalt>
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 800dc5c:	9b01      	ldr	r3, [sp, #4]
 800dc5e:	2200      	movs	r2, #0
 800dc60:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 800dc62:	9b03      	ldr	r3, [sp, #12]
 800dc64:	9a00      	ldr	r2, [sp, #0]
 800dc66:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800dc68:	9803      	ldr	r0, [sp, #12]
 800dc6a:	f002 f8f9 	bl	800fe60 <chSchReadyI>
  }
}
 800dc6e:	b005      	add	sp, #20
 800dc70:	f85d fb04 	ldr.w	pc, [sp], #4
 800dc74:	f3af 8000 	nop.w
 800dc78:	f3af 8000 	nop.w
 800dc7c:	f3af 8000 	nop.w

0800dc80 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 800dc80:	b500      	push	{lr}
 800dc82:	b083      	sub	sp, #12
 800dc84:	9001      	str	r0, [sp, #4]
 800dc86:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 800dc88:	9b00      	ldr	r3, [sp, #0]
 800dc8a:	2b00      	cmp	r3, #0
 800dc8c:	d102      	bne.n	800dc94 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 800dc8e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800dc92:	e00d      	b.n	800dcb0 <chThdEnqueueTimeoutS+0x30>
  }

  queue_insert(currp, tqp);
 800dc94:	f640 5350 	movw	r3, #3408	; 0xd50
 800dc98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dc9c:	699b      	ldr	r3, [r3, #24]
 800dc9e:	4618      	mov	r0, r3
 800dca0:	9901      	ldr	r1, [sp, #4]
 800dca2:	f002 fbbd 	bl	8010420 <queue_insert.5384>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800dca6:	2004      	movs	r0, #4
 800dca8:	9900      	ldr	r1, [sp, #0]
 800dcaa:	f002 f9b1 	bl	8010010 <chSchGoSleepTimeoutS>
 800dcae:	4603      	mov	r3, r0
}
 800dcb0:	4618      	mov	r0, r3
 800dcb2:	b003      	add	sp, #12
 800dcb4:	f85d fb04 	ldr.w	pc, [sp], #4
 800dcb8:	f3af 8000 	nop.w
 800dcbc:	f3af 8000 	nop.w

0800dcc0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 800dcc0:	b500      	push	{lr}
 800dcc2:	b083      	sub	sp, #12
 800dcc4:	9001      	str	r0, [sp, #4]
 800dcc6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 800dcc8:	9801      	ldr	r0, [sp, #4]
 800dcca:	f002 fb79 	bl	80103c0 <queue_notempty.5374>
 800dcce:	4603      	mov	r3, r0
 800dcd0:	2b00      	cmp	r3, #0
 800dcd2:	d003      	beq.n	800dcdc <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 800dcd4:	9801      	ldr	r0, [sp, #4]
 800dcd6:	9900      	ldr	r1, [sp, #0]
 800dcd8:	f002 fc6a 	bl	80105b0 <chThdDoDequeueNextI.5407>
  }
}
 800dcdc:	b003      	add	sp, #12
 800dcde:	f85d fb04 	ldr.w	pc, [sp], #4
 800dce2:	bf00      	nop
 800dce4:	f3af 8000 	nop.w
 800dce8:	f3af 8000 	nop.w
 800dcec:	f3af 8000 	nop.w

0800dcf0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 800dcf0:	b500      	push	{lr}
 800dcf2:	b083      	sub	sp, #12
 800dcf4:	9001      	str	r0, [sp, #4]
 800dcf6:	9100      	str	r1, [sp, #0]
 800dcf8:	e003      	b.n	800dd02 <chThdDequeueAllI+0x12>

  while (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
 800dcfa:	9801      	ldr	r0, [sp, #4]
 800dcfc:	9900      	ldr	r1, [sp, #0]
 800dcfe:	f002 fc57 	bl	80105b0 <chThdDoDequeueNextI.5407>
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 800dd02:	9801      	ldr	r0, [sp, #4]
 800dd04:	f002 fb5c 	bl	80103c0 <queue_notempty.5374>
 800dd08:	4603      	mov	r3, r0
 800dd0a:	2b00      	cmp	r3, #0
 800dd0c:	d1f5      	bne.n	800dcfa <chThdDequeueAllI+0xa>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800dd0e:	b003      	add	sp, #12
 800dd10:	f85d fb04 	ldr.w	pc, [sp], #4
 800dd14:	f3af 8000 	nop.w
 800dd18:	f3af 8000 	nop.w
 800dd1c:	f3af 8000 	nop.w

0800dd20 <port_rt_get_counter_value.5636.4326>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 800dd20:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800dd24:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800dd28:	685b      	ldr	r3, [r3, #4]
}
 800dd2a:	4618      	mov	r0, r3
 800dd2c:	4770      	bx	lr
 800dd2e:	bf00      	nop

0800dd30 <tm_stop.5642.4321>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 800dd30:	b084      	sub	sp, #16
 800dd32:	9003      	str	r0, [sp, #12]
 800dd34:	9102      	str	r1, [sp, #8]
 800dd36:	9201      	str	r2, [sp, #4]

  tmp->n++;
 800dd38:	9b03      	ldr	r3, [sp, #12]
 800dd3a:	68db      	ldr	r3, [r3, #12]
 800dd3c:	1c5a      	adds	r2, r3, #1
 800dd3e:	9b03      	ldr	r3, [sp, #12]
 800dd40:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 800dd42:	9b03      	ldr	r3, [sp, #12]
 800dd44:	689b      	ldr	r3, [r3, #8]
 800dd46:	9a02      	ldr	r2, [sp, #8]
 800dd48:	1ad2      	subs	r2, r2, r3
 800dd4a:	9b01      	ldr	r3, [sp, #4]
 800dd4c:	1ad2      	subs	r2, r2, r3
 800dd4e:	9b03      	ldr	r3, [sp, #12]
 800dd50:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 800dd52:	9b03      	ldr	r3, [sp, #12]
 800dd54:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800dd58:	9b03      	ldr	r3, [sp, #12]
 800dd5a:	689b      	ldr	r3, [r3, #8]
 800dd5c:	461a      	mov	r2, r3
 800dd5e:	f04f 0300 	mov.w	r3, #0
 800dd62:	1812      	adds	r2, r2, r0
 800dd64:	eb43 0301 	adc.w	r3, r3, r1
 800dd68:	9903      	ldr	r1, [sp, #12]
 800dd6a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  if (tmp->last > tmp->worst) {
 800dd6e:	9b03      	ldr	r3, [sp, #12]
 800dd70:	689a      	ldr	r2, [r3, #8]
 800dd72:	9b03      	ldr	r3, [sp, #12]
 800dd74:	685b      	ldr	r3, [r3, #4]
 800dd76:	429a      	cmp	r2, r3
 800dd78:	d903      	bls.n	800dd82 <tm_stop.5642.4321+0x52>
    tmp->worst = tmp->last;
 800dd7a:	9b03      	ldr	r3, [sp, #12]
 800dd7c:	689a      	ldr	r2, [r3, #8]
 800dd7e:	9b03      	ldr	r3, [sp, #12]
 800dd80:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 800dd82:	9b03      	ldr	r3, [sp, #12]
 800dd84:	689a      	ldr	r2, [r3, #8]
 800dd86:	9b03      	ldr	r3, [sp, #12]
 800dd88:	681b      	ldr	r3, [r3, #0]
 800dd8a:	429a      	cmp	r2, r3
 800dd8c:	d203      	bcs.n	800dd96 <tm_stop.5642.4321+0x66>
    tmp->best = tmp->last;
 800dd8e:	9b03      	ldr	r3, [sp, #12]
 800dd90:	689a      	ldr	r2, [r3, #8]
 800dd92:	9b03      	ldr	r3, [sp, #12]
 800dd94:	601a      	str	r2, [r3, #0]
  }
}
 800dd96:	b004      	add	sp, #16
 800dd98:	4770      	bx	lr
 800dd9a:	bf00      	nop
 800dd9c:	f3af 8000 	nop.w

0800dda0 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 800dda0:	b500      	push	{lr}
 800dda2:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 800dda4:	f640 5350 	movw	r3, #3408	; 0xd50
 800dda8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ddac:	2200      	movs	r2, #0
 800ddae:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
  chTMObjectInit(&tm);
 800ddb2:	466b      	mov	r3, sp
 800ddb4:	4618      	mov	r0, r3
 800ddb6:	f000 f813 	bl	800dde0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 800ddba:	466b      	mov	r3, sp
 800ddbc:	4618      	mov	r0, r3
 800ddbe:	f000 f827 	bl	800de10 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800ddc2:	466b      	mov	r3, sp
 800ddc4:	4618      	mov	r0, r3
 800ddc6:	f000 f833 	bl	800de30 <chTMStopMeasurementX.4310>
  ch.tm.offset = tm.last;
 800ddca:	9a02      	ldr	r2, [sp, #8]
 800ddcc:	f640 5350 	movw	r3, #3408	; 0xd50
 800ddd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ddd4:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
}
 800ddd8:	b007      	add	sp, #28
 800ddda:	f85d fb04 	ldr.w	pc, [sp], #4
 800ddde:	bf00      	nop

0800dde0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 800dde0:	b082      	sub	sp, #8
 800dde2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 800dde4:	9b01      	ldr	r3, [sp, #4]
 800dde6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800ddea:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 800ddec:	9b01      	ldr	r3, [sp, #4]
 800ddee:	2200      	movs	r2, #0
 800ddf0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 800ddf2:	9b01      	ldr	r3, [sp, #4]
 800ddf4:	2200      	movs	r2, #0
 800ddf6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 800ddf8:	9b01      	ldr	r3, [sp, #4]
 800ddfa:	2200      	movs	r2, #0
 800ddfc:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 800ddfe:	9901      	ldr	r1, [sp, #4]
 800de00:	f04f 0200 	mov.w	r2, #0
 800de04:	f04f 0300 	mov.w	r3, #0
 800de08:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 800de0c:	b002      	add	sp, #8
 800de0e:	4770      	bx	lr

0800de10 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 800de10:	b500      	push	{lr}
 800de12:	b083      	sub	sp, #12
 800de14:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 800de16:	f7ff ff83 	bl	800dd20 <port_rt_get_counter_value.5636.4326>
 800de1a:	4602      	mov	r2, r0
 800de1c:	9b01      	ldr	r3, [sp, #4]
 800de1e:	609a      	str	r2, [r3, #8]
}
 800de20:	b003      	add	sp, #12
 800de22:	f85d fb04 	ldr.w	pc, [sp], #4
 800de26:	bf00      	nop
 800de28:	f3af 8000 	nop.w
 800de2c:	f3af 8000 	nop.w

0800de30 <chTMStopMeasurementX.4310>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800de30:	b500      	push	{lr}
 800de32:	b083      	sub	sp, #12
 800de34:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800de36:	f7ff ff73 	bl	800dd20 <port_rt_get_counter_value.5636.4326>
 800de3a:	4602      	mov	r2, r0
 800de3c:	f640 5350 	movw	r3, #3408	; 0xd50
 800de40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800de44:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 800de48:	9801      	ldr	r0, [sp, #4]
 800de4a:	4611      	mov	r1, r2
 800de4c:	461a      	mov	r2, r3
 800de4e:	f7ff ff6f 	bl	800dd30 <tm_stop.5642.4321>
}
 800de52:	b003      	add	sp, #12
 800de54:	f85d fb04 	ldr.w	pc, [sp], #4
 800de58:	f3af 8000 	nop.w
 800de5c:	f3af 8000 	nop.w

0800de60 <chTMChainMeasurementToX.4305>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 800de60:	b500      	push	{lr}
 800de62:	b083      	sub	sp, #12
 800de64:	9001      	str	r0, [sp, #4]
 800de66:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 800de68:	f7ff ff5a 	bl	800dd20 <port_rt_get_counter_value.5636.4326>
 800de6c:	4602      	mov	r2, r0
 800de6e:	9b00      	ldr	r3, [sp, #0]
 800de70:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
 800de72:	9b00      	ldr	r3, [sp, #0]
 800de74:	689b      	ldr	r3, [r3, #8]
 800de76:	9801      	ldr	r0, [sp, #4]
 800de78:	4619      	mov	r1, r3
 800de7a:	2200      	movs	r2, #0
 800de7c:	f7ff ff58 	bl	800dd30 <tm_stop.5642.4321>
}
 800de80:	b003      	add	sp, #12
 800de82:	f85d fb04 	ldr.w	pc, [sp], #4
 800de86:	bf00      	nop
 800de88:	f3af 8000 	nop.w
 800de8c:	f3af 8000 	nop.w

0800de90 <port_lock.5830.4303>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800de90:	b082      	sub	sp, #8
 800de92:	2320      	movs	r3, #32
 800de94:	9301      	str	r3, [sp, #4]
 800de96:	9b01      	ldr	r3, [sp, #4]
 800de98:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800de9c:	b002      	add	sp, #8
 800de9e:	4770      	bx	lr

0800dea0 <port_unlock.5833.4301>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800dea0:	b082      	sub	sp, #8
 800dea2:	2300      	movs	r3, #0
 800dea4:	9301      	str	r3, [sp, #4]
 800dea6:	9b01      	ldr	r3, [sp, #4]
 800dea8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800deac:	b002      	add	sp, #8
 800deae:	4770      	bx	lr

0800deb0 <port_lock_from_isr.5835.4299>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800deb0:	b508      	push	{r3, lr}

  port_lock();
 800deb2:	f7ff ffed 	bl	800de90 <port_lock.5830.4303>
}
 800deb6:	bd08      	pop	{r3, pc}
 800deb8:	f3af 8000 	nop.w
 800debc:	f3af 8000 	nop.w

0800dec0 <port_unlock_from_isr.5837.4297>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800dec0:	b508      	push	{r3, lr}

  port_unlock();
 800dec2:	f7ff ffed 	bl	800dea0 <port_unlock.5833.4301>
}
 800dec6:	bd08      	pop	{r3, pc}
 800dec8:	f3af 8000 	nop.w
 800decc:	f3af 8000 	nop.w

0800ded0 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
 800ded0:	b508      	push	{r3, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
 800ded2:	f640 5350 	movw	r3, #3408	; 0xd50
 800ded6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800deda:	2200      	movs	r2, #0
 800dedc:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
 800dee0:	f640 5350 	movw	r3, #3408	; 0xd50
 800dee4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800dee8:	2200      	movs	r2, #0
 800deea:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
 800deee:	4803      	ldr	r0, [pc, #12]	; (800defc <_stats_init+0x2c>)
 800def0:	f7ff ff76 	bl	800dde0 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
 800def4:	4802      	ldr	r0, [pc, #8]	; (800df00 <_stats_init+0x30>)
 800def6:	f7ff ff73 	bl	800dde0 <chTMObjectInit>
}
 800defa:	bd08      	pop	{r3, pc}
 800defc:	20001200 	.word	0x20001200
 800df00:	20001218 	.word	0x20001218
 800df04:	f3af 8000 	nop.w
 800df08:	f3af 8000 	nop.w
 800df0c:	f3af 8000 	nop.w

0800df10 <_stats_increase_irq>:

/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {
 800df10:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800df12:	f7ff ffcd 	bl	800deb0 <port_lock_from_isr.5835.4299>
  ch.kernel_stats.n_irq++;
 800df16:	f640 5350 	movw	r3, #3408	; 0xd50
 800df1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800df1e:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
 800df22:	1c5a      	adds	r2, r3, #1
 800df24:	f640 5350 	movw	r3, #3408	; 0xd50
 800df28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800df2c:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  port_unlock_from_isr();
 800df30:	f7ff ffc6 	bl	800dec0 <port_unlock_from_isr.5837.4297>
}
 800df34:	bd08      	pop	{r3, pc}
 800df36:	bf00      	nop
 800df38:	f3af 8000 	nop.w
 800df3c:	f3af 8000 	nop.w

0800df40 <_stats_ctxswc>:
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
 800df40:	b500      	push	{lr}
 800df42:	b083      	sub	sp, #12
 800df44:	9001      	str	r0, [sp, #4]
 800df46:	9100      	str	r1, [sp, #0]

  ch.kernel_stats.n_ctxswc++;
 800df48:	f640 5350 	movw	r3, #3408	; 0xd50
 800df4c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800df50:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 800df54:	1c5a      	adds	r2, r3, #1
 800df56:	f640 5350 	movw	r3, #3408	; 0xd50
 800df5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800df5e:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 800df62:	9b00      	ldr	r3, [sp, #0]
 800df64:	f103 0248 	add.w	r2, r3, #72	; 0x48
 800df68:	9b01      	ldr	r3, [sp, #4]
 800df6a:	3348      	adds	r3, #72	; 0x48
 800df6c:	4610      	mov	r0, r2
 800df6e:	4619      	mov	r1, r3
 800df70:	f7ff ff76 	bl	800de60 <chTMChainMeasurementToX.4305>
}
 800df74:	b003      	add	sp, #12
 800df76:	f85d fb04 	ldr.w	pc, [sp], #4
 800df7a:	bf00      	nop
 800df7c:	f3af 8000 	nop.w

0800df80 <_stats_start_measure_crit_thd>:

/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {
 800df80:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
 800df82:	4802      	ldr	r0, [pc, #8]	; (800df8c <_stats_start_measure_crit_thd+0xc>)
 800df84:	f7ff ff44 	bl	800de10 <chTMStartMeasurementX>
}
 800df88:	bd08      	pop	{r3, pc}
 800df8a:	bf00      	nop
 800df8c:	20001200 	.word	0x20001200

0800df90 <_stats_stop_measure_crit_thd>:

/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {
 800df90:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
 800df92:	4802      	ldr	r0, [pc, #8]	; (800df9c <_stats_stop_measure_crit_thd+0xc>)
 800df94:	f7ff ff4c 	bl	800de30 <chTMStopMeasurementX.4310>
}
 800df98:	bd08      	pop	{r3, pc}
 800df9a:	bf00      	nop
 800df9c:	20001200 	.word	0x20001200

0800dfa0 <_stats_start_measure_crit_isr>:

/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {
 800dfa0:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
 800dfa2:	4802      	ldr	r0, [pc, #8]	; (800dfac <_stats_start_measure_crit_isr+0xc>)
 800dfa4:	f7ff ff34 	bl	800de10 <chTMStartMeasurementX>
}
 800dfa8:	bd08      	pop	{r3, pc}
 800dfaa:	bf00      	nop
 800dfac:	20001218 	.word	0x20001218

0800dfb0 <_stats_stop_measure_crit_isr>:

/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {
 800dfb0:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
 800dfb2:	4802      	ldr	r0, [pc, #8]	; (800dfbc <_stats_stop_measure_crit_isr+0xc>)
 800dfb4:	f7ff ff3c 	bl	800de30 <chTMStopMeasurementX.4310>
}
 800dfb8:	bd08      	pop	{r3, pc}
 800dfba:	bf00      	nop
 800dfbc:	20001218 	.word	0x20001218

0800dfc0 <port_lock.6007.4278>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800dfc0:	b082      	sub	sp, #8
 800dfc2:	2320      	movs	r3, #32
 800dfc4:	9301      	str	r3, [sp, #4]
 800dfc6:	9b01      	ldr	r3, [sp, #4]
 800dfc8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800dfcc:	b002      	add	sp, #8
 800dfce:	4770      	bx	lr

0800dfd0 <port_unlock.6010.4276>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800dfd0:	b082      	sub	sp, #8
 800dfd2:	2300      	movs	r3, #0
 800dfd4:	9301      	str	r3, [sp, #4]
 800dfd6:	9b01      	ldr	r3, [sp, #4]
 800dfd8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800dfdc:	b002      	add	sp, #8
 800dfde:	4770      	bx	lr

0800dfe0 <chSysLock.6012.4274>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800dfe0:	b508      	push	{r3, lr}

  port_lock();
 800dfe2:	f7ff ffed 	bl	800dfc0 <port_lock.6007.4278>
  _stats_start_measure_crit_thd();
 800dfe6:	f7ff ffcb 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800dfea:	f001 fb79 	bl	800f6e0 <_dbg_check_lock>
}
 800dfee:	bd08      	pop	{r3, pc}

0800dff0 <chSysUnlock.6014.4272>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800dff0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800dff2:	f001 fb95 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800dff6:	f7ff ffcb 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800dffa:	f640 5350 	movw	r3, #3408	; 0xd50
 800dffe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e002:	681a      	ldr	r2, [r3, #0]
 800e004:	f640 5350 	movw	r3, #3408	; 0xd50
 800e008:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e00c:	429a      	cmp	r2, r3
 800e00e:	d013      	beq.n	800e038 <chSysUnlock.6014.4272+0x48>
 800e010:	f640 5350 	movw	r3, #3408	; 0xd50
 800e014:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e018:	699b      	ldr	r3, [r3, #24]
 800e01a:	689a      	ldr	r2, [r3, #8]
 800e01c:	f640 5350 	movw	r3, #3408	; 0xd50
 800e020:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e024:	681b      	ldr	r3, [r3, #0]
 800e026:	689b      	ldr	r3, [r3, #8]
 800e028:	429a      	cmp	r2, r3
 800e02a:	d205      	bcs.n	800e038 <chSysUnlock.6014.4272+0x48>
 800e02c:	f241 7060 	movw	r0, #5984	; 0x1760
 800e030:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e034:	f001 f9ac 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800e038:	f7ff ffca 	bl	800dfd0 <port_unlock.6010.4276>
}
 800e03c:	bd08      	pop	{r3, pc}
 800e03e:	bf00      	nop

0800e040 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
thread_t *chThdAddRef(thread_t *tp) {
 800e040:	b500      	push	{lr}
 800e042:	b083      	sub	sp, #12
 800e044:	9001      	str	r0, [sp, #4]

  chSysLock();
 800e046:	f7ff ffcb 	bl	800dfe0 <chSysLock.6012.4274>
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
 800e04a:	9b01      	ldr	r3, [sp, #4]
 800e04c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800e050:	2bff      	cmp	r3, #255	; 0xff
 800e052:	d105      	bne.n	800e060 <chThdAddRef+0x20>
 800e054:	f241 7050 	movw	r0, #5968	; 0x1750
 800e058:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e05c:	f001 f998 	bl	800f390 <chSysHalt>
  tp->p_refs++;
 800e060:	9b01      	ldr	r3, [sp, #4]
 800e062:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800e066:	3301      	adds	r3, #1
 800e068:	b2da      	uxtb	r2, r3
 800e06a:	9b01      	ldr	r3, [sp, #4]
 800e06c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  chSysUnlock();
 800e070:	f7ff ffbe 	bl	800dff0 <chSysUnlock.6014.4272>

  return tp;
 800e074:	9b01      	ldr	r3, [sp, #4]
}
 800e076:	4618      	mov	r0, r3
 800e078:	b003      	add	sp, #12
 800e07a:	f85d fb04 	ldr.w	pc, [sp], #4
 800e07e:	bf00      	nop

0800e080 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 800e080:	b500      	push	{lr}
 800e082:	b085      	sub	sp, #20
 800e084:	9001      	str	r0, [sp, #4]
  trefs_t refs;

  chSysLock();
 800e086:	f7ff ffab 	bl	800dfe0 <chSysLock.6012.4274>
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
 800e08a:	9b01      	ldr	r3, [sp, #4]
 800e08c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800e090:	2b00      	cmp	r3, #0
 800e092:	d105      	bne.n	800e0a0 <chThdRelease+0x20>
 800e094:	f241 7070 	movw	r0, #6000	; 0x1770
 800e098:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e09c:	f001 f978 	bl	800f390 <chSysHalt>
  tp->p_refs--;
 800e0a0:	9b01      	ldr	r3, [sp, #4]
 800e0a2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800e0a6:	3b01      	subs	r3, #1
 800e0a8:	b2da      	uxtb	r2, r3
 800e0aa:	9b01      	ldr	r3, [sp, #4]
 800e0ac:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  refs = tp->p_refs;
 800e0b0:	9b01      	ldr	r3, [sp, #4]
 800e0b2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800e0b6:	f88d 300f 	strb.w	r3, [sp, #15]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 800e0ba:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800e0be:	2b00      	cmp	r3, #0
 800e0c0:	d131      	bne.n	800e126 <chThdRelease+0xa6>
 800e0c2:	9b01      	ldr	r3, [sp, #4]
 800e0c4:	f893 3020 	ldrb.w	r3, [r3, #32]
 800e0c8:	2b0f      	cmp	r3, #15
 800e0ca:	d12c      	bne.n	800e126 <chThdRelease+0xa6>
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 800e0cc:	9b01      	ldr	r3, [sp, #4]
 800e0ce:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800e0d2:	f003 0303 	and.w	r3, r3, #3
 800e0d6:	2b01      	cmp	r3, #1
 800e0d8:	d002      	beq.n	800e0e0 <chThdRelease+0x60>
 800e0da:	2b02      	cmp	r3, #2
 800e0dc:	d010      	beq.n	800e100 <chThdRelease+0x80>
 800e0de:	e022      	b.n	800e126 <chThdRelease+0xa6>
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 800e0e0:	9b01      	ldr	r3, [sp, #4]
 800e0e2:	695b      	ldr	r3, [r3, #20]
 800e0e4:	9a01      	ldr	r2, [sp, #4]
 800e0e6:	6912      	ldr	r2, [r2, #16]
 800e0e8:	611a      	str	r2, [r3, #16]
 800e0ea:	9b01      	ldr	r3, [sp, #4]
 800e0ec:	691b      	ldr	r3, [r3, #16]
 800e0ee:	9a01      	ldr	r2, [sp, #4]
 800e0f0:	6952      	ldr	r2, [r2, #20]
 800e0f2:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 800e0f4:	f7ff ff7c 	bl	800dff0 <chSysUnlock.6014.4272>
      chHeapFree(tp);
 800e0f8:	9801      	ldr	r0, [sp, #4]
 800e0fa:	f7fd fa89 	bl	800b610 <chHeapFree>
 800e0fe:	e014      	b.n	800e12a <chThdRelease+0xaa>
      return;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 800e100:	9b01      	ldr	r3, [sp, #4]
 800e102:	695b      	ldr	r3, [r3, #20]
 800e104:	9a01      	ldr	r2, [sp, #4]
 800e106:	6912      	ldr	r2, [r2, #16]
 800e108:	611a      	str	r2, [r3, #16]
 800e10a:	9b01      	ldr	r3, [sp, #4]
 800e10c:	691b      	ldr	r3, [r3, #16]
 800e10e:	9a01      	ldr	r2, [sp, #4]
 800e110:	6952      	ldr	r2, [r2, #20]
 800e112:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 800e114:	f7ff ff6c 	bl	800dff0 <chSysUnlock.6014.4272>
      chPoolFree(tp->p_mpool, tp);
 800e118:	9b01      	ldr	r3, [sp, #4]
 800e11a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800e11c:	4618      	mov	r0, r3
 800e11e:	9901      	ldr	r1, [sp, #4]
 800e120:	f7fd fc2e 	bl	800b980 <chPoolFree>
 800e124:	e001      	b.n	800e12a <chThdRelease+0xaa>
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
  chSysUnlock();
 800e126:	f7ff ff63 	bl	800dff0 <chSysUnlock.6014.4272>
}
 800e12a:	b005      	add	sp, #20
 800e12c:	f85d fb04 	ldr.w	pc, [sp], #4

0800e130 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 800e130:	b500      	push	{lr}
 800e132:	b089      	sub	sp, #36	; 0x24
 800e134:	9005      	str	r0, [sp, #20]
 800e136:	9104      	str	r1, [sp, #16]
 800e138:	9203      	str	r2, [sp, #12]
 800e13a:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 800e13c:	9805      	ldr	r0, [sp, #20]
 800e13e:	9904      	ldr	r1, [sp, #16]
 800e140:	f7fd f9ee 	bl	800b520 <chHeapAlloc>
 800e144:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 800e146:	9b07      	ldr	r3, [sp, #28]
 800e148:	2b00      	cmp	r3, #0
 800e14a:	d101      	bne.n	800e150 <chThdCreateFromHeap+0x20>
    return NULL;
 800e14c:	2300      	movs	r3, #0
 800e14e:	e027      	b.n	800e1a0 <chThdCreateFromHeap+0x70>
  }

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 800e150:	9b07      	ldr	r3, [sp, #28]
 800e152:	3360      	adds	r3, #96	; 0x60
 800e154:	9807      	ldr	r0, [sp, #28]
 800e156:	4619      	mov	r1, r3
 800e158:	22ff      	movs	r2, #255	; 0xff
 800e15a:	f002 faa9 	bl	80106b0 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800e15e:	9b07      	ldr	r3, [sp, #28]
 800e160:	f103 0260 	add.w	r2, r3, #96	; 0x60
 800e164:	9907      	ldr	r1, [sp, #28]
 800e166:	9b04      	ldr	r3, [sp, #16]
 800e168:	440b      	add	r3, r1
 800e16a:	4610      	mov	r0, r2
 800e16c:	4619      	mov	r1, r3
 800e16e:	2255      	movs	r2, #85	; 0x55
 800e170:	f002 fa9e 	bl	80106b0 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800e174:	f7ff ff34 	bl	800dfe0 <chSysLock.6012.4274>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 800e178:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800e17a:	9300      	str	r3, [sp, #0]
 800e17c:	9807      	ldr	r0, [sp, #28]
 800e17e:	9904      	ldr	r1, [sp, #16]
 800e180:	9a03      	ldr	r2, [sp, #12]
 800e182:	9b02      	ldr	r3, [sp, #8]
 800e184:	f002 faac 	bl	80106e0 <chThdCreateI>
 800e188:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_HEAP;
 800e18a:	9b06      	ldr	r3, [sp, #24]
 800e18c:	2201      	movs	r2, #1
 800e18e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 800e192:	9806      	ldr	r0, [sp, #24]
 800e194:	2100      	movs	r1, #0
 800e196:	f001 ff7b 	bl	8010090 <chSchWakeupS>
  chSysUnlock();
 800e19a:	f7ff ff29 	bl	800dff0 <chSysUnlock.6014.4272>

  return tp;
 800e19e:	9b06      	ldr	r3, [sp, #24]
}
 800e1a0:	4618      	mov	r0, r3
 800e1a2:	b009      	add	sp, #36	; 0x24
 800e1a4:	f85d fb04 	ldr.w	pc, [sp], #4
 800e1a8:	f3af 8000 	nop.w
 800e1ac:	f3af 8000 	nop.w

0800e1b0 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
                                    tfunc_t pf, void *arg) {
 800e1b0:	b500      	push	{lr}
 800e1b2:	b089      	sub	sp, #36	; 0x24
 800e1b4:	9005      	str	r0, [sp, #20]
 800e1b6:	9104      	str	r1, [sp, #16]
 800e1b8:	9203      	str	r2, [sp, #12]
 800e1ba:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);
 800e1bc:	9b05      	ldr	r3, [sp, #20]
 800e1be:	2b00      	cmp	r3, #0
 800e1c0:	d105      	bne.n	800e1ce <chThdCreateFromMemoryPool+0x1e>
 800e1c2:	f241 7080 	movw	r0, #6016	; 0x1780
 800e1c6:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e1ca:	f001 f8e1 	bl	800f390 <chSysHalt>

  wsp = chPoolAlloc(mp);
 800e1ce:	9805      	ldr	r0, [sp, #20]
 800e1d0:	f7fd fba6 	bl	800b920 <chPoolAlloc>
 800e1d4:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 800e1d6:	9b07      	ldr	r3, [sp, #28]
 800e1d8:	2b00      	cmp	r3, #0
 800e1da:	d101      	bne.n	800e1e0 <chThdCreateFromMemoryPool+0x30>
    return NULL;
 800e1dc:	2300      	movs	r3, #0
 800e1de:	e02d      	b.n	800e23c <chThdCreateFromMemoryPool+0x8c>
  }

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 800e1e0:	9b07      	ldr	r3, [sp, #28]
 800e1e2:	3360      	adds	r3, #96	; 0x60
 800e1e4:	9807      	ldr	r0, [sp, #28]
 800e1e6:	4619      	mov	r1, r3
 800e1e8:	22ff      	movs	r2, #255	; 0xff
 800e1ea:	f002 fa61 	bl	80106b0 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800e1ee:	9b07      	ldr	r3, [sp, #28]
 800e1f0:	f103 0260 	add.w	r2, r3, #96	; 0x60
                  (uint8_t *)wsp + mp->mp_object_size,
 800e1f4:	9b05      	ldr	r3, [sp, #20]
 800e1f6:	685b      	ldr	r3, [r3, #4]

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800e1f8:	9907      	ldr	r1, [sp, #28]
 800e1fa:	440b      	add	r3, r1
 800e1fc:	4610      	mov	r0, r2
 800e1fe:	4619      	mov	r1, r3
 800e200:	2255      	movs	r2, #85	; 0x55
 800e202:	f002 fa55 	bl	80106b0 <_thread_memfill>
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800e206:	f7ff feeb 	bl	800dfe0 <chSysLock.6012.4274>
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 800e20a:	9b05      	ldr	r3, [sp, #20]
 800e20c:	685b      	ldr	r3, [r3, #4]
 800e20e:	9a02      	ldr	r2, [sp, #8]
 800e210:	9200      	str	r2, [sp, #0]
 800e212:	9807      	ldr	r0, [sp, #28]
 800e214:	4619      	mov	r1, r3
 800e216:	9a04      	ldr	r2, [sp, #16]
 800e218:	9b03      	ldr	r3, [sp, #12]
 800e21a:	f002 fa61 	bl	80106e0 <chThdCreateI>
 800e21e:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 800e220:	9b06      	ldr	r3, [sp, #24]
 800e222:	2202      	movs	r2, #2
 800e224:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  tp->p_mpool = mp;
 800e228:	9b06      	ldr	r3, [sp, #24]
 800e22a:	9a05      	ldr	r2, [sp, #20]
 800e22c:	645a      	str	r2, [r3, #68]	; 0x44
  chSchWakeupS(tp, MSG_OK);
 800e22e:	9806      	ldr	r0, [sp, #24]
 800e230:	2100      	movs	r1, #0
 800e232:	f001 ff2d 	bl	8010090 <chSchWakeupS>
  chSysUnlock();
 800e236:	f7ff fedb 	bl	800dff0 <chSysUnlock.6014.4272>

  return tp;
 800e23a:	9b06      	ldr	r3, [sp, #24]
}
 800e23c:	4618      	mov	r0, r3
 800e23e:	b009      	add	sp, #36	; 0x24
 800e240:	f85d fb04 	ldr.w	pc, [sp], #4
 800e244:	f3af 8000 	nop.w
 800e248:	f3af 8000 	nop.w
 800e24c:	f3af 8000 	nop.w

0800e250 <port_lock.6230.4226>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800e250:	b082      	sub	sp, #8
 800e252:	2320      	movs	r3, #32
 800e254:	9301      	str	r3, [sp, #4]
 800e256:	9b01      	ldr	r3, [sp, #4]
 800e258:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e25c:	b002      	add	sp, #8
 800e25e:	4770      	bx	lr

0800e260 <port_unlock.6233.4224>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800e260:	b082      	sub	sp, #8
 800e262:	2300      	movs	r3, #0
 800e264:	9301      	str	r3, [sp, #4]
 800e266:	9b01      	ldr	r3, [sp, #4]
 800e268:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e26c:	b002      	add	sp, #8
 800e26e:	4770      	bx	lr

0800e270 <chSysLock.6235.4222>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800e270:	b508      	push	{r3, lr}

  port_lock();
 800e272:	f7ff ffed 	bl	800e250 <port_lock.6230.4226>
  _stats_start_measure_crit_thd();
 800e276:	f7ff fe83 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800e27a:	f001 fa31 	bl	800f6e0 <_dbg_check_lock>
}
 800e27e:	bd08      	pop	{r3, pc}

0800e280 <chSysUnlock.6237.4220>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800e280:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800e282:	f001 fa4d 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800e286:	f7ff fe83 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800e28a:	f640 5350 	movw	r3, #3408	; 0xd50
 800e28e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e292:	681a      	ldr	r2, [r3, #0]
 800e294:	f640 5350 	movw	r3, #3408	; 0xd50
 800e298:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e29c:	429a      	cmp	r2, r3
 800e29e:	d013      	beq.n	800e2c8 <chSysUnlock.6237.4220+0x48>
 800e2a0:	f640 5350 	movw	r3, #3408	; 0xd50
 800e2a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e2a8:	699b      	ldr	r3, [r3, #24]
 800e2aa:	689a      	ldr	r2, [r3, #8]
 800e2ac:	f640 5350 	movw	r3, #3408	; 0xd50
 800e2b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e2b4:	681b      	ldr	r3, [r3, #0]
 800e2b6:	689b      	ldr	r3, [r3, #8]
 800e2b8:	429a      	cmp	r2, r3
 800e2ba:	d205      	bcs.n	800e2c8 <chSysUnlock.6237.4220+0x48>
 800e2bc:	f241 70c0 	movw	r0, #6080	; 0x17c0
 800e2c0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e2c4:	f001 f864 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800e2c8:	f7ff ffca 	bl	800e260 <port_unlock.6233.4224>
}
 800e2cc:	bd08      	pop	{r3, pc}
 800e2ce:	bf00      	nop

0800e2d0 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 800e2d0:	b500      	push	{lr}
 800e2d2:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 800e2d4:	f7ff ffcc 	bl	800e270 <chSysLock.6235.4222>
  tp = ch.rlist.r_newer;
 800e2d8:	f640 5350 	movw	r3, #3408	; 0xd50
 800e2dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e2e0:	691b      	ldr	r3, [r3, #16]
 800e2e2:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 800e2e4:	9b01      	ldr	r3, [sp, #4]
 800e2e6:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800e2ea:	3301      	adds	r3, #1
 800e2ec:	b2da      	uxtb	r2, r3
 800e2ee:	9b01      	ldr	r3, [sp, #4]
 800e2f0:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
  chSysUnlock();
 800e2f4:	f7ff ffc4 	bl	800e280 <chSysUnlock.6237.4220>

  return tp;
 800e2f8:	9b01      	ldr	r3, [sp, #4]
}
 800e2fa:	4618      	mov	r0, r3
 800e2fc:	b003      	add	sp, #12
 800e2fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800e302:	bf00      	nop
 800e304:	f3af 8000 	nop.w
 800e308:	f3af 8000 	nop.w
 800e30c:	f3af 8000 	nop.w

0800e310 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 800e310:	b500      	push	{lr}
 800e312:	b085      	sub	sp, #20
 800e314:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 800e316:	f7ff ffab 	bl	800e270 <chSysLock.6235.4222>
  ntp = tp->p_newer;
 800e31a:	9b01      	ldr	r3, [sp, #4]
 800e31c:	691b      	ldr	r3, [r3, #16]
 800e31e:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 800e320:	9a03      	ldr	r2, [sp, #12]
 800e322:	f640 5350 	movw	r3, #3408	; 0xd50
 800e326:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e32a:	429a      	cmp	r2, r3
 800e32c:	d102      	bne.n	800e334 <chRegNextThread+0x24>
  /*lint -restore*/
    ntp = NULL;
 800e32e:	2300      	movs	r3, #0
 800e330:	9303      	str	r3, [sp, #12]
 800e332:	e012      	b.n	800e35a <chRegNextThread+0x4a>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
 800e334:	9b03      	ldr	r3, [sp, #12]
 800e336:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800e33a:	2bff      	cmp	r3, #255	; 0xff
 800e33c:	d105      	bne.n	800e34a <chRegNextThread+0x3a>
 800e33e:	f241 70d0 	movw	r0, #6096	; 0x17d0
 800e342:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e346:	f001 f823 	bl	800f390 <chSysHalt>
    ntp->p_refs++;
 800e34a:	9b03      	ldr	r3, [sp, #12]
 800e34c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800e350:	3301      	adds	r3, #1
 800e352:	b2da      	uxtb	r2, r3
 800e354:	9b03      	ldr	r3, [sp, #12]
 800e356:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  }
#endif
  chSysUnlock();
 800e35a:	f7ff ff91 	bl	800e280 <chSysUnlock.6237.4220>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 800e35e:	9801      	ldr	r0, [sp, #4]
 800e360:	f7ff fe8e 	bl	800e080 <chThdRelease>
#endif

  return ntp;
 800e364:	9b03      	ldr	r3, [sp, #12]
}
 800e366:	4618      	mov	r0, r3
 800e368:	b005      	add	sp, #20
 800e36a:	f85d fb04 	ldr.w	pc, [sp], #4
 800e36e:	bf00      	nop

0800e370 <port_lock.6425.4212>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800e370:	b082      	sub	sp, #8
 800e372:	2320      	movs	r3, #32
 800e374:	9301      	str	r3, [sp, #4]
 800e376:	9b01      	ldr	r3, [sp, #4]
 800e378:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e37c:	b002      	add	sp, #8
 800e37e:	4770      	bx	lr

0800e380 <port_unlock.6428.4210>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800e380:	b082      	sub	sp, #8
 800e382:	2300      	movs	r3, #0
 800e384:	9301      	str	r3, [sp, #4]
 800e386:	9b01      	ldr	r3, [sp, #4]
 800e388:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e38c:	b002      	add	sp, #8
 800e38e:	4770      	bx	lr

0800e390 <queue_init.6430.4207>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800e390:	b082      	sub	sp, #8
 800e392:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800e394:	9b01      	ldr	r3, [sp, #4]
 800e396:	9a01      	ldr	r2, [sp, #4]
 800e398:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800e39a:	9b01      	ldr	r3, [sp, #4]
 800e39c:	9a01      	ldr	r2, [sp, #4]
 800e39e:	605a      	str	r2, [r3, #4]
}
 800e3a0:	b002      	add	sp, #8
 800e3a2:	4770      	bx	lr
 800e3a4:	f3af 8000 	nop.w
 800e3a8:	f3af 8000 	nop.w
 800e3ac:	f3af 8000 	nop.w

0800e3b0 <queue_isempty.6519.4204>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 800e3b0:	b082      	sub	sp, #8
 800e3b2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 800e3b4:	9b01      	ldr	r3, [sp, #4]
 800e3b6:	681a      	ldr	r2, [r3, #0]
 800e3b8:	9b01      	ldr	r3, [sp, #4]
 800e3ba:	429a      	cmp	r2, r3
 800e3bc:	bf14      	ite	ne
 800e3be:	2300      	movne	r3, #0
 800e3c0:	2301      	moveq	r3, #1
 800e3c2:	b2db      	uxtb	r3, r3
}
 800e3c4:	4618      	mov	r0, r3
 800e3c6:	b002      	add	sp, #8
 800e3c8:	4770      	bx	lr
 800e3ca:	bf00      	nop
 800e3cc:	f3af 8000 	nop.w

0800e3d0 <queue_notempty.6523.4201>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 800e3d0:	b082      	sub	sp, #8
 800e3d2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800e3d4:	9b01      	ldr	r3, [sp, #4]
 800e3d6:	681a      	ldr	r2, [r3, #0]
 800e3d8:	9b01      	ldr	r3, [sp, #4]
 800e3da:	429a      	cmp	r2, r3
 800e3dc:	bf0c      	ite	eq
 800e3de:	2300      	moveq	r3, #0
 800e3e0:	2301      	movne	r3, #1
 800e3e2:	b2db      	uxtb	r3, r3
}
 800e3e4:	4618      	mov	r0, r3
 800e3e6:	b002      	add	sp, #8
 800e3e8:	4770      	bx	lr
 800e3ea:	bf00      	nop
 800e3ec:	f3af 8000 	nop.w

0800e3f0 <queue_insert.6526.4197>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 800e3f0:	b082      	sub	sp, #8
 800e3f2:	9001      	str	r0, [sp, #4]
 800e3f4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 800e3f6:	9b01      	ldr	r3, [sp, #4]
 800e3f8:	9a00      	ldr	r2, [sp, #0]
 800e3fa:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 800e3fc:	9b00      	ldr	r3, [sp, #0]
 800e3fe:	685a      	ldr	r2, [r3, #4]
 800e400:	9b01      	ldr	r3, [sp, #4]
 800e402:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800e404:	9b01      	ldr	r3, [sp, #4]
 800e406:	685b      	ldr	r3, [r3, #4]
 800e408:	9a01      	ldr	r2, [sp, #4]
 800e40a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 800e40c:	9b00      	ldr	r3, [sp, #0]
 800e40e:	9a01      	ldr	r2, [sp, #4]
 800e410:	605a      	str	r2, [r3, #4]
}
 800e412:	b002      	add	sp, #8
 800e414:	4770      	bx	lr
 800e416:	bf00      	nop
 800e418:	f3af 8000 	nop.w
 800e41c:	f3af 8000 	nop.w

0800e420 <queue_fifo_remove.6530.4194>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800e420:	b084      	sub	sp, #16
 800e422:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 800e424:	9b01      	ldr	r3, [sp, #4]
 800e426:	681b      	ldr	r3, [r3, #0]
 800e428:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800e42a:	9b03      	ldr	r3, [sp, #12]
 800e42c:	681a      	ldr	r2, [r3, #0]
 800e42e:	9b01      	ldr	r3, [sp, #4]
 800e430:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800e432:	9b01      	ldr	r3, [sp, #4]
 800e434:	681b      	ldr	r3, [r3, #0]
 800e436:	9a01      	ldr	r2, [sp, #4]
 800e438:	605a      	str	r2, [r3, #4]

  return tp;
 800e43a:	9b03      	ldr	r3, [sp, #12]
}
 800e43c:	4618      	mov	r0, r3
 800e43e:	b004      	add	sp, #16
 800e440:	4770      	bx	lr
 800e442:	bf00      	nop
 800e444:	f3af 8000 	nop.w
 800e448:	f3af 8000 	nop.w
 800e44c:	f3af 8000 	nop.w

0800e450 <queue_lifo_remove.6533.4191>:

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
 800e450:	b084      	sub	sp, #16
 800e452:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_prev;
 800e454:	9b01      	ldr	r3, [sp, #4]
 800e456:	685b      	ldr	r3, [r3, #4]
 800e458:	9303      	str	r3, [sp, #12]

  tqp->p_prev = tp->p_prev;
 800e45a:	9b03      	ldr	r3, [sp, #12]
 800e45c:	685a      	ldr	r2, [r3, #4]
 800e45e:	9b01      	ldr	r3, [sp, #4]
 800e460:	605a      	str	r2, [r3, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 800e462:	9b01      	ldr	r3, [sp, #4]
 800e464:	685b      	ldr	r3, [r3, #4]
 800e466:	9a01      	ldr	r2, [sp, #4]
 800e468:	601a      	str	r2, [r3, #0]

  return tp;
 800e46a:	9b03      	ldr	r3, [sp, #12]
}
 800e46c:	4618      	mov	r0, r3
 800e46e:	b004      	add	sp, #16
 800e470:	4770      	bx	lr
 800e472:	bf00      	nop
 800e474:	f3af 8000 	nop.w
 800e478:	f3af 8000 	nop.w
 800e47c:	f3af 8000 	nop.w

0800e480 <chSysLock.6536.4189>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800e480:	b508      	push	{r3, lr}

  port_lock();
 800e482:	f7ff ff75 	bl	800e370 <port_lock.6425.4212>
  _stats_start_measure_crit_thd();
 800e486:	f7ff fd7b 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800e48a:	f001 f929 	bl	800f6e0 <_dbg_check_lock>
}
 800e48e:	bd08      	pop	{r3, pc}

0800e490 <chSysUnlock.6538.4187>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800e490:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800e492:	f001 f945 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800e496:	f7ff fd7b 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800e49a:	f640 5350 	movw	r3, #3408	; 0xd50
 800e49e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e4a2:	681a      	ldr	r2, [r3, #0]
 800e4a4:	f640 5350 	movw	r3, #3408	; 0xd50
 800e4a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e4ac:	429a      	cmp	r2, r3
 800e4ae:	d013      	beq.n	800e4d8 <chSysUnlock.6538.4187+0x48>
 800e4b0:	f640 5350 	movw	r3, #3408	; 0xd50
 800e4b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e4b8:	699b      	ldr	r3, [r3, #24]
 800e4ba:	689a      	ldr	r2, [r3, #8]
 800e4bc:	f640 5350 	movw	r3, #3408	; 0xd50
 800e4c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e4c4:	681b      	ldr	r3, [r3, #0]
 800e4c6:	689b      	ldr	r3, [r3, #8]
 800e4c8:	429a      	cmp	r2, r3
 800e4ca:	d205      	bcs.n	800e4d8 <chSysUnlock.6538.4187+0x48>
 800e4cc:	f241 70f0 	movw	r0, #6128	; 0x17f0
 800e4d0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e4d4:	f000 ff5c 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800e4d8:	f7ff ff52 	bl	800e380 <port_unlock.6428.4210>
}
 800e4dc:	bd08      	pop	{r3, pc}
 800e4de:	bf00      	nop

0800e4e0 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
 800e4e0:	b500      	push	{lr}
 800e4e2:	b083      	sub	sp, #12
 800e4e4:	9001      	str	r0, [sp, #4]
 800e4e6:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
 800e4e8:	9b01      	ldr	r3, [sp, #4]
 800e4ea:	2b00      	cmp	r3, #0
 800e4ec:	d002      	beq.n	800e4f4 <chSemObjectInit+0x14>
 800e4ee:	9b00      	ldr	r3, [sp, #0]
 800e4f0:	2b00      	cmp	r3, #0
 800e4f2:	da05      	bge.n	800e500 <chSemObjectInit+0x20>
 800e4f4:	f241 70e0 	movw	r0, #6112	; 0x17e0
 800e4f8:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e4fc:	f000 ff48 	bl	800f390 <chSysHalt>

  queue_init(&sp->s_queue);
 800e500:	9b01      	ldr	r3, [sp, #4]
 800e502:	4618      	mov	r0, r3
 800e504:	f7ff ff44 	bl	800e390 <queue_init.6430.4207>
  sp->s_cnt = n;
 800e508:	9b01      	ldr	r3, [sp, #4]
 800e50a:	9a00      	ldr	r2, [sp, #0]
 800e50c:	609a      	str	r2, [r3, #8]
}
 800e50e:	b003      	add	sp, #12
 800e510:	f85d fb04 	ldr.w	pc, [sp], #4
 800e514:	f3af 8000 	nop.w
 800e518:	f3af 8000 	nop.w
 800e51c:	f3af 8000 	nop.w

0800e520 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 800e520:	b500      	push	{lr}
 800e522:	b083      	sub	sp, #12
 800e524:	9001      	str	r0, [sp, #4]
 800e526:	9100      	str	r1, [sp, #0]

  chSysLock();
 800e528:	f7ff ffaa 	bl	800e480 <chSysLock.6536.4189>
  chSemResetI(sp, n);
 800e52c:	9801      	ldr	r0, [sp, #4]
 800e52e:	9900      	ldr	r1, [sp, #0]
 800e530:	f000 f80e 	bl	800e550 <chSemResetI>
  chSchRescheduleS();
 800e534:	f001 fe14 	bl	8010160 <chSchRescheduleS>
  chSysUnlock();
 800e538:	f7ff ffaa 	bl	800e490 <chSysUnlock.6538.4187>
}
 800e53c:	b003      	add	sp, #12
 800e53e:	f85d fb04 	ldr.w	pc, [sp], #4
 800e542:	bf00      	nop
 800e544:	f3af 8000 	nop.w
 800e548:	f3af 8000 	nop.w
 800e54c:	f3af 8000 	nop.w

0800e550 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 800e550:	b500      	push	{lr}
 800e552:	b085      	sub	sp, #20
 800e554:	9001      	str	r0, [sp, #4]
 800e556:	9100      	str	r1, [sp, #0]
  cnt_t cnt;

  chDbgCheckClassI();
 800e558:	f001 f992 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
 800e55c:	9b01      	ldr	r3, [sp, #4]
 800e55e:	2b00      	cmp	r3, #0
 800e560:	d002      	beq.n	800e568 <chSemResetI+0x18>
 800e562:	9b00      	ldr	r3, [sp, #0]
 800e564:	2b00      	cmp	r3, #0
 800e566:	da05      	bge.n	800e574 <chSemResetI+0x24>
 800e568:	f641 0000 	movw	r0, #6144	; 0x1800
 800e56c:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e570:	f000 ff0e 	bl	800f390 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800e574:	9b01      	ldr	r3, [sp, #4]
 800e576:	689b      	ldr	r3, [r3, #8]
 800e578:	2b00      	cmp	r3, #0
 800e57a:	db09      	blt.n	800e590 <chSemResetI+0x40>
 800e57c:	9b01      	ldr	r3, [sp, #4]
 800e57e:	4618      	mov	r0, r3
 800e580:	f7ff ff16 	bl	800e3b0 <queue_isempty.6519.4204>
 800e584:	4603      	mov	r3, r0
 800e586:	f083 0301 	eor.w	r3, r3, #1
 800e58a:	b2db      	uxtb	r3, r3
 800e58c:	2b00      	cmp	r3, #0
 800e58e:	d013      	beq.n	800e5b8 <chSemResetI+0x68>
 800e590:	9b01      	ldr	r3, [sp, #4]
 800e592:	689b      	ldr	r3, [r3, #8]
 800e594:	2b00      	cmp	r3, #0
 800e596:	da09      	bge.n	800e5ac <chSemResetI+0x5c>
 800e598:	9b01      	ldr	r3, [sp, #4]
 800e59a:	4618      	mov	r0, r3
 800e59c:	f7ff ff18 	bl	800e3d0 <queue_notempty.6523.4201>
 800e5a0:	4603      	mov	r3, r0
 800e5a2:	f083 0301 	eor.w	r3, r3, #1
 800e5a6:	b2db      	uxtb	r3, r3
 800e5a8:	2b00      	cmp	r3, #0
 800e5aa:	d005      	beq.n	800e5b8 <chSemResetI+0x68>
 800e5ac:	f641 0000 	movw	r0, #6144	; 0x1800
 800e5b0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e5b4:	f000 feec 	bl	800f390 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 800e5b8:	9b01      	ldr	r3, [sp, #4]
 800e5ba:	689b      	ldr	r3, [r3, #8]
 800e5bc:	9303      	str	r3, [sp, #12]
  sp->s_cnt = n;
 800e5be:	9b01      	ldr	r3, [sp, #4]
 800e5c0:	9a00      	ldr	r2, [sp, #0]
 800e5c2:	609a      	str	r2, [r3, #8]
 800e5c4:	e00b      	b.n	800e5de <chSemResetI+0x8e>
  while (++cnt <= (cnt_t)0) {
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 800e5c6:	9b01      	ldr	r3, [sp, #4]
 800e5c8:	4618      	mov	r0, r3
 800e5ca:	f7ff ff41 	bl	800e450 <queue_lifo_remove.6533.4191>
 800e5ce:	4603      	mov	r3, r0
 800e5d0:	4618      	mov	r0, r3
 800e5d2:	f001 fc45 	bl	800fe60 <chSchReadyI>
 800e5d6:	4603      	mov	r3, r0
 800e5d8:	f06f 0201 	mvn.w	r2, #1
 800e5dc:	625a      	str	r2, [r3, #36]	; 0x24
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 800e5de:	9b03      	ldr	r3, [sp, #12]
 800e5e0:	3301      	adds	r3, #1
 800e5e2:	9303      	str	r3, [sp, #12]
 800e5e4:	9b03      	ldr	r3, [sp, #12]
 800e5e6:	2b00      	cmp	r3, #0
 800e5e8:	dded      	ble.n	800e5c6 <chSemResetI+0x76>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 800e5ea:	b005      	add	sp, #20
 800e5ec:	f85d fb04 	ldr.w	pc, [sp], #4

0800e5f0 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 800e5f0:	b500      	push	{lr}
 800e5f2:	b085      	sub	sp, #20
 800e5f4:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 800e5f6:	f7ff ff43 	bl	800e480 <chSysLock.6536.4189>
  msg = chSemWaitS(sp);
 800e5fa:	9801      	ldr	r0, [sp, #4]
 800e5fc:	f000 f808 	bl	800e610 <chSemWaitS.4169>
 800e600:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 800e602:	f7ff ff45 	bl	800e490 <chSysUnlock.6538.4187>

  return msg;
 800e606:	9b03      	ldr	r3, [sp, #12]
}
 800e608:	4618      	mov	r0, r3
 800e60a:	b005      	add	sp, #20
 800e60c:	f85d fb04 	ldr.w	pc, [sp], #4

0800e610 <chSemWaitS.4169>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(semaphore_t *sp) {
 800e610:	b500      	push	{lr}
 800e612:	b083      	sub	sp, #12
 800e614:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 800e616:	f001 f94b 	bl	800f8b0 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 800e61a:	9b01      	ldr	r3, [sp, #4]
 800e61c:	2b00      	cmp	r3, #0
 800e61e:	d105      	bne.n	800e62c <chSemWaitS.4169+0x1c>
 800e620:	f641 0010 	movw	r0, #6160	; 0x1810
 800e624:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e628:	f000 feb2 	bl	800f390 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800e62c:	9b01      	ldr	r3, [sp, #4]
 800e62e:	689b      	ldr	r3, [r3, #8]
 800e630:	2b00      	cmp	r3, #0
 800e632:	db09      	blt.n	800e648 <chSemWaitS.4169+0x38>
 800e634:	9b01      	ldr	r3, [sp, #4]
 800e636:	4618      	mov	r0, r3
 800e638:	f7ff feba 	bl	800e3b0 <queue_isempty.6519.4204>
 800e63c:	4603      	mov	r3, r0
 800e63e:	f083 0301 	eor.w	r3, r3, #1
 800e642:	b2db      	uxtb	r3, r3
 800e644:	2b00      	cmp	r3, #0
 800e646:	d013      	beq.n	800e670 <chSemWaitS.4169+0x60>
 800e648:	9b01      	ldr	r3, [sp, #4]
 800e64a:	689b      	ldr	r3, [r3, #8]
 800e64c:	2b00      	cmp	r3, #0
 800e64e:	da09      	bge.n	800e664 <chSemWaitS.4169+0x54>
 800e650:	9b01      	ldr	r3, [sp, #4]
 800e652:	4618      	mov	r0, r3
 800e654:	f7ff febc 	bl	800e3d0 <queue_notempty.6523.4201>
 800e658:	4603      	mov	r3, r0
 800e65a:	f083 0301 	eor.w	r3, r3, #1
 800e65e:	b2db      	uxtb	r3, r3
 800e660:	2b00      	cmp	r3, #0
 800e662:	d005      	beq.n	800e670 <chSemWaitS.4169+0x60>
 800e664:	f641 0010 	movw	r0, #6160	; 0x1810
 800e668:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e66c:	f000 fe90 	bl	800f390 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 800e670:	9b01      	ldr	r3, [sp, #4]
 800e672:	689b      	ldr	r3, [r3, #8]
 800e674:	1e5a      	subs	r2, r3, #1
 800e676:	9b01      	ldr	r3, [sp, #4]
 800e678:	609a      	str	r2, [r3, #8]
 800e67a:	9b01      	ldr	r3, [sp, #4]
 800e67c:	689b      	ldr	r3, [r3, #8]
 800e67e:	2b00      	cmp	r3, #0
 800e680:	da1a      	bge.n	800e6b8 <chSemWaitS.4169+0xa8>
    currp->p_u.wtsemp = sp;
 800e682:	f640 5350 	movw	r3, #3408	; 0xd50
 800e686:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e68a:	699b      	ldr	r3, [r3, #24]
 800e68c:	9a01      	ldr	r2, [sp, #4]
 800e68e:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->s_queue);
 800e690:	f640 5350 	movw	r3, #3408	; 0xd50
 800e694:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e698:	699a      	ldr	r2, [r3, #24]
 800e69a:	9b01      	ldr	r3, [sp, #4]
 800e69c:	4610      	mov	r0, r2
 800e69e:	4619      	mov	r1, r3
 800e6a0:	f7ff fea6 	bl	800e3f0 <queue_insert.6526.4197>
    chSchGoSleepS(CH_STATE_WTSEM);
 800e6a4:	2005      	movs	r0, #5
 800e6a6:	f001 fc23 	bl	800fef0 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 800e6aa:	f640 5350 	movw	r3, #3408	; 0xd50
 800e6ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e6b2:	699b      	ldr	r3, [r3, #24]
 800e6b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e6b6:	e000      	b.n	800e6ba <chSemWaitS.4169+0xaa>
  }

  return MSG_OK;
 800e6b8:	2300      	movs	r3, #0
}
 800e6ba:	4618      	mov	r0, r3
 800e6bc:	b003      	add	sp, #12
 800e6be:	f85d fb04 	ldr.w	pc, [sp], #4
 800e6c2:	bf00      	nop
 800e6c4:	f3af 8000 	nop.w
 800e6c8:	f3af 8000 	nop.w
 800e6cc:	f3af 8000 	nop.w

0800e6d0 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 800e6d0:	b500      	push	{lr}
 800e6d2:	b085      	sub	sp, #20
 800e6d4:	9001      	str	r0, [sp, #4]
 800e6d6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 800e6d8:	f7ff fed2 	bl	800e480 <chSysLock.6536.4189>
  msg = chSemWaitTimeoutS(sp, time);
 800e6dc:	9801      	ldr	r0, [sp, #4]
 800e6de:	9900      	ldr	r1, [sp, #0]
 800e6e0:	f000 f80e 	bl	800e700 <chSemWaitTimeoutS>
 800e6e4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 800e6e6:	f7ff fed3 	bl	800e490 <chSysUnlock.6538.4187>

  return msg;
 800e6ea:	9b03      	ldr	r3, [sp, #12]
}
 800e6ec:	4618      	mov	r0, r3
 800e6ee:	b005      	add	sp, #20
 800e6f0:	f85d fb04 	ldr.w	pc, [sp], #4
 800e6f4:	f3af 8000 	nop.w
 800e6f8:	f3af 8000 	nop.w
 800e6fc:	f3af 8000 	nop.w

0800e700 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 800e700:	b500      	push	{lr}
 800e702:	b083      	sub	sp, #12
 800e704:	9001      	str	r0, [sp, #4]
 800e706:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 800e708:	f001 f8d2 	bl	800f8b0 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 800e70c:	9b01      	ldr	r3, [sp, #4]
 800e70e:	2b00      	cmp	r3, #0
 800e710:	d105      	bne.n	800e71e <chSemWaitTimeoutS+0x1e>
 800e712:	f641 0020 	movw	r0, #6176	; 0x1820
 800e716:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e71a:	f000 fe39 	bl	800f390 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800e71e:	9b01      	ldr	r3, [sp, #4]
 800e720:	689b      	ldr	r3, [r3, #8]
 800e722:	2b00      	cmp	r3, #0
 800e724:	db09      	blt.n	800e73a <chSemWaitTimeoutS+0x3a>
 800e726:	9b01      	ldr	r3, [sp, #4]
 800e728:	4618      	mov	r0, r3
 800e72a:	f7ff fe41 	bl	800e3b0 <queue_isempty.6519.4204>
 800e72e:	4603      	mov	r3, r0
 800e730:	f083 0301 	eor.w	r3, r3, #1
 800e734:	b2db      	uxtb	r3, r3
 800e736:	2b00      	cmp	r3, #0
 800e738:	d013      	beq.n	800e762 <chSemWaitTimeoutS+0x62>
 800e73a:	9b01      	ldr	r3, [sp, #4]
 800e73c:	689b      	ldr	r3, [r3, #8]
 800e73e:	2b00      	cmp	r3, #0
 800e740:	da09      	bge.n	800e756 <chSemWaitTimeoutS+0x56>
 800e742:	9b01      	ldr	r3, [sp, #4]
 800e744:	4618      	mov	r0, r3
 800e746:	f7ff fe43 	bl	800e3d0 <queue_notempty.6523.4201>
 800e74a:	4603      	mov	r3, r0
 800e74c:	f083 0301 	eor.w	r3, r3, #1
 800e750:	b2db      	uxtb	r3, r3
 800e752:	2b00      	cmp	r3, #0
 800e754:	d005      	beq.n	800e762 <chSemWaitTimeoutS+0x62>
 800e756:	f641 0020 	movw	r0, #6176	; 0x1820
 800e75a:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e75e:	f000 fe17 	bl	800f390 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 800e762:	9b01      	ldr	r3, [sp, #4]
 800e764:	689b      	ldr	r3, [r3, #8]
 800e766:	1e5a      	subs	r2, r3, #1
 800e768:	9b01      	ldr	r3, [sp, #4]
 800e76a:	609a      	str	r2, [r3, #8]
 800e76c:	9b01      	ldr	r3, [sp, #4]
 800e76e:	689b      	ldr	r3, [r3, #8]
 800e770:	2b00      	cmp	r3, #0
 800e772:	da21      	bge.n	800e7b8 <chSemWaitTimeoutS+0xb8>
    if (TIME_IMMEDIATE == time) {
 800e774:	9b00      	ldr	r3, [sp, #0]
 800e776:	2b00      	cmp	r3, #0
 800e778:	d107      	bne.n	800e78a <chSemWaitTimeoutS+0x8a>
      sp->s_cnt++;
 800e77a:	9b01      	ldr	r3, [sp, #4]
 800e77c:	689b      	ldr	r3, [r3, #8]
 800e77e:	1c5a      	adds	r2, r3, #1
 800e780:	9b01      	ldr	r3, [sp, #4]
 800e782:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
 800e784:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800e788:	e017      	b.n	800e7ba <chSemWaitTimeoutS+0xba>
    }
    currp->p_u.wtsemp = sp;
 800e78a:	f640 5350 	movw	r3, #3408	; 0xd50
 800e78e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e792:	699b      	ldr	r3, [r3, #24]
 800e794:	9a01      	ldr	r2, [sp, #4]
 800e796:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->s_queue);
 800e798:	f640 5350 	movw	r3, #3408	; 0xd50
 800e79c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800e7a0:	699a      	ldr	r2, [r3, #24]
 800e7a2:	9b01      	ldr	r3, [sp, #4]
 800e7a4:	4610      	mov	r0, r2
 800e7a6:	4619      	mov	r1, r3
 800e7a8:	f7ff fe22 	bl	800e3f0 <queue_insert.6526.4197>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 800e7ac:	2005      	movs	r0, #5
 800e7ae:	9900      	ldr	r1, [sp, #0]
 800e7b0:	f001 fc2e 	bl	8010010 <chSchGoSleepTimeoutS>
 800e7b4:	4603      	mov	r3, r0
 800e7b6:	e000      	b.n	800e7ba <chSemWaitTimeoutS+0xba>
  }

  return MSG_OK;
 800e7b8:	2300      	movs	r3, #0
}
 800e7ba:	4618      	mov	r0, r3
 800e7bc:	b003      	add	sp, #12
 800e7be:	f85d fb04 	ldr.w	pc, [sp], #4
 800e7c2:	bf00      	nop
 800e7c4:	f3af 8000 	nop.w
 800e7c8:	f3af 8000 	nop.w
 800e7cc:	f3af 8000 	nop.w

0800e7d0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 800e7d0:	b500      	push	{lr}
 800e7d2:	b083      	sub	sp, #12
 800e7d4:	9001      	str	r0, [sp, #4]

  chDbgCheck(sp != NULL);
 800e7d6:	9b01      	ldr	r3, [sp, #4]
 800e7d8:	2b00      	cmp	r3, #0
 800e7da:	d105      	bne.n	800e7e8 <chSemSignal+0x18>
 800e7dc:	f641 0040 	movw	r0, #6208	; 0x1840
 800e7e0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e7e4:	f000 fdd4 	bl	800f390 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800e7e8:	9b01      	ldr	r3, [sp, #4]
 800e7ea:	689b      	ldr	r3, [r3, #8]
 800e7ec:	2b00      	cmp	r3, #0
 800e7ee:	db09      	blt.n	800e804 <chSemSignal+0x34>
 800e7f0:	9b01      	ldr	r3, [sp, #4]
 800e7f2:	4618      	mov	r0, r3
 800e7f4:	f7ff fddc 	bl	800e3b0 <queue_isempty.6519.4204>
 800e7f8:	4603      	mov	r3, r0
 800e7fa:	f083 0301 	eor.w	r3, r3, #1
 800e7fe:	b2db      	uxtb	r3, r3
 800e800:	2b00      	cmp	r3, #0
 800e802:	d013      	beq.n	800e82c <chSemSignal+0x5c>
 800e804:	9b01      	ldr	r3, [sp, #4]
 800e806:	689b      	ldr	r3, [r3, #8]
 800e808:	2b00      	cmp	r3, #0
 800e80a:	da09      	bge.n	800e820 <chSemSignal+0x50>
 800e80c:	9b01      	ldr	r3, [sp, #4]
 800e80e:	4618      	mov	r0, r3
 800e810:	f7ff fdde 	bl	800e3d0 <queue_notempty.6523.4201>
 800e814:	4603      	mov	r3, r0
 800e816:	f083 0301 	eor.w	r3, r3, #1
 800e81a:	b2db      	uxtb	r3, r3
 800e81c:	2b00      	cmp	r3, #0
 800e81e:	d005      	beq.n	800e82c <chSemSignal+0x5c>
 800e820:	f641 0040 	movw	r0, #6208	; 0x1840
 800e824:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e828:	f000 fdb2 	bl	800f390 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 800e82c:	f7ff fe28 	bl	800e480 <chSysLock.6536.4189>
  if (++sp->s_cnt <= (cnt_t)0) {
 800e830:	9b01      	ldr	r3, [sp, #4]
 800e832:	689b      	ldr	r3, [r3, #8]
 800e834:	1c5a      	adds	r2, r3, #1
 800e836:	9b01      	ldr	r3, [sp, #4]
 800e838:	609a      	str	r2, [r3, #8]
 800e83a:	9b01      	ldr	r3, [sp, #4]
 800e83c:	689b      	ldr	r3, [r3, #8]
 800e83e:	2b00      	cmp	r3, #0
 800e840:	dc08      	bgt.n	800e854 <chSemSignal+0x84>
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 800e842:	9b01      	ldr	r3, [sp, #4]
 800e844:	4618      	mov	r0, r3
 800e846:	f7ff fdeb 	bl	800e420 <queue_fifo_remove.6530.4194>
 800e84a:	4603      	mov	r3, r0
 800e84c:	4618      	mov	r0, r3
 800e84e:	2100      	movs	r1, #0
 800e850:	f001 fc1e 	bl	8010090 <chSchWakeupS>
  }
  chSysUnlock();
 800e854:	f7ff fe1c 	bl	800e490 <chSysUnlock.6538.4187>
}
 800e858:	b003      	add	sp, #12
 800e85a:	f85d fb04 	ldr.w	pc, [sp], #4
 800e85e:	bf00      	nop

0800e860 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 800e860:	b500      	push	{lr}
 800e862:	b085      	sub	sp, #20
 800e864:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800e866:	f001 f80b 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
 800e86a:	9b01      	ldr	r3, [sp, #4]
 800e86c:	2b00      	cmp	r3, #0
 800e86e:	d105      	bne.n	800e87c <chSemSignalI+0x1c>
 800e870:	f641 0050 	movw	r0, #6224	; 0x1850
 800e874:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e878:	f000 fd8a 	bl	800f390 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800e87c:	9b01      	ldr	r3, [sp, #4]
 800e87e:	689b      	ldr	r3, [r3, #8]
 800e880:	2b00      	cmp	r3, #0
 800e882:	db09      	blt.n	800e898 <chSemSignalI+0x38>
 800e884:	9b01      	ldr	r3, [sp, #4]
 800e886:	4618      	mov	r0, r3
 800e888:	f7ff fd92 	bl	800e3b0 <queue_isempty.6519.4204>
 800e88c:	4603      	mov	r3, r0
 800e88e:	f083 0301 	eor.w	r3, r3, #1
 800e892:	b2db      	uxtb	r3, r3
 800e894:	2b00      	cmp	r3, #0
 800e896:	d013      	beq.n	800e8c0 <chSemSignalI+0x60>
 800e898:	9b01      	ldr	r3, [sp, #4]
 800e89a:	689b      	ldr	r3, [r3, #8]
 800e89c:	2b00      	cmp	r3, #0
 800e89e:	da09      	bge.n	800e8b4 <chSemSignalI+0x54>
 800e8a0:	9b01      	ldr	r3, [sp, #4]
 800e8a2:	4618      	mov	r0, r3
 800e8a4:	f7ff fd94 	bl	800e3d0 <queue_notempty.6523.4201>
 800e8a8:	4603      	mov	r3, r0
 800e8aa:	f083 0301 	eor.w	r3, r3, #1
 800e8ae:	b2db      	uxtb	r3, r3
 800e8b0:	2b00      	cmp	r3, #0
 800e8b2:	d005      	beq.n	800e8c0 <chSemSignalI+0x60>
 800e8b4:	f641 0050 	movw	r0, #6224	; 0x1850
 800e8b8:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e8bc:	f000 fd68 	bl	800f390 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 800e8c0:	9b01      	ldr	r3, [sp, #4]
 800e8c2:	689b      	ldr	r3, [r3, #8]
 800e8c4:	1c5a      	adds	r2, r3, #1
 800e8c6:	9b01      	ldr	r3, [sp, #4]
 800e8c8:	609a      	str	r2, [r3, #8]
 800e8ca:	9b01      	ldr	r3, [sp, #4]
 800e8cc:	689b      	ldr	r3, [r3, #8]
 800e8ce:	2b00      	cmp	r3, #0
 800e8d0:	dc0a      	bgt.n	800e8e8 <chSemSignalI+0x88>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
 800e8d2:	9b01      	ldr	r3, [sp, #4]
 800e8d4:	4618      	mov	r0, r3
 800e8d6:	f7ff fda3 	bl	800e420 <queue_fifo_remove.6530.4194>
 800e8da:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 800e8dc:	9b03      	ldr	r3, [sp, #12]
 800e8de:	2200      	movs	r2, #0
 800e8e0:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800e8e2:	9803      	ldr	r0, [sp, #12]
 800e8e4:	f001 fabc 	bl	800fe60 <chSchReadyI>
  }
}
 800e8e8:	b005      	add	sp, #20
 800e8ea:	f85d fb04 	ldr.w	pc, [sp], #4
 800e8ee:	bf00      	nop

0800e8f0 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 800e8f0:	b500      	push	{lr}
 800e8f2:	b083      	sub	sp, #12
 800e8f4:	9001      	str	r0, [sp, #4]
 800e8f6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 800e8f8:	f000 ffc2 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
 800e8fc:	9b01      	ldr	r3, [sp, #4]
 800e8fe:	2b00      	cmp	r3, #0
 800e900:	d002      	beq.n	800e908 <chSemAddCounterI+0x18>
 800e902:	9b00      	ldr	r3, [sp, #0]
 800e904:	2b00      	cmp	r3, #0
 800e906:	dc05      	bgt.n	800e914 <chSemAddCounterI+0x24>
 800e908:	f641 0060 	movw	r0, #6240	; 0x1860
 800e90c:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e910:	f000 fd3e 	bl	800f390 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800e914:	9b01      	ldr	r3, [sp, #4]
 800e916:	689b      	ldr	r3, [r3, #8]
 800e918:	2b00      	cmp	r3, #0
 800e91a:	db09      	blt.n	800e930 <chSemAddCounterI+0x40>
 800e91c:	9b01      	ldr	r3, [sp, #4]
 800e91e:	4618      	mov	r0, r3
 800e920:	f7ff fd46 	bl	800e3b0 <queue_isempty.6519.4204>
 800e924:	4603      	mov	r3, r0
 800e926:	f083 0301 	eor.w	r3, r3, #1
 800e92a:	b2db      	uxtb	r3, r3
 800e92c:	2b00      	cmp	r3, #0
 800e92e:	d02b      	beq.n	800e988 <chSemAddCounterI+0x98>
 800e930:	9b01      	ldr	r3, [sp, #4]
 800e932:	689b      	ldr	r3, [r3, #8]
 800e934:	2b00      	cmp	r3, #0
 800e936:	da09      	bge.n	800e94c <chSemAddCounterI+0x5c>
 800e938:	9b01      	ldr	r3, [sp, #4]
 800e93a:	4618      	mov	r0, r3
 800e93c:	f7ff fd48 	bl	800e3d0 <queue_notempty.6523.4201>
 800e940:	4603      	mov	r3, r0
 800e942:	f083 0301 	eor.w	r3, r3, #1
 800e946:	b2db      	uxtb	r3, r3
 800e948:	2b00      	cmp	r3, #0
 800e94a:	d01d      	beq.n	800e988 <chSemAddCounterI+0x98>
 800e94c:	f641 0060 	movw	r0, #6240	; 0x1860
 800e950:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e954:	f000 fd1c 	bl	800f390 <chSysHalt>
 800e958:	e016      	b.n	800e988 <chSemAddCounterI+0x98>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->s_cnt <= (cnt_t)0) {
 800e95a:	9b01      	ldr	r3, [sp, #4]
 800e95c:	689b      	ldr	r3, [r3, #8]
 800e95e:	1c5a      	adds	r2, r3, #1
 800e960:	9b01      	ldr	r3, [sp, #4]
 800e962:	609a      	str	r2, [r3, #8]
 800e964:	9b01      	ldr	r3, [sp, #4]
 800e966:	689b      	ldr	r3, [r3, #8]
 800e968:	2b00      	cmp	r3, #0
 800e96a:	dc0a      	bgt.n	800e982 <chSemAddCounterI+0x92>
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 800e96c:	9b01      	ldr	r3, [sp, #4]
 800e96e:	4618      	mov	r0, r3
 800e970:	f7ff fd56 	bl	800e420 <queue_fifo_remove.6530.4194>
 800e974:	4603      	mov	r3, r0
 800e976:	4618      	mov	r0, r3
 800e978:	f001 fa72 	bl	800fe60 <chSchReadyI>
 800e97c:	4603      	mov	r3, r0
 800e97e:	2200      	movs	r2, #0
 800e980:	625a      	str	r2, [r3, #36]	; 0x24
    }
    n--;
 800e982:	9b00      	ldr	r3, [sp, #0]
 800e984:	3b01      	subs	r3, #1
 800e986:	9300      	str	r3, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 800e988:	9b00      	ldr	r3, [sp, #0]
 800e98a:	2b00      	cmp	r3, #0
 800e98c:	dce5      	bgt.n	800e95a <chSemAddCounterI+0x6a>
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
    }
    n--;
  }
}
 800e98e:	b003      	add	sp, #12
 800e990:	f85d fb04 	ldr.w	pc, [sp], #4
 800e994:	f3af 8000 	nop.w
 800e998:	f3af 8000 	nop.w
 800e99c:	f3af 8000 	nop.w

0800e9a0 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 800e9a0:	b500      	push	{lr}
 800e9a2:	b085      	sub	sp, #20
 800e9a4:	9001      	str	r0, [sp, #4]
 800e9a6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chDbgCheck((sps != NULL) && (spw != NULL));
 800e9a8:	9b01      	ldr	r3, [sp, #4]
 800e9aa:	2b00      	cmp	r3, #0
 800e9ac:	d002      	beq.n	800e9b4 <chSemSignalWait+0x14>
 800e9ae:	9b00      	ldr	r3, [sp, #0]
 800e9b0:	2b00      	cmp	r3, #0
 800e9b2:	d105      	bne.n	800e9c0 <chSemSignalWait+0x20>
 800e9b4:	f641 0080 	movw	r0, #6272	; 0x1880
 800e9b8:	f6c0 0001 	movt	r0, #2049	; 0x801
 800e9bc:	f000 fce8 	bl	800f390 <chSysHalt>
  chDbgAssert(((sps->s_cnt >= (cnt_t)0) && queue_isempty(&sps->s_queue)) ||
 800e9c0:	9b01      	ldr	r3, [sp, #4]
 800e9c2:	689b      	ldr	r3, [r3, #8]
 800e9c4:	2b00      	cmp	r3, #0
 800e9c6:	db09      	blt.n	800e9dc <chSemSignalWait+0x3c>
 800e9c8:	9b01      	ldr	r3, [sp, #4]
 800e9ca:	4618      	mov	r0, r3
 800e9cc:	f7ff fcf0 	bl	800e3b0 <queue_isempty.6519.4204>
 800e9d0:	4603      	mov	r3, r0
 800e9d2:	f083 0301 	eor.w	r3, r3, #1
 800e9d6:	b2db      	uxtb	r3, r3
 800e9d8:	2b00      	cmp	r3, #0
 800e9da:	d013      	beq.n	800ea04 <chSemSignalWait+0x64>
 800e9dc:	9b01      	ldr	r3, [sp, #4]
 800e9de:	689b      	ldr	r3, [r3, #8]
 800e9e0:	2b00      	cmp	r3, #0
 800e9e2:	da09      	bge.n	800e9f8 <chSemSignalWait+0x58>
 800e9e4:	9b01      	ldr	r3, [sp, #4]
 800e9e6:	4618      	mov	r0, r3
 800e9e8:	f7ff fcf2 	bl	800e3d0 <queue_notempty.6523.4201>
 800e9ec:	4603      	mov	r3, r0
 800e9ee:	f083 0301 	eor.w	r3, r3, #1
 800e9f2:	b2db      	uxtb	r3, r3
 800e9f4:	2b00      	cmp	r3, #0
 800e9f6:	d005      	beq.n	800ea04 <chSemSignalWait+0x64>
 800e9f8:	f641 0080 	movw	r0, #6272	; 0x1880
 800e9fc:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ea00:	f000 fcc6 	bl	800f390 <chSysHalt>
              ((sps->s_cnt < (cnt_t)0) && queue_notempty(&sps->s_queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
 800ea04:	9b00      	ldr	r3, [sp, #0]
 800ea06:	689b      	ldr	r3, [r3, #8]
 800ea08:	2b00      	cmp	r3, #0
 800ea0a:	db09      	blt.n	800ea20 <chSemSignalWait+0x80>
 800ea0c:	9b00      	ldr	r3, [sp, #0]
 800ea0e:	4618      	mov	r0, r3
 800ea10:	f7ff fcce 	bl	800e3b0 <queue_isempty.6519.4204>
 800ea14:	4603      	mov	r3, r0
 800ea16:	f083 0301 	eor.w	r3, r3, #1
 800ea1a:	b2db      	uxtb	r3, r3
 800ea1c:	2b00      	cmp	r3, #0
 800ea1e:	d013      	beq.n	800ea48 <chSemSignalWait+0xa8>
 800ea20:	9b00      	ldr	r3, [sp, #0]
 800ea22:	689b      	ldr	r3, [r3, #8]
 800ea24:	2b00      	cmp	r3, #0
 800ea26:	da09      	bge.n	800ea3c <chSemSignalWait+0x9c>
 800ea28:	9b00      	ldr	r3, [sp, #0]
 800ea2a:	4618      	mov	r0, r3
 800ea2c:	f7ff fcd0 	bl	800e3d0 <queue_notempty.6523.4201>
 800ea30:	4603      	mov	r3, r0
 800ea32:	f083 0301 	eor.w	r3, r3, #1
 800ea36:	b2db      	uxtb	r3, r3
 800ea38:	2b00      	cmp	r3, #0
 800ea3a:	d005      	beq.n	800ea48 <chSemSignalWait+0xa8>
 800ea3c:	f641 0080 	movw	r0, #6272	; 0x1880
 800ea40:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ea44:	f000 fca4 	bl	800f390 <chSysHalt>
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 800ea48:	f7ff fd1a 	bl	800e480 <chSysLock.6536.4189>
  if (++sps->s_cnt <= (cnt_t)0) {
 800ea4c:	9b01      	ldr	r3, [sp, #4]
 800ea4e:	689b      	ldr	r3, [r3, #8]
 800ea50:	1c5a      	adds	r2, r3, #1
 800ea52:	9b01      	ldr	r3, [sp, #4]
 800ea54:	609a      	str	r2, [r3, #8]
 800ea56:	9b01      	ldr	r3, [sp, #4]
 800ea58:	689b      	ldr	r3, [r3, #8]
 800ea5a:	2b00      	cmp	r3, #0
 800ea5c:	dc0a      	bgt.n	800ea74 <chSemSignalWait+0xd4>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 800ea5e:	9b01      	ldr	r3, [sp, #4]
 800ea60:	4618      	mov	r0, r3
 800ea62:	f7ff fcdd 	bl	800e420 <queue_fifo_remove.6530.4194>
 800ea66:	4603      	mov	r3, r0
 800ea68:	4618      	mov	r0, r3
 800ea6a:	f001 f9f9 	bl	800fe60 <chSchReadyI>
 800ea6e:	4603      	mov	r3, r0
 800ea70:	2200      	movs	r2, #0
 800ea72:	625a      	str	r2, [r3, #36]	; 0x24
  }
  if (--spw->s_cnt < (cnt_t)0) {
 800ea74:	9b00      	ldr	r3, [sp, #0]
 800ea76:	689b      	ldr	r3, [r3, #8]
 800ea78:	1e5a      	subs	r2, r3, #1
 800ea7a:	9b00      	ldr	r3, [sp, #0]
 800ea7c:	609a      	str	r2, [r3, #8]
 800ea7e:	9b00      	ldr	r3, [sp, #0]
 800ea80:	689b      	ldr	r3, [r3, #8]
 800ea82:	2b00      	cmp	r3, #0
 800ea84:	da14      	bge.n	800eab0 <chSemSignalWait+0x110>
    thread_t *ctp = currp;
 800ea86:	f640 5350 	movw	r3, #3408	; 0xd50
 800ea8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ea8e:	699b      	ldr	r3, [r3, #24]
 800ea90:	9302      	str	r3, [sp, #8]
    sem_insert(ctp, &spw->s_queue);
 800ea92:	9b00      	ldr	r3, [sp, #0]
 800ea94:	9802      	ldr	r0, [sp, #8]
 800ea96:	4619      	mov	r1, r3
 800ea98:	f7ff fcaa 	bl	800e3f0 <queue_insert.6526.4197>
    ctp->p_u.wtsemp = spw;
 800ea9c:	9b02      	ldr	r3, [sp, #8]
 800ea9e:	9a00      	ldr	r2, [sp, #0]
 800eaa0:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTSEM);
 800eaa2:	2005      	movs	r0, #5
 800eaa4:	f001 fa24 	bl	800fef0 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 800eaa8:	9b02      	ldr	r3, [sp, #8]
 800eaaa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800eaac:	9303      	str	r3, [sp, #12]
 800eaae:	e003      	b.n	800eab8 <chSemSignalWait+0x118>
  }
  else {
    chSchRescheduleS();
 800eab0:	f001 fb56 	bl	8010160 <chSchRescheduleS>
    msg = MSG_OK;
 800eab4:	2300      	movs	r3, #0
 800eab6:	9303      	str	r3, [sp, #12]
  }
  chSysUnlock();
 800eab8:	f7ff fcea 	bl	800e490 <chSysUnlock.6538.4187>

  return msg;
 800eabc:	9b03      	ldr	r3, [sp, #12]
}
 800eabe:	4618      	mov	r0, r3
 800eac0:	b005      	add	sp, #20
 800eac2:	f85d fb04 	ldr.w	pc, [sp], #4
 800eac6:	bf00      	nop
 800eac8:	f3af 8000 	nop.w
 800eacc:	f3af 8000 	nop.w

0800ead0 <port_lock.6673.4140>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800ead0:	b082      	sub	sp, #8
 800ead2:	2320      	movs	r3, #32
 800ead4:	9301      	str	r3, [sp, #4]
 800ead6:	9b01      	ldr	r3, [sp, #4]
 800ead8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800eadc:	b002      	add	sp, #8
 800eade:	4770      	bx	lr

0800eae0 <port_unlock.6676.4138>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800eae0:	b082      	sub	sp, #8
 800eae2:	2300      	movs	r3, #0
 800eae4:	9301      	str	r3, [sp, #4]
 800eae6:	9b01      	ldr	r3, [sp, #4]
 800eae8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800eaec:	b002      	add	sp, #8
 800eaee:	4770      	bx	lr

0800eaf0 <queue_init.6678.4135>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800eaf0:	b082      	sub	sp, #8
 800eaf2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800eaf4:	9b01      	ldr	r3, [sp, #4]
 800eaf6:	9a01      	ldr	r2, [sp, #4]
 800eaf8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800eafa:	9b01      	ldr	r3, [sp, #4]
 800eafc:	9a01      	ldr	r2, [sp, #4]
 800eafe:	605a      	str	r2, [r3, #4]
}
 800eb00:	b002      	add	sp, #8
 800eb02:	4770      	bx	lr
 800eb04:	f3af 8000 	nop.w
 800eb08:	f3af 8000 	nop.w
 800eb0c:	f3af 8000 	nop.w

0800eb10 <queue_notempty.6767.4130>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 800eb10:	b082      	sub	sp, #8
 800eb12:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800eb14:	9b01      	ldr	r3, [sp, #4]
 800eb16:	681a      	ldr	r2, [r3, #0]
 800eb18:	9b01      	ldr	r3, [sp, #4]
 800eb1a:	429a      	cmp	r2, r3
 800eb1c:	bf0c      	ite	eq
 800eb1e:	2300      	moveq	r3, #0
 800eb20:	2301      	movne	r3, #1
 800eb22:	b2db      	uxtb	r3, r3
}
 800eb24:	4618      	mov	r0, r3
 800eb26:	b002      	add	sp, #8
 800eb28:	4770      	bx	lr
 800eb2a:	bf00      	nop
 800eb2c:	f3af 8000 	nop.w

0800eb30 <queue_prio_insert.6771.4126>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 800eb30:	b084      	sub	sp, #16
 800eb32:	9001      	str	r0, [sp, #4]
 800eb34:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 800eb36:	9b00      	ldr	r3, [sp, #0]
 800eb38:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800eb3a:	9b03      	ldr	r3, [sp, #12]
 800eb3c:	681b      	ldr	r3, [r3, #0]
 800eb3e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800eb40:	9a03      	ldr	r2, [sp, #12]
 800eb42:	9b00      	ldr	r3, [sp, #0]
 800eb44:	429a      	cmp	r2, r3
 800eb46:	d005      	beq.n	800eb54 <queue_prio_insert.6771.4126+0x24>
 800eb48:	9b03      	ldr	r3, [sp, #12]
 800eb4a:	689a      	ldr	r2, [r3, #8]
 800eb4c:	9b01      	ldr	r3, [sp, #4]
 800eb4e:	689b      	ldr	r3, [r3, #8]
 800eb50:	429a      	cmp	r2, r3
 800eb52:	d2f2      	bcs.n	800eb3a <queue_prio_insert.6771.4126+0xa>
  tp->p_next = cp;
 800eb54:	9b01      	ldr	r3, [sp, #4]
 800eb56:	9a03      	ldr	r2, [sp, #12]
 800eb58:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 800eb5a:	9b03      	ldr	r3, [sp, #12]
 800eb5c:	685a      	ldr	r2, [r3, #4]
 800eb5e:	9b01      	ldr	r3, [sp, #4]
 800eb60:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800eb62:	9b01      	ldr	r3, [sp, #4]
 800eb64:	685b      	ldr	r3, [r3, #4]
 800eb66:	9a01      	ldr	r2, [sp, #4]
 800eb68:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 800eb6a:	9b03      	ldr	r3, [sp, #12]
 800eb6c:	9a01      	ldr	r2, [sp, #4]
 800eb6e:	605a      	str	r2, [r3, #4]
}
 800eb70:	b004      	add	sp, #16
 800eb72:	4770      	bx	lr
 800eb74:	f3af 8000 	nop.w
 800eb78:	f3af 8000 	nop.w
 800eb7c:	f3af 8000 	nop.w

0800eb80 <queue_fifo_remove.6775>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800eb80:	b084      	sub	sp, #16
 800eb82:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 800eb84:	9b01      	ldr	r3, [sp, #4]
 800eb86:	681b      	ldr	r3, [r3, #0]
 800eb88:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800eb8a:	9b03      	ldr	r3, [sp, #12]
 800eb8c:	681a      	ldr	r2, [r3, #0]
 800eb8e:	9b01      	ldr	r3, [sp, #4]
 800eb90:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800eb92:	9b01      	ldr	r3, [sp, #4]
 800eb94:	681b      	ldr	r3, [r3, #0]
 800eb96:	9a01      	ldr	r2, [sp, #4]
 800eb98:	605a      	str	r2, [r3, #4]

  return tp;
 800eb9a:	9b03      	ldr	r3, [sp, #12]
}
 800eb9c:	4618      	mov	r0, r3
 800eb9e:	b004      	add	sp, #16
 800eba0:	4770      	bx	lr
 800eba2:	bf00      	nop
 800eba4:	f3af 8000 	nop.w
 800eba8:	f3af 8000 	nop.w
 800ebac:	f3af 8000 	nop.w

0800ebb0 <queue_dequeue.6778.4120>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 800ebb0:	b082      	sub	sp, #8
 800ebb2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 800ebb4:	9b01      	ldr	r3, [sp, #4]
 800ebb6:	685b      	ldr	r3, [r3, #4]
 800ebb8:	9a01      	ldr	r2, [sp, #4]
 800ebba:	6812      	ldr	r2, [r2, #0]
 800ebbc:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800ebbe:	9b01      	ldr	r3, [sp, #4]
 800ebc0:	681b      	ldr	r3, [r3, #0]
 800ebc2:	9a01      	ldr	r2, [sp, #4]
 800ebc4:	6852      	ldr	r2, [r2, #4]
 800ebc6:	605a      	str	r2, [r3, #4]

  return tp;
 800ebc8:	9b01      	ldr	r3, [sp, #4]
}
 800ebca:	4618      	mov	r0, r3
 800ebcc:	b002      	add	sp, #8
 800ebce:	4770      	bx	lr

0800ebd0 <chSysLock.6781>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800ebd0:	b508      	push	{r3, lr}

  port_lock();
 800ebd2:	f7ff ff7d 	bl	800ead0 <port_lock.6673.4140>
  _stats_start_measure_crit_thd();
 800ebd6:	f7ff f9d3 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800ebda:	f000 fd81 	bl	800f6e0 <_dbg_check_lock>
}
 800ebde:	bd08      	pop	{r3, pc}

0800ebe0 <chSysUnlock.6783>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800ebe0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800ebe2:	f000 fd9d 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800ebe6:	f7ff f9d3 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800ebea:	f640 5350 	movw	r3, #3408	; 0xd50
 800ebee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ebf2:	681a      	ldr	r2, [r3, #0]
 800ebf4:	f640 5350 	movw	r3, #3408	; 0xd50
 800ebf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ebfc:	429a      	cmp	r2, r3
 800ebfe:	d013      	beq.n	800ec28 <chSysUnlock.6783+0x48>
 800ec00:	f640 5350 	movw	r3, #3408	; 0xd50
 800ec04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ec08:	699b      	ldr	r3, [r3, #24]
 800ec0a:	689a      	ldr	r2, [r3, #8]
 800ec0c:	f640 5350 	movw	r3, #3408	; 0xd50
 800ec10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ec14:	681b      	ldr	r3, [r3, #0]
 800ec16:	689b      	ldr	r3, [r3, #8]
 800ec18:	429a      	cmp	r2, r3
 800ec1a:	d205      	bcs.n	800ec28 <chSysUnlock.6783+0x48>
 800ec1c:	f641 00a0 	movw	r0, #6304	; 0x18a0
 800ec20:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ec24:	f000 fbb4 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800ec28:	f7ff ff5a 	bl	800eae0 <port_unlock.6676.4138>
}
 800ec2c:	bd08      	pop	{r3, pc}
 800ec2e:	bf00      	nop

0800ec30 <chMtxQueueNotEmptyS.6785>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 800ec30:	b500      	push	{lr}
 800ec32:	b083      	sub	sp, #12
 800ec34:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 800ec36:	f000 fe3b 	bl	800f8b0 <chDbgCheckClassS>

  return queue_notempty(&mp->m_queue);
 800ec3a:	9b01      	ldr	r3, [sp, #4]
 800ec3c:	4618      	mov	r0, r3
 800ec3e:	f7ff ff67 	bl	800eb10 <queue_notempty.6767.4130>
 800ec42:	4603      	mov	r3, r0
}
 800ec44:	4618      	mov	r0, r3
 800ec46:	b003      	add	sp, #12
 800ec48:	f85d fb04 	ldr.w	pc, [sp], #4
 800ec4c:	f3af 8000 	nop.w

0800ec50 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 800ec50:	b500      	push	{lr}
 800ec52:	b083      	sub	sp, #12
 800ec54:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 800ec56:	9b01      	ldr	r3, [sp, #4]
 800ec58:	2b00      	cmp	r3, #0
 800ec5a:	d105      	bne.n	800ec68 <chMtxObjectInit+0x18>
 800ec5c:	f641 0090 	movw	r0, #6288	; 0x1890
 800ec60:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ec64:	f000 fb94 	bl	800f390 <chSysHalt>

  queue_init(&mp->m_queue);
 800ec68:	9b01      	ldr	r3, [sp, #4]
 800ec6a:	4618      	mov	r0, r3
 800ec6c:	f7ff ff40 	bl	800eaf0 <queue_init.6678.4135>
  mp->m_owner = NULL;
 800ec70:	9b01      	ldr	r3, [sp, #4]
 800ec72:	2200      	movs	r2, #0
 800ec74:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 800ec76:	b003      	add	sp, #12
 800ec78:	f85d fb04 	ldr.w	pc, [sp], #4
 800ec7c:	f3af 8000 	nop.w

0800ec80 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 800ec80:	b500      	push	{lr}
 800ec82:	b083      	sub	sp, #12
 800ec84:	9001      	str	r0, [sp, #4]

  chSysLock();
 800ec86:	f7ff ffa3 	bl	800ebd0 <chSysLock.6781>
  chMtxLockS(mp);
 800ec8a:	9801      	ldr	r0, [sp, #4]
 800ec8c:	f000 f808 	bl	800eca0 <chMtxLockS>
  chSysUnlock();
 800ec90:	f7ff ffa6 	bl	800ebe0 <chSysUnlock.6783>
}
 800ec94:	b003      	add	sp, #12
 800ec96:	f85d fb04 	ldr.w	pc, [sp], #4
 800ec9a:	bf00      	nop
 800ec9c:	f3af 8000 	nop.w

0800eca0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 800eca0:	b500      	push	{lr}
 800eca2:	b085      	sub	sp, #20
 800eca4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 800eca6:	f640 5350 	movw	r3, #3408	; 0xd50
 800ecaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ecae:	699b      	ldr	r3, [r3, #24]
 800ecb0:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 800ecb2:	f000 fdfd 	bl	800f8b0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800ecb6:	9b01      	ldr	r3, [sp, #4]
 800ecb8:	2b00      	cmp	r3, #0
 800ecba:	d105      	bne.n	800ecc8 <chMtxLockS+0x28>
 800ecbc:	f641 00b0 	movw	r0, #6320	; 0x18b0
 800ecc0:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ecc4:	f000 fb64 	bl	800f390 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 800ecc8:	9b01      	ldr	r3, [sp, #4]
 800ecca:	689b      	ldr	r3, [r3, #8]
 800eccc:	2b00      	cmp	r3, #0
 800ecce:	d05f      	beq.n	800ed90 <chMtxLockS+0xf0>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;
 800ecd0:	9b01      	ldr	r3, [sp, #4]
 800ecd2:	689b      	ldr	r3, [r3, #8]
 800ecd4:	9303      	str	r3, [sp, #12]
 800ecd6:	e033      	b.n	800ed40 <chMtxLockS+0xa0>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 800ecd8:	9b02      	ldr	r3, [sp, #8]
 800ecda:	689a      	ldr	r2, [r3, #8]
 800ecdc:	9b03      	ldr	r3, [sp, #12]
 800ecde:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 800ece0:	9b03      	ldr	r3, [sp, #12]
 800ece2:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ece6:	2b06      	cmp	r3, #6
 800ece8:	d004      	beq.n	800ecf4 <chMtxLockS+0x54>
 800ecea:	2b07      	cmp	r3, #7
 800ecec:	d011      	beq.n	800ed12 <chMtxLockS+0x72>
 800ecee:	2b00      	cmp	r3, #0
 800ecf0:	d01a      	beq.n	800ed28 <chMtxLockS+0x88>
 800ecf2:	e02b      	b.n	800ed4c <chMtxLockS+0xac>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800ecf4:	9803      	ldr	r0, [sp, #12]
 800ecf6:	f7ff ff5b 	bl	800ebb0 <queue_dequeue.6778.4120>
 800ecfa:	4602      	mov	r2, r0
 800ecfc:	9b03      	ldr	r3, [sp, #12]
 800ecfe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ed00:	4610      	mov	r0, r2
 800ed02:	4619      	mov	r1, r3
 800ed04:	f7ff ff14 	bl	800eb30 <queue_prio_insert.6771.4126>
          tp = tp->p_u.wtmtxp->m_owner;
 800ed08:	9b03      	ldr	r3, [sp, #12]
 800ed0a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ed0c:	689b      	ldr	r3, [r3, #8]
 800ed0e:	9303      	str	r3, [sp, #12]
 800ed10:	e016      	b.n	800ed40 <chMtxLockS+0xa0>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800ed12:	9803      	ldr	r0, [sp, #12]
 800ed14:	f7ff ff4c 	bl	800ebb0 <queue_dequeue.6778.4120>
 800ed18:	4602      	mov	r2, r0
 800ed1a:	9b03      	ldr	r3, [sp, #12]
 800ed1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ed1e:	4610      	mov	r0, r2
 800ed20:	4619      	mov	r1, r3
 800ed22:	f7ff ff05 	bl	800eb30 <queue_prio_insert.6771.4126>
 800ed26:	e011      	b.n	800ed4c <chMtxLockS+0xac>
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
 800ed28:	9b03      	ldr	r3, [sp, #12]
 800ed2a:	2201      	movs	r2, #1
 800ed2c:	f883 2020 	strb.w	r2, [r3, #32]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800ed30:	9803      	ldr	r0, [sp, #12]
 800ed32:	f7ff ff3d 	bl	800ebb0 <queue_dequeue.6778.4120>
 800ed36:	4603      	mov	r3, r0
 800ed38:	4618      	mov	r0, r3
 800ed3a:	f001 f891 	bl	800fe60 <chSchReadyI>
 800ed3e:	e005      	b.n	800ed4c <chMtxLockS+0xac>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800ed40:	9b03      	ldr	r3, [sp, #12]
 800ed42:	689a      	ldr	r2, [r3, #8]
 800ed44:	9b02      	ldr	r3, [sp, #8]
 800ed46:	689b      	ldr	r3, [r3, #8]
 800ed48:	429a      	cmp	r2, r3
 800ed4a:	d3c5      	bcc.n	800ecd8 <chMtxLockS+0x38>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
 800ed4c:	9b01      	ldr	r3, [sp, #4]
 800ed4e:	9802      	ldr	r0, [sp, #8]
 800ed50:	4619      	mov	r1, r3
 800ed52:	f7ff feed 	bl	800eb30 <queue_prio_insert.6771.4126>
      ctp->p_u.wtmtxp = mp;
 800ed56:	9b02      	ldr	r3, [sp, #8]
 800ed58:	9a01      	ldr	r2, [sp, #4]
 800ed5a:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800ed5c:	2006      	movs	r0, #6
 800ed5e:	f001 f8c7 	bl	800fef0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->m_owner == ctp, "not owner");
 800ed62:	9b01      	ldr	r3, [sp, #4]
 800ed64:	689a      	ldr	r2, [r3, #8]
 800ed66:	9b02      	ldr	r3, [sp, #8]
 800ed68:	429a      	cmp	r2, r3
 800ed6a:	d005      	beq.n	800ed78 <chMtxLockS+0xd8>
 800ed6c:	f641 00b0 	movw	r0, #6320	; 0x18b0
 800ed70:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ed74:	f000 fb0c 	bl	800f390 <chSysHalt>
      chDbgAssert(ctp->p_mtxlist == mp, "not owned");
 800ed78:	9b02      	ldr	r3, [sp, #8]
 800ed7a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800ed7c:	9b01      	ldr	r3, [sp, #4]
 800ed7e:	429a      	cmp	r2, r3
 800ed80:	d010      	beq.n	800eda4 <chMtxLockS+0x104>
 800ed82:	f641 00b0 	movw	r0, #6320	; 0x18b0
 800ed86:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ed8a:	f000 fb01 	bl	800f390 <chSysHalt>
 800ed8e:	e009      	b.n	800eda4 <chMtxLockS+0x104>
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 800ed90:	9b01      	ldr	r3, [sp, #4]
 800ed92:	9a02      	ldr	r2, [sp, #8]
 800ed94:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
 800ed96:	9b02      	ldr	r3, [sp, #8]
 800ed98:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800ed9a:	9b01      	ldr	r3, [sp, #4]
 800ed9c:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
 800ed9e:	9b02      	ldr	r3, [sp, #8]
 800eda0:	9a01      	ldr	r2, [sp, #4]
 800eda2:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 800eda4:	b005      	add	sp, #20
 800eda6:	f85d fb04 	ldr.w	pc, [sp], #4
 800edaa:	bf00      	nop
 800edac:	f3af 8000 	nop.w

0800edb0 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 800edb0:	b500      	push	{lr}
 800edb2:	b085      	sub	sp, #20
 800edb4:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 800edb6:	f7ff ff0b 	bl	800ebd0 <chSysLock.6781>
  b = chMtxTryLockS(mp);
 800edba:	9801      	ldr	r0, [sp, #4]
 800edbc:	f7fd fad0 	bl	800c360 <chMtxTryLockS>
 800edc0:	4603      	mov	r3, r0
 800edc2:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 800edc6:	f7ff ff0b 	bl	800ebe0 <chSysUnlock.6783>

  return b;
 800edca:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800edce:	4618      	mov	r0, r3
 800edd0:	b005      	add	sp, #20
 800edd2:	f85d fb04 	ldr.w	pc, [sp], #4
 800edd6:	bf00      	nop
 800edd8:	f3af 8000 	nop.w
 800eddc:	f3af 8000 	nop.w

0800ede0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 800ede0:	4770      	bx	lr
 800ede2:	bf00      	nop
 800ede4:	f3af 8000 	nop.w
 800ede8:	f3af 8000 	nop.w
 800edec:	f3af 8000 	nop.w

0800edf0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 800edf0:	4770      	bx	lr
 800edf2:	bf00      	nop
 800edf4:	f3af 8000 	nop.w
 800edf8:	f3af 8000 	nop.w
 800edfc:	f3af 8000 	nop.w

0800ee00 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 800ee00:	e7fe      	b.n	800ee00 <__default_exit>
 800ee02:	bf00      	nop
 800ee04:	f3af 8000 	nop.w
 800ee08:	f3af 8000 	nop.w
 800ee0c:	f3af 8000 	nop.w

0800ee10 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800ee10:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800ee12:	f241 53b0 	movw	r3, #5552	; 0x15b0
 800ee16:	f6c0 0301 	movt	r3, #2049	; 0x801
 800ee1a:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 800ee1c:	9b03      	ldr	r3, [sp, #12]
 800ee1e:	681b      	ldr	r3, [r3, #0]
 800ee20:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800ee22:	9b03      	ldr	r3, [sp, #12]
 800ee24:	685b      	ldr	r3, [r3, #4]
 800ee26:	9301      	str	r3, [sp, #4]
 800ee28:	e009      	b.n	800ee3e <__init_ram_areas+0x2e>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 800ee2a:	9b02      	ldr	r3, [sp, #8]
 800ee2c:	681a      	ldr	r2, [r3, #0]
 800ee2e:	9b01      	ldr	r3, [sp, #4]
 800ee30:	601a      	str	r2, [r3, #0]
      p++;
 800ee32:	9b01      	ldr	r3, [sp, #4]
 800ee34:	3304      	adds	r3, #4
 800ee36:	9301      	str	r3, [sp, #4]
      tp++;
 800ee38:	9b02      	ldr	r3, [sp, #8]
 800ee3a:	3304      	adds	r3, #4
 800ee3c:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800ee3e:	9b03      	ldr	r3, [sp, #12]
 800ee40:	689a      	ldr	r2, [r3, #8]
 800ee42:	9b01      	ldr	r3, [sp, #4]
 800ee44:	429a      	cmp	r2, r3
 800ee46:	d8f0      	bhi.n	800ee2a <__init_ram_areas+0x1a>
 800ee48:	e005      	b.n	800ee56 <__init_ram_areas+0x46>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800ee4a:	9b01      	ldr	r3, [sp, #4]
 800ee4c:	2200      	movs	r2, #0
 800ee4e:	601a      	str	r2, [r3, #0]
      p++;
 800ee50:	9b01      	ldr	r3, [sp, #4]
 800ee52:	3304      	adds	r3, #4
 800ee54:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800ee56:	9b03      	ldr	r3, [sp, #12]
 800ee58:	68da      	ldr	r2, [r3, #12]
 800ee5a:	9b01      	ldr	r3, [sp, #4]
 800ee5c:	429a      	cmp	r2, r3
 800ee5e:	d8f4      	bhi.n	800ee4a <__init_ram_areas+0x3a>
      *p = 0;
      p++;
    }
    rap++;
 800ee60:	9b03      	ldr	r3, [sp, #12]
 800ee62:	3310      	adds	r3, #16
 800ee64:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800ee66:	9a03      	ldr	r2, [sp, #12]
 800ee68:	4b02      	ldr	r3, [pc, #8]	; (800ee74 <__init_ram_areas+0x64>)
 800ee6a:	429a      	cmp	r2, r3
 800ee6c:	d3d6      	bcc.n	800ee1c <__init_ram_areas+0xc>
#endif
}
 800ee6e:	b004      	add	sp, #16
 800ee70:	4770      	bx	lr
 800ee72:	bf00      	nop
 800ee74:	08011630 	.word	0x08011630
 800ee78:	f3af 8000 	nop.w
 800ee7c:	f3af 8000 	nop.w

0800ee80 <BusFault_Handler.4424>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 800ee80:	e7fe      	b.n	800ee80 <BusFault_Handler.4424>
 800ee82:	bf00      	nop
 800ee84:	f3af 8000 	nop.w
 800ee88:	f3af 8000 	nop.w
 800ee8c:	f3af 8000 	nop.w

0800ee90 <NVIC_SetPriorityGrouping.4201.4415>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800ee90:	b084      	sub	sp, #16
 800ee92:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800ee94:	9b01      	ldr	r3, [sp, #4]
 800ee96:	f003 0307 	and.w	r3, r3, #7
 800ee9a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800ee9c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800eea0:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800eea4:	68db      	ldr	r3, [r3, #12]
 800eea6:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 800eea8:	9a02      	ldr	r2, [sp, #8]
 800eeaa:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800eeae:	4013      	ands	r3, r2
 800eeb0:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 800eeb2:	9b03      	ldr	r3, [sp, #12]
 800eeb4:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800eeb6:	9b02      	ldr	r3, [sp, #8]
 800eeb8:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800eeba:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800eebe:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800eec2:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800eec4:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800eec8:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800eecc:	9a02      	ldr	r2, [sp, #8]
 800eece:	60da      	str	r2, [r3, #12]
}
 800eed0:	b004      	add	sp, #16
 800eed2:	4770      	bx	lr
 800eed4:	f3af 8000 	nop.w
 800eed8:	f3af 8000 	nop.w
 800eedc:	f3af 8000 	nop.w

0800eee0 <NVIC_SetPriority.4207.4409>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800eee0:	b082      	sub	sp, #8
 800eee2:	4603      	mov	r3, r0
 800eee4:	9100      	str	r1, [sp, #0]
 800eee6:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
 800eeea:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800eeee:	2b00      	cmp	r3, #0
 800eef0:	da0f      	bge.n	800ef12 <NVIC_SetPriority.4207.4409+0x32>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800eef2:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800eef6:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800eefa:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800eefe:	f002 020f 	and.w	r2, r2, #15
 800ef02:	1f11      	subs	r1, r2, #4
 800ef04:	9a00      	ldr	r2, [sp, #0]
 800ef06:	b2d2      	uxtb	r2, r2
 800ef08:	0112      	lsls	r2, r2, #4
 800ef0a:	b2d2      	uxtb	r2, r2
 800ef0c:	440b      	add	r3, r1
 800ef0e:	761a      	strb	r2, [r3, #24]
 800ef10:	e00c      	b.n	800ef2c <NVIC_SetPriority.4207.4409+0x4c>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800ef12:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 800ef16:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800ef1a:	f99d 1007 	ldrsb.w	r1, [sp, #7]
 800ef1e:	9a00      	ldr	r2, [sp, #0]
 800ef20:	b2d2      	uxtb	r2, r2
 800ef22:	0112      	lsls	r2, r2, #4
 800ef24:	b2d2      	uxtb	r2, r2
 800ef26:	440b      	add	r3, r1
 800ef28:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 800ef2c:	b002      	add	sp, #8
 800ef2e:	4770      	bx	lr

0800ef30 <port_init.4213.4407>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 800ef30:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 800ef32:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800ef36:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800ef3a:	2200      	movs	r2, #0
 800ef3c:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 800ef3e:	2003      	movs	r0, #3
 800ef40:	f7ff ffa6 	bl	800ee90 <NVIC_SetPriorityGrouping.4201.4415>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800ef44:	f64e 53f0 	movw	r3, #60912	; 0xedf0
 800ef48:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800ef4c:	f64e 52f0 	movw	r2, #60912	; 0xedf0
 800ef50:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800ef54:	68d2      	ldr	r2, [r2, #12]
 800ef56:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800ef5a:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800ef5c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ef60:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800ef64:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800ef68:	f2ce 0200 	movt	r2, #57344	; 0xe000
 800ef6c:	6812      	ldr	r2, [r2, #0]
 800ef6e:	f042 0201 	orr.w	r2, r2, #1
 800ef72:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 800ef74:	f06f 0004 	mvn.w	r0, #4
 800ef78:	2101      	movs	r1, #1
 800ef7a:	f7ff ffb1 	bl	800eee0 <NVIC_SetPriority.4207.4409>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 800ef7e:	f06f 0001 	mvn.w	r0, #1
 800ef82:	2102      	movs	r1, #2
 800ef84:	f7ff ffac 	bl	800eee0 <NVIC_SetPriority.4207.4409>
}
 800ef88:	bd08      	pop	{r3, pc}
 800ef8a:	bf00      	nop
 800ef8c:	f3af 8000 	nop.w

0800ef90 <port_get_irq_status.4215.4405>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 800ef90:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ef92:	f3ef 8311 	mrs	r3, BASEPRI
 800ef96:	9300      	str	r3, [sp, #0]
  return(result);
 800ef98:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 800ef9a:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 800ef9c:	9b01      	ldr	r3, [sp, #4]
}
 800ef9e:	4618      	mov	r0, r3
 800efa0:	b002      	add	sp, #8
 800efa2:	4770      	bx	lr
 800efa4:	f3af 8000 	nop.w
 800efa8:	f3af 8000 	nop.w
 800efac:	f3af 8000 	nop.w

0800efb0 <port_irq_enabled.4218.4402>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 800efb0:	b082      	sub	sp, #8
 800efb2:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 800efb4:	9b01      	ldr	r3, [sp, #4]
 800efb6:	2b00      	cmp	r3, #0
 800efb8:	bf14      	ite	ne
 800efba:	2300      	movne	r3, #0
 800efbc:	2301      	moveq	r3, #1
 800efbe:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800efc0:	4618      	mov	r0, r3
 800efc2:	b002      	add	sp, #8
 800efc4:	4770      	bx	lr
 800efc6:	bf00      	nop
 800efc8:	f3af 8000 	nop.w
 800efcc:	f3af 8000 	nop.w

0800efd0 <port_is_isr_context.4222.4400>:
 *
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
 800efd0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800efd2:	f3ef 8305 	mrs	r3, IPSR
 800efd6:	9301      	str	r3, [sp, #4]
  return(result);
 800efd8:	9b01      	ldr	r3, [sp, #4]

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 800efda:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800efde:	2b00      	cmp	r3, #0
 800efe0:	bf0c      	ite	eq
 800efe2:	2300      	moveq	r3, #0
 800efe4:	2301      	movne	r3, #1
 800efe6:	b2db      	uxtb	r3, r3
}
 800efe8:	4618      	mov	r0, r3
 800efea:	b002      	add	sp, #8
 800efec:	4770      	bx	lr
 800efee:	bf00      	nop

0800eff0 <port_lock.4224.4398>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800eff0:	b082      	sub	sp, #8
 800eff2:	2320      	movs	r3, #32
 800eff4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800eff6:	9b01      	ldr	r3, [sp, #4]
 800eff8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800effc:	b002      	add	sp, #8
 800effe:	4770      	bx	lr

0800f000 <port_unlock.4226.4396>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800f000:	b082      	sub	sp, #8
 800f002:	2300      	movs	r3, #0
 800f004:	9301      	str	r3, [sp, #4]
 800f006:	9b01      	ldr	r3, [sp, #4]
 800f008:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f00c:	b002      	add	sp, #8
 800f00e:	4770      	bx	lr

0800f010 <port_lock_from_isr.4228.4394>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800f010:	b508      	push	{r3, lr}

  port_lock();
 800f012:	f7ff ffed 	bl	800eff0 <port_lock.4224.4398>
}
 800f016:	bd08      	pop	{r3, pc}
 800f018:	f3af 8000 	nop.w
 800f01c:	f3af 8000 	nop.w

0800f020 <port_unlock_from_isr.4230.4392>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800f020:	b508      	push	{r3, lr}

  port_unlock();
 800f022:	f7ff ffed 	bl	800f000 <port_unlock.4226.4396>
}
 800f026:	bd08      	pop	{r3, pc}
 800f028:	f3af 8000 	nop.w
 800f02c:	f3af 8000 	nop.w

0800f030 <port_disable.4232.4390>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800f030:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 800f032:	4770      	bx	lr
 800f034:	f3af 8000 	nop.w
 800f038:	f3af 8000 	nop.w
 800f03c:	f3af 8000 	nop.w

0800f040 <port_enable.4234.4388>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 800f040:	b082      	sub	sp, #8
 800f042:	2300      	movs	r3, #0
 800f044:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800f046:	9b01      	ldr	r3, [sp, #4]
 800f048:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800f04c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800f04e:	b002      	add	sp, #8
 800f050:	4770      	bx	lr
 800f052:	bf00      	nop
 800f054:	f3af 8000 	nop.w
 800f058:	f3af 8000 	nop.w
 800f05c:	f3af 8000 	nop.w

0800f060 <port_wait_for_interrupt.4236.4386>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 800f060:	4770      	bx	lr
 800f062:	bf00      	nop
 800f064:	f3af 8000 	nop.w
 800f068:	f3af 8000 	nop.w
 800f06c:	f3af 8000 	nop.w

0800f070 <port_rt_get_counter_value.4238.4384>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 800f070:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800f074:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800f078:	685b      	ldr	r3, [r3, #4]
}
 800f07a:	4618      	mov	r0, r3
 800f07c:	4770      	bx	lr
 800f07e:	bf00      	nop

0800f080 <st_lld_get_counter.4241.4382>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800f080:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800f084:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800f086:	4618      	mov	r0, r3
 800f088:	4770      	bx	lr
 800f08a:	bf00      	nop
 800f08c:	f3af 8000 	nop.w

0800f090 <port_timer_stop_alarm.4343.4380>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 800f090:	b508      	push	{r3, lr}

  stStopAlarm();
 800f092:	f7fc fd65 	bl	800bb60 <stStopAlarm>
}
 800f096:	bd08      	pop	{r3, pc}
 800f098:	f3af 8000 	nop.w
 800f09c:	f3af 8000 	nop.w

0800f0a0 <port_timer_set_alarm.4349.4377>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 800f0a0:	b500      	push	{lr}
 800f0a2:	b083      	sub	sp, #12
 800f0a4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 800f0a6:	9801      	ldr	r0, [sp, #4]
 800f0a8:	f7fc fd62 	bl	800bb70 <stSetAlarm>
}
 800f0ac:	b003      	add	sp, #12
 800f0ae:	f85d fb04 	ldr.w	pc, [sp], #4
 800f0b2:	bf00      	nop
 800f0b4:	f3af 8000 	nop.w
 800f0b8:	f3af 8000 	nop.w
 800f0bc:	f3af 8000 	nop.w

0800f0c0 <port_timer_get_time.4244.4375>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800f0c0:	b508      	push	{r3, lr}

  return stGetCounter();
 800f0c2:	f7ff ffdd 	bl	800f080 <st_lld_get_counter.4241.4382>
 800f0c6:	4603      	mov	r3, r0
}
 800f0c8:	4618      	mov	r0, r3
 800f0ca:	bd08      	pop	{r3, pc}
 800f0cc:	f3af 8000 	nop.w

0800f0d0 <chSysEnable.4341.4373>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 800f0d0:	b508      	push	{r3, lr}

  _dbg_check_enable();
 800f0d2:	f000 faed 	bl	800f6b0 <_dbg_check_enable>
  port_enable();
 800f0d6:	f7ff ffb3 	bl	800f040 <port_enable.4234.4388>
}
 800f0da:	bd08      	pop	{r3, pc}
 800f0dc:	f3af 8000 	nop.w

0800f0e0 <chSysLock.4352.4371>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800f0e0:	b508      	push	{r3, lr}

  port_lock();
 800f0e2:	f7ff ff85 	bl	800eff0 <port_lock.4224.4398>
  _stats_start_measure_crit_thd();
 800f0e6:	f7fe ff4b 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800f0ea:	f000 faf9 	bl	800f6e0 <_dbg_check_lock>
}
 800f0ee:	bd08      	pop	{r3, pc}

0800f0f0 <chSysUnlock.4361.4369>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800f0f0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800f0f2:	f000 fb15 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800f0f6:	f7fe ff4b 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800f0fa:	f640 5350 	movw	r3, #3408	; 0xd50
 800f0fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f102:	681a      	ldr	r2, [r3, #0]
 800f104:	f640 5350 	movw	r3, #3408	; 0xd50
 800f108:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f10c:	429a      	cmp	r2, r3
 800f10e:	d013      	beq.n	800f138 <chSysUnlock.4361.4369+0x48>
 800f110:	f640 5350 	movw	r3, #3408	; 0xd50
 800f114:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f118:	699b      	ldr	r3, [r3, #24]
 800f11a:	689a      	ldr	r2, [r3, #8]
 800f11c:	f640 5350 	movw	r3, #3408	; 0xd50
 800f120:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f124:	681b      	ldr	r3, [r3, #0]
 800f126:	689b      	ldr	r3, [r3, #8]
 800f128:	429a      	cmp	r2, r3
 800f12a:	d205      	bcs.n	800f138 <chSysUnlock.4361.4369+0x48>
 800f12c:	f241 6040 	movw	r0, #5696	; 0x1640
 800f130:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f134:	f000 f92c 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800f138:	f7ff ff62 	bl	800f000 <port_unlock.4226.4396>
}
 800f13c:	bd08      	pop	{r3, pc}
 800f13e:	bf00      	nop

0800f140 <chSysLockFromISR.4347.4367>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800f140:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800f142:	f7ff ff65 	bl	800f010 <port_lock_from_isr.4228.4394>
  _stats_start_measure_crit_isr();
 800f146:	f7fe ff2b 	bl	800dfa0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800f14a:	f000 fb09 	bl	800f760 <_dbg_check_lock_from_isr>
}
 800f14e:	bd08      	pop	{r3, pc}

0800f150 <chSysUnlockFromISR.4345.4365>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800f150:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 800f152:	f000 fb25 	bl	800f7a0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 800f156:	f7fe ff2b 	bl	800dfb0 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800f15a:	f7ff ff61 	bl	800f020 <port_unlock_from_isr.4230.4392>
}
 800f15e:	bd08      	pop	{r3, pc}

0800f160 <chVTGetSystemTimeX.4246.4363>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800f160:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800f162:	f7ff ffad 	bl	800f0c0 <port_timer_get_time.4244.4375>
 800f166:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800f168:	4618      	mov	r0, r3
 800f16a:	bd08      	pop	{r3, pc}
 800f16c:	f3af 8000 	nop.w

0800f170 <chVTDoTickI.4359.4361>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 800f170:	b500      	push	{lr}
 800f172:	b085      	sub	sp, #20

  chDbgCheckClassI();
 800f174:	f000 fb84 	bl	800f880 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 800f178:	f640 5350 	movw	r3, #3408	; 0xd50
 800f17c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f180:	69db      	ldr	r3, [r3, #28]
 800f182:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 800f184:	f7ff ffec 	bl	800f160 <chVTGetSystemTimeX.4246.4363>
 800f188:	9002      	str	r0, [sp, #8]
 800f18a:	e039      	b.n	800f200 <chVTDoTickI.4359.4361+0x90>
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 800f18c:	f640 5350 	movw	r3, #3408	; 0xd50
 800f190:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f194:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800f196:	9b03      	ldr	r3, [sp, #12]
 800f198:	689b      	ldr	r3, [r3, #8]
 800f19a:	441a      	add	r2, r3
 800f19c:	f640 5350 	movw	r3, #3408	; 0xd50
 800f1a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f1a4:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800f1a6:	9b03      	ldr	r3, [sp, #12]
 800f1a8:	681b      	ldr	r3, [r3, #0]
 800f1aa:	4a38      	ldr	r2, [pc, #224]	; (800f28c <chVTDoTickI.4359.4361+0x11c>)
 800f1ac:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 800f1ae:	9b03      	ldr	r3, [sp, #12]
 800f1b0:	681a      	ldr	r2, [r3, #0]
 800f1b2:	f640 5350 	movw	r3, #3408	; 0xd50
 800f1b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f1ba:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
 800f1bc:	9b03      	ldr	r3, [sp, #12]
 800f1be:	68db      	ldr	r3, [r3, #12]
 800f1c0:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
 800f1c2:	9b03      	ldr	r3, [sp, #12]
 800f1c4:	2200      	movs	r2, #0
 800f1c6:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800f1c8:	f640 5350 	movw	r3, #3408	; 0xd50
 800f1cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f1d0:	69da      	ldr	r2, [r3, #28]
 800f1d2:	4b2e      	ldr	r3, [pc, #184]	; (800f28c <chVTDoTickI.4359.4361+0x11c>)
 800f1d4:	429a      	cmp	r2, r3
 800f1d6:	d101      	bne.n	800f1dc <chVTDoTickI.4359.4361+0x6c>
      port_timer_stop_alarm();
 800f1d8:	f7ff ff5a 	bl	800f090 <port_timer_stop_alarm.4343.4380>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 800f1dc:	f7ff ffb8 	bl	800f150 <chSysUnlockFromISR.4345.4365>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 800f1e0:	9b03      	ldr	r3, [sp, #12]
 800f1e2:	691a      	ldr	r2, [r3, #16]
 800f1e4:	9b00      	ldr	r3, [sp, #0]
 800f1e6:	4610      	mov	r0, r2
 800f1e8:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 800f1ea:	f7ff ffa9 	bl	800f140 <chSysLockFromISR.4347.4367>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 800f1ee:	f640 5350 	movw	r3, #3408	; 0xd50
 800f1f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f1f6:	69db      	ldr	r3, [r3, #28]
 800f1f8:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 800f1fa:	f7ff ffb1 	bl	800f160 <chVTGetSystemTimeX.4246.4363>
 800f1fe:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 800f200:	9b03      	ldr	r3, [sp, #12]
 800f202:	689a      	ldr	r2, [r3, #8]
 800f204:	f640 5350 	movw	r3, #3408	; 0xd50
 800f208:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f20c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f20e:	9902      	ldr	r1, [sp, #8]
 800f210:	1acb      	subs	r3, r1, r3
 800f212:	429a      	cmp	r2, r3
 800f214:	d9ba      	bls.n	800f18c <chVTDoTickI.4359.4361+0x1c>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800f216:	f640 5350 	movw	r3, #3408	; 0xd50
 800f21a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f21e:	69da      	ldr	r2, [r3, #28]
 800f220:	4b1a      	ldr	r3, [pc, #104]	; (800f28c <chVTDoTickI.4359.4361+0x11c>)
 800f222:	429a      	cmp	r2, r3
 800f224:	d02f      	beq.n	800f286 <chVTDoTickI.4359.4361+0x116>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 800f226:	f640 5350 	movw	r3, #3408	; 0xd50
 800f22a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f22e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800f230:	9b03      	ldr	r3, [sp, #12]
 800f232:	689b      	ldr	r3, [r3, #8]
 800f234:	441a      	add	r2, r3
 800f236:	9b02      	ldr	r3, [sp, #8]
 800f238:	1ad3      	subs	r3, r2, r3
 800f23a:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800f23c:	9b01      	ldr	r3, [sp, #4]
 800f23e:	2b01      	cmp	r3, #1
 800f240:	d801      	bhi.n	800f246 <chVTDoTickI.4359.4361+0xd6>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800f242:	2302      	movs	r3, #2
 800f244:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 800f246:	9a02      	ldr	r2, [sp, #8]
 800f248:	9b01      	ldr	r3, [sp, #4]
 800f24a:	4413      	add	r3, r2
 800f24c:	4618      	mov	r0, r3
 800f24e:	f7ff ff27 	bl	800f0a0 <port_timer_set_alarm.4349.4377>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
 800f252:	f7ff ff85 	bl	800f160 <chVTGetSystemTimeX.4246.4363>
 800f256:	4602      	mov	r2, r0
 800f258:	f640 5350 	movw	r3, #3408	; 0xd50
 800f25c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f260:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f262:	1ad2      	subs	r2, r2, r3
 800f264:	9902      	ldr	r1, [sp, #8]
 800f266:	9b01      	ldr	r3, [sp, #4]
 800f268:	4419      	add	r1, r3
 800f26a:	f640 5350 	movw	r3, #3408	; 0xd50
 800f26e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f272:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f274:	1acb      	subs	r3, r1, r3
 800f276:	429a      	cmp	r2, r3
 800f278:	d905      	bls.n	800f286 <chVTDoTickI.4359.4361+0x116>
 800f27a:	f241 6030 	movw	r0, #5680	; 0x1630
 800f27e:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f282:	f000 f885 	bl	800f390 <chSysHalt>
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800f286:	b005      	add	sp, #20
 800f288:	f85d fb04 	ldr.w	pc, [sp], #4
 800f28c:	20000d6c 	.word	0x20000d6c

0800f290 <chRegSetThreadName.4248.4358>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 800f290:	b082      	sub	sp, #8
 800f292:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 800f294:	f640 5350 	movw	r3, #3408	; 0xd50
 800f298:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f29c:	699b      	ldr	r3, [r3, #24]
 800f29e:	9a01      	ldr	r2, [sp, #4]
 800f2a0:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800f2a2:	b002      	add	sp, #8
 800f2a4:	4770      	bx	lr
 800f2a6:	bf00      	nop
 800f2a8:	f3af 8000 	nop.w
 800f2ac:	f3af 8000 	nop.w

0800f2b0 <chRegSetThreadNameX.4252.4354>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 800f2b0:	b082      	sub	sp, #8
 800f2b2:	9001      	str	r0, [sp, #4]
 800f2b4:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 800f2b6:	9b01      	ldr	r3, [sp, #4]
 800f2b8:	9a00      	ldr	r2, [sp, #0]
 800f2ba:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800f2bc:	b002      	add	sp, #8
 800f2be:	4770      	bx	lr

0800f2c0 <_idle_thread.4338.4351>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 800f2c0:	b500      	push	{lr}
 800f2c2:	b083      	sub	sp, #12
 800f2c4:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 800f2c6:	f7ff fecb 	bl	800f060 <port_wait_for_interrupt.4236.4386>
 800f2ca:	e7fc      	b.n	800f2c6 <_idle_thread.4338.4351+0x6>
 800f2cc:	f3af 8000 	nop.w

0800f2d0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 800f2d0:	b500      	push	{lr}
 800f2d2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 800f2d4:	f7ff fe2c 	bl	800ef30 <port_init.4213.4407>
  _scheduler_init();
 800f2d8:	f000 fda2 	bl	800fe20 <_scheduler_init.4218>
  _vt_init();
 800f2dc:	f000 fb98 	bl	800fa10 <_vt_init.4269>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 800f2e0:	f7fe fd5e 	bl	800dda0 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 800f2e4:	f7fc f854 	bl	800b390 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 800f2e8:	f7fc f8ca 	bl	800b480 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
 800f2ec:	f7fe fdf0 	bl	800ded0 <_stats_init>
#endif
#if CH_DBG_ENABLE_TRACE == TRUE
  _dbg_trace_init();
 800f2f0:	f000 faf6 	bl	800f8e0 <_dbg_trace_init.4289>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800f2f4:	4821      	ldr	r0, [pc, #132]	; (800f37c <chSysInit+0xac>)
 800f2f6:	2140      	movs	r1, #64	; 0x40
 800f2f8:	f001 f98a 	bl	8010610 <_thread_init.4122>
 800f2fc:	4602      	mov	r2, r0
 800f2fe:	f640 5350 	movw	r3, #3408	; 0xd50
 800f302:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f306:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800f308:	f640 5350 	movw	r3, #3408	; 0xd50
 800f30c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f310:	699b      	ldr	r3, [r3, #24]
 800f312:	2201      	movs	r2, #1
 800f314:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 800f318:	f640 5350 	movw	r3, #3408	; 0xd50
 800f31c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f320:	699a      	ldr	r2, [r3, #24]
 800f322:	f240 4300 	movw	r3, #1024	; 0x400
 800f326:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f32a:	61d3      	str	r3, [r2, #28]
#endif

#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
 800f32c:	f640 5350 	movw	r3, #3408	; 0xd50
 800f330:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f334:	699b      	ldr	r3, [r3, #24]
 800f336:	3348      	adds	r3, #72	; 0x48
 800f338:	4618      	mov	r0, r3
 800f33a:	f7fe fd69 	bl	800de10 <chTMStartMeasurementX>
#endif

  chSysEnable();
 800f33e:	f7ff fec7 	bl	800f0d0 <chSysEnable.4341.4373>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 800f342:	f241 70a0 	movw	r0, #6048	; 0x17a0
 800f346:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f34a:	f7ff ffa1 	bl	800f290 <chRegSetThreadName.4248.4358>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 800f34e:	2300      	movs	r3, #0
 800f350:	9300      	str	r3, [sp, #0]
 800f352:	480b      	ldr	r0, [pc, #44]	; (800f380 <chSysInit+0xb0>)
 800f354:	21f8      	movs	r1, #248	; 0xf8
 800f356:	2201      	movs	r2, #1
 800f358:	f24f 23c1 	movw	r3, #62145	; 0xf2c1
 800f35c:	f6c0 0300 	movt	r3, #2048	; 0x800
 800f360:	f001 f9fe 	bl	8010760 <chThdCreateStatic>
 800f364:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 800f366:	9803      	ldr	r0, [sp, #12]
 800f368:	f640 71b0 	movw	r1, #4016	; 0xfb0
 800f36c:	f6c0 0101 	movt	r1, #2049	; 0x801
 800f370:	f7ff ff9e 	bl	800f2b0 <chRegSetThreadNameX.4252.4354>
  }
#endif
}
 800f374:	b005      	add	sp, #20
 800f376:	f85d fb04 	ldr.w	pc, [sp], #4
 800f37a:	bf00      	nop
 800f37c:	20001190 	.word	0x20001190
 800f380:	20001230 	.word	0x20001230
 800f384:	f3af 8000 	nop.w
 800f388:	f3af 8000 	nop.w
 800f38c:	f3af 8000 	nop.w

0800f390 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 800f390:	b500      	push	{lr}
 800f392:	b083      	sub	sp, #12
 800f394:	9001      	str	r0, [sp, #4]

  port_disable();
 800f396:	f7ff fe4b 	bl	800f030 <port_disable.4232.4390>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800f39a:	f640 5350 	movw	r3, #3408	; 0xd50
 800f39e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f3a2:	9a01      	ldr	r2, [sp, #4]
 800f3a4:	62da      	str	r2, [r3, #44]	; 0x2c
 800f3a6:	e7fe      	b.n	800f3a6 <chSysHalt+0x16>
 800f3a8:	f3af 8000 	nop.w
 800f3ac:	f3af 8000 	nop.w

0800f3b0 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 800f3b0:	b500      	push	{lr}
 800f3b2:	b087      	sub	sp, #28
 800f3b4:	9001      	str	r0, [sp, #4]
  cnt_t n;

  chDbgCheckClassI();
 800f3b6:	f000 fa63 	bl	800f880 <chDbgCheckClassI>

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 800f3ba:	9b01      	ldr	r3, [sp, #4]
 800f3bc:	f003 0301 	and.w	r3, r3, #1
 800f3c0:	2b00      	cmp	r3, #0
 800f3c2:	d02e      	beq.n	800f422 <chSysIntegrityCheckI+0x72>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800f3c4:	2300      	movs	r3, #0
 800f3c6:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_queue.p_next;
 800f3c8:	f640 5350 	movw	r3, #3408	; 0xd50
 800f3cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f3d0:	681b      	ldr	r3, [r3, #0]
 800f3d2:	9304      	str	r3, [sp, #16]
 800f3d4:	e005      	b.n	800f3e2 <chSysIntegrityCheckI+0x32>
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n++;
 800f3d6:	9b05      	ldr	r3, [sp, #20]
 800f3d8:	3301      	adds	r3, #1
 800f3da:	9305      	str	r3, [sp, #20]
      tp = tp->p_next;
 800f3dc:	9b04      	ldr	r3, [sp, #16]
 800f3de:	681b      	ldr	r3, [r3, #0]
 800f3e0:	9304      	str	r3, [sp, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800f3e2:	9a04      	ldr	r2, [sp, #16]
 800f3e4:	f640 5350 	movw	r3, #3408	; 0xd50
 800f3e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f3ec:	429a      	cmp	r2, r3
 800f3ee:	d1f2      	bne.n	800f3d6 <chSysIntegrityCheckI+0x26>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 800f3f0:	f640 5350 	movw	r3, #3408	; 0xd50
 800f3f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f3f8:	685b      	ldr	r3, [r3, #4]
 800f3fa:	9304      	str	r3, [sp, #16]
 800f3fc:	e005      	b.n	800f40a <chSysIntegrityCheckI+0x5a>
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n--;
 800f3fe:	9b05      	ldr	r3, [sp, #20]
 800f400:	3b01      	subs	r3, #1
 800f402:	9305      	str	r3, [sp, #20]
      tp = tp->p_prev;
 800f404:	9b04      	ldr	r3, [sp, #16]
 800f406:	685b      	ldr	r3, [r3, #4]
 800f408:	9304      	str	r3, [sp, #16]
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800f40a:	9a04      	ldr	r2, [sp, #16]
 800f40c:	f640 5350 	movw	r3, #3408	; 0xd50
 800f410:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f414:	429a      	cmp	r2, r3
 800f416:	d1f2      	bne.n	800f3fe <chSysIntegrityCheckI+0x4e>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800f418:	9b05      	ldr	r3, [sp, #20]
 800f41a:	2b00      	cmp	r3, #0
 800f41c:	d001      	beq.n	800f422 <chSysIntegrityCheckI+0x72>
      return true;
 800f41e:	2301      	movs	r3, #1
 800f420:	e062      	b.n	800f4e8 <chSysIntegrityCheckI+0x138>
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 800f422:	9b01      	ldr	r3, [sp, #4]
 800f424:	f003 0302 	and.w	r3, r3, #2
 800f428:	2b00      	cmp	r3, #0
 800f42a:	d028      	beq.n	800f47e <chSysIntegrityCheckI+0xce>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 800f42c:	2300      	movs	r3, #0
 800f42e:	9305      	str	r3, [sp, #20]
    vtp = ch.vtlist.vt_next;
 800f430:	f640 5350 	movw	r3, #3408	; 0xd50
 800f434:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f438:	69db      	ldr	r3, [r3, #28]
 800f43a:	9303      	str	r3, [sp, #12]
 800f43c:	e005      	b.n	800f44a <chSysIntegrityCheckI+0x9a>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n++;
 800f43e:	9b05      	ldr	r3, [sp, #20]
 800f440:	3301      	adds	r3, #1
 800f442:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_next;
 800f444:	9b03      	ldr	r3, [sp, #12]
 800f446:	681b      	ldr	r3, [r3, #0]
 800f448:	9303      	str	r3, [sp, #12]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800f44a:	9a03      	ldr	r2, [sp, #12]
 800f44c:	4b28      	ldr	r3, [pc, #160]	; (800f4f0 <chSysIntegrityCheckI+0x140>)
 800f44e:	429a      	cmp	r2, r3
 800f450:	d1f5      	bne.n	800f43e <chSysIntegrityCheckI+0x8e>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 800f452:	f640 5350 	movw	r3, #3408	; 0xd50
 800f456:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f45a:	6a1b      	ldr	r3, [r3, #32]
 800f45c:	9303      	str	r3, [sp, #12]
 800f45e:	e005      	b.n	800f46c <chSysIntegrityCheckI+0xbc>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n--;
 800f460:	9b05      	ldr	r3, [sp, #20]
 800f462:	3b01      	subs	r3, #1
 800f464:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_prev;
 800f466:	9b03      	ldr	r3, [sp, #12]
 800f468:	685b      	ldr	r3, [r3, #4]
 800f46a:	9303      	str	r3, [sp, #12]
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800f46c:	9a03      	ldr	r2, [sp, #12]
 800f46e:	4b20      	ldr	r3, [pc, #128]	; (800f4f0 <chSysIntegrityCheckI+0x140>)
 800f470:	429a      	cmp	r2, r3
 800f472:	d1f5      	bne.n	800f460 <chSysIntegrityCheckI+0xb0>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800f474:	9b05      	ldr	r3, [sp, #20]
 800f476:	2b00      	cmp	r3, #0
 800f478:	d001      	beq.n	800f47e <chSysIntegrityCheckI+0xce>
      return true;
 800f47a:	2301      	movs	r3, #1
 800f47c:	e034      	b.n	800f4e8 <chSysIntegrityCheckI+0x138>
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800f47e:	9b01      	ldr	r3, [sp, #4]
 800f480:	f003 0304 	and.w	r3, r3, #4
 800f484:	2b00      	cmp	r3, #0
 800f486:	d02e      	beq.n	800f4e6 <chSysIntegrityCheckI+0x136>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800f488:	2300      	movs	r3, #0
 800f48a:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_newer;
 800f48c:	f640 5350 	movw	r3, #3408	; 0xd50
 800f490:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f494:	691b      	ldr	r3, [r3, #16]
 800f496:	9302      	str	r3, [sp, #8]
 800f498:	e005      	b.n	800f4a6 <chSysIntegrityCheckI+0xf6>
    while (tp != (thread_t *)&ch.rlist) {
      n++;
 800f49a:	9b05      	ldr	r3, [sp, #20]
 800f49c:	3301      	adds	r3, #1
 800f49e:	9305      	str	r3, [sp, #20]
      tp = tp->p_newer;
 800f4a0:	9b02      	ldr	r3, [sp, #8]
 800f4a2:	691b      	ldr	r3, [r3, #16]
 800f4a4:	9302      	str	r3, [sp, #8]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 800f4a6:	9a02      	ldr	r2, [sp, #8]
 800f4a8:	f640 5350 	movw	r3, #3408	; 0xd50
 800f4ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f4b0:	429a      	cmp	r2, r3
 800f4b2:	d1f2      	bne.n	800f49a <chSysIntegrityCheckI+0xea>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 800f4b4:	f640 5350 	movw	r3, #3408	; 0xd50
 800f4b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f4bc:	695b      	ldr	r3, [r3, #20]
 800f4be:	9302      	str	r3, [sp, #8]
 800f4c0:	e005      	b.n	800f4ce <chSysIntegrityCheckI+0x11e>
    while (tp != (thread_t *)&ch.rlist) {
      n--;
 800f4c2:	9b05      	ldr	r3, [sp, #20]
 800f4c4:	3b01      	subs	r3, #1
 800f4c6:	9305      	str	r3, [sp, #20]
      tp = tp->p_older;
 800f4c8:	9b02      	ldr	r3, [sp, #8]
 800f4ca:	695b      	ldr	r3, [r3, #20]
 800f4cc:	9302      	str	r3, [sp, #8]
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 800f4ce:	9a02      	ldr	r2, [sp, #8]
 800f4d0:	f640 5350 	movw	r3, #3408	; 0xd50
 800f4d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f4d8:	429a      	cmp	r2, r3
 800f4da:	d1f2      	bne.n	800f4c2 <chSysIntegrityCheckI+0x112>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800f4dc:	9b05      	ldr	r3, [sp, #20]
 800f4de:	2b00      	cmp	r3, #0
 800f4e0:	d001      	beq.n	800f4e6 <chSysIntegrityCheckI+0x136>
      return true;
 800f4e2:	2301      	movs	r3, #1
 800f4e4:	e000      	b.n	800f4e8 <chSysIntegrityCheckI+0x138>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 800f4e6:	2300      	movs	r3, #0
}
 800f4e8:	4618      	mov	r0, r3
 800f4ea:	b007      	add	sp, #28
 800f4ec:	f85d fb04 	ldr.w	pc, [sp], #4
 800f4f0:	20000d6c 	.word	0x20000d6c
 800f4f4:	f3af 8000 	nop.w
 800f4f8:	f3af 8000 	nop.w
 800f4fc:	f3af 8000 	nop.w

0800f500 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 800f500:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 800f502:	f000 f9bd 	bl	800f880 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 800f506:	f7ff fe33 	bl	800f170 <chVTDoTickI.4359.4361>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 800f50a:	bd08      	pop	{r3, pc}
 800f50c:	f3af 8000 	nop.w

0800f510 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 800f510:	b500      	push	{lr}
 800f512:	b083      	sub	sp, #12

  syssts_t sts = port_get_irq_status();
 800f514:	f7ff fd3c 	bl	800ef90 <port_get_irq_status.4215.4405>
 800f518:	9001      	str	r0, [sp, #4]
  if (port_irq_enabled(sts)) {
 800f51a:	9801      	ldr	r0, [sp, #4]
 800f51c:	f7ff fd48 	bl	800efb0 <port_irq_enabled.4218.4402>
 800f520:	4603      	mov	r3, r0
 800f522:	2b00      	cmp	r3, #0
 800f524:	d009      	beq.n	800f53a <chSysGetStatusAndLockX+0x2a>
    if (port_is_isr_context()) {
 800f526:	f7ff fd53 	bl	800efd0 <port_is_isr_context.4222.4400>
 800f52a:	4603      	mov	r3, r0
 800f52c:	2b00      	cmp	r3, #0
 800f52e:	d002      	beq.n	800f536 <chSysGetStatusAndLockX+0x26>
      chSysLockFromISR();
 800f530:	f7ff fe06 	bl	800f140 <chSysLockFromISR.4347.4367>
 800f534:	e001      	b.n	800f53a <chSysGetStatusAndLockX+0x2a>
    }
    else {
      chSysLock();
 800f536:	f7ff fdd3 	bl	800f0e0 <chSysLock.4352.4371>
    }
  }
  return sts;
 800f53a:	9b01      	ldr	r3, [sp, #4]
}
 800f53c:	4618      	mov	r0, r3
 800f53e:	b003      	add	sp, #12
 800f540:	f85d fb04 	ldr.w	pc, [sp], #4
 800f544:	f3af 8000 	nop.w
 800f548:	f3af 8000 	nop.w
 800f54c:	f3af 8000 	nop.w

0800f550 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 800f550:	b500      	push	{lr}
 800f552:	b083      	sub	sp, #12
 800f554:	9001      	str	r0, [sp, #4]

  if (port_irq_enabled(sts)) {
 800f556:	9801      	ldr	r0, [sp, #4]
 800f558:	f7ff fd2a 	bl	800efb0 <port_irq_enabled.4218.4402>
 800f55c:	4603      	mov	r3, r0
 800f55e:	2b00      	cmp	r3, #0
 800f560:	d00b      	beq.n	800f57a <chSysRestoreStatusX+0x2a>
    if (port_is_isr_context()) {
 800f562:	f7ff fd35 	bl	800efd0 <port_is_isr_context.4222.4400>
 800f566:	4603      	mov	r3, r0
 800f568:	2b00      	cmp	r3, #0
 800f56a:	d002      	beq.n	800f572 <chSysRestoreStatusX+0x22>
      chSysUnlockFromISR();
 800f56c:	f7ff fdf0 	bl	800f150 <chSysUnlockFromISR.4345.4365>
 800f570:	e003      	b.n	800f57a <chSysRestoreStatusX+0x2a>
    }
    else {
      chSchRescheduleS();
 800f572:	f000 fdf5 	bl	8010160 <chSchRescheduleS>
      chSysUnlock();
 800f576:	f7ff fdbb 	bl	800f0f0 <chSysUnlock.4361.4369>
    }
  }
}
 800f57a:	b003      	add	sp, #12
 800f57c:	f85d fb04 	ldr.w	pc, [sp], #4

0800f580 <chSysIsCounterWithinX.4330>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 800f580:	b084      	sub	sp, #16
 800f582:	9003      	str	r0, [sp, #12]
 800f584:	9102      	str	r1, [sp, #8]
 800f586:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 800f588:	9a03      	ldr	r2, [sp, #12]
 800f58a:	9b02      	ldr	r3, [sp, #8]
 800f58c:	1ad2      	subs	r2, r2, r3
 800f58e:	9901      	ldr	r1, [sp, #4]
 800f590:	9b02      	ldr	r3, [sp, #8]
 800f592:	1acb      	subs	r3, r1, r3
 800f594:	429a      	cmp	r2, r3
 800f596:	bf2c      	ite	cs
 800f598:	2300      	movcs	r3, #0
 800f59a:	2301      	movcc	r3, #1
 800f59c:	b2db      	uxtb	r3, r3
}
 800f59e:	4618      	mov	r0, r3
 800f5a0:	b004      	add	sp, #16
 800f5a2:	4770      	bx	lr
 800f5a4:	f3af 8000 	nop.w
 800f5a8:	f3af 8000 	nop.w
 800f5ac:	f3af 8000 	nop.w

0800f5b0 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 800f5b0:	b500      	push	{lr}
 800f5b2:	b085      	sub	sp, #20
 800f5b4:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 800f5b6:	f7ff fd5b 	bl	800f070 <port_rt_get_counter_value.4238.4384>
 800f5ba:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800f5bc:	9a03      	ldr	r2, [sp, #12]
 800f5be:	9b01      	ldr	r3, [sp, #4]
 800f5c0:	4413      	add	r3, r2
 800f5c2:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 800f5c4:	f7ff fd54 	bl	800f070 <port_rt_get_counter_value.4238.4384>
 800f5c8:	4603      	mov	r3, r0
 800f5ca:	4618      	mov	r0, r3
 800f5cc:	9903      	ldr	r1, [sp, #12]
 800f5ce:	9a02      	ldr	r2, [sp, #8]
 800f5d0:	f7ff ffd6 	bl	800f580 <chSysIsCounterWithinX.4330>
 800f5d4:	4603      	mov	r3, r0
 800f5d6:	2b00      	cmp	r3, #0
 800f5d8:	d1f4      	bne.n	800f5c4 <chSysPolledDelayX+0x14>
  }
}
 800f5da:	b005      	add	sp, #20
 800f5dc:	f85d fb04 	ldr.w	pc, [sp], #4

0800f5e0 <port_lock.4605.4325>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800f5e0:	b082      	sub	sp, #8
 800f5e2:	2320      	movs	r3, #32
 800f5e4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800f5e6:	9b01      	ldr	r3, [sp, #4]
 800f5e8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f5ec:	b002      	add	sp, #8
 800f5ee:	4770      	bx	lr

0800f5f0 <port_unlock.4608.4323>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800f5f0:	b082      	sub	sp, #8
 800f5f2:	2300      	movs	r3, #0
 800f5f4:	9301      	str	r3, [sp, #4]
 800f5f6:	9b01      	ldr	r3, [sp, #4]
 800f5f8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f5fc:	b002      	add	sp, #8
 800f5fe:	4770      	bx	lr

0800f600 <port_lock_from_isr.4610.4321>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800f600:	b508      	push	{r3, lr}

  port_lock();
 800f602:	f7ff ffed 	bl	800f5e0 <port_lock.4605.4325>
}
 800f606:	bd08      	pop	{r3, pc}
 800f608:	f3af 8000 	nop.w
 800f60c:	f3af 8000 	nop.w

0800f610 <port_unlock_from_isr.4612.4319>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800f610:	b508      	push	{r3, lr}

  port_unlock();
 800f612:	f7ff ffed 	bl	800f5f0 <port_unlock.4608.4323>
}
 800f616:	bd08      	pop	{r3, pc}
 800f618:	f3af 8000 	nop.w
 800f61c:	f3af 8000 	nop.w

0800f620 <st_lld_get_counter.4614.4317>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800f620:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800f624:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800f626:	4618      	mov	r0, r3
 800f628:	4770      	bx	lr
 800f62a:	bf00      	nop
 800f62c:	f3af 8000 	nop.w

0800f630 <port_timer_get_time.4619.4315>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800f630:	b508      	push	{r3, lr}

  return stGetCounter();
 800f632:	f7ff fff5 	bl	800f620 <st_lld_get_counter.4614.4317>
 800f636:	4603      	mov	r3, r0
}
 800f638:	4618      	mov	r0, r3
 800f63a:	bd08      	pop	{r3, pc}
 800f63c:	f3af 8000 	nop.w

0800f640 <chVTGetSystemTimeX.4621.4313>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800f640:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800f642:	f7ff fff5 	bl	800f630 <port_timer_get_time.4619.4315>
 800f646:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800f648:	4618      	mov	r0, r3
 800f64a:	bd08      	pop	{r3, pc}
 800f64c:	f3af 8000 	nop.w

0800f650 <_dbg_check_disable>:
/**
 * @brief   Guard code for @p chSysDisable().
 *
 * @notapi
 */
void _dbg_check_disable(void) {
 800f650:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f652:	f640 5350 	movw	r3, #3408	; 0xd50
 800f656:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f65a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f65c:	2b00      	cmp	r3, #0
 800f65e:	d106      	bne.n	800f66e <_dbg_check_disable+0x1e>
 800f660:	f640 5350 	movw	r3, #3408	; 0xd50
 800f664:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f668:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f66a:	2b00      	cmp	r3, #0
 800f66c:	d005      	beq.n	800f67a <_dbg_check_disable+0x2a>
    chSysHalt("SV#1");
 800f66e:	f640 70b8 	movw	r0, #4024	; 0xfb8
 800f672:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f676:	f7ff fe8b 	bl	800f390 <chSysHalt>
  }
}
 800f67a:	bd08      	pop	{r3, pc}
 800f67c:	f3af 8000 	nop.w

0800f680 <_dbg_check_suspend>:
/**
 * @brief   Guard code for @p chSysSuspend().
 *
 * @notapi
 */
void _dbg_check_suspend(void) {
 800f680:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f682:	f640 5350 	movw	r3, #3408	; 0xd50
 800f686:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f68a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f68c:	2b00      	cmp	r3, #0
 800f68e:	d106      	bne.n	800f69e <_dbg_check_suspend+0x1e>
 800f690:	f640 5350 	movw	r3, #3408	; 0xd50
 800f694:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f698:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f69a:	2b00      	cmp	r3, #0
 800f69c:	d005      	beq.n	800f6aa <_dbg_check_suspend+0x2a>
    chSysHalt("SV#2");
 800f69e:	f640 70c0 	movw	r0, #4032	; 0xfc0
 800f6a2:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f6a6:	f7ff fe73 	bl	800f390 <chSysHalt>
  }
}
 800f6aa:	bd08      	pop	{r3, pc}
 800f6ac:	f3af 8000 	nop.w

0800f6b0 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 800f6b0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f6b2:	f640 5350 	movw	r3, #3408	; 0xd50
 800f6b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f6ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f6bc:	2b00      	cmp	r3, #0
 800f6be:	d106      	bne.n	800f6ce <_dbg_check_enable+0x1e>
 800f6c0:	f640 5350 	movw	r3, #3408	; 0xd50
 800f6c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f6c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f6ca:	2b00      	cmp	r3, #0
 800f6cc:	d005      	beq.n	800f6da <_dbg_check_enable+0x2a>
    chSysHalt("SV#3");
 800f6ce:	f640 70c8 	movw	r0, #4040	; 0xfc8
 800f6d2:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f6d6:	f7ff fe5b 	bl	800f390 <chSysHalt>
  }
}
 800f6da:	bd08      	pop	{r3, pc}
 800f6dc:	f3af 8000 	nop.w

0800f6e0 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 800f6e0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f6e2:	f640 5350 	movw	r3, #3408	; 0xd50
 800f6e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f6ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f6ec:	2b00      	cmp	r3, #0
 800f6ee:	d106      	bne.n	800f6fe <_dbg_check_lock+0x1e>
 800f6f0:	f640 5350 	movw	r3, #3408	; 0xd50
 800f6f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f6f8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f6fa:	2b00      	cmp	r3, #0
 800f6fc:	d005      	beq.n	800f70a <_dbg_check_lock+0x2a>
    chSysHalt("SV#4");
 800f6fe:	f640 70d0 	movw	r0, #4048	; 0xfd0
 800f702:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f706:	f7ff fe43 	bl	800f390 <chSysHalt>
  }
  _dbg_enter_lock();
 800f70a:	f640 5350 	movw	r3, #3408	; 0xd50
 800f70e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f712:	2201      	movs	r2, #1
 800f714:	635a      	str	r2, [r3, #52]	; 0x34
}
 800f716:	bd08      	pop	{r3, pc}
 800f718:	f3af 8000 	nop.w
 800f71c:	f3af 8000 	nop.w

0800f720 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 800f720:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800f722:	f640 5350 	movw	r3, #3408	; 0xd50
 800f726:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f72a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f72c:	2b00      	cmp	r3, #0
 800f72e:	d106      	bne.n	800f73e <_dbg_check_unlock+0x1e>
 800f730:	f640 5350 	movw	r3, #3408	; 0xd50
 800f734:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f738:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f73a:	2b00      	cmp	r3, #0
 800f73c:	dc05      	bgt.n	800f74a <_dbg_check_unlock+0x2a>
    chSysHalt("SV#5");
 800f73e:	f640 70d8 	movw	r0, #4056	; 0xfd8
 800f742:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f746:	f7ff fe23 	bl	800f390 <chSysHalt>
  }
  _dbg_leave_lock();
 800f74a:	f640 5350 	movw	r3, #3408	; 0xd50
 800f74e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f752:	2200      	movs	r2, #0
 800f754:	635a      	str	r2, [r3, #52]	; 0x34
}
 800f756:	bd08      	pop	{r3, pc}
 800f758:	f3af 8000 	nop.w
 800f75c:	f3af 8000 	nop.w

0800f760 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 800f760:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f762:	f640 5350 	movw	r3, #3408	; 0xd50
 800f766:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f76a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f76c:	2b00      	cmp	r3, #0
 800f76e:	dd06      	ble.n	800f77e <_dbg_check_lock_from_isr+0x1e>
 800f770:	f640 5350 	movw	r3, #3408	; 0xd50
 800f774:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f778:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f77a:	2b00      	cmp	r3, #0
 800f77c:	d005      	beq.n	800f78a <_dbg_check_lock_from_isr+0x2a>
    chSysHalt("SV#6");
 800f77e:	f640 70e0 	movw	r0, #4064	; 0xfe0
 800f782:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f786:	f7ff fe03 	bl	800f390 <chSysHalt>
  }
  _dbg_enter_lock();
 800f78a:	f640 5350 	movw	r3, #3408	; 0xd50
 800f78e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f792:	2201      	movs	r2, #1
 800f794:	635a      	str	r2, [r3, #52]	; 0x34
}
 800f796:	bd08      	pop	{r3, pc}
 800f798:	f3af 8000 	nop.w
 800f79c:	f3af 8000 	nop.w

0800f7a0 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 800f7a0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800f7a2:	f640 5350 	movw	r3, #3408	; 0xd50
 800f7a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f7aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f7ac:	2b00      	cmp	r3, #0
 800f7ae:	dd06      	ble.n	800f7be <_dbg_check_unlock_from_isr+0x1e>
 800f7b0:	f640 5350 	movw	r3, #3408	; 0xd50
 800f7b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f7b8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f7ba:	2b00      	cmp	r3, #0
 800f7bc:	dc05      	bgt.n	800f7ca <_dbg_check_unlock_from_isr+0x2a>
    chSysHalt("SV#7");
 800f7be:	f640 70e8 	movw	r0, #4072	; 0xfe8
 800f7c2:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f7c6:	f7ff fde3 	bl	800f390 <chSysHalt>
  }
  _dbg_leave_lock();
 800f7ca:	f640 5350 	movw	r3, #3408	; 0xd50
 800f7ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f7d2:	2200      	movs	r2, #0
 800f7d4:	635a      	str	r2, [r3, #52]	; 0x34
}
 800f7d6:	bd08      	pop	{r3, pc}
 800f7d8:	f3af 8000 	nop.w
 800f7dc:	f3af 8000 	nop.w

0800f7e0 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 800f7e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800f7e2:	f7ff ff0d 	bl	800f600 <port_lock_from_isr.4610.4321>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f7e6:	f640 5350 	movw	r3, #3408	; 0xd50
 800f7ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f7ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f7f0:	2b00      	cmp	r3, #0
 800f7f2:	db06      	blt.n	800f802 <_dbg_check_enter_isr+0x22>
 800f7f4:	f640 5350 	movw	r3, #3408	; 0xd50
 800f7f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f7fc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f7fe:	2b00      	cmp	r3, #0
 800f800:	d005      	beq.n	800f80e <_dbg_check_enter_isr+0x2e>
    chSysHalt("SV#8");
 800f802:	f640 70f0 	movw	r0, #4080	; 0xff0
 800f806:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f80a:	f7ff fdc1 	bl	800f390 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800f80e:	f640 5350 	movw	r3, #3408	; 0xd50
 800f812:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f816:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f818:	1c5a      	adds	r2, r3, #1
 800f81a:	f640 5350 	movw	r3, #3408	; 0xd50
 800f81e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f822:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 800f824:	f7ff fef4 	bl	800f610 <port_unlock_from_isr.4612.4319>
}
 800f828:	bd08      	pop	{r3, pc}
 800f82a:	bf00      	nop
 800f82c:	f3af 8000 	nop.w

0800f830 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 800f830:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800f832:	f7ff fee5 	bl	800f600 <port_lock_from_isr.4610.4321>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800f836:	f640 5350 	movw	r3, #3408	; 0xd50
 800f83a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f83e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f840:	2b00      	cmp	r3, #0
 800f842:	dd06      	ble.n	800f852 <_dbg_check_leave_isr+0x22>
 800f844:	f640 5350 	movw	r3, #3408	; 0xd50
 800f848:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f84c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f84e:	2b00      	cmp	r3, #0
 800f850:	d005      	beq.n	800f85e <_dbg_check_leave_isr+0x2e>
    chSysHalt("SV#9");
 800f852:	f640 70f8 	movw	r0, #4088	; 0xff8
 800f856:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f85a:	f7ff fd99 	bl	800f390 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800f85e:	f640 5350 	movw	r3, #3408	; 0xd50
 800f862:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f866:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f868:	1e5a      	subs	r2, r3, #1
 800f86a:	f640 5350 	movw	r3, #3408	; 0xd50
 800f86e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f872:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 800f874:	f7ff fecc 	bl	800f610 <port_unlock_from_isr.4612.4319>
}
 800f878:	bd08      	pop	{r3, pc}
 800f87a:	bf00      	nop
 800f87c:	f3af 8000 	nop.w

0800f880 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 800f880:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800f882:	f640 5350 	movw	r3, #3408	; 0xd50
 800f886:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f88a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f88c:	2b00      	cmp	r3, #0
 800f88e:	db06      	blt.n	800f89e <chDbgCheckClassI+0x1e>
 800f890:	f640 5350 	movw	r3, #3408	; 0xd50
 800f894:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f898:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f89a:	2b00      	cmp	r3, #0
 800f89c:	dc05      	bgt.n	800f8aa <chDbgCheckClassI+0x2a>
    chSysHalt("SV#10");
 800f89e:	f241 0000 	movw	r0, #4096	; 0x1000
 800f8a2:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f8a6:	f7ff fd73 	bl	800f390 <chSysHalt>
  }
}
 800f8aa:	bd08      	pop	{r3, pc}
 800f8ac:	f3af 8000 	nop.w

0800f8b0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 800f8b0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800f8b2:	f640 5350 	movw	r3, #3408	; 0xd50
 800f8b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f8ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f8bc:	2b00      	cmp	r3, #0
 800f8be:	d106      	bne.n	800f8ce <chDbgCheckClassS+0x1e>
 800f8c0:	f640 5350 	movw	r3, #3408	; 0xd50
 800f8c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f8c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f8ca:	2b00      	cmp	r3, #0
 800f8cc:	dc05      	bgt.n	800f8da <chDbgCheckClassS+0x2a>
    chSysHalt("SV#11");
 800f8ce:	f241 0008 	movw	r0, #4104	; 0x1008
 800f8d2:	f6c0 0001 	movt	r0, #2049	; 0x801
 800f8d6:	f7ff fd5b 	bl	800f390 <chSysHalt>
  }
}
 800f8da:	bd08      	pop	{r3, pc}
 800f8dc:	f3af 8000 	nop.w

0800f8e0 <_dbg_trace_init.4289>:
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 800f8e0:	f640 5350 	movw	r3, #3408	; 0xd50
 800f8e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f8e8:	2240      	movs	r2, #64	; 0x40
 800f8ea:	639a      	str	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 800f8ec:	f640 5350 	movw	r3, #3408	; 0xd50
 800f8f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f8f4:	4a01      	ldr	r2, [pc, #4]	; (800f8fc <_dbg_trace_init.4289+0x1c>)
 800f8f6:	63da      	str	r2, [r3, #60]	; 0x3c
}
 800f8f8:	4770      	bx	lr
 800f8fa:	bf00      	nop
 800f8fc:	20000d90 	.word	0x20000d90

0800f900 <_dbg_trace.4285>:
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
 800f900:	b510      	push	{r4, lr}
 800f902:	b082      	sub	sp, #8
 800f904:	9001      	str	r0, [sp, #4]

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 800f906:	f640 5350 	movw	r3, #3408	; 0xd50
 800f90a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f90e:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 800f910:	f7ff fe96 	bl	800f640 <chVTGetSystemTimeX.4621.4313>
 800f914:	4603      	mov	r3, r0
 800f916:	6023      	str	r3, [r4, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
 800f918:	f640 5350 	movw	r3, #3408	; 0xd50
 800f91c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f920:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f922:	f640 5350 	movw	r3, #3408	; 0xd50
 800f926:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f92a:	699b      	ldr	r3, [r3, #24]
 800f92c:	6053      	str	r3, [r2, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 800f92e:	f640 5350 	movw	r3, #3408	; 0xd50
 800f932:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f936:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f938:	9a01      	ldr	r2, [sp, #4]
 800f93a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800f93c:	609a      	str	r2, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 800f93e:	f640 5350 	movw	r3, #3408	; 0xd50
 800f942:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f946:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f948:	9a01      	ldr	r2, [sp, #4]
 800f94a:	f892 2020 	ldrb.w	r2, [r2, #32]
 800f94e:	731a      	strb	r2, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 800f950:	f640 5350 	movw	r3, #3408	; 0xd50
 800f954:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f958:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800f95a:	f103 0210 	add.w	r2, r3, #16
 800f95e:	f640 5350 	movw	r3, #3408	; 0xd50
 800f962:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f966:	63da      	str	r2, [r3, #60]	; 0x3c
 800f968:	f640 5350 	movw	r3, #3408	; 0xd50
 800f96c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f970:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800f972:	4b05      	ldr	r3, [pc, #20]	; (800f988 <_dbg_trace.4285+0x88>)
 800f974:	429a      	cmp	r2, r3
 800f976:	d305      	bcc.n	800f984 <_dbg_trace.4285+0x84>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 800f978:	f640 5350 	movw	r3, #3408	; 0xd50
 800f97c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800f980:	4a02      	ldr	r2, [pc, #8]	; (800f98c <_dbg_trace.4285+0x8c>)
 800f982:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 800f984:	b002      	add	sp, #8
 800f986:	bd10      	pop	{r4, pc}
 800f988:	20001190 	.word	0x20001190
 800f98c:	20000d90 	.word	0x20000d90

0800f990 <st_lld_get_counter.4821.4283>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800f990:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800f994:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800f996:	4618      	mov	r0, r3
 800f998:	4770      	bx	lr
 800f99a:	bf00      	nop
 800f99c:	f3af 8000 	nop.w

0800f9a0 <port_timer_start_alarm.4831.4280>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 800f9a0:	b500      	push	{lr}
 800f9a2:	b083      	sub	sp, #12
 800f9a4:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 800f9a6:	9801      	ldr	r0, [sp, #4]
 800f9a8:	f7fc f8c2 	bl	800bb30 <stStartAlarm>
}
 800f9ac:	b003      	add	sp, #12
 800f9ae:	f85d fb04 	ldr.w	pc, [sp], #4
 800f9b2:	bf00      	nop
 800f9b4:	f3af 8000 	nop.w
 800f9b8:	f3af 8000 	nop.w
 800f9bc:	f3af 8000 	nop.w

0800f9c0 <port_timer_stop_alarm.4837.4278>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 800f9c0:	b508      	push	{r3, lr}

  stStopAlarm();
 800f9c2:	f7fc f8cd 	bl	800bb60 <stStopAlarm>
}
 800f9c6:	bd08      	pop	{r3, pc}
 800f9c8:	f3af 8000 	nop.w
 800f9cc:	f3af 8000 	nop.w

0800f9d0 <port_timer_set_alarm.4834.4275>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 800f9d0:	b500      	push	{lr}
 800f9d2:	b083      	sub	sp, #12
 800f9d4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 800f9d6:	9801      	ldr	r0, [sp, #4]
 800f9d8:	f7fc f8ca 	bl	800bb70 <stSetAlarm>
}
 800f9dc:	b003      	add	sp, #12
 800f9de:	f85d fb04 	ldr.w	pc, [sp], #4
 800f9e2:	bf00      	nop
 800f9e4:	f3af 8000 	nop.w
 800f9e8:	f3af 8000 	nop.w
 800f9ec:	f3af 8000 	nop.w

0800f9f0 <port_timer_get_time.4827.4273>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800f9f0:	b508      	push	{r3, lr}

  return stGetCounter();
 800f9f2:	f7ff ffcd 	bl	800f990 <st_lld_get_counter.4821.4283>
 800f9f6:	4603      	mov	r3, r0
}
 800f9f8:	4618      	mov	r0, r3
 800f9fa:	bd08      	pop	{r3, pc}
 800f9fc:	f3af 8000 	nop.w

0800fa00 <chVTGetSystemTimeX.4829.4271>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800fa00:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800fa02:	f7ff fff5 	bl	800f9f0 <port_timer_get_time.4827.4273>
 800fa06:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800fa08:	4618      	mov	r0, r3
 800fa0a:	bd08      	pop	{r3, pc}
 800fa0c:	f3af 8000 	nop.w

0800fa10 <_vt_init.4269>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800fa10:	f640 5350 	movw	r3, #3408	; 0xd50
 800fa14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fa18:	4a0a      	ldr	r2, [pc, #40]	; (800fa44 <_vt_init.4269+0x34>)
 800fa1a:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 800fa1c:	f640 5350 	movw	r3, #3408	; 0xd50
 800fa20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fa24:	4a07      	ldr	r2, [pc, #28]	; (800fa44 <_vt_init.4269+0x34>)
 800fa26:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 800fa28:	f640 5350 	movw	r3, #3408	; 0xd50
 800fa2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fa30:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800fa34:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 800fa36:	f640 5350 	movw	r3, #3408	; 0xd50
 800fa3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fa3e:	2200      	movs	r2, #0
 800fa40:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800fa42:	4770      	bx	lr
 800fa44:	20000d6c 	.word	0x20000d6c
 800fa48:	f3af 8000 	nop.w
 800fa4c:	f3af 8000 	nop.w

0800fa50 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 800fa50:	b500      	push	{lr}
 800fa52:	b089      	sub	sp, #36	; 0x24
 800fa54:	9003      	str	r0, [sp, #12]
 800fa56:	9102      	str	r1, [sp, #8]
 800fa58:	9201      	str	r2, [sp, #4]
 800fa5a:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 800fa5c:	f7ff ff10 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800fa60:	9b03      	ldr	r3, [sp, #12]
 800fa62:	2b00      	cmp	r3, #0
 800fa64:	d005      	beq.n	800fa72 <chVTDoSetI+0x22>
 800fa66:	9b01      	ldr	r3, [sp, #4]
 800fa68:	2b00      	cmp	r3, #0
 800fa6a:	d002      	beq.n	800fa72 <chVTDoSetI+0x22>
 800fa6c:	9b02      	ldr	r3, [sp, #8]
 800fa6e:	2b00      	cmp	r3, #0
 800fa70:	d105      	bne.n	800fa7e <chVTDoSetI+0x2e>
 800fa72:	f241 6050 	movw	r0, #5712	; 0x1650
 800fa76:	f6c0 0001 	movt	r0, #2049	; 0x801
 800fa7a:	f7ff fc89 	bl	800f390 <chSysHalt>

  vtp->vt_par = par;
 800fa7e:	9b03      	ldr	r3, [sp, #12]
 800fa80:	9a00      	ldr	r2, [sp, #0]
 800fa82:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 800fa84:	9b03      	ldr	r3, [sp, #12]
 800fa86:	9a01      	ldr	r2, [sp, #4]
 800fa88:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 800fa8a:	f7ff ffb9 	bl	800fa00 <chVTGetSystemTimeX.4829.4271>
 800fa8e:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800fa90:	9b02      	ldr	r3, [sp, #8]
 800fa92:	2b01      	cmp	r3, #1
 800fa94:	d801      	bhi.n	800fa9a <chVTDoSetI+0x4a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800fa96:	2302      	movs	r3, #2
 800fa98:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800fa9a:	f640 5350 	movw	r3, #3408	; 0xd50
 800fa9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800faa2:	69da      	ldr	r2, [r3, #28]
 800faa4:	4b3d      	ldr	r3, [pc, #244]	; (800fb9c <chVTDoSetI+0x14c>)
 800faa6:	429a      	cmp	r2, r3
 800faa8:	d125      	bne.n	800faf6 <chVTDoSetI+0xa6>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 800faaa:	f640 5350 	movw	r3, #3408	; 0xd50
 800faae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fab2:	9a05      	ldr	r2, [sp, #20]
 800fab4:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 800fab6:	f640 5350 	movw	r3, #3408	; 0xd50
 800faba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fabe:	9a03      	ldr	r2, [sp, #12]
 800fac0:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
 800fac2:	f640 5350 	movw	r3, #3408	; 0xd50
 800fac6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800faca:	9a03      	ldr	r2, [sp, #12]
 800facc:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 800face:	9b03      	ldr	r3, [sp, #12]
 800fad0:	4a32      	ldr	r2, [pc, #200]	; (800fb9c <chVTDoSetI+0x14c>)
 800fad2:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800fad4:	9b03      	ldr	r3, [sp, #12]
 800fad6:	4a31      	ldr	r2, [pc, #196]	; (800fb9c <chVTDoSetI+0x14c>)
 800fad8:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
 800fada:	9b03      	ldr	r3, [sp, #12]
 800fadc:	9a02      	ldr	r2, [sp, #8]
 800fade:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 800fae0:	f640 5350 	movw	r3, #3408	; 0xd50
 800fae4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fae8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800faea:	9b02      	ldr	r3, [sp, #8]
 800faec:	4413      	add	r3, r2
 800faee:	4618      	mov	r0, r3
 800faf0:	f7ff ff56 	bl	800f9a0 <port_timer_start_alarm.4831.4280>
 800faf4:	e04f      	b.n	800fb96 <chVTDoSetI+0x146>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 800faf6:	9a05      	ldr	r2, [sp, #20]
 800faf8:	9b02      	ldr	r3, [sp, #8]
 800fafa:	441a      	add	r2, r3
 800fafc:	f640 5350 	movw	r3, #3408	; 0xd50
 800fb00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fb04:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800fb06:	1ad3      	subs	r3, r2, r3
 800fb08:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
 800fb0a:	f640 5350 	movw	r3, #3408	; 0xd50
 800fb0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fb12:	69db      	ldr	r3, [r3, #28]
 800fb14:	689a      	ldr	r2, [r3, #8]
 800fb16:	9b06      	ldr	r3, [sp, #24]
 800fb18:	429a      	cmp	r2, r3
 800fb1a:	d909      	bls.n	800fb30 <chVTDoSetI+0xe0>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 800fb1c:	f640 5350 	movw	r3, #3408	; 0xd50
 800fb20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fb24:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800fb26:	9b06      	ldr	r3, [sp, #24]
 800fb28:	4413      	add	r3, r2
 800fb2a:	4618      	mov	r0, r3
 800fb2c:	f7ff ff50 	bl	800f9d0 <port_timer_set_alarm.4834.4275>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 800fb30:	f640 5350 	movw	r3, #3408	; 0xd50
 800fb34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fb38:	69db      	ldr	r3, [r3, #28]
 800fb3a:	9307      	str	r3, [sp, #28]
 800fb3c:	e007      	b.n	800fb4e <chVTDoSetI+0xfe>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 800fb3e:	9b07      	ldr	r3, [sp, #28]
 800fb40:	689b      	ldr	r3, [r3, #8]
 800fb42:	9a06      	ldr	r2, [sp, #24]
 800fb44:	1ad3      	subs	r3, r2, r3
 800fb46:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
 800fb48:	9b07      	ldr	r3, [sp, #28]
 800fb4a:	681b      	ldr	r3, [r3, #0]
 800fb4c:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800fb4e:	9b07      	ldr	r3, [sp, #28]
 800fb50:	689a      	ldr	r2, [r3, #8]
 800fb52:	9b06      	ldr	r3, [sp, #24]
 800fb54:	429a      	cmp	r2, r3
 800fb56:	d3f2      	bcc.n	800fb3e <chVTDoSetI+0xee>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 800fb58:	9b03      	ldr	r3, [sp, #12]
 800fb5a:	9a07      	ldr	r2, [sp, #28]
 800fb5c:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800fb5e:	9b03      	ldr	r3, [sp, #12]
 800fb60:	681b      	ldr	r3, [r3, #0]
 800fb62:	685a      	ldr	r2, [r3, #4]
 800fb64:	9b03      	ldr	r3, [sp, #12]
 800fb66:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 800fb68:	9b03      	ldr	r3, [sp, #12]
 800fb6a:	685b      	ldr	r3, [r3, #4]
 800fb6c:	9a03      	ldr	r2, [sp, #12]
 800fb6e:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 800fb70:	9b07      	ldr	r3, [sp, #28]
 800fb72:	9a03      	ldr	r2, [sp, #12]
 800fb74:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 800fb76:	9b03      	ldr	r3, [sp, #12]
 800fb78:	9a06      	ldr	r2, [sp, #24]
 800fb7a:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800fb7c:	9b07      	ldr	r3, [sp, #28]
 800fb7e:	689a      	ldr	r2, [r3, #8]
 800fb80:	9b06      	ldr	r3, [sp, #24]
 800fb82:	1ad2      	subs	r2, r2, r3
 800fb84:	9b07      	ldr	r3, [sp, #28]
 800fb86:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800fb88:	f640 5350 	movw	r3, #3408	; 0xd50
 800fb8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fb90:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800fb94:	625a      	str	r2, [r3, #36]	; 0x24
}
 800fb96:	b009      	add	sp, #36	; 0x24
 800fb98:	f85d fb04 	ldr.w	pc, [sp], #4
 800fb9c:	20000d6c 	.word	0x20000d6c

0800fba0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 800fba0:	b500      	push	{lr}
 800fba2:	b085      	sub	sp, #20
 800fba4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800fba6:	f7ff fe6b 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 800fbaa:	9b01      	ldr	r3, [sp, #4]
 800fbac:	2b00      	cmp	r3, #0
 800fbae:	d105      	bne.n	800fbbc <chVTDoResetI+0x1c>
 800fbb0:	f241 6060 	movw	r0, #5728	; 0x1660
 800fbb4:	f6c0 0001 	movt	r0, #2049	; 0x801
 800fbb8:	f7ff fbea 	bl	800f390 <chSysHalt>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
 800fbbc:	9b01      	ldr	r3, [sp, #4]
 800fbbe:	68db      	ldr	r3, [r3, #12]
 800fbc0:	2b00      	cmp	r3, #0
 800fbc2:	d105      	bne.n	800fbd0 <chVTDoResetI+0x30>
 800fbc4:	f241 6060 	movw	r0, #5728	; 0x1660
 800fbc8:	f6c0 0001 	movt	r0, #2049	; 0x801
 800fbcc:	f7ff fbe0 	bl	800f390 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 800fbd0:	f640 5350 	movw	r3, #3408	; 0xd50
 800fbd4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fbd8:	69da      	ldr	r2, [r3, #28]
 800fbda:	9b01      	ldr	r3, [sp, #4]
 800fbdc:	429a      	cmp	r2, r3
 800fbde:	d01b      	beq.n	800fc18 <chVTDoResetI+0x78>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 800fbe0:	9b01      	ldr	r3, [sp, #4]
 800fbe2:	685b      	ldr	r3, [r3, #4]
 800fbe4:	9a01      	ldr	r2, [sp, #4]
 800fbe6:	6812      	ldr	r2, [r2, #0]
 800fbe8:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 800fbea:	9b01      	ldr	r3, [sp, #4]
 800fbec:	681b      	ldr	r3, [r3, #0]
 800fbee:	9a01      	ldr	r2, [sp, #4]
 800fbf0:	6852      	ldr	r2, [r2, #4]
 800fbf2:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 800fbf4:	9b01      	ldr	r3, [sp, #4]
 800fbf6:	2200      	movs	r2, #0
 800fbf8:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800fbfa:	9b01      	ldr	r3, [sp, #4]
 800fbfc:	681a      	ldr	r2, [r3, #0]
 800fbfe:	4b34      	ldr	r3, [pc, #208]	; (800fcd0 <chVTDoResetI+0x130>)
 800fc00:	429a      	cmp	r2, r3
 800fc02:	d061      	beq.n	800fcc8 <chVTDoResetI+0x128>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 800fc04:	9b01      	ldr	r3, [sp, #4]
 800fc06:	681b      	ldr	r3, [r3, #0]
 800fc08:	9a01      	ldr	r2, [sp, #4]
 800fc0a:	6812      	ldr	r2, [r2, #0]
 800fc0c:	6891      	ldr	r1, [r2, #8]
 800fc0e:	9a01      	ldr	r2, [sp, #4]
 800fc10:	6892      	ldr	r2, [r2, #8]
 800fc12:	440a      	add	r2, r1
 800fc14:	609a      	str	r2, [r3, #8]
 800fc16:	e057      	b.n	800fcc8 <chVTDoResetI+0x128>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 800fc18:	9b01      	ldr	r3, [sp, #4]
 800fc1a:	681a      	ldr	r2, [r3, #0]
 800fc1c:	f640 5350 	movw	r3, #3408	; 0xd50
 800fc20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fc24:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800fc26:	f640 5350 	movw	r3, #3408	; 0xd50
 800fc2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fc2e:	69db      	ldr	r3, [r3, #28]
 800fc30:	4a27      	ldr	r2, [pc, #156]	; (800fcd0 <chVTDoResetI+0x130>)
 800fc32:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 800fc34:	9b01      	ldr	r3, [sp, #4]
 800fc36:	2200      	movs	r2, #0
 800fc38:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800fc3a:	f640 5350 	movw	r3, #3408	; 0xd50
 800fc3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fc42:	69da      	ldr	r2, [r3, #28]
 800fc44:	4b22      	ldr	r3, [pc, #136]	; (800fcd0 <chVTDoResetI+0x130>)
 800fc46:	429a      	cmp	r2, r3
 800fc48:	d102      	bne.n	800fc50 <chVTDoResetI+0xb0>
    port_timer_stop_alarm();
 800fc4a:	f7ff feb9 	bl	800f9c0 <port_timer_stop_alarm.4837.4278>
 800fc4e:	e03b      	b.n	800fcc8 <chVTDoResetI+0x128>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 800fc50:	f640 5350 	movw	r3, #3408	; 0xd50
 800fc54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fc58:	69da      	ldr	r2, [r3, #28]
 800fc5a:	f640 5350 	movw	r3, #3408	; 0xd50
 800fc5e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fc62:	69db      	ldr	r3, [r3, #28]
 800fc64:	6899      	ldr	r1, [r3, #8]
 800fc66:	9b01      	ldr	r3, [sp, #4]
 800fc68:	689b      	ldr	r3, [r3, #8]
 800fc6a:	440b      	add	r3, r1
 800fc6c:	6093      	str	r3, [r2, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 800fc6e:	f7ff fec7 	bl	800fa00 <chVTGetSystemTimeX.4829.4271>
 800fc72:	4602      	mov	r2, r0
 800fc74:	f640 5350 	movw	r3, #3408	; 0xd50
 800fc78:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fc7c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800fc7e:	1ad3      	subs	r3, r2, r3
 800fc80:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 800fc82:	f640 5350 	movw	r3, #3408	; 0xd50
 800fc86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fc8a:	69db      	ldr	r3, [r3, #28]
 800fc8c:	689a      	ldr	r2, [r3, #8]
 800fc8e:	9b02      	ldr	r3, [sp, #8]
 800fc90:	429a      	cmp	r2, r3
 800fc92:	d919      	bls.n	800fcc8 <chVTDoResetI+0x128>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 800fc94:	f640 5350 	movw	r3, #3408	; 0xd50
 800fc98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fc9c:	69db      	ldr	r3, [r3, #28]
 800fc9e:	689a      	ldr	r2, [r3, #8]
 800fca0:	9b02      	ldr	r3, [sp, #8]
 800fca2:	1ad3      	subs	r3, r2, r3
 800fca4:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800fca6:	9b03      	ldr	r3, [sp, #12]
 800fca8:	2b01      	cmp	r3, #1
 800fcaa:	d801      	bhi.n	800fcb0 <chVTDoResetI+0x110>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800fcac:	2302      	movs	r3, #2
 800fcae:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 800fcb0:	f640 5350 	movw	r3, #3408	; 0xd50
 800fcb4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fcb8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800fcba:	9b02      	ldr	r3, [sp, #8]
 800fcbc:	441a      	add	r2, r3
 800fcbe:	9b03      	ldr	r3, [sp, #12]
 800fcc0:	4413      	add	r3, r2
 800fcc2:	4618      	mov	r0, r3
 800fcc4:	f7ff fe84 	bl	800f9d0 <port_timer_set_alarm.4834.4275>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800fcc8:	b005      	add	sp, #20
 800fcca:	f85d fb04 	ldr.w	pc, [sp], #4
 800fcce:	bf00      	nop
 800fcd0:	20000d6c 	.word	0x20000d6c
 800fcd4:	f3af 8000 	nop.w
 800fcd8:	f3af 8000 	nop.w
 800fcdc:	f3af 8000 	nop.w

0800fce0 <port_lock.5026.4257>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800fce0:	b082      	sub	sp, #8
 800fce2:	2320      	movs	r3, #32
 800fce4:	9301      	str	r3, [sp, #4]
 800fce6:	9b01      	ldr	r3, [sp, #4]
 800fce8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fcec:	b002      	add	sp, #8
 800fcee:	4770      	bx	lr

0800fcf0 <port_unlock.5029.4255>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800fcf0:	b082      	sub	sp, #8
 800fcf2:	2300      	movs	r3, #0
 800fcf4:	9301      	str	r3, [sp, #4]
 800fcf6:	9b01      	ldr	r3, [sp, #4]
 800fcf8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fcfc:	b002      	add	sp, #8
 800fcfe:	4770      	bx	lr

0800fd00 <port_lock_from_isr.5031.4253>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800fd00:	b508      	push	{r3, lr}

  port_lock();
 800fd02:	f7ff ffed 	bl	800fce0 <port_lock.5026.4257>
}
 800fd06:	bd08      	pop	{r3, pc}
 800fd08:	f3af 8000 	nop.w
 800fd0c:	f3af 8000 	nop.w

0800fd10 <port_unlock_from_isr.5033.4251>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800fd10:	b508      	push	{r3, lr}

  port_unlock();
 800fd12:	f7ff ffed 	bl	800fcf0 <port_unlock.5029.4255>
}
 800fd16:	bd08      	pop	{r3, pc}
 800fd18:	f3af 8000 	nop.w
 800fd1c:	f3af 8000 	nop.w

0800fd20 <queue_init.5035.4248>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800fd20:	b082      	sub	sp, #8
 800fd22:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800fd24:	9b01      	ldr	r3, [sp, #4]
 800fd26:	9a01      	ldr	r2, [sp, #4]
 800fd28:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800fd2a:	9b01      	ldr	r3, [sp, #4]
 800fd2c:	9a01      	ldr	r2, [sp, #4]
 800fd2e:	605a      	str	r2, [r3, #4]
}
 800fd30:	b002      	add	sp, #8
 800fd32:	4770      	bx	lr
 800fd34:	f3af 8000 	nop.w
 800fd38:	f3af 8000 	nop.w
 800fd3c:	f3af 8000 	nop.w

0800fd40 <queue_fifo_remove.5124.4245>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800fd40:	b084      	sub	sp, #16
 800fd42:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 800fd44:	9b01      	ldr	r3, [sp, #4]
 800fd46:	681b      	ldr	r3, [r3, #0]
 800fd48:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800fd4a:	9b03      	ldr	r3, [sp, #12]
 800fd4c:	681a      	ldr	r2, [r3, #0]
 800fd4e:	9b01      	ldr	r3, [sp, #4]
 800fd50:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800fd52:	9b01      	ldr	r3, [sp, #4]
 800fd54:	681b      	ldr	r3, [r3, #0]
 800fd56:	9a01      	ldr	r2, [sp, #4]
 800fd58:	605a      	str	r2, [r3, #4]

  return tp;
 800fd5a:	9b03      	ldr	r3, [sp, #12]
}
 800fd5c:	4618      	mov	r0, r3
 800fd5e:	b004      	add	sp, #16
 800fd60:	4770      	bx	lr
 800fd62:	bf00      	nop
 800fd64:	f3af 8000 	nop.w
 800fd68:	f3af 8000 	nop.w
 800fd6c:	f3af 8000 	nop.w

0800fd70 <queue_dequeue.5127.4242>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 800fd70:	b082      	sub	sp, #8
 800fd72:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 800fd74:	9b01      	ldr	r3, [sp, #4]
 800fd76:	685b      	ldr	r3, [r3, #4]
 800fd78:	9a01      	ldr	r2, [sp, #4]
 800fd7a:	6812      	ldr	r2, [r2, #0]
 800fd7c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800fd7e:	9b01      	ldr	r3, [sp, #4]
 800fd80:	681b      	ldr	r3, [r3, #0]
 800fd82:	9a01      	ldr	r2, [sp, #4]
 800fd84:	6852      	ldr	r2, [r2, #4]
 800fd86:	605a      	str	r2, [r3, #4]

  return tp;
 800fd88:	9b01      	ldr	r3, [sp, #4]
}
 800fd8a:	4618      	mov	r0, r3
 800fd8c:	b002      	add	sp, #8
 800fd8e:	4770      	bx	lr

0800fd90 <chSchIsRescRequiredI.5147.4240>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 800fd90:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 800fd92:	f7ff fd75 	bl	800f880 <chDbgCheckClassI>

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 800fd96:	f640 5350 	movw	r3, #3408	; 0xd50
 800fd9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fd9e:	681b      	ldr	r3, [r3, #0]
 800fda0:	689a      	ldr	r2, [r3, #8]
 800fda2:	f640 5350 	movw	r3, #3408	; 0xd50
 800fda6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fdaa:	699b      	ldr	r3, [r3, #24]
 800fdac:	689b      	ldr	r3, [r3, #8]
 800fdae:	429a      	cmp	r2, r3
 800fdb0:	bf94      	ite	ls
 800fdb2:	2300      	movls	r3, #0
 800fdb4:	2301      	movhi	r3, #1
 800fdb6:	b2db      	uxtb	r3, r3
}
 800fdb8:	4618      	mov	r0, r3
 800fdba:	bd08      	pop	{r3, pc}
 800fdbc:	f3af 8000 	nop.w

0800fdc0 <chSysLockFromISR.5149.4238>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800fdc0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800fdc2:	f7ff ff9d 	bl	800fd00 <port_lock_from_isr.5031.4253>
  _stats_start_measure_crit_isr();
 800fdc6:	f7fe f8eb 	bl	800dfa0 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800fdca:	f7ff fcc9 	bl	800f760 <_dbg_check_lock_from_isr>
}
 800fdce:	bd08      	pop	{r3, pc}

0800fdd0 <chSysUnlockFromISR.5151.4236>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800fdd0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 800fdd2:	f7ff fce5 	bl	800f7a0 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 800fdd6:	f7fe f8eb 	bl	800dfb0 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800fdda:	f7ff ff99 	bl	800fd10 <port_unlock_from_isr.5033.4251>
}
 800fdde:	bd08      	pop	{r3, pc}

0800fde0 <chVTIsArmedI.5134.4225>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800fde0:	b500      	push	{lr}
 800fde2:	b083      	sub	sp, #12
 800fde4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800fde6:	f7ff fd4b 	bl	800f880 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
 800fdea:	9b01      	ldr	r3, [sp, #4]
 800fdec:	68db      	ldr	r3, [r3, #12]
 800fdee:	2b00      	cmp	r3, #0
 800fdf0:	bf0c      	ite	eq
 800fdf2:	2300      	moveq	r3, #0
 800fdf4:	2301      	movne	r3, #1
 800fdf6:	b2db      	uxtb	r3, r3
}
 800fdf8:	4618      	mov	r0, r3
 800fdfa:	b003      	add	sp, #12
 800fdfc:	f85d fb04 	ldr.w	pc, [sp], #4

0800fe00 <chSemFastSignalI.5130.4220>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 800fe00:	b500      	push	{lr}
 800fe02:	b083      	sub	sp, #12
 800fe04:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800fe06:	f7ff fd3b 	bl	800f880 <chDbgCheckClassI>

  sp->s_cnt++;
 800fe0a:	9b01      	ldr	r3, [sp, #4]
 800fe0c:	689b      	ldr	r3, [r3, #8]
 800fe0e:	1c5a      	adds	r2, r3, #1
 800fe10:	9b01      	ldr	r3, [sp, #4]
 800fe12:	609a      	str	r2, [r3, #8]
}
 800fe14:	b003      	add	sp, #12
 800fe16:	f85d fb04 	ldr.w	pc, [sp], #4
 800fe1a:	bf00      	nop
 800fe1c:	f3af 8000 	nop.w

0800fe20 <_scheduler_init.4218>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 800fe20:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 800fe22:	f640 5050 	movw	r0, #3408	; 0xd50
 800fe26:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800fe2a:	f7ff ff79 	bl	800fd20 <queue_init.5035.4248>
  ch.rlist.r_prio = NOPRIO;
 800fe2e:	f640 5350 	movw	r3, #3408	; 0xd50
 800fe32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fe36:	2200      	movs	r2, #0
 800fe38:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 800fe3a:	f640 5350 	movw	r3, #3408	; 0xd50
 800fe3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fe42:	f640 5250 	movw	r2, #3408	; 0xd50
 800fe46:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800fe4a:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 800fe4c:	f640 5350 	movw	r3, #3408	; 0xd50
 800fe50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800fe54:	f640 5250 	movw	r2, #3408	; 0xd50
 800fe58:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800fe5c:	615a      	str	r2, [r3, #20]
#endif
}
 800fe5e:	bd08      	pop	{r3, pc}

0800fe60 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 800fe60:	b500      	push	{lr}
 800fe62:	b085      	sub	sp, #20
 800fe64:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800fe66:	f7ff fd0b 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800fe6a:	9b01      	ldr	r3, [sp, #4]
 800fe6c:	2b00      	cmp	r3, #0
 800fe6e:	d105      	bne.n	800fe7c <chSchReadyI+0x1c>
 800fe70:	f241 6070 	movw	r0, #5744	; 0x1670
 800fe74:	f6c0 0001 	movt	r0, #2049	; 0x801
 800fe78:	f7ff fa8a 	bl	800f390 <chSysHalt>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 800fe7c:	9b01      	ldr	r3, [sp, #4]
 800fe7e:	f893 3020 	ldrb.w	r3, [r3, #32]
 800fe82:	2b00      	cmp	r3, #0
 800fe84:	d004      	beq.n	800fe90 <chSchReadyI+0x30>
 800fe86:	9b01      	ldr	r3, [sp, #4]
 800fe88:	f893 3020 	ldrb.w	r3, [r3, #32]
 800fe8c:	2b0f      	cmp	r3, #15
 800fe8e:	d105      	bne.n	800fe9c <chSchReadyI+0x3c>
 800fe90:	f241 6070 	movw	r0, #5744	; 0x1670
 800fe94:	f6c0 0001 	movt	r0, #2049	; 0x801
 800fe98:	f7ff fa7a 	bl	800f390 <chSysHalt>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800fe9c:	9b01      	ldr	r3, [sp, #4]
 800fe9e:	2200      	movs	r2, #0
 800fea0:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 800fea4:	f640 5350 	movw	r3, #3408	; 0xd50
 800fea8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800feac:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800feae:	9b03      	ldr	r3, [sp, #12]
 800feb0:	681b      	ldr	r3, [r3, #0]
 800feb2:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 800feb4:	9b03      	ldr	r3, [sp, #12]
 800feb6:	689a      	ldr	r2, [r3, #8]
 800feb8:	9b01      	ldr	r3, [sp, #4]
 800feba:	689b      	ldr	r3, [r3, #8]
 800febc:	429a      	cmp	r2, r3
 800febe:	d2f6      	bcs.n	800feae <chSchReadyI+0x4e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800fec0:	9b01      	ldr	r3, [sp, #4]
 800fec2:	9a03      	ldr	r2, [sp, #12]
 800fec4:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 800fec6:	9b03      	ldr	r3, [sp, #12]
 800fec8:	685a      	ldr	r2, [r3, #4]
 800feca:	9b01      	ldr	r3, [sp, #4]
 800fecc:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800fece:	9b01      	ldr	r3, [sp, #4]
 800fed0:	685b      	ldr	r3, [r3, #4]
 800fed2:	9a01      	ldr	r2, [sp, #4]
 800fed4:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 800fed6:	9b03      	ldr	r3, [sp, #12]
 800fed8:	9a01      	ldr	r2, [sp, #4]
 800feda:	605a      	str	r2, [r3, #4]

  return tp;
 800fedc:	9b01      	ldr	r3, [sp, #4]
}
 800fede:	4618      	mov	r0, r3
 800fee0:	b005      	add	sp, #20
 800fee2:	f85d fb04 	ldr.w	pc, [sp], #4
 800fee6:	bf00      	nop
 800fee8:	f3af 8000 	nop.w
 800feec:	f3af 8000 	nop.w

0800fef0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800fef0:	b510      	push	{r4, lr}
 800fef2:	b084      	sub	sp, #16
 800fef4:	4603      	mov	r3, r0
 800fef6:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();
 800fefa:	f7ff fcd9 	bl	800f8b0 <chDbgCheckClassS>

  otp = currp;
 800fefe:	f640 5350 	movw	r3, #3408	; 0xd50
 800ff02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ff06:	699b      	ldr	r3, [r3, #24]
 800ff08:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 800ff0a:	9b03      	ldr	r3, [sp, #12]
 800ff0c:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800ff10:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800ff14:	f640 5050 	movw	r0, #3408	; 0xd50
 800ff18:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800ff1c:	f7ff ff10 	bl	800fd40 <queue_fifo_remove.5124.4245>
 800ff20:	4602      	mov	r2, r0
 800ff22:	f640 5350 	movw	r3, #3408	; 0xd50
 800ff26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ff2a:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800ff2c:	f640 5350 	movw	r3, #3408	; 0xd50
 800ff30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ff34:	699b      	ldr	r3, [r3, #24]
 800ff36:	2201      	movs	r2, #1
 800ff38:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
 800ff3c:	9803      	ldr	r0, [sp, #12]
 800ff3e:	f7ff fcdf 	bl	800f900 <_dbg_trace.4285>
 800ff42:	f640 5350 	movw	r3, #3408	; 0xd50
 800ff46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ff4a:	699b      	ldr	r3, [r3, #24]
 800ff4c:	4618      	mov	r0, r3
 800ff4e:	9903      	ldr	r1, [sp, #12]
 800ff50:	f7fd fff6 	bl	800df40 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800ff54:	f3ef 8309 	mrs	r3, PSP
 800ff58:	461c      	mov	r4, r3
  return(result);
 800ff5a:	4623      	mov	r3, r4
 800ff5c:	9302      	str	r3, [sp, #8]
 800ff5e:	9b02      	ldr	r3, [sp, #8]
 800ff60:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800ff64:	9b03      	ldr	r3, [sp, #12]
 800ff66:	69db      	ldr	r3, [r3, #28]
 800ff68:	429a      	cmp	r2, r3
 800ff6a:	d205      	bcs.n	800ff78 <chSchGoSleepS+0x88>
 800ff6c:	f241 0010 	movw	r0, #4112	; 0x1010
 800ff70:	f6c0 0001 	movt	r0, #2049	; 0x801
 800ff74:	f7ff fa0c 	bl	800f390 <chSysHalt>
 800ff78:	f640 5350 	movw	r3, #3408	; 0xd50
 800ff7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800ff80:	699b      	ldr	r3, [r3, #24]
 800ff82:	4618      	mov	r0, r3
 800ff84:	9903      	ldr	r1, [sp, #12]
 800ff86:	f7f0 f9a3 	bl	80002d0 <_port_switch>
}
 800ff8a:	b004      	add	sp, #16
 800ff8c:	bd10      	pop	{r4, pc}
 800ff8e:	bf00      	nop

0800ff90 <wakeup.5158.4209>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 800ff90:	b500      	push	{lr}
 800ff92:	b085      	sub	sp, #20
 800ff94:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 800ff96:	9b01      	ldr	r3, [sp, #4]
 800ff98:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 800ff9a:	f7ff ff11 	bl	800fdc0 <chSysLockFromISR.5149.4238>
  switch (tp->p_state) {
 800ff9e:	9b03      	ldr	r3, [sp, #12]
 800ffa0:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ffa4:	2b07      	cmp	r3, #7
 800ffa6:	d823      	bhi.n	800fff0 <wakeup.5158.4209+0x60>
 800ffa8:	a201      	add	r2, pc, #4	; (adr r2, 800ffb0 <wakeup.5158.4209+0x20>)
 800ffaa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ffae:	bf00      	nop
 800ffb0:	0800ffd1 	.word	0x0800ffd1
 800ffb4:	0800fff1 	.word	0x0800fff1
 800ffb8:	0800fff1 	.word	0x0800fff1
 800ffbc:	0800ffd7 	.word	0x0800ffd7
 800ffc0:	0800ffeb 	.word	0x0800ffeb
 800ffc4:	0800ffe1 	.word	0x0800ffe1
 800ffc8:	0800fff1 	.word	0x0800fff1
 800ffcc:	0800ffeb 	.word	0x0800ffeb
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 800ffd0:	f7ff fefe 	bl	800fdd0 <chSysUnlockFromISR.5151.4236>
 800ffd4:	e015      	b.n	8010002 <wakeup.5158.4209+0x72>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 800ffd6:	9b03      	ldr	r3, [sp, #12]
 800ffd8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ffda:	2200      	movs	r2, #0
 800ffdc:	601a      	str	r2, [r3, #0]
 800ffde:	e007      	b.n	800fff0 <wakeup.5158.4209+0x60>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800ffe0:	9b03      	ldr	r3, [sp, #12]
 800ffe2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ffe4:	4618      	mov	r0, r3
 800ffe6:	f7ff ff0b 	bl	800fe00 <chSemFastSignalI.5130.4220>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 800ffea:	9803      	ldr	r0, [sp, #12]
 800ffec:	f7ff fec0 	bl	800fd70 <queue_dequeue.5127.4242>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800fff0:	9b03      	ldr	r3, [sp, #12]
 800fff2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800fff6:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800fff8:	9803      	ldr	r0, [sp, #12]
 800fffa:	f7ff ff31 	bl	800fe60 <chSchReadyI>
  chSysUnlockFromISR();
 800fffe:	f7ff fee7 	bl	800fdd0 <chSysUnlockFromISR.5151.4236>
}
 8010002:	b005      	add	sp, #20
 8010004:	f85d fb04 	ldr.w	pc, [sp], #4
 8010008:	f3af 8000 	nop.w
 801000c:	f3af 8000 	nop.w

08010010 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8010010:	b500      	push	{lr}
 8010012:	b089      	sub	sp, #36	; 0x24
 8010014:	4603      	mov	r3, r0
 8010016:	9100      	str	r1, [sp, #0]
 8010018:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
 801001c:	f7ff fc48 	bl	800f8b0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 8010020:	9b00      	ldr	r3, [sp, #0]
 8010022:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8010026:	d01e      	beq.n	8010066 <chSchGoSleepTimeoutS+0x56>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8010028:	f640 5350 	movw	r3, #3408	; 0xd50
 801002c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010030:	699b      	ldr	r3, [r3, #24]
 8010032:	aa03      	add	r2, sp, #12
 8010034:	4610      	mov	r0, r2
 8010036:	9900      	ldr	r1, [sp, #0]
 8010038:	f64f 7291 	movw	r2, #65425	; 0xff91
 801003c:	f6c0 0200 	movt	r2, #2048	; 0x800
 8010040:	f7ff fd06 	bl	800fa50 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8010044:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8010048:	4618      	mov	r0, r3
 801004a:	f7ff ff51 	bl	800fef0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 801004e:	ab03      	add	r3, sp, #12
 8010050:	4618      	mov	r0, r3
 8010052:	f7ff fec5 	bl	800fde0 <chVTIsArmedI.5134.4225>
 8010056:	4603      	mov	r3, r0
 8010058:	2b00      	cmp	r3, #0
 801005a:	d009      	beq.n	8010070 <chSchGoSleepTimeoutS+0x60>
      chVTDoResetI(&vt);
 801005c:	ab03      	add	r3, sp, #12
 801005e:	4618      	mov	r0, r3
 8010060:	f7ff fd9e 	bl	800fba0 <chVTDoResetI>
 8010064:	e004      	b.n	8010070 <chSchGoSleepTimeoutS+0x60>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8010066:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801006a:	4618      	mov	r0, r3
 801006c:	f7ff ff40 	bl	800fef0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8010070:	f640 5350 	movw	r3, #3408	; 0xd50
 8010074:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010078:	699b      	ldr	r3, [r3, #24]
 801007a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 801007c:	4618      	mov	r0, r3
 801007e:	b009      	add	sp, #36	; 0x24
 8010080:	f85d fb04 	ldr.w	pc, [sp], #4
 8010084:	f3af 8000 	nop.w
 8010088:	f3af 8000 	nop.w
 801008c:	f3af 8000 	nop.w

08010090 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8010090:	b510      	push	{r4, lr}
 8010092:	b084      	sub	sp, #16
 8010094:	9001      	str	r0, [sp, #4]
 8010096:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 8010098:	f7ff fc0a 	bl	800f8b0 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 801009c:	f640 5350 	movw	r3, #3408	; 0xd50
 80100a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80100a4:	681a      	ldr	r2, [r3, #0]
 80100a6:	f640 5350 	movw	r3, #3408	; 0xd50
 80100aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80100ae:	429a      	cmp	r2, r3
 80100b0:	d013      	beq.n	80100da <chSchWakeupS+0x4a>
 80100b2:	f640 5350 	movw	r3, #3408	; 0xd50
 80100b6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80100ba:	699b      	ldr	r3, [r3, #24]
 80100bc:	689a      	ldr	r2, [r3, #8]
 80100be:	f640 5350 	movw	r3, #3408	; 0xd50
 80100c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80100c6:	681b      	ldr	r3, [r3, #0]
 80100c8:	689b      	ldr	r3, [r3, #8]
 80100ca:	429a      	cmp	r2, r3
 80100cc:	d205      	bcs.n	80100da <chSchWakeupS+0x4a>
 80100ce:	f241 6080 	movw	r0, #5760	; 0x1680
 80100d2:	f6c0 0001 	movt	r0, #2049	; 0x801
 80100d6:	f7ff f95b 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80100da:	9b01      	ldr	r3, [sp, #4]
 80100dc:	9a00      	ldr	r2, [sp, #0]
 80100de:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80100e0:	9b01      	ldr	r3, [sp, #4]
 80100e2:	689a      	ldr	r2, [r3, #8]
 80100e4:	f640 5350 	movw	r3, #3408	; 0xd50
 80100e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80100ec:	699b      	ldr	r3, [r3, #24]
 80100ee:	689b      	ldr	r3, [r3, #8]
 80100f0:	429a      	cmp	r2, r3
 80100f2:	d803      	bhi.n	80100fc <chSchWakeupS+0x6c>
    (void) chSchReadyI(ntp);
 80100f4:	9801      	ldr	r0, [sp, #4]
 80100f6:	f7ff feb3 	bl	800fe60 <chSchReadyI>
 80100fa:	e02f      	b.n	801015c <chSchWakeupS+0xcc>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 80100fc:	f640 5350 	movw	r3, #3408	; 0xd50
 8010100:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010104:	699b      	ldr	r3, [r3, #24]
 8010106:	4618      	mov	r0, r3
 8010108:	f7ff feaa 	bl	800fe60 <chSchReadyI>
 801010c:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 801010e:	f640 5350 	movw	r3, #3408	; 0xd50
 8010112:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010116:	9a01      	ldr	r2, [sp, #4]
 8010118:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 801011a:	9b01      	ldr	r3, [sp, #4]
 801011c:	2201      	movs	r2, #1
 801011e:	f883 2020 	strb.w	r2, [r3, #32]
    chSysSwitch(ntp, otp);
 8010122:	9803      	ldr	r0, [sp, #12]
 8010124:	f7ff fbec 	bl	800f900 <_dbg_trace.4285>
 8010128:	9801      	ldr	r0, [sp, #4]
 801012a:	9903      	ldr	r1, [sp, #12]
 801012c:	f7fd ff08 	bl	800df40 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8010130:	f3ef 8309 	mrs	r3, PSP
 8010134:	461c      	mov	r4, r3
  return(result);
 8010136:	4623      	mov	r3, r4
 8010138:	9302      	str	r3, [sp, #8]
 801013a:	9b02      	ldr	r3, [sp, #8]
 801013c:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8010140:	9b03      	ldr	r3, [sp, #12]
 8010142:	69db      	ldr	r3, [r3, #28]
 8010144:	429a      	cmp	r2, r3
 8010146:	d205      	bcs.n	8010154 <chSchWakeupS+0xc4>
 8010148:	f241 0010 	movw	r0, #4112	; 0x1010
 801014c:	f6c0 0001 	movt	r0, #2049	; 0x801
 8010150:	f7ff f91e 	bl	800f390 <chSysHalt>
 8010154:	9801      	ldr	r0, [sp, #4]
 8010156:	9903      	ldr	r1, [sp, #12]
 8010158:	f7f0 f8ba 	bl	80002d0 <_port_switch>
  }
}
 801015c:	b004      	add	sp, #16
 801015e:	bd10      	pop	{r4, pc}

08010160 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8010160:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 8010162:	f7ff fba5 	bl	800f8b0 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 8010166:	f7ff fe13 	bl	800fd90 <chSchIsRescRequiredI.5147.4240>
 801016a:	4603      	mov	r3, r0
 801016c:	2b00      	cmp	r3, #0
 801016e:	d001      	beq.n	8010174 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
 8010170:	f000 f86e 	bl	8010250 <chSchDoRescheduleAhead.4193>
  }
}
 8010174:	bd08      	pop	{r3, pc}
 8010176:	bf00      	nop
 8010178:	f3af 8000 	nop.w
 801017c:	f3af 8000 	nop.w

08010180 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8010180:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8010182:	f640 5350 	movw	r3, #3408	; 0xd50
 8010186:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801018a:	681b      	ldr	r3, [r3, #0]
 801018c:	689b      	ldr	r3, [r3, #8]
 801018e:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8010190:	f640 5350 	movw	r3, #3408	; 0xd50
 8010194:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010198:	699b      	ldr	r3, [r3, #24]
 801019a:	689b      	ldr	r3, [r3, #8]
 801019c:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 801019e:	9a01      	ldr	r2, [sp, #4]
 80101a0:	9b00      	ldr	r3, [sp, #0]
 80101a2:	429a      	cmp	r2, r3
 80101a4:	bf94      	ite	ls
 80101a6:	2300      	movls	r3, #0
 80101a8:	2301      	movhi	r3, #1
 80101aa:	b2db      	uxtb	r3, r3
#endif
}
 80101ac:	4618      	mov	r0, r3
 80101ae:	b002      	add	sp, #8
 80101b0:	4770      	bx	lr
 80101b2:	bf00      	nop
 80101b4:	f3af 8000 	nop.w
 80101b8:	f3af 8000 	nop.w
 80101bc:	f3af 8000 	nop.w

080101c0 <chSchDoRescheduleBehind.4195>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 80101c0:	b510      	push	{r4, lr}
 80101c2:	b082      	sub	sp, #8
  thread_t *otp;

  otp = currp;
 80101c4:	f640 5350 	movw	r3, #3408	; 0xd50
 80101c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80101cc:	699b      	ldr	r3, [r3, #24]
 80101ce:	9301      	str	r3, [sp, #4]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80101d0:	f640 5050 	movw	r0, #3408	; 0xd50
 80101d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80101d8:	f7ff fdb2 	bl	800fd40 <queue_fifo_remove.5124.4245>
 80101dc:	4602      	mov	r2, r0
 80101de:	f640 5350 	movw	r3, #3408	; 0xd50
 80101e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80101e6:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80101e8:	f640 5350 	movw	r3, #3408	; 0xd50
 80101ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80101f0:	699b      	ldr	r3, [r3, #24]
 80101f2:	2201      	movs	r2, #1
 80101f4:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
 80101f8:	9801      	ldr	r0, [sp, #4]
 80101fa:	f7ff fe31 	bl	800fe60 <chSchReadyI>
  chSysSwitch(currp, otp);
 80101fe:	9801      	ldr	r0, [sp, #4]
 8010200:	f7ff fb7e 	bl	800f900 <_dbg_trace.4285>
 8010204:	f640 5350 	movw	r3, #3408	; 0xd50
 8010208:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801020c:	699b      	ldr	r3, [r3, #24]
 801020e:	4618      	mov	r0, r3
 8010210:	9901      	ldr	r1, [sp, #4]
 8010212:	f7fd fe95 	bl	800df40 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8010216:	f3ef 8309 	mrs	r3, PSP
 801021a:	461c      	mov	r4, r3
  return(result);
 801021c:	4623      	mov	r3, r4
 801021e:	9300      	str	r3, [sp, #0]
 8010220:	9b00      	ldr	r3, [sp, #0]
 8010222:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8010226:	9b01      	ldr	r3, [sp, #4]
 8010228:	69db      	ldr	r3, [r3, #28]
 801022a:	429a      	cmp	r2, r3
 801022c:	d205      	bcs.n	801023a <chSchDoRescheduleBehind.4195+0x7a>
 801022e:	f241 0010 	movw	r0, #4112	; 0x1010
 8010232:	f6c0 0001 	movt	r0, #2049	; 0x801
 8010236:	f7ff f8ab 	bl	800f390 <chSysHalt>
 801023a:	f640 5350 	movw	r3, #3408	; 0xd50
 801023e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010242:	699b      	ldr	r3, [r3, #24]
 8010244:	4618      	mov	r0, r3
 8010246:	9901      	ldr	r1, [sp, #4]
 8010248:	f7f0 f842 	bl	80002d0 <_port_switch>
}
 801024c:	b002      	add	sp, #8
 801024e:	bd10      	pop	{r4, pc}

08010250 <chSchDoRescheduleAhead.4193>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8010250:	b510      	push	{r4, lr}
 8010252:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
 8010254:	f640 5350 	movw	r3, #3408	; 0xd50
 8010258:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801025c:	699b      	ldr	r3, [r3, #24]
 801025e:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8010260:	f640 5050 	movw	r0, #3408	; 0xd50
 8010264:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8010268:	f7ff fd6a 	bl	800fd40 <queue_fifo_remove.5124.4245>
 801026c:	4602      	mov	r2, r0
 801026e:	f640 5350 	movw	r3, #3408	; 0xd50
 8010272:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010276:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8010278:	f640 5350 	movw	r3, #3408	; 0xd50
 801027c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010280:	699b      	ldr	r3, [r3, #24]
 8010282:	2201      	movs	r2, #1
 8010284:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
 8010288:	9b02      	ldr	r3, [sp, #8]
 801028a:	2200      	movs	r2, #0
 801028c:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 8010290:	f640 5350 	movw	r3, #3408	; 0xd50
 8010294:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010298:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 801029a:	9b03      	ldr	r3, [sp, #12]
 801029c:	681b      	ldr	r3, [r3, #0]
 801029e:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
 80102a0:	9b03      	ldr	r3, [sp, #12]
 80102a2:	689a      	ldr	r2, [r3, #8]
 80102a4:	9b02      	ldr	r3, [sp, #8]
 80102a6:	689b      	ldr	r3, [r3, #8]
 80102a8:	429a      	cmp	r2, r3
 80102aa:	d8f6      	bhi.n	801029a <chSchDoRescheduleAhead.4193+0x4a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80102ac:	9b02      	ldr	r3, [sp, #8]
 80102ae:	9a03      	ldr	r2, [sp, #12]
 80102b0:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 80102b2:	9b03      	ldr	r3, [sp, #12]
 80102b4:	685a      	ldr	r2, [r3, #4]
 80102b6:	9b02      	ldr	r3, [sp, #8]
 80102b8:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 80102ba:	9b02      	ldr	r3, [sp, #8]
 80102bc:	685b      	ldr	r3, [r3, #4]
 80102be:	9a02      	ldr	r2, [sp, #8]
 80102c0:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 80102c2:	9b03      	ldr	r3, [sp, #12]
 80102c4:	9a02      	ldr	r2, [sp, #8]
 80102c6:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 80102c8:	9802      	ldr	r0, [sp, #8]
 80102ca:	f7ff fb19 	bl	800f900 <_dbg_trace.4285>
 80102ce:	f640 5350 	movw	r3, #3408	; 0xd50
 80102d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80102d6:	699b      	ldr	r3, [r3, #24]
 80102d8:	4618      	mov	r0, r3
 80102da:	9902      	ldr	r1, [sp, #8]
 80102dc:	f7fd fe30 	bl	800df40 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80102e0:	f3ef 8309 	mrs	r3, PSP
 80102e4:	461c      	mov	r4, r3
  return(result);
 80102e6:	4623      	mov	r3, r4
 80102e8:	9301      	str	r3, [sp, #4]
 80102ea:	9b01      	ldr	r3, [sp, #4]
 80102ec:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 80102f0:	9b02      	ldr	r3, [sp, #8]
 80102f2:	69db      	ldr	r3, [r3, #28]
 80102f4:	429a      	cmp	r2, r3
 80102f6:	d205      	bcs.n	8010304 <chSchDoRescheduleAhead.4193+0xb4>
 80102f8:	f241 0010 	movw	r0, #4112	; 0x1010
 80102fc:	f6c0 0001 	movt	r0, #2049	; 0x801
 8010300:	f7ff f846 	bl	800f390 <chSysHalt>
 8010304:	f640 5350 	movw	r3, #3408	; 0xd50
 8010308:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801030c:	699b      	ldr	r3, [r3, #24]
 801030e:	4618      	mov	r0, r3
 8010310:	9902      	ldr	r1, [sp, #8]
 8010312:	f7ef ffdd 	bl	80002d0 <_port_switch>
}
 8010316:	b004      	add	sp, #16
 8010318:	bd10      	pop	{r4, pc}
 801031a:	bf00      	nop
 801031c:	f3af 8000 	nop.w

08010320 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8010320:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8010322:	f7ff ff95 	bl	8010250 <chSchDoRescheduleAhead.4193>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8010326:	bd08      	pop	{r3, pc}
 8010328:	f3af 8000 	nop.w
 801032c:	f3af 8000 	nop.w

08010330 <port_lock.5268.4188>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8010330:	b082      	sub	sp, #8
 8010332:	2320      	movs	r3, #32
 8010334:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8010336:	9b01      	ldr	r3, [sp, #4]
 8010338:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 801033c:	b002      	add	sp, #8
 801033e:	4770      	bx	lr

08010340 <port_unlock.5271.4186>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8010340:	b082      	sub	sp, #8
 8010342:	2300      	movs	r3, #0
 8010344:	9301      	str	r3, [sp, #4]
 8010346:	9b01      	ldr	r3, [sp, #4]
 8010348:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 801034c:	b002      	add	sp, #8
 801034e:	4770      	bx	lr

08010350 <st_lld_get_counter.5273.4184>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8010350:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8010354:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8010356:	4618      	mov	r0, r3
 8010358:	4770      	bx	lr
 801035a:	bf00      	nop
 801035c:	f3af 8000 	nop.w

08010360 <port_timer_get_time.5278.4182>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8010360:	b508      	push	{r3, lr}

  return stGetCounter();
 8010362:	f7ff fff5 	bl	8010350 <st_lld_get_counter.5273.4184>
 8010366:	4603      	mov	r3, r0
}
 8010368:	4618      	mov	r0, r3
 801036a:	bd08      	pop	{r3, pc}
 801036c:	f3af 8000 	nop.w

08010370 <list_init.5280.4179>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8010370:	b082      	sub	sp, #8
 8010372:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8010374:	9b01      	ldr	r3, [sp, #4]
 8010376:	9a01      	ldr	r2, [sp, #4]
 8010378:	601a      	str	r2, [r3, #0]
}
 801037a:	b002      	add	sp, #8
 801037c:	4770      	bx	lr
 801037e:	bf00      	nop

08010380 <list_notempty.5367>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8010380:	b082      	sub	sp, #8
 8010382:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8010384:	9b01      	ldr	r3, [sp, #4]
 8010386:	681a      	ldr	r2, [r3, #0]
 8010388:	9b01      	ldr	r3, [sp, #4]
 801038a:	429a      	cmp	r2, r3
 801038c:	bf0c      	ite	eq
 801038e:	2300      	moveq	r3, #0
 8010390:	2301      	movne	r3, #1
 8010392:	b2db      	uxtb	r3, r3
}
 8010394:	4618      	mov	r0, r3
 8010396:	b002      	add	sp, #8
 8010398:	4770      	bx	lr
 801039a:	bf00      	nop
 801039c:	f3af 8000 	nop.w

080103a0 <queue_init.5371.4173>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80103a0:	b082      	sub	sp, #8
 80103a2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80103a4:	9b01      	ldr	r3, [sp, #4]
 80103a6:	9a01      	ldr	r2, [sp, #4]
 80103a8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80103aa:	9b01      	ldr	r3, [sp, #4]
 80103ac:	9a01      	ldr	r2, [sp, #4]
 80103ae:	605a      	str	r2, [r3, #4]
}
 80103b0:	b002      	add	sp, #8
 80103b2:	4770      	bx	lr
 80103b4:	f3af 8000 	nop.w
 80103b8:	f3af 8000 	nop.w
 80103bc:	f3af 8000 	nop.w

080103c0 <queue_notempty.5374>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 80103c0:	b082      	sub	sp, #8
 80103c2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80103c4:	9b01      	ldr	r3, [sp, #4]
 80103c6:	681a      	ldr	r2, [r3, #0]
 80103c8:	9b01      	ldr	r3, [sp, #4]
 80103ca:	429a      	cmp	r2, r3
 80103cc:	bf0c      	ite	eq
 80103ce:	2300      	moveq	r3, #0
 80103d0:	2301      	movne	r3, #1
 80103d2:	b2db      	uxtb	r3, r3
}
 80103d4:	4618      	mov	r0, r3
 80103d6:	b002      	add	sp, #8
 80103d8:	4770      	bx	lr
 80103da:	bf00      	nop
 80103dc:	f3af 8000 	nop.w

080103e0 <list_insert.5377>:

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
 80103e0:	b082      	sub	sp, #8
 80103e2:	9001      	str	r0, [sp, #4]
 80103e4:	9100      	str	r1, [sp, #0]

  tp->p_next = tlp->p_next;
 80103e6:	9b00      	ldr	r3, [sp, #0]
 80103e8:	681a      	ldr	r2, [r3, #0]
 80103ea:	9b01      	ldr	r3, [sp, #4]
 80103ec:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 80103ee:	9b00      	ldr	r3, [sp, #0]
 80103f0:	9a01      	ldr	r2, [sp, #4]
 80103f2:	601a      	str	r2, [r3, #0]
}
 80103f4:	b002      	add	sp, #8
 80103f6:	4770      	bx	lr
 80103f8:	f3af 8000 	nop.w
 80103fc:	f3af 8000 	nop.w

08010400 <list_remove.5381>:

static inline thread_t *list_remove(threads_list_t *tlp) {
 8010400:	b084      	sub	sp, #16
 8010402:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8010404:	9b01      	ldr	r3, [sp, #4]
 8010406:	681b      	ldr	r3, [r3, #0]
 8010408:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 801040a:	9b03      	ldr	r3, [sp, #12]
 801040c:	681a      	ldr	r2, [r3, #0]
 801040e:	9b01      	ldr	r3, [sp, #4]
 8010410:	601a      	str	r2, [r3, #0]

  return tp;
 8010412:	9b03      	ldr	r3, [sp, #12]
}
 8010414:	4618      	mov	r0, r3
 8010416:	b004      	add	sp, #16
 8010418:	4770      	bx	lr
 801041a:	bf00      	nop
 801041c:	f3af 8000 	nop.w

08010420 <queue_insert.5384>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8010420:	b082      	sub	sp, #8
 8010422:	9001      	str	r0, [sp, #4]
 8010424:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8010426:	9b01      	ldr	r3, [sp, #4]
 8010428:	9a00      	ldr	r2, [sp, #0]
 801042a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 801042c:	9b00      	ldr	r3, [sp, #0]
 801042e:	685a      	ldr	r2, [r3, #4]
 8010430:	9b01      	ldr	r3, [sp, #4]
 8010432:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8010434:	9b01      	ldr	r3, [sp, #4]
 8010436:	685b      	ldr	r3, [r3, #4]
 8010438:	9a01      	ldr	r2, [sp, #4]
 801043a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 801043c:	9b00      	ldr	r3, [sp, #0]
 801043e:	9a01      	ldr	r2, [sp, #4]
 8010440:	605a      	str	r2, [r3, #4]
}
 8010442:	b002      	add	sp, #8
 8010444:	4770      	bx	lr
 8010446:	bf00      	nop
 8010448:	f3af 8000 	nop.w
 801044c:	f3af 8000 	nop.w

08010450 <queue_fifo_remove.5388.4155>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8010450:	b084      	sub	sp, #16
 8010452:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8010454:	9b01      	ldr	r3, [sp, #4]
 8010456:	681b      	ldr	r3, [r3, #0]
 8010458:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 801045a:	9b03      	ldr	r3, [sp, #12]
 801045c:	681a      	ldr	r2, [r3, #0]
 801045e:	9b01      	ldr	r3, [sp, #4]
 8010460:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8010462:	9b01      	ldr	r3, [sp, #4]
 8010464:	681b      	ldr	r3, [r3, #0]
 8010466:	9a01      	ldr	r2, [sp, #4]
 8010468:	605a      	str	r2, [r3, #4]

  return tp;
 801046a:	9b03      	ldr	r3, [sp, #12]
}
 801046c:	4618      	mov	r0, r3
 801046e:	b004      	add	sp, #16
 8010470:	4770      	bx	lr
 8010472:	bf00      	nop
 8010474:	f3af 8000 	nop.w
 8010478:	f3af 8000 	nop.w
 801047c:	f3af 8000 	nop.w

08010480 <chSchCanYieldS.5414.4153>:
 * @retval false        if yielding is not possible.
 * @retval true         if there is a ready thread at equal or higher priority.
 *
 * @sclass
 */
static inline bool chSchCanYieldS(void) {
 8010480:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 8010482:	f7ff fa15 	bl	800f8b0 <chDbgCheckClassS>

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8010486:	f640 5350 	movw	r3, #3408	; 0xd50
 801048a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801048e:	681b      	ldr	r3, [r3, #0]
 8010490:	689a      	ldr	r2, [r3, #8]
 8010492:	f640 5350 	movw	r3, #3408	; 0xd50
 8010496:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801049a:	699b      	ldr	r3, [r3, #24]
 801049c:	689b      	ldr	r3, [r3, #8]
 801049e:	429a      	cmp	r2, r3
 80104a0:	bf34      	ite	cc
 80104a2:	2300      	movcc	r3, #0
 80104a4:	2301      	movcs	r3, #1
 80104a6:	b2db      	uxtb	r3, r3
}
 80104a8:	4618      	mov	r0, r3
 80104aa:	bd08      	pop	{r3, pc}
 80104ac:	f3af 8000 	nop.w

080104b0 <chSchDoYieldS.5416>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal or higher priority, if any.
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {
 80104b0:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 80104b2:	f7ff f9fd 	bl	800f8b0 <chDbgCheckClassS>

  if (chSchCanYieldS()) {
 80104b6:	f7ff ffe3 	bl	8010480 <chSchCanYieldS.5414.4153>
 80104ba:	4603      	mov	r3, r0
 80104bc:	2b00      	cmp	r3, #0
 80104be:	d001      	beq.n	80104c4 <chSchDoYieldS.5416+0x14>
    chSchDoRescheduleBehind();
 80104c0:	f7ff fe7e 	bl	80101c0 <chSchDoRescheduleBehind.4195>
  }
}
 80104c4:	bd08      	pop	{r3, pc}
 80104c6:	bf00      	nop
 80104c8:	f3af 8000 	nop.w
 80104cc:	f3af 8000 	nop.w

080104d0 <chSysLock.5400>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80104d0:	b508      	push	{r3, lr}

  port_lock();
 80104d2:	f7ff ff2d 	bl	8010330 <port_lock.5268.4188>
  _stats_start_measure_crit_thd();
 80104d6:	f7fd fd53 	bl	800df80 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80104da:	f7ff f901 	bl	800f6e0 <_dbg_check_lock>
}
 80104de:	bd08      	pop	{r3, pc}

080104e0 <chSysUnlock.5402>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80104e0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80104e2:	f7ff f91d 	bl	800f720 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80104e6:	f7fd fd53 	bl	800df90 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80104ea:	f640 5350 	movw	r3, #3408	; 0xd50
 80104ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80104f2:	681a      	ldr	r2, [r3, #0]
 80104f4:	f640 5350 	movw	r3, #3408	; 0xd50
 80104f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80104fc:	429a      	cmp	r2, r3
 80104fe:	d013      	beq.n	8010528 <chSysUnlock.5402+0x48>
 8010500:	f640 5350 	movw	r3, #3408	; 0xd50
 8010504:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010508:	699b      	ldr	r3, [r3, #24]
 801050a:	689a      	ldr	r2, [r3, #8]
 801050c:	f640 5350 	movw	r3, #3408	; 0xd50
 8010510:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010514:	681b      	ldr	r3, [r3, #0]
 8010516:	689b      	ldr	r3, [r3, #8]
 8010518:	429a      	cmp	r2, r3
 801051a:	d205      	bcs.n	8010528 <chSysUnlock.5402+0x48>
 801051c:	f241 60a0 	movw	r0, #5792	; 0x16a0
 8010520:	f6c0 0001 	movt	r0, #2049	; 0x801
 8010524:	f7fe ff34 	bl	800f390 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8010528:	f7ff ff0a 	bl	8010340 <port_unlock.5271.4186>
}
 801052c:	bd08      	pop	{r3, pc}
 801052e:	bf00      	nop

08010530 <chVTGetSystemTimeX.5391>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8010530:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8010532:	f7ff ff15 	bl	8010360 <port_timer_get_time.5278.4182>
 8010536:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8010538:	4618      	mov	r0, r3
 801053a:	bd08      	pop	{r3, pc}
 801053c:	f3af 8000 	nop.w

08010540 <chThdGetSelfX.5398>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8010540:	f640 5350 	movw	r3, #3408	; 0xd50
 8010544:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010548:	699b      	ldr	r3, [r3, #24]
}
 801054a:	4618      	mov	r0, r3
 801054c:	4770      	bx	lr
 801054e:	bf00      	nop

08010550 <chThdStartI.5404>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 8010550:	b500      	push	{lr}
 8010552:	b083      	sub	sp, #12
 8010554:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");
 8010556:	9b01      	ldr	r3, [sp, #4]
 8010558:	f893 3020 	ldrb.w	r3, [r3, #32]
 801055c:	2b02      	cmp	r3, #2
 801055e:	d005      	beq.n	801056c <chThdStartI.5404+0x1c>
 8010560:	f241 60b0 	movw	r0, #5808	; 0x16b0
 8010564:	f6c0 0001 	movt	r0, #2049	; 0x801
 8010568:	f7fe ff12 	bl	800f390 <chSysHalt>

  return chSchReadyI(tp);
 801056c:	9801      	ldr	r0, [sp, #4]
 801056e:	f7ff fc77 	bl	800fe60 <chSchReadyI>
 8010572:	4603      	mov	r3, r0
}
 8010574:	4618      	mov	r0, r3
 8010576:	b003      	add	sp, #12
 8010578:	f85d fb04 	ldr.w	pc, [sp], #4
 801057c:	f3af 8000 	nop.w

08010580 <chThdSleepS.5411>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 8010580:	b500      	push	{lr}
 8010582:	b083      	sub	sp, #12
 8010584:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
 8010586:	9b01      	ldr	r3, [sp, #4]
 8010588:	2b00      	cmp	r3, #0
 801058a:	d105      	bne.n	8010598 <chThdSleepS.5411+0x18>
 801058c:	f241 60e0 	movw	r0, #5856	; 0x16e0
 8010590:	f6c0 0001 	movt	r0, #2049	; 0x801
 8010594:	f7fe fefc 	bl	800f390 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8010598:	2008      	movs	r0, #8
 801059a:	9901      	ldr	r1, [sp, #4]
 801059c:	f7ff fd38 	bl	8010010 <chSchGoSleepTimeoutS>
}
 80105a0:	b003      	add	sp, #12
 80105a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80105a6:	bf00      	nop
 80105a8:	f3af 8000 	nop.w
 80105ac:	f3af 8000 	nop.w

080105b0 <chThdDoDequeueNextI.5407>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80105b0:	b500      	push	{lr}
 80105b2:	b085      	sub	sp, #20
 80105b4:	9001      	str	r0, [sp, #4]
 80105b6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 80105b8:	9801      	ldr	r0, [sp, #4]
 80105ba:	f7ff ff01 	bl	80103c0 <queue_notempty.5374>
 80105be:	4603      	mov	r3, r0
 80105c0:	f083 0301 	eor.w	r3, r3, #1
 80105c4:	b2db      	uxtb	r3, r3
 80105c6:	2b00      	cmp	r3, #0
 80105c8:	d005      	beq.n	80105d6 <chThdDoDequeueNextI.5407+0x26>
 80105ca:	f241 7030 	movw	r0, #5936	; 0x1730
 80105ce:	f6c0 0001 	movt	r0, #2049	; 0x801
 80105d2:	f7fe fedd 	bl	800f390 <chSysHalt>

  tp = queue_fifo_remove(tqp);
 80105d6:	9801      	ldr	r0, [sp, #4]
 80105d8:	f7ff ff3a 	bl	8010450 <queue_fifo_remove.5388.4155>
 80105dc:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 80105de:	9b03      	ldr	r3, [sp, #12]
 80105e0:	f893 3020 	ldrb.w	r3, [r3, #32]
 80105e4:	2b04      	cmp	r3, #4
 80105e6:	d005      	beq.n	80105f4 <chThdDoDequeueNextI.5407+0x44>
 80105e8:	f241 7030 	movw	r0, #5936	; 0x1730
 80105ec:	f6c0 0001 	movt	r0, #2049	; 0x801
 80105f0:	f7fe fece 	bl	800f390 <chSysHalt>

  tp->p_u.rdymsg = msg;
 80105f4:	9b03      	ldr	r3, [sp, #12]
 80105f6:	9a00      	ldr	r2, [sp, #0]
 80105f8:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80105fa:	9803      	ldr	r0, [sp, #12]
 80105fc:	f7ff fc30 	bl	800fe60 <chSchReadyI>
}
 8010600:	b005      	add	sp, #20
 8010602:	f85d fb04 	ldr.w	pc, [sp], #4
 8010606:	bf00      	nop
 8010608:	f3af 8000 	nop.w
 801060c:	f3af 8000 	nop.w

08010610 <_thread_init.4122>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8010610:	b500      	push	{lr}
 8010612:	b083      	sub	sp, #12
 8010614:	9001      	str	r0, [sp, #4]
 8010616:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8010618:	9b01      	ldr	r3, [sp, #4]
 801061a:	9a00      	ldr	r2, [sp, #0]
 801061c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 801061e:	9b01      	ldr	r3, [sp, #4]
 8010620:	2202      	movs	r2, #2
 8010622:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8010626:	9b01      	ldr	r3, [sp, #4]
 8010628:	2200      	movs	r2, #0
 801062a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 801062e:	9b01      	ldr	r3, [sp, #4]
 8010630:	9a00      	ldr	r2, [sp, #0]
 8010632:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
 8010634:	9b01      	ldr	r3, [sp, #4]
 8010636:	2200      	movs	r2, #0
 8010638:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 801063a:	9b01      	ldr	r3, [sp, #4]
 801063c:	2200      	movs	r2, #0
 801063e:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8010640:	9b01      	ldr	r3, [sp, #4]
 8010642:	2201      	movs	r2, #1
 8010644:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8010648:	9b01      	ldr	r3, [sp, #4]
 801064a:	2200      	movs	r2, #0
 801064c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 801064e:	9a01      	ldr	r2, [sp, #4]
 8010650:	f640 5350 	movw	r3, #3408	; 0xd50
 8010654:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010658:	6113      	str	r3, [r2, #16]
 801065a:	f640 5350 	movw	r3, #3408	; 0xd50
 801065e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010662:	695a      	ldr	r2, [r3, #20]
 8010664:	9b01      	ldr	r3, [sp, #4]
 8010666:	615a      	str	r2, [r3, #20]
 8010668:	9b01      	ldr	r3, [sp, #4]
 801066a:	695b      	ldr	r3, [r3, #20]
 801066c:	9a01      	ldr	r2, [sp, #4]
 801066e:	611a      	str	r2, [r3, #16]
 8010670:	f640 5350 	movw	r3, #3408	; 0xd50
 8010674:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8010678:	9a01      	ldr	r2, [sp, #4]
 801067a:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 801067c:	9b01      	ldr	r3, [sp, #4]
 801067e:	3328      	adds	r3, #40	; 0x28
 8010680:	4618      	mov	r0, r3
 8010682:	f7ff fe75 	bl	8010370 <list_init.5280.4179>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8010686:	9b01      	ldr	r3, [sp, #4]
 8010688:	332c      	adds	r3, #44	; 0x2c
 801068a:	4618      	mov	r0, r3
 801068c:	f7ff fe88 	bl	80103a0 <queue_init.5371.4173>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 8010690:	9b01      	ldr	r3, [sp, #4]
 8010692:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8010696:	9b01      	ldr	r3, [sp, #4]
 8010698:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->p_stats);
 801069a:	9b01      	ldr	r3, [sp, #4]
 801069c:	3348      	adds	r3, #72	; 0x48
 801069e:	4618      	mov	r0, r3
 80106a0:	f7fd fb9e 	bl	800dde0 <chTMObjectInit>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 80106a4:	9b01      	ldr	r3, [sp, #4]
}
 80106a6:	4618      	mov	r0, r3
 80106a8:	b003      	add	sp, #12
 80106aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80106ae:	bf00      	nop

080106b0 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 80106b0:	b084      	sub	sp, #16
 80106b2:	9003      	str	r0, [sp, #12]
 80106b4:	9102      	str	r1, [sp, #8]
 80106b6:	4613      	mov	r3, r2
 80106b8:	f88d 3007 	strb.w	r3, [sp, #7]
 80106bc:	e005      	b.n	80106ca <_thread_memfill+0x1a>

  while (startp < endp) {
    *startp++ = v;
 80106be:	9b03      	ldr	r3, [sp, #12]
 80106c0:	1c5a      	adds	r2, r3, #1
 80106c2:	9203      	str	r2, [sp, #12]
 80106c4:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80106c8:	701a      	strb	r2, [r3, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80106ca:	9a03      	ldr	r2, [sp, #12]
 80106cc:	9b02      	ldr	r3, [sp, #8]
 80106ce:	429a      	cmp	r2, r3
 80106d0:	d3f5      	bcc.n	80106be <_thread_memfill+0xe>
    *startp++ = v;
  }
}
 80106d2:	b004      	add	sp, #16
 80106d4:	4770      	bx	lr
 80106d6:	bf00      	nop
 80106d8:	f3af 8000 	nop.w
 80106dc:	f3af 8000 	nop.w

080106e0 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 80106e0:	b500      	push	{lr}
 80106e2:	b087      	sub	sp, #28
 80106e4:	9003      	str	r0, [sp, #12]
 80106e6:	9102      	str	r1, [sp, #8]
 80106e8:	9201      	str	r2, [sp, #4]
 80106ea:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 80106ec:	9b03      	ldr	r3, [sp, #12]
 80106ee:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 80106f0:	f7ff f8c6 	bl	800f880 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 80106f4:	9b03      	ldr	r3, [sp, #12]
 80106f6:	2b00      	cmp	r3, #0
 80106f8:	d008      	beq.n	801070c <chThdCreateI+0x2c>
 80106fa:	9b02      	ldr	r3, [sp, #8]
 80106fc:	2be7      	cmp	r3, #231	; 0xe7
 80106fe:	d905      	bls.n	801070c <chThdCreateI+0x2c>
 8010700:	9b01      	ldr	r3, [sp, #4]
 8010702:	2b7f      	cmp	r3, #127	; 0x7f
 8010704:	d802      	bhi.n	801070c <chThdCreateI+0x2c>
 8010706:	9b00      	ldr	r3, [sp, #0]
 8010708:	2b00      	cmp	r3, #0
 801070a:	d105      	bne.n	8010718 <chThdCreateI+0x38>
 801070c:	f241 6090 	movw	r0, #5776	; 0x1690
 8010710:	f6c0 0001 	movt	r0, #2049	; 0x801
 8010714:	f7fe fe3c 	bl	800f390 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8010718:	9b02      	ldr	r3, [sp, #8]
 801071a:	3b24      	subs	r3, #36	; 0x24
 801071c:	9a03      	ldr	r2, [sp, #12]
 801071e:	441a      	add	r2, r3
 8010720:	9b05      	ldr	r3, [sp, #20]
 8010722:	60da      	str	r2, [r3, #12]
 8010724:	9b05      	ldr	r3, [sp, #20]
 8010726:	68db      	ldr	r3, [r3, #12]
 8010728:	9a00      	ldr	r2, [sp, #0]
 801072a:	601a      	str	r2, [r3, #0]
 801072c:	9b05      	ldr	r3, [sp, #20]
 801072e:	68db      	ldr	r3, [r3, #12]
 8010730:	9a08      	ldr	r2, [sp, #32]
 8010732:	605a      	str	r2, [r3, #4]
 8010734:	9b05      	ldr	r3, [sp, #20]
 8010736:	68da      	ldr	r2, [r3, #12]
 8010738:	f240 23e1 	movw	r3, #737	; 0x2e1
 801073c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8010740:	6213      	str	r3, [r2, #32]

  return _thread_init(tp, prio);
 8010742:	9805      	ldr	r0, [sp, #20]
 8010744:	9901      	ldr	r1, [sp, #4]
 8010746:	f7ff ff63 	bl	8010610 <_thread_init.4122>
 801074a:	4603      	mov	r3, r0
}
 801074c:	4618      	mov	r0, r3
 801074e:	b007      	add	sp, #28
 8010750:	f85d fb04 	ldr.w	pc, [sp], #4
 8010754:	f3af 8000 	nop.w
 8010758:	f3af 8000 	nop.w
 801075c:	f3af 8000 	nop.w

08010760 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8010760:	b500      	push	{lr}
 8010762:	b089      	sub	sp, #36	; 0x24
 8010764:	9005      	str	r0, [sp, #20]
 8010766:	9104      	str	r1, [sp, #16]
 8010768:	9203      	str	r2, [sp, #12]
 801076a:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 801076c:	9b05      	ldr	r3, [sp, #20]
 801076e:	3360      	adds	r3, #96	; 0x60
 8010770:	9805      	ldr	r0, [sp, #20]
 8010772:	4619      	mov	r1, r3
 8010774:	22ff      	movs	r2, #255	; 0xff
 8010776:	f7ff ff9b 	bl	80106b0 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 801077a:	9b05      	ldr	r3, [sp, #20]
 801077c:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8010780:	9905      	ldr	r1, [sp, #20]
 8010782:	9b04      	ldr	r3, [sp, #16]
 8010784:	440b      	add	r3, r1
 8010786:	4610      	mov	r0, r2
 8010788:	4619      	mov	r1, r3
 801078a:	2255      	movs	r2, #85	; 0x55
 801078c:	f7ff ff90 	bl	80106b0 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8010790:	f7ff fe9e 	bl	80104d0 <chSysLock.5400>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8010794:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010796:	9300      	str	r3, [sp, #0]
 8010798:	9805      	ldr	r0, [sp, #20]
 801079a:	9904      	ldr	r1, [sp, #16]
 801079c:	9a03      	ldr	r2, [sp, #12]
 801079e:	9b02      	ldr	r3, [sp, #8]
 80107a0:	f7ff ff9e 	bl	80106e0 <chThdCreateI>
 80107a4:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 80107a6:	9807      	ldr	r0, [sp, #28]
 80107a8:	2100      	movs	r1, #0
 80107aa:	f7ff fc71 	bl	8010090 <chSchWakeupS>
  chSysUnlock();
 80107ae:	f7ff fe97 	bl	80104e0 <chSysUnlock.5402>

  return tp;
 80107b2:	9b07      	ldr	r3, [sp, #28]
}
 80107b4:	4618      	mov	r0, r3
 80107b6:	b009      	add	sp, #36	; 0x24
 80107b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80107bc:	f3af 8000 	nop.w

080107c0 <memset>:
 80107c0:	b4f0      	push	{r4, r5, r6, r7}
 80107c2:	0784      	lsls	r4, r0, #30
 80107c4:	d043      	beq.n	801084e <memset+0x8e>
 80107c6:	1e54      	subs	r4, r2, #1
 80107c8:	2a00      	cmp	r2, #0
 80107ca:	d03e      	beq.n	801084a <memset+0x8a>
 80107cc:	b2cd      	uxtb	r5, r1
 80107ce:	4603      	mov	r3, r0
 80107d0:	e003      	b.n	80107da <memset+0x1a>
 80107d2:	1e62      	subs	r2, r4, #1
 80107d4:	2c00      	cmp	r4, #0
 80107d6:	d038      	beq.n	801084a <memset+0x8a>
 80107d8:	4614      	mov	r4, r2
 80107da:	f803 5b01 	strb.w	r5, [r3], #1
 80107de:	079a      	lsls	r2, r3, #30
 80107e0:	d1f7      	bne.n	80107d2 <memset+0x12>
 80107e2:	2c03      	cmp	r4, #3
 80107e4:	d92a      	bls.n	801083c <memset+0x7c>
 80107e6:	b2cd      	uxtb	r5, r1
 80107e8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80107ec:	2c0f      	cmp	r4, #15
 80107ee:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80107f2:	d915      	bls.n	8010820 <memset+0x60>
 80107f4:	f1a4 0710 	sub.w	r7, r4, #16
 80107f8:	093f      	lsrs	r7, r7, #4
 80107fa:	f103 0610 	add.w	r6, r3, #16
 80107fe:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 8010802:	461a      	mov	r2, r3
 8010804:	6015      	str	r5, [r2, #0]
 8010806:	6055      	str	r5, [r2, #4]
 8010808:	6095      	str	r5, [r2, #8]
 801080a:	60d5      	str	r5, [r2, #12]
 801080c:	3210      	adds	r2, #16
 801080e:	42b2      	cmp	r2, r6
 8010810:	d1f8      	bne.n	8010804 <memset+0x44>
 8010812:	f004 040f 	and.w	r4, r4, #15
 8010816:	3701      	adds	r7, #1
 8010818:	2c03      	cmp	r4, #3
 801081a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 801081e:	d90d      	bls.n	801083c <memset+0x7c>
 8010820:	461e      	mov	r6, r3
 8010822:	4622      	mov	r2, r4
 8010824:	3a04      	subs	r2, #4
 8010826:	2a03      	cmp	r2, #3
 8010828:	f846 5b04 	str.w	r5, [r6], #4
 801082c:	d8fa      	bhi.n	8010824 <memset+0x64>
 801082e:	1f22      	subs	r2, r4, #4
 8010830:	f022 0203 	bic.w	r2, r2, #3
 8010834:	3204      	adds	r2, #4
 8010836:	4413      	add	r3, r2
 8010838:	f004 0403 	and.w	r4, r4, #3
 801083c:	b12c      	cbz	r4, 801084a <memset+0x8a>
 801083e:	b2c9      	uxtb	r1, r1
 8010840:	441c      	add	r4, r3
 8010842:	f803 1b01 	strb.w	r1, [r3], #1
 8010846:	42a3      	cmp	r3, r4
 8010848:	d1fb      	bne.n	8010842 <memset+0x82>
 801084a:	bcf0      	pop	{r4, r5, r6, r7}
 801084c:	4770      	bx	lr
 801084e:	4614      	mov	r4, r2
 8010850:	4603      	mov	r3, r0
 8010852:	e7c6      	b.n	80107e2 <memset+0x22>
	...

08010860 <strpbrk>:
 8010860:	b4f0      	push	{r4, r5, r6, r7}
 8010862:	7804      	ldrb	r4, [r0, #0]
 8010864:	b30c      	cbz	r4, 80108aa <strpbrk+0x4a>
 8010866:	780e      	ldrb	r6, [r1, #0]
 8010868:	4607      	mov	r7, r0
 801086a:	b1c6      	cbz	r6, 801089e <strpbrk+0x3e>
 801086c:	42a6      	cmp	r6, r4
 801086e:	d010      	beq.n	8010892 <strpbrk+0x32>
 8010870:	1c4b      	adds	r3, r1, #1
 8010872:	e001      	b.n	8010878 <strpbrk+0x18>
 8010874:	4294      	cmp	r4, r2
 8010876:	d00b      	beq.n	8010890 <strpbrk+0x30>
 8010878:	461d      	mov	r5, r3
 801087a:	f813 2b01 	ldrb.w	r2, [r3], #1
 801087e:	2a00      	cmp	r2, #0
 8010880:	d1f8      	bne.n	8010874 <strpbrk+0x14>
 8010882:	7844      	ldrb	r4, [r0, #1]
 8010884:	3001      	adds	r0, #1
 8010886:	2c00      	cmp	r4, #0
 8010888:	d1ee      	bne.n	8010868 <strpbrk+0x8>
 801088a:	782e      	ldrb	r6, [r5, #0]
 801088c:	4607      	mov	r7, r0
 801088e:	e000      	b.n	8010892 <strpbrk+0x32>
 8010890:	4626      	mov	r6, r4
 8010892:	2e00      	cmp	r6, #0
 8010894:	bf14      	ite	ne
 8010896:	4638      	movne	r0, r7
 8010898:	2000      	moveq	r0, #0
 801089a:	bcf0      	pop	{r4, r5, r6, r7}
 801089c:	4770      	bx	lr
 801089e:	7844      	ldrb	r4, [r0, #1]
 80108a0:	460d      	mov	r5, r1
 80108a2:	3001      	adds	r0, #1
 80108a4:	2c00      	cmp	r4, #0
 80108a6:	d1df      	bne.n	8010868 <strpbrk+0x8>
 80108a8:	e7ef      	b.n	801088a <strpbrk+0x2a>
 80108aa:	4620      	mov	r0, r4
 80108ac:	bcf0      	pop	{r4, r5, r6, r7}
 80108ae:	4770      	bx	lr

080108b0 <strspn>:
 80108b0:	b4f0      	push	{r4, r5, r6, r7}
 80108b2:	7804      	ldrb	r4, [r0, #0]
 80108b4:	b1cc      	cbz	r4, 80108ea <strspn+0x3a>
 80108b6:	780e      	ldrb	r6, [r1, #0]
 80108b8:	4607      	mov	r7, r0
 80108ba:	b19e      	cbz	r6, 80108e4 <strspn+0x34>
 80108bc:	4605      	mov	r5, r0
 80108be:	42b4      	cmp	r4, r6
 80108c0:	d00a      	beq.n	80108d8 <strspn+0x28>
 80108c2:	460a      	mov	r2, r1
 80108c4:	e001      	b.n	80108ca <strspn+0x1a>
 80108c6:	429c      	cmp	r4, r3
 80108c8:	d006      	beq.n	80108d8 <strspn+0x28>
 80108ca:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80108ce:	2b00      	cmp	r3, #0
 80108d0:	d1f9      	bne.n	80108c6 <strspn+0x16>
 80108d2:	1a28      	subs	r0, r5, r0
 80108d4:	bcf0      	pop	{r4, r5, r6, r7}
 80108d6:	4770      	bx	lr
 80108d8:	786c      	ldrb	r4, [r5, #1]
 80108da:	1c7d      	adds	r5, r7, #1
 80108dc:	2c00      	cmp	r4, #0
 80108de:	d0f8      	beq.n	80108d2 <strspn+0x22>
 80108e0:	462f      	mov	r7, r5
 80108e2:	e7ec      	b.n	80108be <strspn+0xe>
 80108e4:	4630      	mov	r0, r6
 80108e6:	bcf0      	pop	{r4, r5, r6, r7}
 80108e8:	4770      	bx	lr
 80108ea:	4620      	mov	r0, r4
 80108ec:	e7f2      	b.n	80108d4 <strspn+0x24>
 80108ee:	bf00      	nop
 80108f0:	0000445e 	.word	0x0000445e
 80108f4:	00000a0d 	.word	0x00000a0d
 80108f8:	6c756e28 	.word	0x6c756e28
 80108fc:	0000296c 	.word	0x0000296c
 8010900:	67617355 	.word	0x67617355
 8010904:	6d203a65 	.word	0x6d203a65
 8010908:	0a0d6d65 	.word	0x0a0d6d65
 801090c:	00000000 	.word	0x00000000
 8010910:	65726f63 	.word	0x65726f63
 8010914:	65726620 	.word	0x65726620
 8010918:	656d2065 	.word	0x656d2065
 801091c:	79726f6d 	.word	0x79726f6d
 8010920:	25203a20 	.word	0x25203a20
 8010924:	79622075 	.word	0x79622075
 8010928:	0d736574 	.word	0x0d736574
 801092c:	0000000a 	.word	0x0000000a
 8010930:	70616568 	.word	0x70616568
 8010934:	61726620 	.word	0x61726620
 8010938:	6e656d67 	.word	0x6e656d67
 801093c:	20207374 	.word	0x20207374
 8010940:	25203a20 	.word	0x25203a20
 8010944:	000a0d75 	.word	0x000a0d75
 8010948:	70616568 	.word	0x70616568
 801094c:	65726620 	.word	0x65726620
 8010950:	6f742065 	.word	0x6f742065
 8010954:	206c6174 	.word	0x206c6174
 8010958:	25203a20 	.word	0x25203a20
 801095c:	79622075 	.word	0x79622075
 8010960:	0d736574 	.word	0x0d736574
 8010964:	0000000a 	.word	0x0000000a
 8010968:	67617355 	.word	0x67617355
 801096c:	74203a65 	.word	0x74203a65
 8010970:	61657268 	.word	0x61657268
 8010974:	0a0d7364 	.word	0x0a0d7364
 8010978:	00000000 	.word	0x00000000
 801097c:	20202020 	.word	0x20202020
 8010980:	72646461 	.word	0x72646461
 8010984:	20202020 	.word	0x20202020
 8010988:	63617473 	.word	0x63617473
 801098c:	7270206b 	.word	0x7270206b
 8010990:	72206f69 	.word	0x72206f69
 8010994:	20736665 	.word	0x20736665
 8010998:	20202020 	.word	0x20202020
 801099c:	74617473 	.word	0x74617473
 80109a0:	69742065 	.word	0x69742065
 80109a4:	0a0d656d 	.word	0x0a0d656d
 80109a8:	00000000 	.word	0x00000000
 80109ac:	6c383025 	.word	0x6c383025
 80109b0:	30252078 	.word	0x30252078
 80109b4:	20786c38 	.word	0x20786c38
 80109b8:	756c3425 	.word	0x756c3425
 80109bc:	6c342520 	.word	0x6c342520
 80109c0:	39252075 	.word	0x39252075
 80109c4:	000a0d73 	.word	0x000a0d73
 80109c8:	67617355 	.word	0x67617355
 80109cc:	74203a65 	.word	0x74203a65
 80109d0:	0d747365 	.word	0x0d747365
 80109d4:	0000000a 	.word	0x0000000a
 80109d8:	2074756f 	.word	0x2074756f
 80109dc:	6d20666f 	.word	0x6d20666f
 80109e0:	726f6d65 	.word	0x726f6d65
 80109e4:	000a0d79 	.word	0x000a0d79
 80109e8:	67617355 	.word	0x67617355
 80109ec:	77203a65 	.word	0x77203a65
 80109f0:	65746972 	.word	0x65746972
 80109f4:	00000a0d 	.word	0x00000a0d
 80109f8:	730a0a0d 	.word	0x730a0a0d
 80109fc:	70706f74 	.word	0x70706f74
 8010a00:	0a0d6465 	.word	0x0a0d6465
 8010a04:	00000000 	.word	0x00000000
 8010a08:	6e696c62 	.word	0x6e696c62
 8010a0c:	0072656b 	.word	0x0072656b
 8010a10:	202d2d2d 	.word	0x202d2d2d
 8010a14:	726f6353 	.word	0x726f6353
 8010a18:	203a2065 	.word	0x203a2065
 8010a1c:	00000000 	.word	0x00000000
 8010a20:	67736d20 	.word	0x67736d20
 8010a24:	2c532f73 	.word	0x2c532f73
 8010a28:	00000020 	.word	0x00000020
 8010a2c:	78746320 	.word	0x78746320
 8010a30:	2f637773 	.word	0x2f637773
 8010a34:	00000053 	.word	0x00000053
 8010a38:	72687420 	.word	0x72687420
 8010a3c:	73646165 	.word	0x73646165
 8010a40:	0000532f 	.word	0x0000532f
 8010a44:	73657220 	.word	0x73657220
 8010a48:	64656863 	.word	0x64656863
 8010a4c:	73656c75 	.word	0x73656c75
 8010a50:	202c532f 	.word	0x202c532f
 8010a54:	00000000 	.word	0x00000000
 8010a58:	74796220 	.word	0x74796220
 8010a5c:	532f7365 	.word	0x532f7365
 8010a60:	00000000 	.word	0x00000000
 8010a64:	6d697420 	.word	0x6d697420
 8010a68:	2f737265 	.word	0x2f737265
 8010a6c:	00000053 	.word	0x00000053
 8010a70:	69617720 	.word	0x69617720
 8010a74:	69732b74 	.word	0x69732b74
 8010a78:	6c616e67 	.word	0x6c616e67
 8010a7c:	0000532f 	.word	0x0000532f
 8010a80:	636f6c20 	.word	0x636f6c20
 8010a84:	6e752b6b 	.word	0x6e752b6b
 8010a88:	6b636f6c 	.word	0x6b636f6c
 8010a8c:	0000532f 	.word	0x0000532f
 8010a90:	202d2d2d 	.word	0x202d2d2d
 8010a94:	74737953 	.word	0x74737953
 8010a98:	203a6d65 	.word	0x203a6d65
 8010a9c:	00000000 	.word	0x00000000
 8010aa0:	74796220 	.word	0x74796220
 8010aa4:	00007365 	.word	0x00007365
 8010aa8:	202d2d2d 	.word	0x202d2d2d
 8010aac:	65726854 	.word	0x65726854
 8010ab0:	203a6461 	.word	0x203a6461
 8010ab4:	00000000 	.word	0x00000000
 8010ab8:	202d2d2d 	.word	0x202d2d2d
 8010abc:	656d6954 	.word	0x656d6954
 8010ac0:	203a2072 	.word	0x203a2072
 8010ac4:	00000000 	.word	0x00000000
 8010ac8:	202d2d2d 	.word	0x202d2d2d
 8010acc:	616d6553 	.word	0x616d6553
 8010ad0:	203a6870 	.word	0x203a6870
 8010ad4:	00000000 	.word	0x00000000
 8010ad8:	202d2d2d 	.word	0x202d2d2d
 8010adc:	6e657645 	.word	0x6e657645
 8010ae0:	203a5374 	.word	0x203a5374
 8010ae4:	00000000 	.word	0x00000000
 8010ae8:	202d2d2d 	.word	0x202d2d2d
 8010aec:	6e657645 	.word	0x6e657645
 8010af0:	203a4c74 	.word	0x203a4c74
 8010af4:	00000000 	.word	0x00000000
 8010af8:	202d2d2d 	.word	0x202d2d2d
 8010afc:	6574754d 	.word	0x6574754d
 8010b00:	203a2078 	.word	0x203a2078
 8010b04:	00000000 	.word	0x00000000
 8010b08:	202d2d2d 	.word	0x202d2d2d
 8010b0c:	646e6f43 	.word	0x646e6f43
 8010b10:	203a2e56 	.word	0x203a2e56
 8010b14:	00000000 	.word	0x00000000
 8010b18:	202d2d2d 	.word	0x202d2d2d
 8010b1c:	75657551 	.word	0x75657551
 8010b20:	203a2065 	.word	0x203a2065
 8010b24:	00000000 	.word	0x00000000
 8010b28:	202d2d2d 	.word	0x202d2d2d
 8010b2c:	6c69614d 	.word	0x6c69614d
 8010b30:	203a2e42 	.word	0x203a2e42
 8010b34:	00000000 	.word	0x00000000
 8010b38:	67617355 	.word	0x67617355
 8010b3c:	25203a65 	.word	0x25203a65
 8010b40:	000a0d73 	.word	0x000a0d73
 8010b44:	00207325 	.word	0x00207325
 8010b48:	6f666e69 	.word	0x6f666e69
 8010b4c:	00000000 	.word	0x00000000
 8010b50:	6e72654b 	.word	0x6e72654b
 8010b54:	203a6c65 	.word	0x203a6c65
 8010b58:	20202020 	.word	0x20202020
 8010b5c:	73252020 	.word	0x73252020
 8010b60:	00000a0d 	.word	0x00000a0d
 8010b64:	2e312e33 	.word	0x2e312e33
 8010b68:	00000033 	.word	0x00000033
 8010b6c:	706d6f43 	.word	0x706d6f43
 8010b70:	72656c69 	.word	0x72656c69
 8010b74:	2020203a 	.word	0x2020203a
 8010b78:	73252020 	.word	0x73252020
 8010b7c:	00000a0d 	.word	0x00000a0d
 8010b80:	20434347 	.word	0x20434347
 8010b84:	2e382e34 	.word	0x2e382e34
 8010b88:	00000032 	.word	0x00000032
 8010b8c:	68637241 	.word	0x68637241
 8010b90:	63657469 	.word	0x63657469
 8010b94:	65727574 	.word	0x65727574
 8010b98:	7325203a 	.word	0x7325203a
 8010b9c:	00000a0d 	.word	0x00000a0d
 8010ba0:	764d5241 	.word	0x764d5241
 8010ba4:	4d2d4537 	.word	0x4d2d4537
 8010ba8:	00000000 	.word	0x00000000
 8010bac:	65726f43 	.word	0x65726f43
 8010bb0:	72615620 	.word	0x72615620
 8010bb4:	746e6169 	.word	0x746e6169
 8010bb8:	7325203a 	.word	0x7325203a
 8010bbc:	00000a0d 	.word	0x00000a0d
 8010bc0:	74726f43 	.word	0x74726f43
 8010bc4:	4d2d7865 	.word	0x4d2d7865
 8010bc8:	00000034 	.word	0x00000034
 8010bcc:	74726f50 	.word	0x74726f50
 8010bd0:	666e4920 	.word	0x666e4920
 8010bd4:	20203a6f 	.word	0x20203a6f
 8010bd8:	73252020 	.word	0x73252020
 8010bdc:	00000a0d 	.word	0x00000a0d
 8010be0:	61766441 	.word	0x61766441
 8010be4:	6465636e 	.word	0x6465636e
 8010be8:	72656b20 	.word	0x72656b20
 8010bec:	206c656e 	.word	0x206c656e
 8010bf0:	65646f6d 	.word	0x65646f6d
 8010bf4:	00000000 	.word	0x00000000
 8010bf8:	74616c50 	.word	0x74616c50
 8010bfc:	6d726f66 	.word	0x6d726f66
 8010c00:	2020203a 	.word	0x2020203a
 8010c04:	73252020 	.word	0x73252020
 8010c08:	00000a0d 	.word	0x00000a0d
 8010c0c:	334d5453 	.word	0x334d5453
 8010c10:	30344632 	.word	0x30344632
 8010c14:	69482037 	.word	0x69482037
 8010c18:	50206867 	.word	0x50206867
 8010c1c:	6f667265 	.word	0x6f667265
 8010c20:	6e616d72 	.word	0x6e616d72
 8010c24:	77206563 	.word	0x77206563
 8010c28:	20687469 	.word	0x20687469
 8010c2c:	20505344 	.word	0x20505344
 8010c30:	20646e61 	.word	0x20646e61
 8010c34:	00555046 	.word	0x00555046
 8010c38:	72616f42 	.word	0x72616f42
 8010c3c:	20203a64 	.word	0x20203a64
 8010c40:	20202020 	.word	0x20202020
 8010c44:	73252020 	.word	0x73252020
 8010c48:	00000a0d 	.word	0x00000a0d
 8010c4c:	694d5453 	.word	0x694d5453
 8010c50:	656f7263 	.word	0x656f7263
 8010c54:	7463656c 	.word	0x7463656c
 8010c58:	696e6f72 	.word	0x696e6f72
 8010c5c:	53207363 	.word	0x53207363
 8010c60:	32334d54 	.word	0x32334d54
 8010c64:	442d3446 	.word	0x442d3446
 8010c68:	6f637369 	.word	0x6f637369
 8010c6c:	79726576 	.word	0x79726576
 8010c70:	00000000 	.word	0x00000000
 8010c74:	6c697542 	.word	0x6c697542
 8010c78:	69742064 	.word	0x69742064
 8010c7c:	203a656d 	.word	0x203a656d
 8010c80:	73252020 	.word	0x73252020
 8010c84:	73257325 	.word	0x73257325
 8010c88:	00000a0d 	.word	0x00000a0d
 8010c8c:	2072614d 	.word	0x2072614d
 8010c90:	32203033 	.word	0x32203033
 8010c94:	00363130 	.word	0x00363130
 8010c98:	00202d20 	.word	0x00202d20
 8010c9c:	353a3231 	.word	0x353a3231
 8010ca0:	39333a34 	.word	0x39333a34
 8010ca4:	00000000 	.word	0x00000000
 8010ca8:	74737973 	.word	0x74737973
 8010cac:	00656d69 	.word	0x00656d69
 8010cb0:	0d756c25 	.word	0x0d756c25
 8010cb4:	0000000a 	.word	0x0000000a
 8010cb8:	6c656873 	.word	0x6c656873
 8010cbc:	0000006c 	.word	0x0000006c
 8010cc0:	68430a0d 	.word	0x68430a0d
 8010cc4:	4f696269 	.word	0x4f696269
 8010cc8:	54522f53 	.word	0x54522f53
 8010ccc:	65685320 	.word	0x65685320
 8010cd0:	0a0d6c6c 	.word	0x0a0d6c6c
 8010cd4:	00000000 	.word	0x00000000
 8010cd8:	203e6863 	.word	0x203e6863
 8010cdc:	00000000 	.word	0x00000000
 8010ce0:	6f6c0a0d 	.word	0x6f6c0a0d
 8010ce4:	74756f67 	.word	0x74756f67
 8010ce8:	00000000 	.word	0x00000000
 8010cec:	00000920 	.word	0x00000920
 8010cf0:	206f6f74 	.word	0x206f6f74
 8010cf4:	796e616d 	.word	0x796e616d
 8010cf8:	67726120 	.word	0x67726120
 8010cfc:	6e656d75 	.word	0x6e656d75
 8010d00:	0a0d7374 	.word	0x0a0d7374
 8010d04:	00000000 	.word	0x00000000
 8010d08:	74697865 	.word	0x74697865
 8010d0c:	00000000 	.word	0x00000000
 8010d10:	706c6568 	.word	0x706c6568
 8010d14:	00000000 	.word	0x00000000
 8010d18:	6d6d6f43 	.word	0x6d6d6f43
 8010d1c:	73646e61 	.word	0x73646e61
 8010d20:	6568203a 	.word	0x6568203a
 8010d24:	6520706c 	.word	0x6520706c
 8010d28:	20746978 	.word	0x20746978
 8010d2c:	00000000 	.word	0x00000000
 8010d30:	00000a0d 	.word	0x00000a0d
 8010d34:	00007325 	.word	0x00007325
 8010d38:	0a0d3f20 	.word	0x0a0d3f20
 8010d3c:	00000000 	.word	0x00000000
 8010d40:	00000041 	.word	0x00000041
 8010d44:	00000042 	.word	0x00000042
 8010d48:	00000043 	.word	0x00000043
 8010d4c:	00004241 	.word	0x00004241
 8010d50:	00000044 	.word	0x00000044
 8010d54:	00000045 	.word	0x00000045
 8010d58:	44434241 	.word	0x44434241
 8010d5c:	00000000 	.word	0x00000000
 8010d60:	00434241 	.word	0x00434241
 8010d64:	00000041 	.word	0x00000041
	...
 8010d70:	00000042 	.word	0x00000042
 8010d74:	00000041 	.word	0x00000041
 8010d78:	00000044 	.word	0x00000044
 8010d7c:	00000043 	.word	0x00000043
 8010d80:	00000045 	.word	0x00000045
 8010d84:	44434241 	.word	0x44434241
 8010d88:	00000045 	.word	0x00000045
 8010d8c:	00434241 	.word	0x00434241
 8010d90:	00000000 	.word	0x00000000
 8010d94:	202a2a2a 	.word	0x202a2a2a
 8010d98:	62696843 	.word	0x62696843
 8010d9c:	2f534f69 	.word	0x2f534f69
 8010da0:	74205452 	.word	0x74205452
 8010da4:	20747365 	.word	0x20747365
 8010da8:	74697573 	.word	0x74697573
 8010dac:	00000065 	.word	0x00000065
 8010db0:	002a2a2a 	.word	0x002a2a2a
 8010db4:	202a2a2a 	.word	0x202a2a2a
 8010db8:	6e72654b 	.word	0x6e72654b
 8010dbc:	203a6c65 	.word	0x203a6c65
 8010dc0:	20202020 	.word	0x20202020
 8010dc4:	00002020 	.word	0x00002020
 8010dc8:	2e312e33 	.word	0x2e312e33
 8010dcc:	00000033 	.word	0x00000033
 8010dd0:	202a2a2a 	.word	0x202a2a2a
 8010dd4:	706d6f43 	.word	0x706d6f43
 8010dd8:	64656c69 	.word	0x64656c69
 8010ddc:	2020203a 	.word	0x2020203a
 8010de0:	00002020 	.word	0x00002020
 8010de4:	2072614d 	.word	0x2072614d
 8010de8:	32203033 	.word	0x32203033
 8010dec:	20363130 	.word	0x20363130
 8010df0:	3231202d 	.word	0x3231202d
 8010df4:	3a34353a 	.word	0x3a34353a
 8010df8:	00003733 	.word	0x00003733
 8010dfc:	202a2a2a 	.word	0x202a2a2a
 8010e00:	706d6f43 	.word	0x706d6f43
 8010e04:	72656c69 	.word	0x72656c69
 8010e08:	2020203a 	.word	0x2020203a
 8010e0c:	00002020 	.word	0x00002020
 8010e10:	20434347 	.word	0x20434347
 8010e14:	2e382e34 	.word	0x2e382e34
 8010e18:	00000032 	.word	0x00000032
 8010e1c:	202a2a2a 	.word	0x202a2a2a
 8010e20:	68637241 	.word	0x68637241
 8010e24:	63657469 	.word	0x63657469
 8010e28:	65727574 	.word	0x65727574
 8010e2c:	0000203a 	.word	0x0000203a
 8010e30:	764d5241 	.word	0x764d5241
 8010e34:	4d2d4537 	.word	0x4d2d4537
 8010e38:	00000000 	.word	0x00000000
 8010e3c:	202a2a2a 	.word	0x202a2a2a
 8010e40:	65726f43 	.word	0x65726f43
 8010e44:	72615620 	.word	0x72615620
 8010e48:	746e6169 	.word	0x746e6169
 8010e4c:	0000203a 	.word	0x0000203a
 8010e50:	74726f43 	.word	0x74726f43
 8010e54:	4d2d7865 	.word	0x4d2d7865
 8010e58:	00000034 	.word	0x00000034
 8010e5c:	202a2a2a 	.word	0x202a2a2a
 8010e60:	74726f50 	.word	0x74726f50
 8010e64:	666e4920 	.word	0x666e4920
 8010e68:	20203a6f 	.word	0x20203a6f
 8010e6c:	00002020 	.word	0x00002020
 8010e70:	61766441 	.word	0x61766441
 8010e74:	6465636e 	.word	0x6465636e
 8010e78:	72656b20 	.word	0x72656b20
 8010e7c:	206c656e 	.word	0x206c656e
 8010e80:	65646f6d 	.word	0x65646f6d
 8010e84:	00000000 	.word	0x00000000
 8010e88:	202a2a2a 	.word	0x202a2a2a
 8010e8c:	74616c50 	.word	0x74616c50
 8010e90:	6d726f66 	.word	0x6d726f66
 8010e94:	2020203a 	.word	0x2020203a
 8010e98:	00002020 	.word	0x00002020
 8010e9c:	334d5453 	.word	0x334d5453
 8010ea0:	30344632 	.word	0x30344632
 8010ea4:	69482037 	.word	0x69482037
 8010ea8:	50206867 	.word	0x50206867
 8010eac:	6f667265 	.word	0x6f667265
 8010eb0:	6e616d72 	.word	0x6e616d72
 8010eb4:	77206563 	.word	0x77206563
 8010eb8:	20687469 	.word	0x20687469
 8010ebc:	20505344 	.word	0x20505344
 8010ec0:	20646e61 	.word	0x20646e61
 8010ec4:	00555046 	.word	0x00555046
 8010ec8:	202a2a2a 	.word	0x202a2a2a
 8010ecc:	74736554 	.word	0x74736554
 8010ed0:	616f4220 	.word	0x616f4220
 8010ed4:	203a6472 	.word	0x203a6472
 8010ed8:	00002020 	.word	0x00002020
 8010edc:	694d5453 	.word	0x694d5453
 8010ee0:	656f7263 	.word	0x656f7263
 8010ee4:	7463656c 	.word	0x7463656c
 8010ee8:	696e6f72 	.word	0x696e6f72
 8010eec:	53207363 	.word	0x53207363
 8010ef0:	32334d54 	.word	0x32334d54
 8010ef4:	442d3446 	.word	0x442d3446
 8010ef8:	6f637369 	.word	0x6f637369
 8010efc:	79726576 	.word	0x79726576
 8010f00:	00000000 	.word	0x00000000
 8010f04:	202d2d2d 	.word	0x202d2d2d
 8010f08:	74736554 	.word	0x74736554
 8010f0c:	73614320 	.word	0x73614320
 8010f10:	00002065 	.word	0x00002065
 8010f14:	0000002e 	.word	0x0000002e
 8010f18:	00002820 	.word	0x00002820
 8010f1c:	00000029 	.word	0x00000029
 8010f20:	202d2d2d 	.word	0x202d2d2d
 8010f24:	75736552 	.word	0x75736552
 8010f28:	203a746c 	.word	0x203a746c
 8010f2c:	4c494146 	.word	0x4c494146
 8010f30:	20455255 	.word	0x20455255
 8010f34:	00002328 	.word	0x00002328
 8010f38:	00005b20 	.word	0x00005b20
 8010f3c:	0000295d 	.word	0x0000295d
 8010f40:	202d2d2d 	.word	0x202d2d2d
 8010f44:	75736552 	.word	0x75736552
 8010f48:	203a746c 	.word	0x203a746c
 8010f4c:	43435553 	.word	0x43435553
 8010f50:	00535345 	.word	0x00535345
 8010f54:	616e6946 	.word	0x616e6946
 8010f58:	6572206c 	.word	0x6572206c
 8010f5c:	746c7573 	.word	0x746c7573
 8010f60:	0000203a 	.word	0x0000203a
 8010f64:	4c494146 	.word	0x4c494146
 8010f68:	00455255 	.word	0x00455255
 8010f6c:	43435553 	.word	0x43435553
 8010f70:	00535345 	.word	0x00535345
 8010f74:	00000045 	.word	0x00000045
 8010f78:	00000044 	.word	0x00000044
 8010f7c:	00000043 	.word	0x00000043
 8010f80:	00000042 	.word	0x00000042
 8010f84:	00000041 	.word	0x00000041
 8010f88:	44434241 	.word	0x44434241
 8010f8c:	00000045 	.word	0x00000045
 8010f90:	5f627375 	.word	0x5f627375
 8010f94:	5f646c6c 	.word	0x5f646c6c
 8010f98:	706d7570 	.word	0x706d7570
 8010f9c:	00000000 	.word	0x00000000
 8010fa0:	00000a0d 	.word	0x00000a0d
	...
 8010fb0:	656c6469 	.word	0x656c6469
 8010fb4:	00000000 	.word	0x00000000
 8010fb8:	31235653 	.word	0x31235653
 8010fbc:	00000000 	.word	0x00000000
 8010fc0:	32235653 	.word	0x32235653
 8010fc4:	00000000 	.word	0x00000000
 8010fc8:	33235653 	.word	0x33235653
 8010fcc:	00000000 	.word	0x00000000
 8010fd0:	34235653 	.word	0x34235653
 8010fd4:	00000000 	.word	0x00000000
 8010fd8:	35235653 	.word	0x35235653
 8010fdc:	00000000 	.word	0x00000000
 8010fe0:	36235653 	.word	0x36235653
 8010fe4:	00000000 	.word	0x00000000
 8010fe8:	37235653 	.word	0x37235653
 8010fec:	00000000 	.word	0x00000000
 8010ff0:	38235653 	.word	0x38235653
 8010ff4:	00000000 	.word	0x00000000
 8010ff8:	39235653 	.word	0x39235653
 8010ffc:	00000000 	.word	0x00000000
 8011000:	31235653 	.word	0x31235653
 8011004:	00000030 	.word	0x00000030
 8011008:	31235653 	.word	0x31235653
 801100c:	00000031 	.word	0x00000031
 8011010:	63617473 	.word	0x63617473
 8011014:	766f206b 	.word	0x766f206b
 8011018:	6c667265 	.word	0x6c667265
 801101c:	0000776f 	.word	0x0000776f
 8011020:	65726854 	.word	0x65726854
 8011024:	2c736461 	.word	0x2c736461
 8011028:	716e6520 	.word	0x716e6520
 801102c:	69756575 	.word	0x69756575
 8011030:	7420676e 	.word	0x7420676e
 8011034:	20747365 	.word	0x20747365
 8011038:	00003123 	.word	0x00003123
 801103c:	65726854 	.word	0x65726854
 8011040:	2c736461 	.word	0x2c736461
 8011044:	716e6520 	.word	0x716e6520
 8011048:	69756575 	.word	0x69756575
 801104c:	7420676e 	.word	0x7420676e
 8011050:	20747365 	.word	0x20747365
 8011054:	00003223 	.word	0x00003223
 8011058:	65726854 	.word	0x65726854
 801105c:	2c736461 	.word	0x2c736461
 8011060:	69727020 	.word	0x69727020
 8011064:	7469726f 	.word	0x7469726f
 8011068:	68632079 	.word	0x68632079
 801106c:	65676e61 	.word	0x65676e61
 8011070:	00000000 	.word	0x00000000
 8011074:	65726854 	.word	0x65726854
 8011078:	2c736461 	.word	0x2c736461
 801107c:	6c656420 	.word	0x6c656420
 8011080:	00737961 	.word	0x00737961
 8011084:	616d6553 	.word	0x616d6553
 8011088:	726f6870 	.word	0x726f6870
 801108c:	202c7365 	.word	0x202c7365
 8011090:	75716e65 	.word	0x75716e65
 8011094:	6e697565 	.word	0x6e697565
 8011098:	00000067 	.word	0x00000067
 801109c:	616d6553 	.word	0x616d6553
 80110a0:	726f6870 	.word	0x726f6870
 80110a4:	202c7365 	.word	0x202c7365
 80110a8:	656d6974 	.word	0x656d6974
 80110ac:	0074756f 	.word	0x0074756f
 80110b0:	616d6553 	.word	0x616d6553
 80110b4:	726f6870 	.word	0x726f6870
 80110b8:	202c7365 	.word	0x202c7365
 80110bc:	6d6f7461 	.word	0x6d6f7461
 80110c0:	73206369 	.word	0x73206369
 80110c4:	616e6769 	.word	0x616e6769
 80110c8:	61772d6c 	.word	0x61772d6c
 80110cc:	00007469 	.word	0x00007469
 80110d0:	616e6942 	.word	0x616e6942
 80110d4:	53207972 	.word	0x53207972
 80110d8:	70616d65 	.word	0x70616d65
 80110dc:	65726f68 	.word	0x65726f68
 80110e0:	66202c73 	.word	0x66202c73
 80110e4:	74636e75 	.word	0x74636e75
 80110e8:	616e6f69 	.word	0x616e6f69
 80110ec:	7974696c 	.word	0x7974696c
 80110f0:	00000000 	.word	0x00000000
 80110f4:	6574754d 	.word	0x6574754d
 80110f8:	2c736578 	.word	0x2c736578
 80110fc:	69727020 	.word	0x69727020
 8011100:	7469726f 	.word	0x7469726f
 8011104:	6e652079 	.word	0x6e652079
 8011108:	75657571 	.word	0x75657571
 801110c:	20676e69 	.word	0x20676e69
 8011110:	74736574 	.word	0x74736574
 8011114:	00000000 	.word	0x00000000
 8011118:	6574754d 	.word	0x6574754d
 801111c:	2c736578 	.word	0x2c736578
 8011120:	69727020 	.word	0x69727020
 8011124:	7469726f 	.word	0x7469726f
 8011128:	65722079 	.word	0x65722079
 801112c:	6e727574 	.word	0x6e727574
 8011130:	00000000 	.word	0x00000000
 8011134:	6574754d 	.word	0x6574754d
 8011138:	2c736578 	.word	0x2c736578
 801113c:	61747320 	.word	0x61747320
 8011140:	00737574 	.word	0x00737574
 8011144:	646e6f43 	.word	0x646e6f43
 8011148:	2c726156 	.word	0x2c726156
 801114c:	67697320 	.word	0x67697320
 8011150:	206c616e 	.word	0x206c616e
 8011154:	74736574 	.word	0x74736574
 8011158:	00000000 	.word	0x00000000
 801115c:	646e6f43 	.word	0x646e6f43
 8011160:	2c726156 	.word	0x2c726156
 8011164:	6f726220 	.word	0x6f726220
 8011168:	61636461 	.word	0x61636461
 801116c:	74207473 	.word	0x74207473
 8011170:	00747365 	.word	0x00747365
 8011174:	646e6f43 	.word	0x646e6f43
 8011178:	2c726156 	.word	0x2c726156
 801117c:	6f6f6220 	.word	0x6f6f6220
 8011180:	74207473 	.word	0x74207473
 8011184:	00747365 	.word	0x00747365
 8011188:	7373654d 	.word	0x7373654d
 801118c:	73656761 	.word	0x73656761
 8011190:	6f6c202c 	.word	0x6f6c202c
 8011194:	0000706f 	.word	0x0000706f
 8011198:	6c69614d 	.word	0x6c69614d
 801119c:	65786f62 	.word	0x65786f62
 80111a0:	71202c73 	.word	0x71202c73
 80111a4:	69756575 	.word	0x69756575
 80111a8:	6120676e 	.word	0x6120676e
 80111ac:	7420646e 	.word	0x7420646e
 80111b0:	6f656d69 	.word	0x6f656d69
 80111b4:	00737475 	.word	0x00737475
 80111b8:	6e657645 	.word	0x6e657645
 80111bc:	202c7374 	.word	0x202c7374
 80111c0:	69676572 	.word	0x69676572
 80111c4:	61727473 	.word	0x61727473
 80111c8:	6e6f6974 	.word	0x6e6f6974
 80111cc:	646e6120 	.word	0x646e6120
 80111d0:	73696420 	.word	0x73696420
 80111d4:	63746170 	.word	0x63746170
 80111d8:	00000068 	.word	0x00000068
 80111dc:	6e657645 	.word	0x6e657645
 80111e0:	202c7374 	.word	0x202c7374
 80111e4:	74696177 	.word	0x74696177
 80111e8:	646e6120 	.word	0x646e6120
 80111ec:	6f726220 	.word	0x6f726220
 80111f0:	61636461 	.word	0x61636461
 80111f4:	00007473 	.word	0x00007473
 80111f8:	6e657645 	.word	0x6e657645
 80111fc:	202c7374 	.word	0x202c7374
 8011200:	656d6974 	.word	0x656d6974
 8011204:	7374756f 	.word	0x7374756f
 8011208:	00000000 	.word	0x00000000
 801120c:	70616548 	.word	0x70616548
 8011210:	6c61202c 	.word	0x6c61202c
 8011214:	61636f6c 	.word	0x61636f6c
 8011218:	6e6f6974 	.word	0x6e6f6974
 801121c:	646e6120 	.word	0x646e6120
 8011220:	61726620 	.word	0x61726620
 8011224:	6e656d67 	.word	0x6e656d67
 8011228:	69746174 	.word	0x69746174
 801122c:	74206e6f 	.word	0x74206e6f
 8011230:	00747365 	.word	0x00747365
 8011234:	6f6d654d 	.word	0x6f6d654d
 8011238:	50207972 	.word	0x50207972
 801123c:	736c6f6f 	.word	0x736c6f6f
 8011240:	7571202c 	.word	0x7571202c
 8011244:	2f657565 	.word	0x2f657565
 8011248:	75716564 	.word	0x75716564
 801124c:	00657565 	.word	0x00657565
 8011250:	616e7944 	.word	0x616e7944
 8011254:	2063696d 	.word	0x2063696d
 8011258:	73495041 	.word	0x73495041
 801125c:	6874202c 	.word	0x6874202c
 8011260:	64616572 	.word	0x64616572
 8011264:	72632073 	.word	0x72632073
 8011268:	69746165 	.word	0x69746165
 801126c:	66206e6f 	.word	0x66206e6f
 8011270:	206d6f72 	.word	0x206d6f72
 8011274:	70616568 	.word	0x70616568
 8011278:	00000000 	.word	0x00000000
 801127c:	616e7944 	.word	0x616e7944
 8011280:	2063696d 	.word	0x2063696d
 8011284:	73495041 	.word	0x73495041
 8011288:	6874202c 	.word	0x6874202c
 801128c:	64616572 	.word	0x64616572
 8011290:	72632073 	.word	0x72632073
 8011294:	69746165 	.word	0x69746165
 8011298:	66206e6f 	.word	0x66206e6f
 801129c:	206d6f72 	.word	0x206d6f72
 80112a0:	6f6d656d 	.word	0x6f6d656d
 80112a4:	70207972 	.word	0x70207972
 80112a8:	006c6f6f 	.word	0x006c6f6f
 80112ac:	616e7944 	.word	0x616e7944
 80112b0:	2063696d 	.word	0x2063696d
 80112b4:	73495041 	.word	0x73495041
 80112b8:	6572202c 	.word	0x6572202c
 80112bc:	74736967 	.word	0x74736967
 80112c0:	61207972 	.word	0x61207972
 80112c4:	7220646e 	.word	0x7220646e
 80112c8:	72656665 	.word	0x72656665
 80112cc:	65636e65 	.word	0x65636e65
 80112d0:	00000073 	.word	0x00000073
 80112d4:	75657551 	.word	0x75657551
 80112d8:	202c7365 	.word	0x202c7365
 80112dc:	75706e69 	.word	0x75706e69
 80112e0:	75712074 	.word	0x75712074
 80112e4:	73657565 	.word	0x73657565
 80112e8:	00000000 	.word	0x00000000
 80112ec:	75657551 	.word	0x75657551
 80112f0:	202c7365 	.word	0x202c7365
 80112f4:	7074756f 	.word	0x7074756f
 80112f8:	71207475 	.word	0x71207475
 80112fc:	65756575 	.word	0x65756575
 8011300:	00000073 	.word	0x00000073
 8011304:	74737953 	.word	0x74737953
 8011308:	202c6d65 	.word	0x202c6d65
 801130c:	74697263 	.word	0x74697263
 8011310:	6c616369 	.word	0x6c616369
 8011314:	6e6f7a20 	.word	0x6e6f7a20
 8011318:	00007365 	.word	0x00007365
 801131c:	74737953 	.word	0x74737953
 8011320:	202c6d65 	.word	0x202c6d65
 8011324:	65746e69 	.word	0x65746e69
 8011328:	70757272 	.word	0x70757272
 801132c:	68207374 	.word	0x68207374
 8011330:	6c646e61 	.word	0x6c646e61
 8011334:	00676e69 	.word	0x00676e69
 8011338:	74737953 	.word	0x74737953
 801133c:	202c6d65 	.word	0x202c6d65
 8011340:	65746e69 	.word	0x65746e69
 8011344:	74697267 	.word	0x74697267
 8011348:	00000079 	.word	0x00000079
 801134c:	636e6542 	.word	0x636e6542
 8011350:	72616d68 	.word	0x72616d68
 8011354:	6d202c6b 	.word	0x6d202c6b
 8011358:	61737365 	.word	0x61737365
 801135c:	20736567 	.word	0x20736567
 8011360:	00003123 	.word	0x00003123
 8011364:	636e6542 	.word	0x636e6542
 8011368:	72616d68 	.word	0x72616d68
 801136c:	6d202c6b 	.word	0x6d202c6b
 8011370:	61737365 	.word	0x61737365
 8011374:	20736567 	.word	0x20736567
 8011378:	00003223 	.word	0x00003223
 801137c:	636e6542 	.word	0x636e6542
 8011380:	72616d68 	.word	0x72616d68
 8011384:	6d202c6b 	.word	0x6d202c6b
 8011388:	61737365 	.word	0x61737365
 801138c:	20736567 	.word	0x20736567
 8011390:	00003323 	.word	0x00003323
 8011394:	636e6542 	.word	0x636e6542
 8011398:	72616d68 	.word	0x72616d68
 801139c:	63202c6b 	.word	0x63202c6b
 80113a0:	65746e6f 	.word	0x65746e6f
 80113a4:	73207478 	.word	0x73207478
 80113a8:	63746977 	.word	0x63746977
 80113ac:	00000068 	.word	0x00000068
 80113b0:	636e6542 	.word	0x636e6542
 80113b4:	72616d68 	.word	0x72616d68
 80113b8:	74202c6b 	.word	0x74202c6b
 80113bc:	61657268 	.word	0x61657268
 80113c0:	202c7364 	.word	0x202c7364
 80113c4:	6c6c7566 	.word	0x6c6c7566
 80113c8:	63796320 	.word	0x63796320
 80113cc:	0000656c 	.word	0x0000656c
 80113d0:	636e6542 	.word	0x636e6542
 80113d4:	72616d68 	.word	0x72616d68
 80113d8:	74202c6b 	.word	0x74202c6b
 80113dc:	61657268 	.word	0x61657268
 80113e0:	202c7364 	.word	0x202c7364
 80113e4:	61657263 	.word	0x61657263
 80113e8:	6f206574 	.word	0x6f206574
 80113ec:	00796c6e 	.word	0x00796c6e
 80113f0:	636e6542 	.word	0x636e6542
 80113f4:	72616d68 	.word	0x72616d68
 80113f8:	6d202c6b 	.word	0x6d202c6b
 80113fc:	20737361 	.word	0x20737361
 8011400:	63736572 	.word	0x63736572
 8011404:	75646568 	.word	0x75646568
 8011408:	202c656c 	.word	0x202c656c
 801140c:	68742035 	.word	0x68742035
 8011410:	64616572 	.word	0x64616572
 8011414:	00000073 	.word	0x00000073
 8011418:	636e6542 	.word	0x636e6542
 801141c:	72616d68 	.word	0x72616d68
 8011420:	72202c6b 	.word	0x72202c6b
 8011424:	646e756f 	.word	0x646e756f
 8011428:	626f7220 	.word	0x626f7220
 801142c:	63206e69 	.word	0x63206e69
 8011430:	65746e6f 	.word	0x65746e6f
 8011434:	73207478 	.word	0x73207478
 8011438:	63746977 	.word	0x63746977
 801143c:	676e6968 	.word	0x676e6968
 8011440:	00000000 	.word	0x00000000
 8011444:	636e6542 	.word	0x636e6542
 8011448:	72616d68 	.word	0x72616d68
 801144c:	49202c6b 	.word	0x49202c6b
 8011450:	51204f2f 	.word	0x51204f2f
 8011454:	65756575 	.word	0x65756575
 8011458:	68742073 	.word	0x68742073
 801145c:	67756f72 	.word	0x67756f72
 8011460:	74757068 	.word	0x74757068
 8011464:	00000000 	.word	0x00000000
 8011468:	636e6542 	.word	0x636e6542
 801146c:	72616d68 	.word	0x72616d68
 8011470:	76202c6b 	.word	0x76202c6b
 8011474:	75747269 	.word	0x75747269
 8011478:	74206c61 	.word	0x74206c61
 801147c:	72656d69 	.word	0x72656d69
 8011480:	65732073 	.word	0x65732073
 8011484:	65722f74 	.word	0x65722f74
 8011488:	00746573 	.word	0x00746573
 801148c:	636e6542 	.word	0x636e6542
 8011490:	72616d68 	.word	0x72616d68
 8011494:	73202c6b 	.word	0x73202c6b
 8011498:	70616d65 	.word	0x70616d65
 801149c:	65726f68 	.word	0x65726f68
 80114a0:	61772073 	.word	0x61772073
 80114a4:	732f7469 	.word	0x732f7469
 80114a8:	616e6769 	.word	0x616e6769
 80114ac:	0000006c 	.word	0x0000006c
 80114b0:	636e6542 	.word	0x636e6542
 80114b4:	72616d68 	.word	0x72616d68
 80114b8:	6d202c6b 	.word	0x6d202c6b
 80114bc:	78657475 	.word	0x78657475
 80114c0:	6c207365 	.word	0x6c207365
 80114c4:	2f6b636f 	.word	0x2f6b636f
 80114c8:	6f6c6e75 	.word	0x6f6c6e75
 80114cc:	00006b63 	.word	0x00006b63
 80114d0:	636e6542 	.word	0x636e6542
 80114d4:	72616d68 	.word	0x72616d68
 80114d8:	52202c6b 	.word	0x52202c6b
 80114dc:	66204d41 	.word	0x66204d41
 80114e0:	70746f6f 	.word	0x70746f6f
 80114e4:	746e6972 	.word	0x746e6972
 80114e8:	00000000 	.word	0x00000000
 80114ec:	6f666e69 	.word	0x6f666e69
 80114f0:	00000000 	.word	0x00000000
 80114f4:	74737973 	.word	0x74737973
 80114f8:	00656d69 	.word	0x00656d69
 80114fc:	006d656d 	.word	0x006d656d
 8011500:	65726874 	.word	0x65726874
 8011504:	00736461 	.word	0x00736461
 8011508:	74736574 	.word	0x74736574
 801150c:	00000000 	.word	0x00000000
 8011510:	74697277 	.word	0x74697277
 8011514:	00000065 	.word	0x00000065
 8011518:	44414552 	.word	0x44414552
 801151c:	00000059 	.word	0x00000059
 8011520:	52525543 	.word	0x52525543
 8011524:	00544e45 	.word	0x00544e45
 8011528:	54535457 	.word	0x54535457
 801152c:	00545241 	.word	0x00545241
 8011530:	50535553 	.word	0x50535553
 8011534:	45444e45 	.word	0x45444e45
 8011538:	00000044 	.word	0x00000044
 801153c:	55455551 	.word	0x55455551
 8011540:	00004445 	.word	0x00004445
 8011544:	45535457 	.word	0x45535457
 8011548:	0000004d 	.word	0x0000004d
 801154c:	544d5457 	.word	0x544d5457
 8011550:	00000058 	.word	0x00000058
 8011554:	4f435457 	.word	0x4f435457
 8011558:	0000444e 	.word	0x0000444e
 801155c:	45454c53 	.word	0x45454c53
 8011560:	474e4950 	.word	0x474e4950
 8011564:	00000000 	.word	0x00000000
 8011568:	58455457 	.word	0x58455457
 801156c:	00005449 	.word	0x00005449
 8011570:	524f5457 	.word	0x524f5457
 8011574:	00545645 	.word	0x00545645
 8011578:	4e415457 	.word	0x4e415457
 801157c:	54564544 	.word	0x54564544
 8011580:	00000000 	.word	0x00000000
 8011584:	4d444e53 	.word	0x4d444e53
 8011588:	00514753 	.word	0x00514753
 801158c:	4d444e53 	.word	0x4d444e53
 8011590:	00004753 	.word	0x00004753
 8011594:	534d5457 	.word	0x534d5457
 8011598:	00000047 	.word	0x00000047
 801159c:	414e4946 	.word	0x414e4946
 80115a0:	0000004c 	.word	0x0000004c
	...

080115b0 <ram_areas.4021.5166>:
 80115b0:	08012b88 20002578 20002578 20002578     .+..x%. x%. x%. 
 80115c0:	08012b88 20000000 20000000 20000000     .+..... ... ... 
 80115d0:	08012b88 2001c000 2001c000 2001c000     .+..... ... ... 
 80115e0:	08012b88 00000000 00000000 00000000     .+..............
 80115f0:	08012b88 10000000 10000000 10000000     .+..............
 8011600:	08012b88 40024000 40024000 40024000     .+...@.@.@.@.@.@
 8011610:	08012b88 00000000 00000000 00000000     .+..............
 8011620:	08012b88 00000000 00000000 00000000     .+..............

08011630 <__func__.6004.4488.5164>:
 8011630:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

08011640 <__func__.5915.4489.5165>:
 8011640:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011650 <__func__.6621.4997.5122>:
 8011650:	54566863 65536f44 00004974 00000000     chVTDoSetI......

08011660 <__func__.6629.4998.5121>:
 8011660:	54566863 65526f44 49746573 00000000     chVTDoResetI....

08011670 <__func__.6618.5244.5120>:
 8011670:	63536863 61655268 00497964 00000000     chSchReadyI.....

08011680 <__func__.6646.5245.5119>:
 8011680:	63536863 6b615768 53707565 00000000     chSchWakeupS....

08011690 <__func__.6630.5582.5064>:
 8011690:	68546863 65724364 49657461 00000000     chThdCreateI....

080116a0 <__func__.5915.5578.5118>:
 80116a0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080116b0 <__func__.6085.5579.5117>:
 80116b0:	68546863 61745364 00497472 00000000     chThdStartI.....

080116c0 <__func__.6646.5583>:
 80116c0:	68546863 74655364 6f697250 79746972     chThdSetPriority
	...

080116e0 <__func__.6089.5581.5116>:
 80116e0:	68546863 656c5364 00537065 00000000     chThdSleepS.....

080116f0 <__func__.6674.5584>:
 80116f0:	68546863 69784564 00005374 00000000     chThdExitS......

08011700 <__func__.6679.5585>:
 8011700:	68546863 69615764 00000074 00000000     chThdWait.......

08011710 <__func__.6684.5586>:
 8011710:	68546863 73755364 646e6570 00000053     chThdSuspendS...

08011720 <__func__.6696.5588>:
 8011720:	68546863 73655264 49656d75 00000000     chThdResumeI....

08011730 <__func__.6101.5580.5115>:
 8011730:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
 8011740:	00497478 00000000 00000000 00000000     xtI.............

08011750 <__func__.6613.6217>:
 8011750:	68546863 64644164 00666552 00000000     chThdAddRef.....

08011760 <__func__.5915.6216>:
 8011760:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011770 <__func__.6618.6218>:
 8011770:	68546863 6c655264 65736165 00000000     chThdRelease....

08011780 <__func__.6640.6219>:
 8011780:	68546863 65724364 46657461 4d6d6f72     chThdCreateFromM
 8011790:	726f6d65 6f6f5079 0000006c 00000000     emoryPool.......

080117a0 <ch_debug.5124>:
 80117a0:	6e69616d 18431600 08600404 1814100c     main..C...`.....
 80117b0:	2221201c 00000000 00000000 00000000     . !"............

080117c0 <__func__.5915.6395>:
 80117c0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080117d0 <__func__.6619.6396>:
 80117d0:	65526863 78654e67 72685474 00646165     chRegNextThread.

080117e0 <__func__.6614.6653>:
 80117e0:	65536863 6a624f6d 49746365 0074696e     chSemObjectInit.

080117f0 <__func__.5915.6652>:
 80117f0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011800 <__func__.6624.6654>:
 8011800:	65536863 7365526d 00497465 00000000     chSemResetI.....

08011810 <__func__.6635.6655>:
 8011810:	65536863 6961576d 00005374 00000000     chSemWaitS......

08011820 <__func__.6645.6656>:
 8011820:	65536863 6961576d 6d695474 74756f65     chSemWaitTimeout
 8011830:	00000053 00000000 00000000 00000000     S...............

08011840 <__func__.6649.6657>:
 8011840:	65536863 6769536d 006c616e 00000000     chSemSignal.....

08011850 <__func__.6653.6658>:
 8011850:	65536863 6769536d 496c616e 00000000     chSemSignalI....

08011860 <__func__.6659.6659>:
 8011860:	65536863 6464416d 6e756f43 49726574     chSemAddCounterI
	...

08011880 <__func__.6668.6660>:
 8011880:	65536863 6769536d 576c616e 00746961     chSemSignalWait.

08011890 <__func__.6613.6880>:
 8011890:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

080118a0 <__func__.5915.6879>:
 80118a0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080118b0 <__func__.6621.6881>:
 80118b0:	744d6863 636f4c78 0000536b 00000000     chMtxLockS......

080118c0 <__func__.6638.6882>:
 80118c0:	744d6863 79725478 6b636f4c 00000053     chMtxTryLockS...

080118d0 <__func__.6644.6883>:
 80118d0:	744d6863 6c6e5578 006b636f 00000000     chMtxUnlock.....

080118e0 <__func__.6655.6884>:
 80118e0:	744d6863 6c6e5578 536b636f 00000000     chMtxUnlockS....

080118f0 <__func__.6613.7117>:
 80118f0:	6f436863 624f646e 7463656a 74696e49     chCondObjectInit
	...

08011910 <__func__.6617.7118>:
 8011910:	6f436863 6953646e 6c616e67 00000000     chCondSignal....

08011920 <__func__.5915.7116>:
 8011920:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011930 <__func__.6621.7119>:
 8011930:	6f436863 6953646e 6c616e67 00000049     chCondSignalI...

08011940 <__func__.6629.7120>:
 8011940:	6f436863 7242646e 6364616f 49747361     chCondBroadcastI
	...

08011960 <__func__.6643.7121>:
 8011960:	6f436863 6157646e 00537469 00000000     chCondWaitS.....

08011970 <__func__.6655.7122>:
 8011970:	6f436863 6157646e 69547469 756f656d     chCondWaitTimeou
 8011980:	00005374 00000000 00000000 00000000     tS..............

08011990 <__func__.6616.7375>:
 8011990:	76456863 67655274 65747369 73614d72     chEvtRegisterMas
 80119a0:	7469576b 616c4668 00007367 00000000     kWithFlags......

080119b0 <__func__.5915.7374>:
 80119b0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080119c0 <__func__.6622.7376>:
 80119c0:	76456863 726e5574 73696765 00726574     chEvtUnregister.

080119d0 <__func__.6638.7378>:
 80119d0:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
 80119e0:	49736761 00000000 00000000 00000000     agsI............

080119f0 <__func__.6650.7379>:
 80119f0:	76456863 67695374 006c616e 00000000     chEvtSignal.....

08011a00 <__func__.6655.7377>:
 8011a00:	76456863 67695374 496c616e 00000000     chEvtSignalI....

08011a10 <__func__.6669.7380>:
 8011a10:	76456863 73694474 63746170 00000068     chEvtDispatch...

08011a20 <__func__.6615.7584>:
 8011a20:	734d6863 6e655367 00000064 00000000     chMsgSend.......

08011a30 <__func__.5915.7583>:
 8011a30:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011a40 <__func__.6624.7585>:
 8011a40:	734d6863 6c655267 65736165 00000000     chMsgRelease....

08011a50 <__func__.6615.7828>:
 8011a50:	424d6863 656a624f 6e497463 00007469     chMBObjectInit..

08011a60 <__func__.5915.7827>:
 8011a60:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011a70 <__func__.6622.7829>:
 8011a70:	424d6863 65736552 00004974 00000000     chMBResetI......

08011a80 <__func__.6635.7830>:
 8011a80:	424d6863 74736f50 00000053 00000000     chMBPostS.......

08011a90 <__func__.6640.7831>:
 8011a90:	424d6863 74736f50 00000049 00000000     chMBPostI.......

08011aa0 <__func__.6653.7832>:
 8011aa0:	424d6863 74736f50 61656841 00005364     chMBPostAheadS..

08011ab0 <__func__.6658.7833>:
 8011ab0:	424d6863 74736f50 61656841 00004964     chMBPostAheadI..

08011ac0 <__func__.6671.7834>:
 8011ac0:	424d6863 63746546 00005368 00000000     chMBFetchS......

08011ad0 <__func__.6676.7835>:
 8011ad0:	424d6863 63746546 00004968 00000000     chMBFetchI......

08011ae0 <__func__.5915.8093>:
 8011ae0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011af0 <__func__.6641.8094>:
 8011af0:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

08011b00 <__func__.6677.8095>:
 8011b00:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

08011b20 <__func__.5915.8280>:
 8011b20:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011b30 <__func__.6620.8418>:
 8011b30:	65486863 624f7061 7463656a 74696e49     chHeapObjectInit
	...

08011b50 <__func__.6637.8419>:
 8011b50:	65486863 72467061 00006565 00000000     chHeapFree......

08011b60 <__func__.6615.8621>:
 8011b60:	6f506863 624f6c6f 7463656a 74696e49     chPoolObjectInit
	...

08011b80 <__func__.6621.8624>:
 8011b80:	6f506863 6f4c6c6f 72416461 00796172     chPoolLoadArray.

08011b90 <__func__.6629.8622>:
 8011b90:	6f506863 6c416c6f 49636f6c 00000000     chPoolAllocI....

08011ba0 <__func__.5915.8620>:
 8011ba0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011bb0 <__func__.6639.8623>:
 8011bb0:	6f506863 72466c6f 00496565 00000000     chPoolFreeI.....

08011bc0 <__func__.7427.8762>:
 8011bc0:	74537473 41747261 6d72616c 00000000     stStartAlarm....

08011bd0 <__func__.7434.8763>:
 8011bd0:	65537473 616c4174 00006d72 00000000     stSetAlarm......

08011be0 <__func__.7761.9101>:
 8011be0:	4f716269 63656a62 696e4974 00000074     ibqObjectInit...

08011bf0 <__func__.7772.9102>:
 8011bf0:	50716269 4674736f 426c6c75 65666675     ibqPostFullBuffe
 8011c00:	00004972 00000000 00000000 00000000     rI..............

08011c10 <__func__.6247.9100>:
 8011c10:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011c20 <__func__.7786.9103>:
 8011c20:	47716269 75467465 75426c6c 72656666     ibqGetFullBuffer
 8011c30:	656d6954 5374756f 00000000 00000000     TimeoutS........

08011c40 <__func__.7793.9104>:
 8011c40:	52716269 61656c65 6d456573 42797470     ibqReleaseEmptyB
 8011c50:	65666675 00005372 00000000 00000000     ufferS..........

08011c60 <__func__.7819.9105>:
 8011c60:	4f71626f 63656a62 696e4974 00000074     obqObjectInit...

08011c70 <__func__.7830.9106>:
 8011c70:	5271626f 61656c65 6d456573 42797470     obqReleaseEmptyB
 8011c80:	65666675 00004972 00000000 00000000     ufferI..........

08011c90 <__func__.7844.9107>:
 8011c90:	4771626f 6d457465 42797470 65666675     obqGetEmptyBuffe
 8011ca0:	6d695472 74756f65 00000053 00000000     rTimeoutS.......

08011cb0 <__func__.7853.9108>:
 8011cb0:	5071626f 4674736f 426c6c75 65666675     obqPostFullBuffe
 8011cc0:	00005372 00000000 00000000 00000000     rS..............

08011cd0 <vmt.9713>:
 8011cd0:	0800a0f1 0800a131 0800a171 0800a1b1     ....1...q.......
 8011ce0:	0800a1f1 0800a231 0800a271 0800a2b1     ....1...q.......

08011cf0 <__func__.7483.9714>:
 8011cf0:	53756473 74726174 00000000 00000000     sduStart........

08011d00 <__func__.5915.9712>:
 8011d00:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011d10 <__func__.7496.9716>:
 8011d10:	43756473 69666e6f 65727567 6b6f6f48     sduConfigureHook
 8011d20:	00000049 00000000 00000000 00000000     I...............

08011d30 <__func__.7509.9724>:
 8011d30:	53756473 6f48464f 00496b6f 00000000     sduSOFHookI.....

08011d40 <zero_status.10187>:
	...

08011d50 <active_status.10189>:
	...

08011d60 <halted_status.10188>:
 8011d60:	00000001 00000000 00000000 00000000     ................

08011d70 <__func__.7808.10190>:
 8011d70:	53627375 74726174 00000000 00000000     usbStart........

08011d80 <__func__.6247.10186>:
 8011d80:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011d90 <__func__.7825.10192>:
 8011d90:	49627375 4574696e 6f70646e 49746e69     usbInitEndpointI
	...

08011db0 <__func__.7841.10194>:
 8011db0:	53627375 74726174 65636552 49657669     usbStartReceiveI
	...

08011dd0 <__func__.7849.10195>:
 8011dd0:	53627375 74726174 6e617254 74696d73     usbStartTransmit
 8011de0:	00000049 00000000 00000000 00000000     I...............

08011df0 <__func__.7889.10198>:
 8011df0:	6273755f 3070655f 00006e69 00000000     _usb_ep0in......

08011e00 <__func__.7903.10199>:
 8011e00:	6273755f 3070655f 0074756f 00000000     _usb_ep0out.....

08011e10 <ep0config.11060>:
 8011e10:	00000000 08008b11 08008c71 08008d81     ........q.......
 8011e20:	00400040 20001720 20001720 00000001     @.@. ..  .. ....
 8011e30:	20001730 00000000 00000000 00000000     0.. ............

08011e40 <fsparams.11057>:
 8011e40:	00000080 00000140 00000003 00000000     ....@...........

08011e50 <hsparams.11059>:
 8011e50:	00000100 00000400 00000005 00000000     ................

08011e60 <__func__.7804.11054>:
 8011e60:	5f67746f 5f6d6172 6f6c6c61 00000063     otg_ram_alloc...

08011e70 <__func__.7810.11055>:
 8011e70:	5f67746f 6f666966 6972775f 665f6574     otg_fifo_write_f
 8011e80:	5f6d6f72 66667562 00007265 00000000     rom_buffer......

08011e90 <__func__.6417.11052>:
 8011e90:	68546863 61745364 00497472 00000000     chThdStartI.....

08011ea0 <__func__.6247.11053>:
 8011ea0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011eb0 <pal_default_config>:
 8011eb0:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
 8011ec0:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
 8011ed0:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 8011ee0:	04000000 00000040 02208001 00000000     ....@..... .....
 8011ef0:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
 8011f00:	00060600 55000100 00000000 ffffffff     .......U........
 8011f10:	00555055 00000fff 00000000 00000000     UPU.............
 8011f20:	00000040 00000000 ffffffff 00000000     @...............
 8011f30:	0000ffff 00000000 00000000 00000000     ................
 8011f40:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8011f60:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8011f7c:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8011f98:	ffffffff 00000000 0000ffff 00000000     ................
	...

08011fb0 <wa>:
 8011fb0:	20001758 200018c0 20001a28 20001b90     X.. ... (.. ... 
 8011fc0:	20001cf8 00000000 00000000 00000000     ... ............

08011fd0 <__func__.5915.11406>:
 8011fd0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08011fe0 <testthd1.5500>:
 8011fe0:	08011020 00000000 00000000 08005fc1      ............_..

08011ff0 <testthd2.5505>:
 8011ff0:	0801103c 00000000 00000000 08006101     <............a..

08012000 <testthd3.5506>:
 8012000:	08011058 00000000 00000000 08006261     X...........ab..

08012010 <testthd4.5507>:
 8012010:	08011074 00000000 00000000 08006441     t...........Ad..

08012020 <patternthd.5499>:
 8012020:	08011fe0 08011ff0 08012000 08012010     ......... ... ..
	...

08012040 <__func__.5915.11684>:
 8012040:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08012050 <testsem1.5487>:
 8012050:	08011084 08006701 00000000 08006751     .....g......Qg..

08012060 <testsem2.5492>:
 8012060:	0801109c 08006961 00000000 080069b1     ....ai.......i..

08012070 <testsem3.5493>:
 8012070:	080110b0 08006b91 00000000 08006be1     .....k.......k..

08012080 <testsem4.5494>:
 8012080:	080110d0 00000000 00000000 08006ce1     .............l..

08012090 <patternsem.5486>:
 8012090:	08012050 08012060 08012070 08012080     P ..` ..p ... ..
	...

080120b0 <__func__.5915.11979>:
 80120b0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080120c0 <testmtx1.5466>:
 80120c0:	080110f4 08006f51 00000000 08006f91     ....Qo.......o..

080120d0 <testmtx4.5471>:
 80120d0:	08011118 08007101 00000000 08004751     .....q......QG..

080120e0 <testmtx5.5472>:
 80120e0:	08011134 08004aa1 00000000 08004ab1     4....J.......J..

080120f0 <testmtx6.5473>:
 80120f0:	08011144 08004be1 00000000 08004c41     D....K......AL..

08012100 <testmtx7.5474>:
 8012100:	0801115c 08004dc1 00000000 08004de1     \....M.......M..

08012110 <testmtx8.5475>:
 8012110:	08011174 08004f21 00000000 08004fe1     t...!O.......O..

08012120 <patternmtx.5465>:
 8012120:	080120c0 080120d0 080120e0 080120f0     . ... ... ... ..
 8012130:	08012100 08012110 00000000 00000000     .!...!..........

08012140 <__func__.5915.12268>:
 8012140:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08012150 <testmsg1.5457>:
 8012150:	08011188 00000000 00000000 08005121     ............!Q..

08012160 <patternmsg.5456>:
 8012160:	08012150 00000000 00000000 00000000     P!..............

08012170 <testmbox1.5439>:
 8012170:	08011198 080052b1 00000000 080052d1     .....R.......R..

08012180 <patternmbox.5438>:
 8012180:	08012170 00000000 00000000 00000000     p!..............

08012190 <__func__.5915.12679>:
 8012190:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080121a0 <evhndl.12944>:
 80121a0:	08003cf1 08003d11 08003d31 00000000     .<...=..1=......

080121b0 <testevt1.5424>:
 80121b0:	080111b8 08003ce1 00000000 08003d51     .....<......Q=..

080121c0 <testevt2.5429>:
 80121c0:	080111dc 08003e41 00000000 08003ea1     ....A>.......>..

080121d0 <testevt3.5430>:
 80121d0:	080111f8 08004251 00000000 08004261     ....QB......aB..

080121e0 <patternevt.5423>:
 80121e0:	080121b0 080121c0 080121d0 00000000     .!...!...!......

080121f0 <__func__.5915.12946>:
 80121f0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08012200 <testheap1.5414>:
 8012200:	0801120c 08004351 00000000 08004371     ....QC......qC..

08012210 <patternheap.5413>:
 8012210:	08012200 00000000 00000000 00000000     ."..............

08012220 <testpools1.5407>:
 8012220:	08011234 080028b1 00000000 080028d1     4....(.......(..

08012230 <patternpools.5406>:
 8012230:	08012220 00000000 00000000 00000000      "..............

08012240 <testdyn1.5374>:
 8012240:	08011250 08002a61 00000000 08002a81     P...a*.......*..

08012250 <testdyn2.5379>:
 8012250:	0801127c 08002c21 00000000 08002c41     |...!,......A,..

08012260 <testdyn3.5380>:
 8012260:	080112ac 08002e91 00000000 08002eb1     ................

08012270 <patterndyn.5373>:
 8012270:	08012240 08012250 08012260 00000000     @"..P"..`"......

08012280 <testqueues1.5352>:
 8012280:	080112d4 08003261 00000000 080032b1     ....a2.......2..

08012290 <testqueues2.5357>:
 8012290:	080112ec 08003631 00000000 08003681     ....16.......6..

080122a0 <patternqueues.5351>:
 80122a0:	08012280 08012290 00000000 00000000     ."..."..........

080122b0 <__func__.5915.13650>:
 80122b0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080122c0 <testsys1.5341>:
 80122c0:	08011304 00000000 00000000 08001371     ............q...

080122d0 <testsys2.5346>:
 80122d0:	0801131c 00000000 00000000 08001401     ................

080122e0 <testsys3.5347>:
 80122e0:	08011338 00000000 00000000 08001421     8...........!...

080122f0 <patternsys.5340>:
 80122f0:	080122c0 080122d0 080122e0 00000000     ."..."..."......

08012300 <__func__.5915.13914>:
 8012300:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08012310 <testbmk1.5318>:
 8012310:	0801134c 00000000 00000000 080016b1     L...............

08012320 <testbmk2.5323>:
 8012320:	08011364 00000000 00000000 08001741     d...........A...

08012330 <testbmk3.5324>:
 8012330:	0801137c 00000000 00000000 080017d1     |...............

08012340 <testbmk4.5325>:
 8012340:	08011394 00000000 00000000 08001961     ............a...

08012350 <testbmk5.5326>:
 8012350:	080113b0 00000000 00000000 08001a41     ............A...

08012360 <testbmk6.5327>:
 8012360:	080113d0 00000000 00000000 08001ad1     ................

08012370 <testbmk7.5328>:
 8012370:	080113f0 08001b81 00000000 08001ba1     ................

08012380 <testbmk8.5329>:
 8012380:	08011418 00000000 00000000 08001d81     ................

08012390 <testbmk9.5330>:
 8012390:	08011444 00000000 00000000 08001ed1     D...............

080123a0 <testbmk10.5331>:
 80123a0:	08011468 00000000 00000000 08001fd1     h...............

080123b0 <testbmk11.5332>:
 80123b0:	0801148c 08002081 00000000 080020a1     ..... ....... ..

080123c0 <testbmk12.5333>:
 80123c0:	080114b0 08002161 00000000 08002171     ....a!......q!..

080123d0 <testbmk13.5334>:
 80123d0:	080114d0 00000000 00000000 08002231     ............1"..

080123e0 <patternbmk.5312>:
 80123e0:	08012310 08012320 08012330 08012340     .#.. #..0#..@#..
 80123f0:	08012350 08012360 08012370 08012380     P#..`#..p#...#..
 8012400:	08012390 080123a0 080123b0 080123c0     .#...#...#...#..
 8012410:	080123d0 00000000 00000000 00000000     .#..............

08012420 <__func__.5915.14211>:
 8012420:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08012430 <__func__.6247.14531>:
 8012430:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08012440 <vcom_device_descriptor_data.15042>:
 8012440:	01100112 40000002 57400483 02010200     .......@..@W....
 8012450:	00000103 00000000 00000000 00000000     ................

08012460 <vcom_device_descriptor.15041>:
 8012460:	00000012 08012440 00000000 00000000     ....@$..........

08012470 <vcom_configuration_descriptor_data.15044>:
 8012470:	00430209 c0000102 00040932 02020100     ..C.....2.......
 8012480:	24050001 05011000 01000124 02022404     ...$....$....$..
 8012490:	00062405 82050701 ff000803 00010409     .$..............
 80124a0:	00000a02 01050700 00004002 02810507     .........@......
 80124b0:	00000040 00000000 00000000 00000000     @...............

080124c0 <vcom_configuration_descriptor.15043>:
 80124c0:	00000043 08012470 00000000 00000000     C...p$..........

080124d0 <vcom_string0.15046>:
 80124d0:	04090304 00000000 00000000 00000000     ................

080124e0 <vcom_string1.15047>:
 80124e0:	00530326 004d0054 00630069 006f0072     &.S.T.M.i.c.r.o.
 80124f0:	006c0065 00630065 00720074 006e006f     e.l.e.c.t.r.o.n.
 8012500:	00630069 00000073 00000000 00000000     i.c.s...........

08012510 <vcom_string2.15048>:
 8012510:	00430338 00690068 00690062 0053004f     8.C.h.i.b.i.O.S.
 8012520:	0052002f 00200054 00690056 00740072     /.R.T. .V.i.r.t.
 8012530:	00610075 0020006c 004f0043 0020004d     u.a.l. .C.O.M. .
 8012540:	006f0050 00740072 00000000 00000000     P.o.r.t.........

08012550 <vcom_string3.15049>:
 8012550:	00330308 00330031 00000000 00000000     ..3.1.3.........

08012560 <vcom_strings.15045>:
 8012560:	00000004 080124d0 00000026 080124e0     .....$..&....$..
 8012570:	00000038 08012510 00000008 08012550     8....%......P%..

08012580 <ep1config.15050>:
 8012580:	00000002 00000000 0800a6f1 0800a7d1     ................
 8012590:	00400040 200023e0 200023f0 00000002     @.@..#. .#. ....
	...

080125b0 <ep2config.15053>:
 80125b0:	00000003 00000000 0800a871 00000000     ........q.......
 80125c0:	00000010 20002400 00000000 00000001     .....$. ........
	...

080125e0 <usbcfg>:
 80125e0:	08000e01 08000da1 0800a5d1 08000e91     ................

080125f0 <serusbcfg>:
 80125f0:	20001350 00020101 00000000 00000000     P.. ............

08012600 <commands.15537>:
 8012600:	080114fc 08000f11 08011500 08000f81     ................
 8012610:	08011508 08001011 08011510 08001081     ................
	...

08012630 <shell_cfg1.15536>:
 8012630:	20001f58 08012600                       X.. .&..
