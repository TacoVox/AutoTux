
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <Reset_Handler>:
 8000200:	b672      	cpsid	i
 8000202:	4822      	ldr	r0, [pc, #136]	; (800028c <endfiniloop+0x4>)
 8000204:	f380 8809 	msr	PSP, r0
 8000208:	2002      	movs	r0, #2
 800020a:	f380 8814 	msr	CONTROL, r0
 800020e:	f3bf 8f6f 	isb	sy
 8000212:	f004 fe95 	bl	8004f40 <__core_init>
 8000216:	f001 fb1b 	bl	8001850 <__early_init>
 800021a:	481d      	ldr	r0, [pc, #116]	; (8000290 <endfiniloop+0x8>)
 800021c:	491d      	ldr	r1, [pc, #116]	; (8000294 <endfiniloop+0xc>)
 800021e:	4a1e      	ldr	r2, [pc, #120]	; (8000298 <endfiniloop+0x10>)

08000220 <msloop>:
 8000220:	4291      	cmp	r1, r2
 8000222:	bf3c      	itt	cc
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
 8000228:	e7fa      	bcc.n	8000220 <msloop>
 800022a:	491c      	ldr	r1, [pc, #112]	; (800029c <endfiniloop+0x14>)
 800022c:	4a17      	ldr	r2, [pc, #92]	; (800028c <endfiniloop+0x4>)

0800022e <psloop>:
 800022e:	4291      	cmp	r1, r2
 8000230:	bf3c      	itt	cc
 8000232:	f841 0b04 	strcc.w	r0, [r1], #4
 8000236:	e7fa      	bcc.n	800022e <psloop>
 8000238:	4919      	ldr	r1, [pc, #100]	; (80002a0 <endfiniloop+0x18>)
 800023a:	4a1a      	ldr	r2, [pc, #104]	; (80002a4 <endfiniloop+0x1c>)
 800023c:	4b1a      	ldr	r3, [pc, #104]	; (80002a8 <endfiniloop+0x20>)

0800023e <dloop>:
 800023e:	429a      	cmp	r2, r3
 8000240:	bf3e      	ittt	cc
 8000242:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000246:	f842 0b04 	strcc.w	r0, [r2], #4
 800024a:	e7f8      	bcc.n	800023e <dloop>
 800024c:	2000      	movs	r0, #0
 800024e:	4917      	ldr	r1, [pc, #92]	; (80002ac <endfiniloop+0x24>)
 8000250:	4a17      	ldr	r2, [pc, #92]	; (80002b0 <endfiniloop+0x28>)

08000252 <bloop>:
 8000252:	4291      	cmp	r1, r2
 8000254:	bf3c      	itt	cc
 8000256:	f841 0b04 	strcc.w	r0, [r1], #4
 800025a:	e7fa      	bcc.n	8000252 <bloop>
 800025c:	f004 fe88 	bl	8004f70 <__init_ram_areas>
 8000260:	f004 fe76 	bl	8004f50 <__late_init>
 8000264:	4c13      	ldr	r4, [pc, #76]	; (80002b4 <endfiniloop+0x2c>)
 8000266:	4d14      	ldr	r5, [pc, #80]	; (80002b8 <endfiniloop+0x30>)

08000268 <initloop>:
 8000268:	42ac      	cmp	r4, r5
 800026a:	da03      	bge.n	8000274 <endinitloop>
 800026c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000270:	4788      	blx	r1
 8000272:	e7f9      	b.n	8000268 <initloop>

08000274 <endinitloop>:
 8000274:	f000 fc54 	bl	8000b20 <main>
 8000278:	4c10      	ldr	r4, [pc, #64]	; (80002bc <endfiniloop+0x34>)
 800027a:	4d11      	ldr	r5, [pc, #68]	; (80002c0 <endfiniloop+0x38>)

0800027c <finiloop>:
 800027c:	42ac      	cmp	r4, r5
 800027e:	da03      	bge.n	8000288 <endfiniloop>
 8000280:	f854 1b04 	ldr.w	r1, [r4], #4
 8000284:	4788      	blx	r1
 8000286:	e7f9      	b.n	800027c <finiloop>

08000288 <endfiniloop>:
 8000288:	f004 be6a 	b.w	8004f60 <__default_exit>
 800028c:	20000800 	.word	0x20000800
 8000290:	55555555 	.word	0x55555555
 8000294:	20000000 	.word	0x20000000
 8000298:	20000400 	.word	0x20000400
 800029c:	20000400 	.word	0x20000400
 80002a0:	08007c18 	.word	0x08007c18
 80002a4:	20000800 	.word	0x20000800
 80002a8:	20000808 	.word	0x20000808
 80002ac:	20000808 	.word	0x20000808
 80002b0:	200016a8 	.word	0x200016a8
 80002b4:	08000200 	.word	0x08000200
 80002b8:	08000200 	.word	0x08000200
 80002bc:	08000200 	.word	0x08000200
 80002c0:	08000200 	.word	0x08000200
	...

080002d0 <_port_switch>:
 80002d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002d4:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002d8:	68c3      	ldr	r3, [r0, #12]
 80002da:	469d      	mov	sp, r3
 80002dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002e0 <_port_thread_start>:
 80002e0:	f005 f95e 	bl	80055a0 <_dbg_check_unlock>
 80002e4:	f006 fb34 	bl	8006950 <_stats_stop_measure_crit_thd>
 80002e8:	2300      	movs	r3, #0
 80002ea:	f383 8811 	msr	BASEPRI, r3
 80002ee:	4628      	mov	r0, r5
 80002f0:	47a0      	blx	r4
 80002f2:	2000      	movs	r0, #0
 80002f4:	f006 f904 	bl	8006500 <chThdExit>

080002f8 <_port_switch_from_isr>:
 80002f8:	f006 fb22 	bl	8006940 <_stats_start_measure_crit_thd>
 80002fc:	f005 f930 	bl	8005560 <_dbg_check_lock>
 8000300:	f005 ff06 	bl	8006110 <chSchDoReschedule>
 8000304:	f005 f94c 	bl	80055a0 <_dbg_check_unlock>
 8000308:	f006 fb22 	bl	8006950 <_stats_stop_measure_crit_thd>

0800030c <_port_exit_from_isr>:
 800030c:	df00      	svc	0
 800030e:	e7fe      	b.n	800030e <_port_exit_from_isr+0x2>

08000310 <memcpy>:
 8000310:	4684      	mov	ip, r0
 8000312:	ea41 0300 	orr.w	r3, r1, r0
 8000316:	f013 0303 	ands.w	r3, r3, #3
 800031a:	d16d      	bne.n	80003f8 <memcpy+0xe8>
 800031c:	3a40      	subs	r2, #64	; 0x40
 800031e:	d341      	bcc.n	80003a4 <memcpy+0x94>
 8000320:	f851 3b04 	ldr.w	r3, [r1], #4
 8000324:	f840 3b04 	str.w	r3, [r0], #4
 8000328:	f851 3b04 	ldr.w	r3, [r1], #4
 800032c:	f840 3b04 	str.w	r3, [r0], #4
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	f851 3b04 	ldr.w	r3, [r1], #4
 800038c:	f840 3b04 	str.w	r3, [r0], #4
 8000390:	f851 3b04 	ldr.w	r3, [r1], #4
 8000394:	f840 3b04 	str.w	r3, [r0], #4
 8000398:	f851 3b04 	ldr.w	r3, [r1], #4
 800039c:	f840 3b04 	str.w	r3, [r0], #4
 80003a0:	3a40      	subs	r2, #64	; 0x40
 80003a2:	d2bd      	bcs.n	8000320 <memcpy+0x10>
 80003a4:	3230      	adds	r2, #48	; 0x30
 80003a6:	d311      	bcc.n	80003cc <memcpy+0xbc>
 80003a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003ac:	f840 3b04 	str.w	r3, [r0], #4
 80003b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b4:	f840 3b04 	str.w	r3, [r0], #4
 80003b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003bc:	f840 3b04 	str.w	r3, [r0], #4
 80003c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c4:	f840 3b04 	str.w	r3, [r0], #4
 80003c8:	3a10      	subs	r2, #16
 80003ca:	d2ed      	bcs.n	80003a8 <memcpy+0x98>
 80003cc:	320c      	adds	r2, #12
 80003ce:	d305      	bcc.n	80003dc <memcpy+0xcc>
 80003d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003d4:	f840 3b04 	str.w	r3, [r0], #4
 80003d8:	3a04      	subs	r2, #4
 80003da:	d2f9      	bcs.n	80003d0 <memcpy+0xc0>
 80003dc:	3204      	adds	r2, #4
 80003de:	d008      	beq.n	80003f2 <memcpy+0xe2>
 80003e0:	07d2      	lsls	r2, r2, #31
 80003e2:	bf1c      	itt	ne
 80003e4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003e8:	f800 3b01 	strbne.w	r3, [r0], #1
 80003ec:	d301      	bcc.n	80003f2 <memcpy+0xe2>
 80003ee:	880b      	ldrh	r3, [r1, #0]
 80003f0:	8003      	strh	r3, [r0, #0]
 80003f2:	4660      	mov	r0, ip
 80003f4:	4770      	bx	lr
 80003f6:	bf00      	nop
 80003f8:	2a08      	cmp	r2, #8
 80003fa:	d313      	bcc.n	8000424 <memcpy+0x114>
 80003fc:	078b      	lsls	r3, r1, #30
 80003fe:	d08d      	beq.n	800031c <memcpy+0xc>
 8000400:	f010 0303 	ands.w	r3, r0, #3
 8000404:	d08a      	beq.n	800031c <memcpy+0xc>
 8000406:	f1c3 0304 	rsb	r3, r3, #4
 800040a:	1ad2      	subs	r2, r2, r3
 800040c:	07db      	lsls	r3, r3, #31
 800040e:	bf1c      	itt	ne
 8000410:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000414:	f800 3b01 	strbne.w	r3, [r0], #1
 8000418:	d380      	bcc.n	800031c <memcpy+0xc>
 800041a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800041e:	f820 3b02 	strh.w	r3, [r0], #2
 8000422:	e77b      	b.n	800031c <memcpy+0xc>
 8000424:	3a04      	subs	r2, #4
 8000426:	d3d9      	bcc.n	80003dc <memcpy+0xcc>
 8000428:	3a01      	subs	r2, #1
 800042a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800042e:	f800 3b01 	strb.w	r3, [r0], #1
 8000432:	d2f9      	bcs.n	8000428 <memcpy+0x118>
 8000434:	780b      	ldrb	r3, [r1, #0]
 8000436:	7003      	strb	r3, [r0, #0]
 8000438:	784b      	ldrb	r3, [r1, #1]
 800043a:	7043      	strb	r3, [r0, #1]
 800043c:	788b      	ldrb	r3, [r1, #2]
 800043e:	7083      	strb	r3, [r0, #2]
 8000440:	4660      	mov	r0, ip
 8000442:	4770      	bx	lr
	...

08000450 <long_to_string_with_divisor.14618.4336>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8000450:	b088      	sub	sp, #32
 8000452:	9003      	str	r0, [sp, #12]
 8000454:	9102      	str	r1, [sp, #8]
 8000456:	9201      	str	r2, [sp, #4]
 8000458:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 800045a:	9b02      	ldr	r3, [sp, #8]
 800045c:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 800045e:	9b00      	ldr	r3, [sp, #0]
 8000460:	2b00      	cmp	r3, #0
 8000462:	d102      	bne.n	800046a <long_to_string_with_divisor.14618.4336+0x1a>
    ll = num;
 8000464:	9b02      	ldr	r3, [sp, #8]
 8000466:	9304      	str	r3, [sp, #16]
 8000468:	e001      	b.n	800046e <long_to_string_with_divisor.14618.4336+0x1e>
  } else {
    ll = divisor;
 800046a:	9b00      	ldr	r3, [sp, #0]
 800046c:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 800046e:	9b03      	ldr	r3, [sp, #12]
 8000470:	330b      	adds	r3, #11
 8000472:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 8000474:	9b05      	ldr	r3, [sp, #20]
 8000476:	9a01      	ldr	r2, [sp, #4]
 8000478:	fbb3 f2f2 	udiv	r2, r3, r2
 800047c:	9901      	ldr	r1, [sp, #4]
 800047e:	fb01 f202 	mul.w	r2, r1, r2
 8000482:	1a9b      	subs	r3, r3, r2
 8000484:	9307      	str	r3, [sp, #28]
    i += '0';
 8000486:	9b07      	ldr	r3, [sp, #28]
 8000488:	3330      	adds	r3, #48	; 0x30
 800048a:	9307      	str	r3, [sp, #28]
    if (i > '9')
 800048c:	9b07      	ldr	r3, [sp, #28]
 800048e:	2b39      	cmp	r3, #57	; 0x39
 8000490:	dd02      	ble.n	8000498 <long_to_string_with_divisor.14618.4336+0x48>
      i += 'A' - '0' - 10;
 8000492:	9b07      	ldr	r3, [sp, #28]
 8000494:	3307      	adds	r3, #7
 8000496:	9307      	str	r3, [sp, #28]
    *--q = i;
 8000498:	9b06      	ldr	r3, [sp, #24]
 800049a:	3b01      	subs	r3, #1
 800049c:	9306      	str	r3, [sp, #24]
 800049e:	9b07      	ldr	r3, [sp, #28]
 80004a0:	b2da      	uxtb	r2, r3
 80004a2:	9b06      	ldr	r3, [sp, #24]
 80004a4:	701a      	strb	r2, [r3, #0]
    l /= radix;
 80004a6:	9a05      	ldr	r2, [sp, #20]
 80004a8:	9b01      	ldr	r3, [sp, #4]
 80004aa:	fbb2 f3f3 	udiv	r3, r2, r3
 80004ae:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 80004b0:	9a04      	ldr	r2, [sp, #16]
 80004b2:	9b01      	ldr	r3, [sp, #4]
 80004b4:	fbb2 f3f3 	udiv	r3, r2, r3
 80004b8:	9304      	str	r3, [sp, #16]
 80004ba:	9b04      	ldr	r3, [sp, #16]
 80004bc:	2b00      	cmp	r3, #0
 80004be:	d1d9      	bne.n	8000474 <long_to_string_with_divisor.14618.4336+0x24>

  i = (int)(p + MAX_FILLER - q);
 80004c0:	9b03      	ldr	r3, [sp, #12]
 80004c2:	330b      	adds	r3, #11
 80004c4:	461a      	mov	r2, r3
 80004c6:	9b06      	ldr	r3, [sp, #24]
 80004c8:	1ad3      	subs	r3, r2, r3
 80004ca:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 80004cc:	9b03      	ldr	r3, [sp, #12]
 80004ce:	1c5a      	adds	r2, r3, #1
 80004d0:	9203      	str	r2, [sp, #12]
 80004d2:	9a06      	ldr	r2, [sp, #24]
 80004d4:	1c51      	adds	r1, r2, #1
 80004d6:	9106      	str	r1, [sp, #24]
 80004d8:	7812      	ldrb	r2, [r2, #0]
 80004da:	701a      	strb	r2, [r3, #0]
  while (--i);
 80004dc:	9b07      	ldr	r3, [sp, #28]
 80004de:	3b01      	subs	r3, #1
 80004e0:	9307      	str	r3, [sp, #28]
 80004e2:	9b07      	ldr	r3, [sp, #28]
 80004e4:	2b00      	cmp	r3, #0
 80004e6:	d1f1      	bne.n	80004cc <long_to_string_with_divisor.14618.4336+0x7c>

  return p;
 80004e8:	9b03      	ldr	r3, [sp, #12]
}
 80004ea:	4618      	mov	r0, r3
 80004ec:	b008      	add	sp, #32
 80004ee:	4770      	bx	lr

080004f0 <ch_ltoa.14626.4331>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 80004f0:	b500      	push	{lr}
 80004f2:	b085      	sub	sp, #20
 80004f4:	9003      	str	r0, [sp, #12]
 80004f6:	9102      	str	r1, [sp, #8]
 80004f8:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 80004fa:	9803      	ldr	r0, [sp, #12]
 80004fc:	9902      	ldr	r1, [sp, #8]
 80004fe:	9a01      	ldr	r2, [sp, #4]
 8000500:	2300      	movs	r3, #0
 8000502:	f7ff ffa5 	bl	8000450 <long_to_string_with_divisor.14618.4336>
 8000506:	4603      	mov	r3, r0
}
 8000508:	4618      	mov	r0, r3
 800050a:	b005      	add	sp, #20
 800050c:	f85d fb04 	ldr.w	pc, [sp], #4

08000510 <chvprintf.4323>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8000510:	b500      	push	{lr}
 8000512:	b091      	sub	sp, #68	; 0x44
 8000514:	9003      	str	r0, [sp, #12]
 8000516:	9102      	str	r1, [sp, #8]
 8000518:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800051a:	2300      	movs	r3, #0
 800051c:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800051e:	9b02      	ldr	r3, [sp, #8]
 8000520:	1c5a      	adds	r2, r3, #1
 8000522:	9202      	str	r2, [sp, #8]
 8000524:	781b      	ldrb	r3, [r3, #0]
 8000526:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0)
 800052a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800052e:	2b00      	cmp	r3, #0
 8000530:	d101      	bne.n	8000536 <chvprintf.4323+0x26>
      return n;
 8000532:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000534:	e210      	b.n	8000958 <chvprintf.4323+0x448>
    if (c != '%') {
 8000536:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800053a:	2b25      	cmp	r3, #37	; 0x25
 800053c:	d00b      	beq.n	8000556 <chvprintf.4323+0x46>
      streamPut(chp, (uint8_t)c);
 800053e:	9b03      	ldr	r3, [sp, #12]
 8000540:	681b      	ldr	r3, [r3, #0]
 8000542:	689b      	ldr	r3, [r3, #8]
 8000544:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8000548:	9803      	ldr	r0, [sp, #12]
 800054a:	4611      	mov	r1, r2
 800054c:	4798      	blx	r3
      n++;
 800054e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000550:	3301      	adds	r3, #1
 8000552:	9309      	str	r3, [sp, #36]	; 0x24
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8000554:	e7e3      	b.n	800051e <chvprintf.4323+0xe>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8000556:	ab04      	add	r3, sp, #16
 8000558:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 800055a:	ab04      	add	r3, sp, #16
 800055c:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 800055e:	2300      	movs	r3, #0
 8000560:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 8000564:	9b02      	ldr	r3, [sp, #8]
 8000566:	781b      	ldrb	r3, [r3, #0]
 8000568:	2b2d      	cmp	r3, #45	; 0x2d
 800056a:	d105      	bne.n	8000578 <chvprintf.4323+0x68>
      fmt++;
 800056c:	9b02      	ldr	r3, [sp, #8]
 800056e:	3301      	adds	r3, #1
 8000570:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 8000572:	2301      	movs	r3, #1
 8000574:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 8000578:	2320      	movs	r3, #32
 800057a:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 800057e:	9b02      	ldr	r3, [sp, #8]
 8000580:	781b      	ldrb	r3, [r3, #0]
 8000582:	2b30      	cmp	r3, #48	; 0x30
 8000584:	d105      	bne.n	8000592 <chvprintf.4323+0x82>
      fmt++;
 8000586:	9b02      	ldr	r3, [sp, #8]
 8000588:	3301      	adds	r3, #1
 800058a:	9302      	str	r3, [sp, #8]
      filler = '0';
 800058c:	2330      	movs	r3, #48	; 0x30
 800058e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 8000592:	2300      	movs	r3, #0
 8000594:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 8000596:	9b02      	ldr	r3, [sp, #8]
 8000598:	1c5a      	adds	r2, r3, #1
 800059a:	9202      	str	r2, [sp, #8]
 800059c:	781b      	ldrb	r3, [r3, #0]
 800059e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
 80005a2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005a6:	2b2f      	cmp	r3, #47	; 0x2f
 80005a8:	d909      	bls.n	80005be <chvprintf.4323+0xae>
 80005aa:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005ae:	2b39      	cmp	r3, #57	; 0x39
 80005b0:	d805      	bhi.n	80005be <chvprintf.4323+0xae>
        c -= '0';
 80005b2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005b6:	3b30      	subs	r3, #48	; 0x30
 80005b8:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80005bc:	e009      	b.n	80005d2 <chvprintf.4323+0xc2>
      else if (c == '*')
 80005be:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005c2:	2b2a      	cmp	r3, #42	; 0x2a
 80005c4:	d110      	bne.n	80005e8 <chvprintf.4323+0xd8>
        c = va_arg(ap, int);
 80005c6:	9b01      	ldr	r3, [sp, #4]
 80005c8:	1d1a      	adds	r2, r3, #4
 80005ca:	9201      	str	r2, [sp, #4]
 80005cc:	681b      	ldr	r3, [r3, #0]
 80005ce:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      else
        break;
      width = width * 10 + c;
 80005d2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80005d4:	4613      	mov	r3, r2
 80005d6:	009b      	lsls	r3, r3, #2
 80005d8:	4413      	add	r3, r2
 80005da:	005b      	lsls	r3, r3, #1
 80005dc:	461a      	mov	r2, r3
 80005de:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005e2:	4413      	add	r3, r2
 80005e4:	930a      	str	r3, [sp, #40]	; 0x28
 80005e6:	e7d6      	b.n	8000596 <chvprintf.4323+0x86>
    }
    precision = 0;
 80005e8:	2300      	movs	r3, #0
 80005ea:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 80005ec:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005f0:	2b2e      	cmp	r3, #46	; 0x2e
 80005f2:	d129      	bne.n	8000648 <chvprintf.4323+0x138>
      while (TRUE) {
        c = *fmt++;
 80005f4:	9b02      	ldr	r3, [sp, #8]
 80005f6:	1c5a      	adds	r2, r3, #1
 80005f8:	9202      	str	r2, [sp, #8]
 80005fa:	781b      	ldrb	r3, [r3, #0]
 80005fc:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
 8000600:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000604:	2b2f      	cmp	r3, #47	; 0x2f
 8000606:	d909      	bls.n	800061c <chvprintf.4323+0x10c>
 8000608:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800060c:	2b39      	cmp	r3, #57	; 0x39
 800060e:	d805      	bhi.n	800061c <chvprintf.4323+0x10c>
          c -= '0';
 8000610:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000614:	3b30      	subs	r3, #48	; 0x30
 8000616:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800061a:	e009      	b.n	8000630 <chvprintf.4323+0x120>
        else if (c == '*')
 800061c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000620:	2b2a      	cmp	r3, #42	; 0x2a
 8000622:	d111      	bne.n	8000648 <chvprintf.4323+0x138>
          c = va_arg(ap, int);
 8000624:	9b01      	ldr	r3, [sp, #4]
 8000626:	1d1a      	adds	r2, r3, #4
 8000628:	9201      	str	r2, [sp, #4]
 800062a:	681b      	ldr	r3, [r3, #0]
 800062c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        else
          break;
        precision *= 10;
 8000630:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8000632:	4613      	mov	r3, r2
 8000634:	009b      	lsls	r3, r3, #2
 8000636:	4413      	add	r3, r2
 8000638:	005b      	lsls	r3, r3, #1
 800063a:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 800063c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000640:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8000642:	4413      	add	r3, r2
 8000644:	930b      	str	r3, [sp, #44]	; 0x2c
 8000646:	e7d5      	b.n	80005f4 <chvprintf.4323+0xe4>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8000648:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800064c:	2b6c      	cmp	r3, #108	; 0x6c
 800064e:	d003      	beq.n	8000658 <chvprintf.4323+0x148>
 8000650:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000654:	2b4c      	cmp	r3, #76	; 0x4c
 8000656:	d10d      	bne.n	8000674 <chvprintf.4323+0x164>
      is_long = TRUE;
 8000658:	2301      	movs	r3, #1
 800065a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 800065e:	9b02      	ldr	r3, [sp, #8]
 8000660:	781b      	ldrb	r3, [r3, #0]
 8000662:	2b00      	cmp	r3, #0
 8000664:	d01a      	beq.n	800069c <chvprintf.4323+0x18c>
        c = *fmt++;
 8000666:	9b02      	ldr	r3, [sp, #8]
 8000668:	1c5a      	adds	r2, r3, #1
 800066a:	9202      	str	r2, [sp, #8]
 800066c:	781b      	ldrb	r3, [r3, #0]
 800066e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8000672:	e014      	b.n	800069e <chvprintf.4323+0x18e>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 8000674:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000678:	2b40      	cmp	r3, #64	; 0x40
 800067a:	d905      	bls.n	8000688 <chvprintf.4323+0x178>
 800067c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000680:	2b5a      	cmp	r3, #90	; 0x5a
 8000682:	d801      	bhi.n	8000688 <chvprintf.4323+0x178>
 8000684:	2301      	movs	r3, #1
 8000686:	e000      	b.n	800068a <chvprintf.4323+0x17a>
 8000688:	2300      	movs	r3, #0
 800068a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 800068e:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8000692:	f003 0301 	and.w	r3, r3, #1
 8000696:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 800069a:	e000      	b.n	800069e <chvprintf.4323+0x18e>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 800069c:	bf00      	nop
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800069e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80006a2:	3b44      	subs	r3, #68	; 0x44
 80006a4:	2b34      	cmp	r3, #52	; 0x34
 80006a6:	f200 80e5 	bhi.w	8000874 <chvprintf.4323+0x364>
 80006aa:	a201      	add	r2, pc, #4	; (adr r2, 80006b0 <chvprintf.4323+0x1a0>)
 80006ac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80006b0:	080007ed 	.word	0x080007ed
 80006b4:	08000875 	.word	0x08000875
 80006b8:	08000875 	.word	0x08000875
 80006bc:	08000875 	.word	0x08000875
 80006c0:	08000875 	.word	0x08000875
 80006c4:	080007ed 	.word	0x080007ed
 80006c8:	08000875 	.word	0x08000875
 80006cc:	08000875 	.word	0x08000875
 80006d0:	08000875 	.word	0x08000875
 80006d4:	08000875 	.word	0x08000875
 80006d8:	08000875 	.word	0x08000875
 80006dc:	0800083f 	.word	0x0800083f
 80006e0:	08000875 	.word	0x08000875
 80006e4:	08000875 	.word	0x08000875
 80006e8:	08000875 	.word	0x08000875
 80006ec:	08000875 	.word	0x08000875
 80006f0:	08000875 	.word	0x08000875
 80006f4:	08000837 	.word	0x08000837
 80006f8:	08000875 	.word	0x08000875
 80006fc:	08000875 	.word	0x08000875
 8000700:	0800082f 	.word	0x0800082f
 8000704:	08000875 	.word	0x08000875
 8000708:	08000875 	.word	0x08000875
 800070c:	08000875 	.word	0x08000875
 8000710:	08000875 	.word	0x08000875
 8000714:	08000875 	.word	0x08000875
 8000718:	08000875 	.word	0x08000875
 800071c:	08000875 	.word	0x08000875
 8000720:	08000875 	.word	0x08000875
 8000724:	08000875 	.word	0x08000875
 8000728:	08000875 	.word	0x08000875
 800072c:	08000785 	.word	0x08000785
 8000730:	080007ed 	.word	0x080007ed
 8000734:	08000875 	.word	0x08000875
 8000738:	08000875 	.word	0x08000875
 800073c:	08000875 	.word	0x08000875
 8000740:	08000875 	.word	0x08000875
 8000744:	080007ed 	.word	0x080007ed
 8000748:	08000875 	.word	0x08000875
 800074c:	08000875 	.word	0x08000875
 8000750:	08000875 	.word	0x08000875
 8000754:	08000875 	.word	0x08000875
 8000758:	08000875 	.word	0x08000875
 800075c:	0800083f 	.word	0x0800083f
 8000760:	08000875 	.word	0x08000875
 8000764:	08000875 	.word	0x08000875
 8000768:	08000875 	.word	0x08000875
 800076c:	0800079f 	.word	0x0800079f
 8000770:	08000875 	.word	0x08000875
 8000774:	08000837 	.word	0x08000837
 8000778:	08000875 	.word	0x08000875
 800077c:	08000875 	.word	0x08000875
 8000780:	0800082f 	.word	0x0800082f
    case 'c':
      filler = ' ';
 8000784:	2320      	movs	r3, #32
 8000786:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 800078a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800078c:	1c5a      	adds	r2, r3, #1
 800078e:	920f      	str	r2, [sp, #60]	; 0x3c
 8000790:	9a01      	ldr	r2, [sp, #4]
 8000792:	1d11      	adds	r1, r2, #4
 8000794:	9101      	str	r1, [sp, #4]
 8000796:	6812      	ldr	r2, [r2, #0]
 8000798:	b2d2      	uxtb	r2, r2
 800079a:	701a      	strb	r2, [r3, #0]
 800079c:	e070      	b.n	8000880 <chvprintf.4323+0x370>
      break;
    case 's':
      filler = ' ';
 800079e:	2320      	movs	r3, #32
 80007a0:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 80007a4:	9b01      	ldr	r3, [sp, #4]
 80007a6:	1d1a      	adds	r2, r3, #4
 80007a8:	9201      	str	r2, [sp, #4]
 80007aa:	681b      	ldr	r3, [r3, #0]
 80007ac:	930e      	str	r3, [sp, #56]	; 0x38
 80007ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80007b0:	2b00      	cmp	r3, #0
 80007b2:	d104      	bne.n	80007be <chvprintf.4323+0x2ae>
        s = "(null)";
 80007b4:	f247 13f4 	movw	r3, #29172	; 0x71f4
 80007b8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80007bc:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 80007be:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80007c0:	2b00      	cmp	r3, #0
 80007c2:	d102      	bne.n	80007ca <chvprintf.4323+0x2ba>
        precision = 32767;
 80007c4:	f647 73ff 	movw	r3, #32767	; 0x7fff
 80007c8:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 80007ca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80007cc:	930f      	str	r3, [sp, #60]	; 0x3c
 80007ce:	e002      	b.n	80007d6 <chvprintf.4323+0x2c6>
 80007d0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80007d2:	3301      	adds	r3, #1
 80007d4:	930f      	str	r3, [sp, #60]	; 0x3c
 80007d6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80007d8:	781b      	ldrb	r3, [r3, #0]
 80007da:	2b00      	cmp	r3, #0
 80007dc:	d050      	beq.n	8000880 <chvprintf.4323+0x370>
 80007de:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80007e0:	3b01      	subs	r3, #1
 80007e2:	930b      	str	r3, [sp, #44]	; 0x2c
 80007e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80007e6:	2b00      	cmp	r3, #0
 80007e8:	daf2      	bge.n	80007d0 <chvprintf.4323+0x2c0>
 80007ea:	e049      	b.n	8000880 <chvprintf.4323+0x370>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 80007ec:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80007f0:	2b00      	cmp	r3, #0
 80007f2:	d005      	beq.n	8000800 <chvprintf.4323+0x2f0>
        l = va_arg(ap, long);
 80007f4:	9b01      	ldr	r3, [sp, #4]
 80007f6:	1d1a      	adds	r2, r3, #4
 80007f8:	9201      	str	r2, [sp, #4]
 80007fa:	681b      	ldr	r3, [r3, #0]
 80007fc:	9307      	str	r3, [sp, #28]
 80007fe:	e004      	b.n	800080a <chvprintf.4323+0x2fa>
      else
        l = va_arg(ap, int);
 8000800:	9b01      	ldr	r3, [sp, #4]
 8000802:	1d1a      	adds	r2, r3, #4
 8000804:	9201      	str	r2, [sp, #4]
 8000806:	681b      	ldr	r3, [r3, #0]
 8000808:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 800080a:	9b07      	ldr	r3, [sp, #28]
 800080c:	2b00      	cmp	r3, #0
 800080e:	da07      	bge.n	8000820 <chvprintf.4323+0x310>
        *p++ = '-';
 8000810:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000812:	1c5a      	adds	r2, r3, #1
 8000814:	920f      	str	r2, [sp, #60]	; 0x3c
 8000816:	222d      	movs	r2, #45	; 0x2d
 8000818:	701a      	strb	r2, [r3, #0]
        l = -l;
 800081a:	9b07      	ldr	r3, [sp, #28]
 800081c:	425b      	negs	r3, r3
 800081e:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 8000820:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8000822:	9907      	ldr	r1, [sp, #28]
 8000824:	220a      	movs	r2, #10
 8000826:	f7ff fe63 	bl	80004f0 <ch_ltoa.14626.4331>
 800082a:	900f      	str	r0, [sp, #60]	; 0x3c
 800082c:	e028      	b.n	8000880 <chvprintf.4323+0x370>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 800082e:	2310      	movs	r3, #16
 8000830:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8000834:	e006      	b.n	8000844 <chvprintf.4323+0x334>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 8000836:	230a      	movs	r3, #10
 8000838:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800083c:	e002      	b.n	8000844 <chvprintf.4323+0x334>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 800083e:	2308      	movs	r3, #8
 8000840:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 8000844:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8000848:	2b00      	cmp	r3, #0
 800084a:	d005      	beq.n	8000858 <chvprintf.4323+0x348>
        l = va_arg(ap, unsigned long);
 800084c:	9b01      	ldr	r3, [sp, #4]
 800084e:	1d1a      	adds	r2, r3, #4
 8000850:	9201      	str	r2, [sp, #4]
 8000852:	681b      	ldr	r3, [r3, #0]
 8000854:	9307      	str	r3, [sp, #28]
 8000856:	e004      	b.n	8000862 <chvprintf.4323+0x352>
      else
        l = va_arg(ap, unsigned int);
 8000858:	9b01      	ldr	r3, [sp, #4]
 800085a:	1d1a      	adds	r2, r3, #4
 800085c:	9201      	str	r2, [sp, #4]
 800085e:	681b      	ldr	r3, [r3, #0]
 8000860:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 8000862:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000866:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8000868:	9907      	ldr	r1, [sp, #28]
 800086a:	461a      	mov	r2, r3
 800086c:	f7ff fe40 	bl	80004f0 <ch_ltoa.14626.4331>
 8000870:	900f      	str	r0, [sp, #60]	; 0x3c
 8000872:	e005      	b.n	8000880 <chvprintf.4323+0x370>
      break;
    default:
      *p++ = c;
 8000874:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000876:	1c5a      	adds	r2, r3, #1
 8000878:	920f      	str	r2, [sp, #60]	; 0x3c
 800087a:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 800087e:	701a      	strb	r2, [r3, #0]
      break;
    }
    i = (int)(p - s);
 8000880:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8000882:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000884:	1ad3      	subs	r3, r2, r3
 8000886:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 8000888:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800088a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800088c:	1ad3      	subs	r3, r2, r3
 800088e:	930a      	str	r3, [sp, #40]	; 0x28
 8000890:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000892:	2b00      	cmp	r3, #0
 8000894:	da01      	bge.n	800089a <chvprintf.4323+0x38a>
      width = 0;
 8000896:	2300      	movs	r3, #0
 8000898:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 800089a:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 800089e:	f083 0301 	eor.w	r3, r3, #1
 80008a2:	b2db      	uxtb	r3, r3
 80008a4:	2b00      	cmp	r3, #0
 80008a6:	d002      	beq.n	80008ae <chvprintf.4323+0x39e>
      width = -width;
 80008a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80008aa:	425b      	negs	r3, r3
 80008ac:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 80008ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80008b0:	2b00      	cmp	r3, #0
 80008b2:	da37      	bge.n	8000924 <chvprintf.4323+0x414>
      if (*s == '-' && filler == '0') {
 80008b4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80008b6:	781b      	ldrb	r3, [r3, #0]
 80008b8:	2b2d      	cmp	r3, #45	; 0x2d
 80008ba:	d113      	bne.n	80008e4 <chvprintf.4323+0x3d4>
 80008bc:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 80008c0:	2b30      	cmp	r3, #48	; 0x30
 80008c2:	d10f      	bne.n	80008e4 <chvprintf.4323+0x3d4>
        streamPut(chp, (uint8_t)*s++);
 80008c4:	9b03      	ldr	r3, [sp, #12]
 80008c6:	681b      	ldr	r3, [r3, #0]
 80008c8:	689a      	ldr	r2, [r3, #8]
 80008ca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80008cc:	1c59      	adds	r1, r3, #1
 80008ce:	910e      	str	r1, [sp, #56]	; 0x38
 80008d0:	781b      	ldrb	r3, [r3, #0]
 80008d2:	9803      	ldr	r0, [sp, #12]
 80008d4:	4619      	mov	r1, r3
 80008d6:	4790      	blx	r2
        n++;
 80008d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80008da:	3301      	adds	r3, #1
 80008dc:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 80008de:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80008e0:	3b01      	subs	r3, #1
 80008e2:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 80008e4:	9b03      	ldr	r3, [sp, #12]
 80008e6:	681b      	ldr	r3, [r3, #0]
 80008e8:	689b      	ldr	r3, [r3, #8]
 80008ea:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 80008ee:	9803      	ldr	r0, [sp, #12]
 80008f0:	4611      	mov	r1, r2
 80008f2:	4798      	blx	r3
        n++;
 80008f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80008f6:	3301      	adds	r3, #1
 80008f8:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 80008fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80008fc:	3301      	adds	r3, #1
 80008fe:	930a      	str	r3, [sp, #40]	; 0x28
 8000900:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000902:	2b00      	cmp	r3, #0
 8000904:	d1ee      	bne.n	80008e4 <chvprintf.4323+0x3d4>
 8000906:	e00d      	b.n	8000924 <chvprintf.4323+0x414>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8000908:	9b03      	ldr	r3, [sp, #12]
 800090a:	681b      	ldr	r3, [r3, #0]
 800090c:	689a      	ldr	r2, [r3, #8]
 800090e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000910:	1c59      	adds	r1, r3, #1
 8000912:	910e      	str	r1, [sp, #56]	; 0x38
 8000914:	781b      	ldrb	r3, [r3, #0]
 8000916:	9803      	ldr	r0, [sp, #12]
 8000918:	4619      	mov	r1, r3
 800091a:	4790      	blx	r2
      n++;
 800091c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800091e:	3301      	adds	r3, #1
 8000920:	9309      	str	r3, [sp, #36]	; 0x24
 8000922:	e000      	b.n	8000926 <chvprintf.4323+0x416>
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
 8000924:	bf00      	nop
    }
    while (--i >= 0) {
 8000926:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000928:	3b01      	subs	r3, #1
 800092a:	930c      	str	r3, [sp, #48]	; 0x30
 800092c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800092e:	2b00      	cmp	r3, #0
 8000930:	daea      	bge.n	8000908 <chvprintf.4323+0x3f8>
 8000932:	e00d      	b.n	8000950 <chvprintf.4323+0x440>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 8000934:	9b03      	ldr	r3, [sp, #12]
 8000936:	681b      	ldr	r3, [r3, #0]
 8000938:	689b      	ldr	r3, [r3, #8]
 800093a:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 800093e:	9803      	ldr	r0, [sp, #12]
 8000940:	4611      	mov	r1, r2
 8000942:	4798      	blx	r3
      n++;
 8000944:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000946:	3301      	adds	r3, #1
 8000948:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 800094a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800094c:	3b01      	subs	r3, #1
 800094e:	930a      	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8000950:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000952:	2b00      	cmp	r3, #0
 8000954:	d1ee      	bne.n	8000934 <chvprintf.4323+0x424>
 8000956:	e5e2      	b.n	800051e <chvprintf.4323+0xe>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8000958:	4618      	mov	r0, r3
 800095a:	b011      	add	sp, #68	; 0x44
 800095c:	f85d fb04 	ldr.w	pc, [sp], #4

08000960 <chprintf.4310>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8000960:	b40e      	push	{r1, r2, r3}
 8000962:	b500      	push	{lr}
 8000964:	b084      	sub	sp, #16
 8000966:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8000968:	ab06      	add	r3, sp, #24
 800096a:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800096c:	9801      	ldr	r0, [sp, #4]
 800096e:	9905      	ldr	r1, [sp, #20]
 8000970:	9a02      	ldr	r2, [sp, #8]
 8000972:	f7ff fdcd 	bl	8000510 <chvprintf.4323>
 8000976:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 8000978:	9b03      	ldr	r3, [sp, #12]
}
 800097a:	4618      	mov	r0, r3
 800097c:	b004      	add	sp, #16
 800097e:	f85d eb04 	ldr.w	lr, [sp], #4
 8000982:	b003      	add	sp, #12
 8000984:	4770      	bx	lr
 8000986:	bf00      	nop
 8000988:	f3af 8000 	nop.w
 800098c:	f3af 8000 	nop.w

08000990 <port_lock.14689.4302>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000990:	b082      	sub	sp, #8
 8000992:	2320      	movs	r3, #32
 8000994:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000996:	9b01      	ldr	r3, [sp, #4]
 8000998:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800099c:	b002      	add	sp, #8
 800099e:	4770      	bx	lr

080009a0 <port_unlock.14692.4300>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80009a0:	b082      	sub	sp, #8
 80009a2:	2300      	movs	r3, #0
 80009a4:	9301      	str	r3, [sp, #4]
 80009a6:	9b01      	ldr	r3, [sp, #4]
 80009a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80009ac:	b002      	add	sp, #8
 80009ae:	4770      	bx	lr

080009b0 <port_lock_from_isr.14694.4298>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80009b0:	b508      	push	{r3, lr}

  port_lock();
 80009b2:	f7ff ffed 	bl	8000990 <port_lock.14689.4302>
}
 80009b6:	bd08      	pop	{r3, pc}
 80009b8:	f3af 8000 	nop.w
 80009bc:	f3af 8000 	nop.w

080009c0 <port_unlock_from_isr.14696.4296>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80009c0:	b508      	push	{r3, lr}

  port_unlock();
 80009c2:	f7ff ffed 	bl	80009a0 <port_unlock.14692.4300>
}
 80009c6:	bd08      	pop	{r3, pc}
 80009c8:	f3af 8000 	nop.w
 80009cc:	f3af 8000 	nop.w

080009d0 <chSysLockFromISR.14958.4294>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80009d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80009d2:	f7ff ffed 	bl	80009b0 <port_lock_from_isr.14694.4298>
  _stats_start_measure_crit_isr();
 80009d6:	f005 ffc3 	bl	8006960 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80009da:	f004 fe01 	bl	80055e0 <_dbg_check_lock_from_isr>
}
 80009de:	bd08      	pop	{r3, pc}

080009e0 <chSysUnlockFromISR.14962.4292>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80009e0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 80009e2:	f004 fe1d 	bl	8005620 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80009e6:	f005 ffc3 	bl	8006970 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 80009ea:	f7ff ffe9 	bl	80009c0 <port_unlock_from_isr.14696.4296>
}
 80009ee:	bd08      	pop	{r3, pc}

080009f0 <osalSysLockFromISR.14960.4290>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80009f0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80009f2:	f7ff ffed 	bl	80009d0 <chSysLockFromISR.14958.4294>
}
 80009f6:	bd08      	pop	{r3, pc}
 80009f8:	f3af 8000 	nop.w
 80009fc:	f3af 8000 	nop.w

08000a00 <osalSysUnlockFromISR.14968.4288>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8000a00:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8000a02:	f7ff ffed 	bl	80009e0 <chSysUnlockFromISR.14962.4292>
}
 8000a06:	bd08      	pop	{r3, pc}
 8000a08:	f3af 8000 	nop.w
 8000a0c:	f3af 8000 	nop.w

08000a10 <get_descriptor.14698.4282>:
 * handled here.
 */
static const USBDescriptor *get_descriptor(USBDriver *usbp,
                                           uint8_t dtype,
                                           uint8_t dindex,
                                           uint16_t lang) {
 8000a10:	b082      	sub	sp, #8
 8000a12:	9001      	str	r0, [sp, #4]
 8000a14:	f88d 1003 	strb.w	r1, [sp, #3]
 8000a18:	f88d 2002 	strb.w	r2, [sp, #2]
 8000a1c:	f8ad 3000 	strh.w	r3, [sp]

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8000a20:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000a24:	2b02      	cmp	r3, #2
 8000a26:	d008      	beq.n	8000a3a <get_descriptor.14698.4282+0x2a>
 8000a28:	2b03      	cmp	r3, #3
 8000a2a:	d00b      	beq.n	8000a44 <get_descriptor.14698.4282+0x34>
 8000a2c:	2b01      	cmp	r3, #1
 8000a2e:	d116      	bne.n	8000a5e <get_descriptor.14698.4282+0x4e>
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
 8000a30:	f647 2380 	movw	r3, #31360	; 0x7a80
 8000a34:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000a38:	e012      	b.n	8000a60 <get_descriptor.14698.4282+0x50>
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
 8000a3a:	f647 23e0 	movw	r3, #31456	; 0x7ae0
 8000a3e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000a42:	e00d      	b.n	8000a60 <get_descriptor.14698.4282+0x50>
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8000a44:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8000a48:	2b03      	cmp	r3, #3
 8000a4a:	d808      	bhi.n	8000a5e <get_descriptor.14698.4282+0x4e>
      return &vcom_strings[dindex];
 8000a4c:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8000a50:	00da      	lsls	r2, r3, #3
 8000a52:	f647 3380 	movw	r3, #31616	; 0x7b80
 8000a56:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000a5a:	4413      	add	r3, r2
 8000a5c:	e000      	b.n	8000a60 <get_descriptor.14698.4282+0x50>
  }
  return NULL;
 8000a5e:	2300      	movs	r3, #0
}
 8000a60:	4618      	mov	r0, r3
 8000a62:	b002      	add	sp, #8
 8000a64:	4770      	bx	lr
 8000a66:	bf00      	nop
 8000a68:	f3af 8000 	nop.w
 8000a6c:	f3af 8000 	nop.w

08000a70 <usb_event.14964.4278>:
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8000a70:	b500      	push	{lr}
 8000a72:	b083      	sub	sp, #12
 8000a74:	9001      	str	r0, [sp, #4]
 8000a76:	460b      	mov	r3, r1
 8000a78:	f88d 3003 	strb.w	r3, [sp, #3]
  extern SerialUSBDriver SDU1;

  switch (event) {
 8000a7c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000a80:	2b05      	cmp	r3, #5
 8000a82:	d834      	bhi.n	8000aee <usb_event.14964.4278+0x7e>
 8000a84:	a201      	add	r2, pc, #4	; (adr r2, 8000a8c <usb_event.14964.4278+0x1c>)
 8000a86:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000a8a:	bf00      	nop
 8000a8c:	08000aef 	.word	0x08000aef
 8000a90:	08000aef 	.word	0x08000aef
 8000a94:	08000aa5 	.word	0x08000aa5
 8000a98:	08000adb 	.word	0x08000adb
 8000a9c:	08000aef 	.word	0x08000aef
 8000aa0:	08000aef 	.word	0x08000aef
  case USB_EVENT_RESET:
    return;
  case USB_EVENT_ADDRESS:
    return;
  case USB_EVENT_CONFIGURED:
    chSysLockFromISR();
 8000aa4:	f7ff ff94 	bl	80009d0 <chSysLockFromISR.14958.4294>

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8000aa8:	9801      	ldr	r0, [sp, #4]
 8000aaa:	2101      	movs	r1, #1
 8000aac:	f647 32a0 	movw	r2, #31648	; 0x7ba0
 8000ab0:	f6c0 0200 	movt	r2, #2048	; 0x800
 8000ab4:	f003 f864 	bl	8003b80 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 8000ab8:	9801      	ldr	r0, [sp, #4]
 8000aba:	2102      	movs	r1, #2
 8000abc:	f647 32d0 	movw	r2, #31696	; 0x7bd0
 8000ac0:	f6c0 0200 	movt	r2, #2048	; 0x800
 8000ac4:	f003 f85c 	bl	8003b80 <usbInitEndpointI>

    /* Resetting the state of the CDC subsystem.*/
    sduConfigureHookI(&SDU1);
 8000ac8:	f241 10f0 	movw	r0, #4592	; 0x11f0
 8000acc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000ad0:	f002 fbc6 	bl	8003260 <sduConfigureHookI>

    chSysUnlockFromISR();
 8000ad4:	f7ff ff84 	bl	80009e0 <chSysUnlockFromISR.14962.4292>
 8000ad8:	e009      	b.n	8000aee <usb_event.14964.4278+0x7e>
    return;
  case USB_EVENT_SUSPEND:
    chSysLockFromISR();
 8000ada:	f7ff ff79 	bl	80009d0 <chSysLockFromISR.14958.4294>

    /* Disconnection event on suspend.*/
    sduDisconnectI(&SDU1);
 8000ade:	f241 10f0 	movw	r0, #4592	; 0x11f0
 8000ae2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000ae6:	f002 fba3 	bl	8003230 <sduDisconnectI>

    chSysUnlockFromISR();
 8000aea:	f7ff ff79 	bl	80009e0 <chSysUnlockFromISR.14962.4292>
    return;
  case USB_EVENT_STALLED:
    return;
  }
  return;
}
 8000aee:	b003      	add	sp, #12
 8000af0:	f85d fb04 	ldr.w	pc, [sp], #4
 8000af4:	f3af 8000 	nop.w
 8000af8:	f3af 8000 	nop.w
 8000afc:	f3af 8000 	nop.w

08000b00 <sof_handler.14970.4013>:

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 8000b00:	b500      	push	{lr}
 8000b02:	b083      	sub	sp, #12
 8000b04:	9001      	str	r0, [sp, #4]

  (void)usbp;

  osalSysLockFromISR();
 8000b06:	f7ff ff73 	bl	80009f0 <osalSysLockFromISR.14960.4290>
  sduSOFHookI(&SDU1);
 8000b0a:	f241 10f0 	movw	r0, #4592	; 0x11f0
 8000b0e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000b12:	f002 fc1d 	bl	8003350 <sduSOFHookI>
  osalSysUnlockFromISR();
 8000b16:	f7ff ff73 	bl	8000a00 <osalSysUnlockFromISR.14968.4288>
}
 8000b1a:	b003      	add	sp, #12
 8000b1c:	f85d fb04 	ldr.w	pc, [sp], #4

08000b20 <main>:


/*
 * Application entry point.
 */
int main(void) {
 8000b20:	b500      	push	{lr}
 8000b22:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8000b24:	f003 fb74 	bl	8004210 <halInit>
  chSysInit();
 8000b28:	f004 fc22 	bl	8005370 <chSysInit>

  /*
   * Initializes a serial-over-USB CDC driver.
   */
  sduObjectInit(&SDU1);
 8000b2c:	f241 10f0 	movw	r0, #4592	; 0x11f0
 8000b30:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000b34:	f002 faec 	bl	8003110 <sduObjectInit>
  sduStart(&SDU1, &serusbcfg);
 8000b38:	f241 10f0 	movw	r0, #4592	; 0x11f0
 8000b3c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000b40:	f647 4110 	movw	r1, #31760	; 0x7c10
 8000b44:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000b48:	f002 fb22 	bl	8003190 <sduStart>
  /*
   * Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */
  usbDisconnectBus(serusbcfg.usbp);
 8000b4c:	f647 4310 	movw	r3, #31760	; 0x7c10
 8000b50:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000b54:	681b      	ldr	r3, [r3, #0]
 8000b56:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8000b58:	f647 4310 	movw	r3, #31760	; 0x7c10
 8000b5c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000b60:	681b      	ldr	r3, [r3, #0]
 8000b62:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8000b64:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000b66:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8000b6a:	6393      	str	r3, [r2, #56]	; 0x38
  chThdSleepMilliseconds(1500);
 8000b6c:	f643 2098 	movw	r0, #15000	; 0x3a98
 8000b70:	f005 fcb6 	bl	80064e0 <chThdSleep>
  usbStart(serusbcfg.usbp, &usbcfg);
 8000b74:	f647 4310 	movw	r3, #31760	; 0x7c10
 8000b78:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000b7c:	681b      	ldr	r3, [r3, #0]
 8000b7e:	4618      	mov	r0, r3
 8000b80:	f647 4100 	movw	r1, #31744	; 0x7c00
 8000b84:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000b88:	f002 ffba 	bl	8003b00 <usbStart>
  usbConnectBus(serusbcfg.usbp);
 8000b8c:	f647 4310 	movw	r3, #31760	; 0x7c10
 8000b90:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000b94:	681b      	ldr	r3, [r3, #0]
 8000b96:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8000b98:	f647 4310 	movw	r3, #31760	; 0x7c10
 8000b9c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000ba0:	681b      	ldr	r3, [r3, #0]
 8000ba2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8000ba4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000ba6:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8000baa:	6393      	str	r3, [r2, #56]	; 0x38

  /*
   * Shell manager initialization.
   */
  //shellInit();
	chprintf( (BaseSequentialStream *)&SDU1, "Welcome to stm!\r\n");
 8000bac:	f241 10f0 	movw	r0, #4592	; 0x11f0
 8000bb0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000bb4:	f247 11fc 	movw	r1, #29180	; 0x71fc
 8000bb8:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000bbc:	f7ff fed0 	bl	8000960 <chprintf.4310>
	msg_t charbuf;
	while(true) {
		charbuf = chnGetTimeout(&SDU1, 1000);
 8000bc0:	f241 13f0 	movw	r3, #4592	; 0x11f0
 8000bc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000bc8:	681b      	ldr	r3, [r3, #0]
 8000bca:	695b      	ldr	r3, [r3, #20]
 8000bcc:	f241 10f0 	movw	r0, #4592	; 0x11f0
 8000bd0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000bd4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8000bd8:	4798      	blx	r3
 8000bda:	9001      	str	r0, [sp, #4]
		if (charbuf != Q_TIMEOUT) {
 8000bdc:	9b01      	ldr	r3, [sp, #4]
 8000bde:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8000be2:	d00d      	beq.n	8000c00 <main+0xe0>
			chprintf( (BaseSequentialStream *)&SDU1, "%c", (char)charbuf);
 8000be4:	9b01      	ldr	r3, [sp, #4]
 8000be6:	b2db      	uxtb	r3, r3
 8000be8:	f241 10f0 	movw	r0, #4592	; 0x11f0
 8000bec:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000bf0:	f247 2110 	movw	r1, #29200	; 0x7210
 8000bf4:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000bf8:	461a      	mov	r2, r3
 8000bfa:	f7ff feb1 	bl	8000960 <chprintf.4310>
 8000bfe:	e009      	b.n	8000c14 <main+0xf4>
		} else {
			chprintf( (BaseSequentialStream *)&SDU1, "\0");
 8000c00:	f241 10f0 	movw	r0, #4592	; 0x11f0
 8000c04:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000c08:	f247 2114 	movw	r1, #29204	; 0x7214
 8000c0c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000c10:	f7ff fea6 	bl	8000960 <chprintf.4310>
		}
		chThdSleepMilliseconds(20);
 8000c14:	20c8      	movs	r0, #200	; 0xc8
 8000c16:	f005 fc63 	bl	80064e0 <chThdSleep>
 8000c1a:	e7d1      	b.n	8000bc0 <main+0xa0>
 8000c1c:	f3af 8000 	nop.w

08000c20 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8000c20:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000c22:	f005 fe55 	bl	80068d0 <_stats_increase_irq>
 8000c26:	f004 fd1b 	bl	8005660 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD1);
 8000c2a:	f640 6008 	movw	r0, #3592	; 0xe08
 8000c2e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000c32:	f001 ff3d 	bl	8002ab0 <usb_lld_serve_interrupt.10939>

  OSAL_IRQ_EPILOGUE();
 8000c36:	f004 fd3b 	bl	80056b0 <_dbg_check_leave_isr>
 8000c3a:	f003 faa9 	bl	8004190 <_port_irq_epilogue>
}
 8000c3e:	bd08      	pop	{r3, pc}

08000c40 <Vector174>:
/**
 * @brief   OTG2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG2_HANDLER) {
 8000c40:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000c42:	f005 fe45 	bl	80068d0 <_stats_increase_irq>
 8000c46:	f004 fd0b 	bl	8005660 <_dbg_check_enter_isr>

  usb_lld_serve_interrupt(&USBD2);
 8000c4a:	f640 70f0 	movw	r0, #4080	; 0xff0
 8000c4e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000c52:	f001 ff2d 	bl	8002ab0 <usb_lld_serve_interrupt.10939>

  OSAL_IRQ_EPILOGUE();
 8000c56:	f004 fd2b 	bl	80056b0 <_dbg_check_leave_isr>
 8000c5a:	f003 fa99 	bl	8004190 <_port_irq_epilogue>
}
 8000c5e:	bd08      	pop	{r3, pc}

08000c60 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8000c60:	b500      	push	{lr}
 8000c62:	b083      	sub	sp, #12

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8000c64:	f640 6008 	movw	r0, #3592	; 0xe08
 8000c68:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000c6c:	f002 ff20 	bl	8003ab0 <usbObjectInit>
  USBD1.wait      = NULL;
 8000c70:	f640 6308 	movw	r3, #3592	; 0xe08
 8000c74:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c78:	2200      	movs	r2, #0
 8000c7a:	679a      	str	r2, [r3, #120]	; 0x78
  USBD1.otg       = OTG_FS;
 8000c7c:	f640 6308 	movw	r3, #3592	; 0xe08
 8000c80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c84:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8000c88:	669a      	str	r2, [r3, #104]	; 0x68
  USBD1.otgparams = &fsparams;
 8000c8a:	f640 6308 	movw	r3, #3592	; 0xe08
 8000c8e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c92:	f647 02f0 	movw	r2, #30960	; 0x78f0
 8000c96:	f6c0 0200 	movt	r2, #2048	; 0x800
 8000c9a:	66da      	str	r2, [r3, #108]	; 0x6c

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8000c9c:	f640 6308 	movw	r3, #3592	; 0xe08
 8000ca0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ca4:	2200      	movs	r2, #0
 8000ca6:	67da      	str	r2, [r3, #124]	; 0x7c
  /* Filling the thread working area here because the function
     @p chThdCreateI() does not do it.*/
#if CH_DBG_FILL_THREADS
  {
    void *wsp = USBD1.wa_pump;
 8000ca8:	4b26      	ldr	r3, [pc, #152]	; (8000d44 <usb_lld_init+0xe4>)
 8000caa:	9301      	str	r3, [sp, #4]
    _thread_memfill((uint8_t *)wsp,
 8000cac:	9b01      	ldr	r3, [sp, #4]
 8000cae:	3360      	adds	r3, #96	; 0x60
 8000cb0:	9801      	ldr	r0, [sp, #4]
 8000cb2:	4619      	mov	r1, r3
 8000cb4:	22ff      	movs	r2, #255	; 0xff
 8000cb6:	f005 fb8b 	bl	80063d0 <_thread_memfill>
                    (uint8_t *)wsp + sizeof(thread_t),
                    CH_DBG_THREAD_FILL_VALUE);
    _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 8000cba:	9b01      	ldr	r3, [sp, #4]
 8000cbc:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8000cc0:	9b01      	ldr	r3, [sp, #4]
 8000cc2:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8000cc6:	4610      	mov	r0, r2
 8000cc8:	4619      	mov	r1, r3
 8000cca:	2255      	movs	r2, #85	; 0x55
 8000ccc:	f005 fb80 	bl	80063d0 <_thread_memfill>
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif

#if STM32_USB_USE_OTG2
  usbObjectInit(&USBD2);
 8000cd0:	f640 70f0 	movw	r0, #4080	; 0xff0
 8000cd4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000cd8:	f002 feea 	bl	8003ab0 <usbObjectInit>
  USBD2.wait      = NULL;
 8000cdc:	f640 73f0 	movw	r3, #4080	; 0xff0
 8000ce0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000ce4:	2200      	movs	r2, #0
 8000ce6:	679a      	str	r2, [r3, #120]	; 0x78
  USBD2.otg       = OTG_HS;
 8000ce8:	f640 73f0 	movw	r3, #4080	; 0xff0
 8000cec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000cf0:	2200      	movs	r2, #0
 8000cf2:	f2c4 0204 	movt	r2, #16388	; 0x4004
 8000cf6:	669a      	str	r2, [r3, #104]	; 0x68
  USBD2.otgparams = &hsparams;
 8000cf8:	f640 73f0 	movw	r3, #4080	; 0xff0
 8000cfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000d00:	f647 1200 	movw	r2, #30976	; 0x7900
 8000d04:	f6c0 0200 	movt	r2, #2048	; 0x800
 8000d08:	66da      	str	r2, [r3, #108]	; 0x6c

#if defined(_CHIBIOS_RT_)
  USBD2.tr = NULL;
 8000d0a:	f640 73f0 	movw	r3, #4080	; 0xff0
 8000d0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000d12:	2200      	movs	r2, #0
 8000d14:	67da      	str	r2, [r3, #124]	; 0x7c
  /* Filling the thread working area here because the function
     @p chThdCreateI() does not do it.*/
#if CH_DBG_FILL_THREADS
  {
    void *wsp = USBD2.wa_pump;
 8000d16:	4b0c      	ldr	r3, [pc, #48]	; (8000d48 <usb_lld_init+0xe8>)
 8000d18:	9300      	str	r3, [sp, #0]
    _thread_memfill((uint8_t *)wsp,
 8000d1a:	9b00      	ldr	r3, [sp, #0]
 8000d1c:	3360      	adds	r3, #96	; 0x60
 8000d1e:	9800      	ldr	r0, [sp, #0]
 8000d20:	4619      	mov	r1, r3
 8000d22:	22ff      	movs	r2, #255	; 0xff
 8000d24:	f005 fb54 	bl	80063d0 <_thread_memfill>
                    (uint8_t *)wsp + sizeof(thread_t),
                    CH_DBG_THREAD_FILL_VALUE);
    _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 8000d28:	9b00      	ldr	r3, [sp, #0]
 8000d2a:	f103 0260 	add.w	r2, r3, #96	; 0x60
 8000d2e:	9b00      	ldr	r3, [sp, #0]
 8000d30:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8000d34:	4610      	mov	r0, r2
 8000d36:	4619      	mov	r1, r3
 8000d38:	2255      	movs	r2, #85	; 0x55
 8000d3a:	f005 fb49 	bl	80063d0 <_thread_memfill>
                    CH_DBG_STACK_FILL_VALUE);
  }
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif
}
 8000d3e:	b003      	add	sp, #12
 8000d40:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d44:	20000e88 	.word	0x20000e88
 8000d48:	20001070 	.word	0x20001070
 8000d4c:	f3af 8000 	nop.w

08000d50 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8000d50:	b500      	push	{lr}
 8000d52:	b087      	sub	sp, #28
 8000d54:	9003      	str	r0, [sp, #12]
  stm32_otg_t *otgp = usbp->otg;
 8000d56:	9b03      	ldr	r3, [sp, #12]
 8000d58:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8000d5a:	9305      	str	r3, [sp, #20]

  if (usbp->state == USB_STOP) {
 8000d5c:	9b03      	ldr	r3, [sp, #12]
 8000d5e:	781b      	ldrb	r3, [r3, #0]
 8000d60:	2b01      	cmp	r3, #1
 8000d62:	f040 80dd 	bne.w	8000f20 <usb_lld_start+0x1d0>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8000d66:	9a03      	ldr	r2, [sp, #12]
 8000d68:	f640 6308 	movw	r3, #3592	; 0xe08
 8000d6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000d70:	429a      	cmp	r2, r3
 8000d72:	d12d      	bne.n	8000dd0 <usb_lld_start+0x80>
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(false);
 8000d74:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000d78:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000d7c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000d80:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000d84:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8000d86:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000d8a:	635a      	str	r2, [r3, #52]	; 0x34
      rccResetOTG_FS();
 8000d8c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000d90:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000d94:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000d98:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000d9c:	6952      	ldr	r2, [r2, #20]
 8000d9e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000da2:	615a      	str	r2, [r3, #20]
 8000da4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000da8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000dac:	2200      	movs	r2, #0
 8000dae:	615a      	str	r2, [r3, #20]

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 8000db0:	2043      	movs	r0, #67	; 0x43
 8000db2:	210e      	movs	r1, #14
 8000db4:	f000 fe4c 	bl	8001a50 <nvicEnableVector>

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8000db8:	9a05      	ldr	r2, [sp, #20]
 8000dba:	f44f 53a2 	mov.w	r3, #5184	; 0x1440
 8000dbe:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8000dc2:	60d3      	str	r3, [r2, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8000dc4:	9a05      	ldr	r2, [sp, #20]
 8000dc6:	2303      	movs	r3, #3
 8000dc8:	f2c0 2320 	movt	r3, #544	; 0x220
 8000dcc:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
    }
#endif

#if STM32_USB_USE_OTG2
    if (&USBD2 == usbp) {
 8000dd0:	9a03      	ldr	r2, [sp, #12]
 8000dd2:	f640 73f0 	movw	r3, #4080	; 0xff0
 8000dd6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000dda:	429a      	cmp	r2, r3
 8000ddc:	d145      	bne.n	8000e6a <usb_lld_start+0x11a>
      /* OTG HS clock enable and reset.*/
      rccEnableOTG_HS(false);
 8000dde:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000de2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000de6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000dea:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000dee:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8000df0:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8000df4:	631a      	str	r2, [r3, #48]	; 0x30
      rccResetOTG_HS();
 8000df6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000dfa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000dfe:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000e02:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000e06:	6912      	ldr	r2, [r2, #16]
 8000e08:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8000e0c:	611a      	str	r2, [r3, #16]
 8000e0e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000e12:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000e16:	2200      	movs	r2, #0
 8000e18:	611a      	str	r2, [r3, #16]
#if defined(BOARD_OTG2_USES_ULPI)
      rccEnableOTG_HSULPI(true);
#else
      /* Workaround for the problem described here:
         http://forum.chibios.org/phpbb/viewtopic.php?f=16&t=1798.*/
      rccDisableOTG_HSULPI(true);
 8000e1a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000e1e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000e22:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000e26:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000e2a:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8000e2c:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8000e30:	631a      	str	r2, [r3, #48]	; 0x30
 8000e32:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8000e36:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000e3a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000e3e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000e42:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8000e44:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8000e48:	651a      	str	r2, [r3, #80]	; 0x50
#endif

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
 8000e4a:	204d      	movs	r0, #77	; 0x4d
 8000e4c:	210e      	movs	r1, #14
 8000e4e:	f000 fdff 	bl	8001a50 <nvicEnableVector>
#if defined(BOARD_OTG2_USES_ULPI)
      /* High speed ULPI PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_HS) |
                      GUSBCFG_SRPCAP | GUSBCFG_HNPCAP;
#else
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8000e52:	9a05      	ldr	r2, [sp, #20]
 8000e54:	f44f 53a2 	mov.w	r3, #5184	; 0x1440
 8000e58:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8000e5c:	60d3      	str	r3, [r2, #12]
      /* USB 2.0 High Speed PHY in FS mode.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_HS_FS;
#endif
#else
      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8000e5e:	9a05      	ldr	r2, [sp, #20]
 8000e60:	2303      	movs	r3, #3
 8000e62:	f2c0 2320 	movt	r3, #544	; 0x220
 8000e66:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
#endif
    }
#endif

    /* Clearing mask of TXFIFOs to be filled.*/
    usbp->txpending = 0;
 8000e6a:	9b03      	ldr	r3, [sp, #12]
 8000e6c:	2200      	movs	r2, #0
 8000e6e:	675a      	str	r2, [r3, #116]	; 0x74

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8000e70:	9b05      	ldr	r3, [sp, #20]
 8000e72:	2200      	movs	r2, #0
 8000e74:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8000e78:	9b05      	ldr	r3, [sp, #20]
 8000e7a:	22c0      	movs	r2, #192	; 0xc0
 8000e7c:	601a      	str	r2, [r3, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8000e7e:	9b05      	ldr	r3, [sp, #20]
 8000e80:	f44f 2250 	mov.w	r2, #851968	; 0xd0000
 8000e84:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 8000e86:	9803      	ldr	r0, [sp, #12]
 8000e88:	f001 f9a2 	bl	80021d0 <otg_core_reset.10672>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8000e8c:	9b05      	ldr	r3, [sp, #20]
 8000e8e:	2200      	movs	r2, #0
 8000e90:	609a      	str	r2, [r3, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 8000e92:	9803      	ldr	r0, [sp, #12]
 8000e94:	f001 f9bc 	bl	8002210 <otg_disable_ep.10843>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8000e98:	9b05      	ldr	r3, [sp, #20]
 8000e9a:	2200      	movs	r2, #0
 8000e9c:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8000ea0:	9b05      	ldr	r3, [sp, #20]
 8000ea2:	2200      	movs	r2, #0
 8000ea4:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8000ea8:	9b05      	ldr	r3, [sp, #20]
 8000eaa:	2200      	movs	r2, #0
 8000eac:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8000eb0:	9b03      	ldr	r3, [sp, #12]
 8000eb2:	685b      	ldr	r3, [r3, #4]
 8000eb4:	68db      	ldr	r3, [r3, #12]
 8000eb6:	2b00      	cmp	r3, #0
 8000eb8:	d106      	bne.n	8000ec8 <usb_lld_start+0x178>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8000eba:	9a05      	ldr	r2, [sp, #20]
 8000ebc:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8000ec0:	f2cc 0330 	movt	r3, #49200	; 0xc030
 8000ec4:	6193      	str	r3, [r2, #24]
 8000ec6:	e005      	b.n	8000ed4 <usb_lld_start+0x184>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8000ec8:	9a05      	ldr	r2, [sp, #20]
 8000eca:	f643 4308 	movw	r3, #15368	; 0x3c08
 8000ece:	f2cc 0330 	movt	r3, #49200	; 0xc030
 8000ed2:	6193      	str	r3, [r2, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8000ed4:	9b05      	ldr	r3, [sp, #20]
 8000ed6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000eda:	615a      	str	r2, [r3, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8000edc:	9b03      	ldr	r3, [sp, #12]
 8000ede:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8000ee0:	2b00      	cmp	r3, #0
 8000ee2:	d117      	bne.n	8000f14 <usb_lld_start+0x1c4>
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 8000ee4:	9b03      	ldr	r3, [sp, #12]
 8000ee6:	3380      	adds	r3, #128	; 0x80
 8000ee8:	9a03      	ldr	r2, [sp, #12]
 8000eea:	9200      	str	r2, [sp, #0]
 8000eec:	4618      	mov	r0, r3
 8000eee:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8000ef2:	2202      	movs	r2, #2
 8000ef4:	f241 7341 	movw	r3, #5953	; 0x1741
 8000ef8:	f6c0 0300 	movt	r3, #2048	; 0x800
 8000efc:	f005 fa80 	bl	8006400 <chThdCreateI>
 8000f00:	4602      	mov	r2, r0
 8000f02:	9b03      	ldr	r3, [sp, #12]
 8000f04:	67da      	str	r2, [r3, #124]	; 0x7c
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
 8000f06:	9b03      	ldr	r3, [sp, #12]
 8000f08:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8000f0a:	4618      	mov	r0, r3
 8000f0c:	f001 f8e8 	bl	80020e0 <chThdStartI.10658>
      chSchRescheduleS();
 8000f10:	f005 f866 	bl	8005fe0 <chSchRescheduleS>
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8000f14:	9b05      	ldr	r3, [sp, #20]
 8000f16:	689b      	ldr	r3, [r3, #8]
 8000f18:	f043 0201 	orr.w	r2, r3, #1
 8000f1c:	9b05      	ldr	r3, [sp, #20]
 8000f1e:	609a      	str	r2, [r3, #8]
  }
}
 8000f20:	b007      	add	sp, #28
 8000f22:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f26:	bf00      	nop
 8000f28:	f3af 8000 	nop.w
 8000f2c:	f3af 8000 	nop.w

08000f30 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8000f30:	b510      	push	{r4, lr}
 8000f32:	b084      	sub	sp, #16
 8000f34:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8000f36:	9b01      	ldr	r3, [sp, #4]
 8000f38:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8000f3a:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 8000f3c:	9801      	ldr	r0, [sp, #4]
 8000f3e:	2100      	movs	r1, #0
 8000f40:	f001 f9c6 	bl	80022d0 <otg_txfifo_flush.10849>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8000f44:	9b02      	ldr	r3, [sp, #8]
 8000f46:	2200      	movs	r2, #0
 8000f48:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8000f4c:	9b02      	ldr	r3, [sp, #8]
 8000f4e:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8000f52:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000f56:	2300      	movs	r3, #0
 8000f58:	9303      	str	r3, [sp, #12]
 8000f5a:	e024      	b.n	8000fa6 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8000f5c:	9a02      	ldr	r2, [sp, #8]
 8000f5e:	9b03      	ldr	r3, [sp, #12]
 8000f60:	3348      	adds	r3, #72	; 0x48
 8000f62:	015b      	lsls	r3, r3, #5
 8000f64:	4413      	add	r3, r2
 8000f66:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000f6a:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8000f6c:	9a02      	ldr	r2, [sp, #8]
 8000f6e:	9b03      	ldr	r3, [sp, #12]
 8000f70:	3358      	adds	r3, #88	; 0x58
 8000f72:	015b      	lsls	r3, r3, #5
 8000f74:	4413      	add	r3, r2
 8000f76:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000f7a:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000f7c:	9a02      	ldr	r2, [sp, #8]
 8000f7e:	9b03      	ldr	r3, [sp, #12]
 8000f80:	015b      	lsls	r3, r3, #5
 8000f82:	4413      	add	r3, r2
 8000f84:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8000f88:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000f8c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8000f8e:	9a02      	ldr	r2, [sp, #8]
 8000f90:	9b03      	ldr	r3, [sp, #12]
 8000f92:	015b      	lsls	r3, r3, #5
 8000f94:	4413      	add	r3, r2
 8000f96:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8000f9a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000f9e:	601a      	str	r2, [r3, #0]
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000fa0:	9b03      	ldr	r3, [sp, #12]
 8000fa2:	3301      	adds	r3, #1
 8000fa4:	9303      	str	r3, [sp, #12]
 8000fa6:	9b01      	ldr	r3, [sp, #4]
 8000fa8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8000faa:	689a      	ldr	r2, [r3, #8]
 8000fac:	9b03      	ldr	r3, [sp, #12]
 8000fae:	429a      	cmp	r2, r3
 8000fb0:	d2d4      	bcs.n	8000f5c <usb_lld_reset+0x2c>
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8000fb2:	9801      	ldr	r0, [sp, #4]
 8000fb4:	f001 f9ac 	bl	8002310 <otg_ram_reset.10853>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8000fb8:	9b01      	ldr	r3, [sp, #4]
 8000fba:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8000fbc:	681a      	ldr	r2, [r3, #0]
 8000fbe:	9b02      	ldr	r3, [sp, #8]
 8000fc0:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 8000fc2:	9801      	ldr	r0, [sp, #4]
 8000fc4:	f001 f96c 	bl	80022a0 <otg_rxfifo_flush.10846>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8000fc8:	9b02      	ldr	r3, [sp, #8]
 8000fca:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 8000fce:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8000fd2:	9b02      	ldr	r3, [sp, #8]
 8000fd4:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8000fd8:	9b02      	ldr	r3, [sp, #8]
 8000fda:	699b      	ldr	r3, [r3, #24]
 8000fdc:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8000fe0:	f043 0310 	orr.w	r3, r3, #16
 8000fe4:	9a02      	ldr	r2, [sp, #8]
 8000fe6:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8000fe8:	9b02      	ldr	r3, [sp, #8]
 8000fea:	2209      	movs	r2, #9
 8000fec:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8000ff0:	9b02      	ldr	r3, [sp, #8]
 8000ff2:	2209      	movs	r2, #9
 8000ff4:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8000ff8:	9a01      	ldr	r2, [sp, #4]
 8000ffa:	f647 03c0 	movw	r3, #30912	; 0x78c0
 8000ffe:	f6c0 0300 	movt	r3, #2048	; 0x800
 8001002:	60d3      	str	r3, [r2, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 8001004:	9b02      	ldr	r3, [sp, #8]
 8001006:	2200      	movs	r2, #0
 8001008:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 800100c:	2340      	movs	r3, #64	; 0x40
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 800100e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001012:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001016:	9a02      	ldr	r2, [sp, #8]
 8001018:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 800101c:	9b02      	ldr	r3, [sp, #8]
 800101e:	2200      	movs	r2, #0
 8001020:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 8001024:	2340      	movs	r3, #64	; 0x40
 8001026:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800102a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 800102e:	9a02      	ldr	r2, [sp, #8]
 8001030:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8001034:	2340      	movs	r3, #64	; 0x40
 8001036:	089b      	lsrs	r3, r3, #2
 8001038:	b29b      	uxth	r3, r3
 800103a:	041b      	lsls	r3, r3, #16
 800103c:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 800103e:	2340      	movs	r3, #64	; 0x40
 8001040:	089b      	lsrs	r3, r3, #2
 8001042:	b29b      	uxth	r3, r3
 8001044:	9801      	ldr	r0, [sp, #4]
 8001046:	4619      	mov	r1, r3
 8001048:	f001 f972 	bl	8002330 <otg_ram_alloc.10856>
 800104c:	4603      	mov	r3, r0
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800104e:	ea44 0203 	orr.w	r2, r4, r3
 8001052:	9b02      	ldr	r3, [sp, #8]
 8001054:	629a      	str	r2, [r3, #40]	; 0x28
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
                                                  ep0config.in_maxsize / 4));
}
 8001056:	b004      	add	sp, #16
 8001058:	bd10      	pop	{r4, pc}
 800105a:	bf00      	nop
 800105c:	f3af 8000 	nop.w

08001060 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 8001060:	b084      	sub	sp, #16
 8001062:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8001064:	9b01      	ldr	r3, [sp, #4]
 8001066:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8001068:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 800106a:	9b03      	ldr	r3, [sp, #12]
 800106c:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 8001070:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8001074:	9b01      	ldr	r3, [sp, #4]
 8001076:	f893 3066 	ldrb.w	r3, [r3, #102]	; 0x66
 800107a:	011b      	lsls	r3, r3, #4
 800107c:	431a      	orrs	r2, r3
 800107e:	9b03      	ldr	r3, [sp, #12]
 8001080:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 8001084:	b004      	add	sp, #16
 8001086:	4770      	bx	lr
 8001088:	f3af 8000 	nop.w
 800108c:	f3af 8000 	nop.w

08001090 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8001090:	b530      	push	{r4, r5, lr}
 8001092:	b087      	sub	sp, #28
 8001094:	9001      	str	r0, [sp, #4]
 8001096:	460b      	mov	r3, r1
 8001098:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 800109c:	9b01      	ldr	r3, [sp, #4]
 800109e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80010a0:	9303      	str	r3, [sp, #12]

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80010a2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80010a6:	9a01      	ldr	r2, [sp, #4]
 80010a8:	3302      	adds	r3, #2
 80010aa:	009b      	lsls	r3, r3, #2
 80010ac:	4413      	add	r3, r2
 80010ae:	685b      	ldr	r3, [r3, #4]
 80010b0:	681b      	ldr	r3, [r3, #0]
 80010b2:	f003 0303 	and.w	r3, r3, #3
 80010b6:	2b03      	cmp	r3, #3
 80010b8:	f200 8115 	bhi.w	80012e6 <usb_lld_init_endpoint+0x256>
 80010bc:	a201      	add	r2, pc, #4	; (adr r2, 80010c4 <usb_lld_init_endpoint+0x34>)
 80010be:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80010c2:	bf00      	nop
 80010c4:	080010d5 	.word	0x080010d5
 80010c8:	080010e1 	.word	0x080010e1
 80010cc:	080010ed 	.word	0x080010ed
 80010d0:	080010f9 	.word	0x080010f9
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 80010d4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80010d8:	f2c1 0300 	movt	r3, #4096	; 0x1000
 80010dc:	9305      	str	r3, [sp, #20]
 80010de:	e010      	b.n	8001102 <usb_lld_init_endpoint+0x72>
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 80010e0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80010e4:	f2c1 0304 	movt	r3, #4100	; 0x1004
 80010e8:	9305      	str	r3, [sp, #20]
 80010ea:	e00a      	b.n	8001102 <usb_lld_init_endpoint+0x72>
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 80010ec:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80010f0:	f2c1 0308 	movt	r3, #4104	; 0x1008
 80010f4:	9305      	str	r3, [sp, #20]
 80010f6:	e004      	b.n	8001102 <usb_lld_init_endpoint+0x72>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 80010f8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80010fc:	f2c1 030c 	movt	r3, #4108	; 0x100c
 8001100:	9305      	str	r3, [sp, #20]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 8001102:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001106:	9a03      	ldr	r2, [sp, #12]
 8001108:	015b      	lsls	r3, r3, #5
 800110a:	4413      	add	r3, r2
 800110c:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8001110:	2200      	movs	r2, #0
 8001112:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 8001114:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001118:	9a01      	ldr	r2, [sp, #4]
 800111a:	3302      	adds	r3, #2
 800111c:	009b      	lsls	r3, r3, #2
 800111e:	4413      	add	r3, r2
 8001120:	685b      	ldr	r3, [r3, #4]
 8001122:	699b      	ldr	r3, [r3, #24]
 8001124:	2b00      	cmp	r3, #0
 8001126:	d020      	beq.n	800116a <usb_lld_init_endpoint+0xda>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8001128:	f89d 0003 	ldrb.w	r0, [sp, #3]
 800112c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001130:	9a01      	ldr	r2, [sp, #4]
 8001132:	3302      	adds	r3, #2
 8001134:	009b      	lsls	r3, r3, #2
 8001136:	4413      	add	r3, r2
 8001138:	685b      	ldr	r3, [r3, #4]
 800113a:	8a5b      	ldrh	r3, [r3, #18]
 800113c:	461a      	mov	r2, r3
 800113e:	9b05      	ldr	r3, [sp, #20]
 8001140:	431a      	orrs	r2, r3
 8001142:	9903      	ldr	r1, [sp, #12]
 8001144:	f100 0358 	add.w	r3, r0, #88	; 0x58
 8001148:	015b      	lsls	r3, r3, #5
 800114a:	440b      	add	r3, r1
 800114c:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 800114e:	9b03      	ldr	r3, [sp, #12]
 8001150:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8001154:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001158:	3310      	adds	r3, #16
 800115a:	2101      	movs	r1, #1
 800115c:	fa01 f303 	lsl.w	r3, r1, r3
 8001160:	431a      	orrs	r2, r3
 8001162:	9b03      	ldr	r3, [sp, #12]
 8001164:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8001168:	e01d      	b.n	80011a6 <usb_lld_init_endpoint+0x116>
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 800116a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800116e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001172:	9903      	ldr	r1, [sp, #12]
 8001174:	3258      	adds	r2, #88	; 0x58
 8001176:	0152      	lsls	r2, r2, #5
 8001178:	440a      	add	r2, r1
 800117a:	6812      	ldr	r2, [r2, #0]
 800117c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001180:	9903      	ldr	r1, [sp, #12]
 8001182:	3358      	adds	r3, #88	; 0x58
 8001184:	015b      	lsls	r3, r3, #5
 8001186:	440b      	add	r3, r1
 8001188:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 800118a:	9b03      	ldr	r3, [sp, #12]
 800118c:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8001190:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001194:	3310      	adds	r3, #16
 8001196:	2101      	movs	r1, #1
 8001198:	fa01 f303 	lsl.w	r3, r1, r3
 800119c:	43db      	mvns	r3, r3
 800119e:	401a      	ands	r2, r3
 80011a0:	9b03      	ldr	r3, [sp, #12]
 80011a2:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 80011a6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80011aa:	9a03      	ldr	r2, [sp, #12]
 80011ac:	015b      	lsls	r3, r3, #5
 80011ae:	4413      	add	r3, r2
 80011b0:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80011b4:	2200      	movs	r2, #0
 80011b6:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->in_state != NULL) {
 80011b8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80011bc:	9a01      	ldr	r2, [sp, #4]
 80011be:	3302      	adds	r3, #2
 80011c0:	009b      	lsls	r3, r3, #2
 80011c2:	4413      	add	r3, r2
 80011c4:	685b      	ldr	r3, [r3, #4]
 80011c6:	695b      	ldr	r3, [r3, #20]
 80011c8:	2b00      	cmp	r3, #0
 80011ca:	d05d      	beq.n	8001288 <usb_lld_init_endpoint+0x1f8>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 80011cc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80011d0:	9a01      	ldr	r2, [sp, #4]
 80011d2:	3302      	adds	r3, #2
 80011d4:	009b      	lsls	r3, r3, #2
 80011d6:	4413      	add	r3, r2
 80011d8:	685b      	ldr	r3, [r3, #4]
 80011da:	8a1b      	ldrh	r3, [r3, #16]
 80011dc:	089b      	lsrs	r3, r3, #2
 80011de:	b29b      	uxth	r3, r3
 80011e0:	9304      	str	r3, [sp, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 80011e2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80011e6:	9a01      	ldr	r2, [sp, #4]
 80011e8:	3302      	adds	r3, #2
 80011ea:	009b      	lsls	r3, r3, #2
 80011ec:	4413      	add	r3, r2
 80011ee:	685b      	ldr	r3, [r3, #4]
 80011f0:	8b9b      	ldrh	r3, [r3, #28]
 80011f2:	2b01      	cmp	r3, #1
 80011f4:	d90c      	bls.n	8001210 <usb_lld_init_endpoint+0x180>
      fsize *= usbp->epc[ep]->in_multiplier;
 80011f6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80011fa:	9a01      	ldr	r2, [sp, #4]
 80011fc:	3302      	adds	r3, #2
 80011fe:	009b      	lsls	r3, r3, #2
 8001200:	4413      	add	r3, r2
 8001202:	685b      	ldr	r3, [r3, #4]
 8001204:	8b9b      	ldrh	r3, [r3, #28]
 8001206:	461a      	mov	r2, r3
 8001208:	9b04      	ldr	r3, [sp, #16]
 800120a:	fb02 f303 	mul.w	r3, r2, r3
 800120e:	9304      	str	r3, [sp, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8001210:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001214:	1e5c      	subs	r4, r3, #1
 8001216:	9b04      	ldr	r3, [sp, #16]
 8001218:	041d      	lsls	r5, r3, #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 800121a:	9801      	ldr	r0, [sp, #4]
 800121c:	9904      	ldr	r1, [sp, #16]
 800121e:	f001 f887 	bl	8002330 <otg_ram_alloc.10856>
 8001222:	4603      	mov	r3, r0
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8001224:	ea45 0203 	orr.w	r2, r5, r3
 8001228:	9903      	ldr	r1, [sp, #12]
 800122a:	f104 0340 	add.w	r3, r4, #64	; 0x40
 800122e:	009b      	lsls	r3, r3, #2
 8001230:	440b      	add	r3, r1
 8001232:	605a      	str	r2, [r3, #4]
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);
 8001234:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001238:	9801      	ldr	r0, [sp, #4]
 800123a:	4619      	mov	r1, r3
 800123c:	f001 f848 	bl	80022d0 <otg_txfifo_flush.10849>

    otgp->ie[ep].DIEPCTL = ctl |
 8001240:	f89d 0003 	ldrb.w	r0, [sp, #3]
                           DIEPCTL_TXFNUM(ep) |
 8001244:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001248:	059b      	lsls	r3, r3, #22
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 800124a:	461a      	mov	r2, r3
 800124c:	9b05      	ldr	r3, [sp, #20]
 800124e:	431a      	orrs	r2, r3
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8001250:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001254:	9901      	ldr	r1, [sp, #4]
 8001256:	3302      	adds	r3, #2
 8001258:	009b      	lsls	r3, r3, #2
 800125a:	440b      	add	r3, r1
 800125c:	685b      	ldr	r3, [r3, #4]
 800125e:	8a1b      	ldrh	r3, [r3, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 8001260:	431a      	orrs	r2, r3
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8001262:	9903      	ldr	r1, [sp, #12]
 8001264:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8001268:	015b      	lsls	r3, r3, #5
 800126a:	440b      	add	r3, r1
 800126c:	601a      	str	r2, [r3, #0]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 800126e:	9b03      	ldr	r3, [sp, #12]
 8001270:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 8001274:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001278:	2101      	movs	r1, #1
 800127a:	fa01 f303 	lsl.w	r3, r1, r3
 800127e:	431a      	orrs	r2, r3
 8001280:	9b03      	ldr	r3, [sp, #12]
 8001282:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8001286:	e02e      	b.n	80012e6 <usb_lld_init_endpoint+0x256>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8001288:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800128c:	3b01      	subs	r3, #1
 800128e:	9a03      	ldr	r2, [sp, #12]
 8001290:	3340      	adds	r3, #64	; 0x40
 8001292:	009b      	lsls	r3, r3, #2
 8001294:	4413      	add	r3, r2
 8001296:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800129a:	f2c0 2200 	movt	r2, #512	; 0x200
 800129e:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 80012a0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80012a4:	9801      	ldr	r0, [sp, #4]
 80012a6:	4619      	mov	r1, r3
 80012a8:	f001 f812 	bl	80022d0 <otg_txfifo_flush.10849>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 80012ac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80012b0:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80012b4:	9903      	ldr	r1, [sp, #12]
 80012b6:	3248      	adds	r2, #72	; 0x48
 80012b8:	0152      	lsls	r2, r2, #5
 80012ba:	440a      	add	r2, r1
 80012bc:	6812      	ldr	r2, [r2, #0]
 80012be:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80012c2:	9903      	ldr	r1, [sp, #12]
 80012c4:	3348      	adds	r3, #72	; 0x48
 80012c6:	015b      	lsls	r3, r3, #5
 80012c8:	440b      	add	r3, r1
 80012ca:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 80012cc:	9b03      	ldr	r3, [sp, #12]
 80012ce:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80012d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80012d6:	2101      	movs	r1, #1
 80012d8:	fa01 f303 	lsl.w	r3, r1, r3
 80012dc:	43db      	mvns	r3, r3
 80012de:	401a      	ands	r2, r3
 80012e0:	9b03      	ldr	r3, [sp, #12]
 80012e2:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }
}
 80012e6:	b007      	add	sp, #28
 80012e8:	bd30      	pop	{r4, r5, pc}
 80012ea:	bf00      	nop
 80012ec:	f3af 8000 	nop.w

080012f0 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 80012f0:	b084      	sub	sp, #16
 80012f2:	9001      	str	r0, [sp, #4]
 80012f4:	460b      	mov	r3, r1
 80012f6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 80012fa:	9b01      	ldr	r3, [sp, #4]
 80012fc:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80012fe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001302:	3358      	adds	r3, #88	; 0x58
 8001304:	015b      	lsls	r3, r3, #5
 8001306:	4413      	add	r3, r2
 8001308:	681b      	ldr	r3, [r3, #0]
 800130a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 800130c:	9b03      	ldr	r3, [sp, #12]
 800130e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8001312:	2b00      	cmp	r3, #0
 8001314:	d101      	bne.n	800131a <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 8001316:	2300      	movs	r3, #0
 8001318:	e007      	b.n	800132a <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 800131a:	9b03      	ldr	r3, [sp, #12]
 800131c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001320:	2b00      	cmp	r3, #0
 8001322:	d001      	beq.n	8001328 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 8001324:	2301      	movs	r3, #1
 8001326:	e000      	b.n	800132a <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 8001328:	2302      	movs	r3, #2
}
 800132a:	4618      	mov	r0, r3
 800132c:	b004      	add	sp, #16
 800132e:	4770      	bx	lr

08001330 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 8001330:	b084      	sub	sp, #16
 8001332:	9001      	str	r0, [sp, #4]
 8001334:	460b      	mov	r3, r1
 8001336:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 800133a:	9b01      	ldr	r3, [sp, #4]
 800133c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800133e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001342:	3348      	adds	r3, #72	; 0x48
 8001344:	015b      	lsls	r3, r3, #5
 8001346:	4413      	add	r3, r2
 8001348:	681b      	ldr	r3, [r3, #0]
 800134a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 800134c:	9b03      	ldr	r3, [sp, #12]
 800134e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8001352:	2b00      	cmp	r3, #0
 8001354:	d101      	bne.n	800135a <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 8001356:	2300      	movs	r3, #0
 8001358:	e007      	b.n	800136a <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 800135a:	9b03      	ldr	r3, [sp, #12]
 800135c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001360:	2b00      	cmp	r3, #0
 8001362:	d001      	beq.n	8001368 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 8001364:	2301      	movs	r3, #1
 8001366:	e000      	b.n	800136a <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 8001368:	2302      	movs	r3, #2
}
 800136a:	4618      	mov	r0, r3
 800136c:	b004      	add	sp, #16
 800136e:	4770      	bx	lr

08001370 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 8001370:	b500      	push	{lr}
 8001372:	b085      	sub	sp, #20
 8001374:	9003      	str	r0, [sp, #12]
 8001376:	460b      	mov	r3, r1
 8001378:	9201      	str	r2, [sp, #4]
 800137a:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 800137e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8001382:	9a03      	ldr	r2, [sp, #12]
 8001384:	3302      	adds	r3, #2
 8001386:	009b      	lsls	r3, r3, #2
 8001388:	4413      	add	r3, r2
 800138a:	685b      	ldr	r3, [r3, #4]
 800138c:	6a1b      	ldr	r3, [r3, #32]
 800138e:	9801      	ldr	r0, [sp, #4]
 8001390:	4619      	mov	r1, r3
 8001392:	2208      	movs	r2, #8
 8001394:	f7fe ffbc 	bl	8000310 <memcpy>
}
 8001398:	b005      	add	sp, #20
 800139a:	f85d fb04 	ldr.w	pc, [sp], #4
 800139e:	bf00      	nop

080013a0 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 80013a0:	b086      	sub	sp, #24
 80013a2:	9001      	str	r0, [sp, #4]
 80013a4:	460b      	mov	r3, r1
 80013a6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80013aa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80013ae:	9a01      	ldr	r2, [sp, #4]
 80013b0:	3302      	adds	r3, #2
 80013b2:	009b      	lsls	r3, r3, #2
 80013b4:	4413      	add	r3, r2
 80013b6:	685b      	ldr	r3, [r3, #4]
 80013b8:	699b      	ldr	r3, [r3, #24]
 80013ba:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 80013bc:	9b05      	ldr	r3, [sp, #20]
 80013be:	681a      	ldr	r2, [r3, #0]
 80013c0:	9b05      	ldr	r3, [sp, #20]
 80013c2:	60da      	str	r2, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 80013c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80013c8:	2b00      	cmp	r3, #0
 80013ca:	d106      	bne.n	80013da <usb_lld_start_out+0x3a>
 80013cc:	9b05      	ldr	r3, [sp, #20]
 80013ce:	681b      	ldr	r3, [r3, #0]
 80013d0:	2b40      	cmp	r3, #64	; 0x40
 80013d2:	d902      	bls.n	80013da <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 80013d4:	9b05      	ldr	r3, [sp, #20]
 80013d6:	2240      	movs	r2, #64	; 0x40
 80013d8:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 80013da:	9b05      	ldr	r3, [sp, #20]
 80013dc:	681a      	ldr	r2, [r3, #0]
 80013de:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80013e2:	9901      	ldr	r1, [sp, #4]
 80013e4:	3302      	adds	r3, #2
 80013e6:	009b      	lsls	r3, r3, #2
 80013e8:	440b      	add	r3, r1
 80013ea:	685b      	ldr	r3, [r3, #4]
 80013ec:	8a5b      	ldrh	r3, [r3, #18]
 80013ee:	4413      	add	r3, r2
 80013f0:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 80013f2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80013f6:	9901      	ldr	r1, [sp, #4]
 80013f8:	3302      	adds	r3, #2
 80013fa:	009b      	lsls	r3, r3, #2
 80013fc:	440b      	add	r3, r1
 80013fe:	685b      	ldr	r3, [r3, #4]
 8001400:	8a5b      	ldrh	r3, [r3, #18]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8001402:	fbb2 f3f3 	udiv	r3, r2, r3
 8001406:	9304      	str	r3, [sp, #16]
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8001408:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800140c:	9a01      	ldr	r2, [sp, #4]
 800140e:	3302      	adds	r3, #2
 8001410:	009b      	lsls	r3, r3, #2
 8001412:	4413      	add	r3, r2
 8001414:	685b      	ldr	r3, [r3, #4]
 8001416:	8a5b      	ldrh	r3, [r3, #18]
 8001418:	9a04      	ldr	r2, [sp, #16]
 800141a:	fb02 f303 	mul.w	r3, r2, r3
 800141e:	3303      	adds	r3, #3
 8001420:	f023 0303 	bic.w	r3, r3, #3
 8001424:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8001426:	9b01      	ldr	r3, [sp, #4]
 8001428:	6e99      	ldr	r1, [r3, #104]	; 0x68
 800142a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800142e:	9a04      	ldr	r2, [sp, #16]
 8001430:	04d0      	lsls	r0, r2, #19
 8001432:	9a03      	ldr	r2, [sp, #12]
 8001434:	4302      	orrs	r2, r0
 8001436:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 800143a:	015b      	lsls	r3, r3, #5
 800143c:	440b      	add	r3, r1
 800143e:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8001442:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8001444:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001448:	9a01      	ldr	r2, [sp, #4]
 800144a:	3302      	adds	r3, #2
 800144c:	009b      	lsls	r3, r3, #2
 800144e:	4413      	add	r3, r2
 8001450:	685b      	ldr	r3, [r3, #4]
 8001452:	681b      	ldr	r3, [r3, #0]
 8001454:	f003 0303 	and.w	r3, r3, #3
 8001458:	2b01      	cmp	r3, #1
 800145a:	d12c      	bne.n	80014b6 <usb_lld_start_out+0x116>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 800145c:	9b01      	ldr	r3, [sp, #4]
 800145e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8001460:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8001464:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8001468:	2b00      	cmp	r3, #0
 800146a:	d012      	beq.n	8001492 <usb_lld_start_out+0xf2>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 800146c:	9b01      	ldr	r3, [sp, #4]
 800146e:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8001470:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001474:	9a01      	ldr	r2, [sp, #4]
 8001476:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8001478:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800147c:	3258      	adds	r2, #88	; 0x58
 800147e:	0152      	lsls	r2, r2, #5
 8001480:	4402      	add	r2, r0
 8001482:	6812      	ldr	r2, [r2, #0]
 8001484:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001488:	3358      	adds	r3, #88	; 0x58
 800148a:	015b      	lsls	r3, r3, #5
 800148c:	440b      	add	r3, r1
 800148e:	601a      	str	r2, [r3, #0]
 8001490:	e011      	b.n	80014b6 <usb_lld_start_out+0x116>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8001492:	9b01      	ldr	r3, [sp, #4]
 8001494:	6e99      	ldr	r1, [r3, #104]	; 0x68
 8001496:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800149a:	9a01      	ldr	r2, [sp, #4]
 800149c:	6e90      	ldr	r0, [r2, #104]	; 0x68
 800149e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80014a2:	3258      	adds	r2, #88	; 0x58
 80014a4:	0152      	lsls	r2, r2, #5
 80014a6:	4402      	add	r2, r0
 80014a8:	6812      	ldr	r2, [r2, #0]
 80014aa:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80014ae:	3358      	adds	r3, #88	; 0x58
 80014b0:	015b      	lsls	r3, r3, #5
 80014b2:	440b      	add	r3, r1
 80014b4:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 80014b6:	9b01      	ldr	r3, [sp, #4]
 80014b8:	6e99      	ldr	r1, [r3, #104]	; 0x68
 80014ba:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80014be:	9a01      	ldr	r2, [sp, #4]
 80014c0:	6e90      	ldr	r0, [r2, #104]	; 0x68
 80014c2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80014c6:	3258      	adds	r2, #88	; 0x58
 80014c8:	0152      	lsls	r2, r2, #5
 80014ca:	4402      	add	r2, r0
 80014cc:	6812      	ldr	r2, [r2, #0]
 80014ce:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80014d2:	3358      	adds	r3, #88	; 0x58
 80014d4:	015b      	lsls	r3, r3, #5
 80014d6:	440b      	add	r3, r1
 80014d8:	601a      	str	r2, [r3, #0]
}
 80014da:	b006      	add	sp, #24
 80014dc:	4770      	bx	lr
 80014de:	bf00      	nop

080014e0 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 80014e0:	b084      	sub	sp, #16
 80014e2:	9001      	str	r0, [sp, #4]
 80014e4:	460b      	mov	r3, r1
 80014e6:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80014ea:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80014ee:	9a01      	ldr	r2, [sp, #4]
 80014f0:	3302      	adds	r3, #2
 80014f2:	009b      	lsls	r3, r3, #2
 80014f4:	4413      	add	r3, r2
 80014f6:	685b      	ldr	r3, [r3, #4]
 80014f8:	695b      	ldr	r3, [r3, #20]
 80014fa:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 80014fc:	9b03      	ldr	r3, [sp, #12]
 80014fe:	681a      	ldr	r2, [r3, #0]
 8001500:	9b03      	ldr	r3, [sp, #12]
 8001502:	60da      	str	r2, [r3, #12]
  if (isp->txsize == 0) {
 8001504:	9b03      	ldr	r3, [sp, #12]
 8001506:	681b      	ldr	r3, [r3, #0]
 8001508:	2b00      	cmp	r3, #0
 800150a:	d10b      	bne.n	8001524 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800150c:	9b01      	ldr	r3, [sp, #4]
 800150e:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8001510:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001514:	015b      	lsls	r3, r3, #5
 8001516:	4413      	add	r3, r2
 8001518:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800151c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8001520:	601a      	str	r2, [r3, #0]
 8001522:	e031      	b.n	8001588 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8001524:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001528:	2b00      	cmp	r3, #0
 800152a:	d106      	bne.n	800153a <usb_lld_start_in+0x5a>
 800152c:	9b03      	ldr	r3, [sp, #12]
 800152e:	681b      	ldr	r3, [r3, #0]
 8001530:	2b40      	cmp	r3, #64	; 0x40
 8001532:	d902      	bls.n	800153a <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 8001534:	9b03      	ldr	r3, [sp, #12]
 8001536:	2240      	movs	r2, #64	; 0x40
 8001538:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800153a:	9b03      	ldr	r3, [sp, #12]
 800153c:	681a      	ldr	r2, [r3, #0]
 800153e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001542:	9901      	ldr	r1, [sp, #4]
 8001544:	3302      	adds	r3, #2
 8001546:	009b      	lsls	r3, r3, #2
 8001548:	440b      	add	r3, r1
 800154a:	685b      	ldr	r3, [r3, #4]
 800154c:	8a1b      	ldrh	r3, [r3, #16]
 800154e:	4413      	add	r3, r2
 8001550:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 8001552:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001556:	9901      	ldr	r1, [sp, #4]
 8001558:	3302      	adds	r3, #2
 800155a:	009b      	lsls	r3, r3, #2
 800155c:	440b      	add	r3, r1
 800155e:	685b      	ldr	r3, [r3, #4]
 8001560:	8a1b      	ldrh	r3, [r3, #16]
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8001562:	fbb2 f3f3 	udiv	r3, r2, r3
 8001566:	9302      	str	r3, [sp, #8]
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8001568:	9b01      	ldr	r3, [sp, #4]
 800156a:	6e99      	ldr	r1, [r3, #104]	; 0x68
 800156c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001570:	9a02      	ldr	r2, [sp, #8]
 8001572:	04d0      	lsls	r0, r2, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 8001574:	9a03      	ldr	r2, [sp, #12]
 8001576:	6812      	ldr	r2, [r2, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 8001578:	4302      	orrs	r2, r0
 800157a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800157e:	015b      	lsls	r3, r3, #5
 8001580:	440b      	add	r3, r1
 8001582:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 8001586:	601a      	str	r2, [r3, #0]
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8001588:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800158c:	9a01      	ldr	r2, [sp, #4]
 800158e:	3302      	adds	r3, #2
 8001590:	009b      	lsls	r3, r3, #2
 8001592:	4413      	add	r3, r2
 8001594:	685b      	ldr	r3, [r3, #4]
 8001596:	681b      	ldr	r3, [r3, #0]
 8001598:	f003 0303 	and.w	r3, r3, #3
 800159c:	2b01      	cmp	r3, #1
 800159e:	d12c      	bne.n	80015fa <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80015a0:	9b01      	ldr	r3, [sp, #4]
 80015a2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80015a4:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 80015a8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80015ac:	2b00      	cmp	r3, #0
 80015ae:	d012      	beq.n	80015d6 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 80015b0:	9b01      	ldr	r3, [sp, #4]
 80015b2:	6e99      	ldr	r1, [r3, #104]	; 0x68
 80015b4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80015b8:	9a01      	ldr	r2, [sp, #4]
 80015ba:	6e90      	ldr	r0, [r2, #104]	; 0x68
 80015bc:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80015c0:	3248      	adds	r2, #72	; 0x48
 80015c2:	0152      	lsls	r2, r2, #5
 80015c4:	4402      	add	r2, r0
 80015c6:	6812      	ldr	r2, [r2, #0]
 80015c8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80015cc:	3348      	adds	r3, #72	; 0x48
 80015ce:	015b      	lsls	r3, r3, #5
 80015d0:	440b      	add	r3, r1
 80015d2:	601a      	str	r2, [r3, #0]
 80015d4:	e011      	b.n	80015fa <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 80015d6:	9b01      	ldr	r3, [sp, #4]
 80015d8:	6e99      	ldr	r1, [r3, #104]	; 0x68
 80015da:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80015de:	9a01      	ldr	r2, [sp, #4]
 80015e0:	6e90      	ldr	r0, [r2, #104]	; 0x68
 80015e2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80015e6:	3248      	adds	r2, #72	; 0x48
 80015e8:	0152      	lsls	r2, r2, #5
 80015ea:	4402      	add	r2, r0
 80015ec:	6812      	ldr	r2, [r2, #0]
 80015ee:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80015f2:	3348      	adds	r3, #72	; 0x48
 80015f4:	015b      	lsls	r3, r3, #5
 80015f6:	440b      	add	r3, r1
 80015f8:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80015fa:	9b01      	ldr	r3, [sp, #4]
 80015fc:	6e99      	ldr	r1, [r3, #104]	; 0x68
 80015fe:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001602:	9a01      	ldr	r2, [sp, #4]
 8001604:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8001606:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800160a:	3248      	adds	r2, #72	; 0x48
 800160c:	0152      	lsls	r2, r2, #5
 800160e:	4402      	add	r2, r0
 8001610:	6812      	ldr	r2, [r2, #0]
 8001612:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8001616:	3348      	adds	r3, #72	; 0x48
 8001618:	015b      	lsls	r3, r3, #5
 800161a:	440b      	add	r3, r1
 800161c:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800161e:	9b01      	ldr	r3, [sp, #4]
 8001620:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8001622:	9a01      	ldr	r2, [sp, #4]
 8001624:	6e92      	ldr	r2, [r2, #104]	; 0x68
 8001626:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 800162a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800162e:	2001      	movs	r0, #1
 8001630:	fa00 f202 	lsl.w	r2, r0, r2
 8001634:	430a      	orrs	r2, r1
 8001636:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 800163a:	b004      	add	sp, #16
 800163c:	4770      	bx	lr
 800163e:	bf00      	nop

08001640 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8001640:	b082      	sub	sp, #8
 8001642:	9001      	str	r0, [sp, #4]
 8001644:	460b      	mov	r3, r1
 8001646:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800164a:	9b01      	ldr	r3, [sp, #4]
 800164c:	6e99      	ldr	r1, [r3, #104]	; 0x68
 800164e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001652:	9a01      	ldr	r2, [sp, #4]
 8001654:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8001656:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800165a:	3258      	adds	r2, #88	; 0x58
 800165c:	0152      	lsls	r2, r2, #5
 800165e:	4402      	add	r2, r0
 8001660:	6812      	ldr	r2, [r2, #0]
 8001662:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8001666:	3358      	adds	r3, #88	; 0x58
 8001668:	015b      	lsls	r3, r3, #5
 800166a:	440b      	add	r3, r1
 800166c:	601a      	str	r2, [r3, #0]
}
 800166e:	b002      	add	sp, #8
 8001670:	4770      	bx	lr
 8001672:	bf00      	nop
 8001674:	f3af 8000 	nop.w
 8001678:	f3af 8000 	nop.w
 800167c:	f3af 8000 	nop.w

08001680 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8001680:	b082      	sub	sp, #8
 8001682:	9001      	str	r0, [sp, #4]
 8001684:	460b      	mov	r3, r1
 8001686:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800168a:	9b01      	ldr	r3, [sp, #4]
 800168c:	6e99      	ldr	r1, [r3, #104]	; 0x68
 800168e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001692:	9a01      	ldr	r2, [sp, #4]
 8001694:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8001696:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800169a:	3248      	adds	r2, #72	; 0x48
 800169c:	0152      	lsls	r2, r2, #5
 800169e:	4402      	add	r2, r0
 80016a0:	6812      	ldr	r2, [r2, #0]
 80016a2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80016a6:	3348      	adds	r3, #72	; 0x48
 80016a8:	015b      	lsls	r3, r3, #5
 80016aa:	440b      	add	r3, r1
 80016ac:	601a      	str	r2, [r3, #0]
}
 80016ae:	b002      	add	sp, #8
 80016b0:	4770      	bx	lr
 80016b2:	bf00      	nop
 80016b4:	f3af 8000 	nop.w
 80016b8:	f3af 8000 	nop.w
 80016bc:	f3af 8000 	nop.w

080016c0 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 80016c0:	b082      	sub	sp, #8
 80016c2:	9001      	str	r0, [sp, #4]
 80016c4:	460b      	mov	r3, r1
 80016c6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 80016ca:	9b01      	ldr	r3, [sp, #4]
 80016cc:	6e99      	ldr	r1, [r3, #104]	; 0x68
 80016ce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80016d2:	9a01      	ldr	r2, [sp, #4]
 80016d4:	6e90      	ldr	r0, [r2, #104]	; 0x68
 80016d6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80016da:	3258      	adds	r2, #88	; 0x58
 80016dc:	0152      	lsls	r2, r2, #5
 80016de:	4402      	add	r2, r0
 80016e0:	6812      	ldr	r2, [r2, #0]
 80016e2:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80016e6:	3358      	adds	r3, #88	; 0x58
 80016e8:	015b      	lsls	r3, r3, #5
 80016ea:	440b      	add	r3, r1
 80016ec:	601a      	str	r2, [r3, #0]
}
 80016ee:	b002      	add	sp, #8
 80016f0:	4770      	bx	lr
 80016f2:	bf00      	nop
 80016f4:	f3af 8000 	nop.w
 80016f8:	f3af 8000 	nop.w
 80016fc:	f3af 8000 	nop.w

08001700 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8001700:	b082      	sub	sp, #8
 8001702:	9001      	str	r0, [sp, #4]
 8001704:	460b      	mov	r3, r1
 8001706:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 800170a:	9b01      	ldr	r3, [sp, #4]
 800170c:	6e99      	ldr	r1, [r3, #104]	; 0x68
 800170e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001712:	9a01      	ldr	r2, [sp, #4]
 8001714:	6e90      	ldr	r0, [r2, #104]	; 0x68
 8001716:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800171a:	3248      	adds	r2, #72	; 0x48
 800171c:	0152      	lsls	r2, r2, #5
 800171e:	4402      	add	r2, r0
 8001720:	6812      	ldr	r2, [r2, #0]
 8001722:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8001726:	3348      	adds	r3, #72	; 0x48
 8001728:	015b      	lsls	r3, r3, #5
 800172a:	440b      	add	r3, r1
 800172c:	601a      	str	r2, [r3, #0]
}
 800172e:	b002      	add	sp, #8
 8001730:	4770      	bx	lr
 8001732:	bf00      	nop
 8001734:	f3af 8000 	nop.w
 8001738:	f3af 8000 	nop.w
 800173c:	f3af 8000 	nop.w

08001740 <usb_lld_pump.4242>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8001740:	b500      	push	{lr}
 8001742:	b089      	sub	sp, #36	; 0x24
 8001744:	9001      	str	r0, [sp, #4]
  USBDriver *usbp = (USBDriver *)p;
 8001746:	9b01      	ldr	r3, [sp, #4]
 8001748:	9306      	str	r3, [sp, #24]
  stm32_otg_t *otgp = usbp->otg;
 800174a:	9b06      	ldr	r3, [sp, #24]
 800174c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800174e:	9305      	str	r3, [sp, #20]

#if defined(_CHIBIOS_RT_)
  chRegSetThreadName("usb_lld_pump");
 8001750:	f247 2020 	movw	r0, #29216	; 0x7220
 8001754:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001758:	f000 fcda 	bl	8002110 <chRegSetThreadName.10554>
#endif
  osalSysLock();
 800175c:	f000 fce8 	bl	8002130 <osalSysLock.10670>
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 8001760:	9b06      	ldr	r3, [sp, #24]
 8001762:	781b      	ldrb	r3, [r3, #0]
 8001764:	2b01      	cmp	r3, #1
 8001766:	d009      	beq.n	800177c <usb_lld_pump.4242+0x3c>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 8001768:	9b06      	ldr	r3, [sp, #24]
 800176a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 800176c:	2b00      	cmp	r3, #0
 800176e:	d110      	bne.n	8001792 <usb_lld_pump.4242+0x52>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 8001770:	9b05      	ldr	r3, [sp, #20]
 8001772:	695b      	ldr	r3, [r3, #20]
 8001774:	f003 0310 	and.w	r3, r3, #16
 8001778:	2b00      	cmp	r3, #0
 800177a:	d10a      	bne.n	8001792 <usb_lld_pump.4242+0x52>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 800177c:	9b05      	ldr	r3, [sp, #20]
 800177e:	699b      	ldr	r3, [r3, #24]
 8001780:	f043 0210 	orr.w	r2, r3, #16
 8001784:	9b05      	ldr	r3, [sp, #20]
 8001786:	619a      	str	r2, [r3, #24]
      osalThreadSuspendS(&usbp->wait);
 8001788:	9b06      	ldr	r3, [sp, #24]
 800178a:	3378      	adds	r3, #120	; 0x78
 800178c:	4618      	mov	r0, r3
 800178e:	f000 fcff 	bl	8002190 <osalThreadSuspendS.10661>
    }
    osalSysUnlock();
 8001792:	f000 fcd5 	bl	8002140 <osalSysUnlock.10666>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8001796:	2300      	movs	r3, #0
 8001798:	f88d 301f 	strb.w	r3, [sp, #31]
 800179c:	e04c      	b.n	8001838 <usb_lld_pump.4242+0xf8>

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
 800179e:	9806      	ldr	r0, [sp, #24]
 80017a0:	f000 fe2e 	bl	8002400 <otg_rxfifo_handler.10871>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80017a4:	9b05      	ldr	r3, [sp, #20]
 80017a6:	695b      	ldr	r3, [r3, #20]
 80017a8:	f003 0310 	and.w	r3, r3, #16
 80017ac:	2b00      	cmp	r3, #0
 80017ae:	d1f6      	bne.n	800179e <usb_lld_pump.4242+0x5e>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 80017b0:	f89d 301f 	ldrb.w	r3, [sp, #31]
 80017b4:	2201      	movs	r2, #1
 80017b6:	fa02 f303 	lsl.w	r3, r2, r3
 80017ba:	9304      	str	r3, [sp, #16]
      if (usbp->txpending & epmask) {
 80017bc:	9b06      	ldr	r3, [sp, #24]
 80017be:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80017c0:	9b04      	ldr	r3, [sp, #16]
 80017c2:	4013      	ands	r3, r2
 80017c4:	2b00      	cmp	r3, #0
 80017c6:	d032      	beq.n	800182e <usb_lld_pump.4242+0xee>
        bool done;

        osalSysLock();
 80017c8:	f000 fcb2 	bl	8002130 <osalSysLock.10670>
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 80017cc:	9b05      	ldr	r3, [sp, #20]
 80017ce:	689b      	ldr	r3, [r3, #8]
 80017d0:	f023 0201 	bic.w	r2, r3, #1
 80017d4:	9b05      	ldr	r3, [sp, #20]
 80017d6:	609a      	str	r2, [r3, #8]
        usbp->txpending &= ~epmask;
 80017d8:	9b06      	ldr	r3, [sp, #24]
 80017da:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80017dc:	9b04      	ldr	r3, [sp, #16]
 80017de:	43db      	mvns	r3, r3
 80017e0:	401a      	ands	r2, r3
 80017e2:	9b06      	ldr	r3, [sp, #24]
 80017e4:	675a      	str	r2, [r3, #116]	; 0x74
        osalSysUnlock();
 80017e6:	f000 fcab 	bl	8002140 <osalSysUnlock.10666>

        done = otg_txfifo_handler(usbp, ep);
 80017ea:	f89d 301f 	ldrb.w	r3, [sp, #31]
 80017ee:	9806      	ldr	r0, [sp, #24]
 80017f0:	4619      	mov	r1, r3
 80017f2:	f000 fe8d 	bl	8002510 <otg_txfifo_handler.10874>
 80017f6:	4603      	mov	r3, r0
 80017f8:	f88d 300f 	strb.w	r3, [sp, #15]

        osalSysLock();
 80017fc:	f000 fc98 	bl	8002130 <osalSysLock.10670>
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8001800:	9b05      	ldr	r3, [sp, #20]
 8001802:	689b      	ldr	r3, [r3, #8]
 8001804:	f043 0201 	orr.w	r2, r3, #1
 8001808:	9b05      	ldr	r3, [sp, #20]
 800180a:	609a      	str	r2, [r3, #8]
        if (!done)
 800180c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8001810:	f083 0301 	eor.w	r3, r3, #1
 8001814:	b2db      	uxtb	r3, r3
 8001816:	2b00      	cmp	r3, #0
 8001818:	d007      	beq.n	800182a <usb_lld_pump.4242+0xea>
          otgp->DIEPEMPMSK |= epmask;
 800181a:	9b05      	ldr	r3, [sp, #20]
 800181c:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8001820:	9b04      	ldr	r3, [sp, #16]
 8001822:	431a      	orrs	r2, r3
 8001824:	9b05      	ldr	r3, [sp, #20]
 8001826:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
        osalSysUnlock();
 800182a:	f000 fc89 	bl	8002140 <osalSysUnlock.10666>
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800182e:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8001832:	3301      	adds	r3, #1
 8001834:	f88d 301f 	strb.w	r3, [sp, #31]
 8001838:	f89d 201f 	ldrb.w	r2, [sp, #31]
 800183c:	9b06      	ldr	r3, [sp, #24]
 800183e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001840:	689b      	ldr	r3, [r3, #8]
 8001842:	429a      	cmp	r2, r3
 8001844:	d9ae      	bls.n	80017a4 <usb_lld_pump.4242+0x64>
        if (!done)
          otgp->DIEPEMPMSK |= epmask;
        osalSysUnlock();
      }
    }
    osalSysLock();
 8001846:	f000 fc73 	bl	8002130 <osalSysLock.10670>
 800184a:	e789      	b.n	8001760 <usb_lld_pump.4242+0x20>
 800184c:	f3af 8000 	nop.w

08001850 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8001850:	b508      	push	{r3, lr}

  stm32_clock_init();
 8001852:	f000 f9b5 	bl	8001bc0 <stm32_clock_init>
}
 8001856:	bd08      	pop	{r3, pc}
 8001858:	f3af 8000 	nop.w
 800185c:	f3af 8000 	nop.w

08001860 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8001860:	4770      	bx	lr
 8001862:	bf00      	nop
 8001864:	f3af 8000 	nop.w
 8001868:	f3af 8000 	nop.w
 800186c:	f3af 8000 	nop.w

08001870 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8001870:	b500      	push	{lr}
 8001872:	b085      	sub	sp, #20
 8001874:	9001      	str	r0, [sp, #4]
 8001876:	460b      	mov	r3, r1
 8001878:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800187c:	9b01      	ldr	r3, [sp, #4]
 800187e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8001882:	2b06      	cmp	r3, #6
 8001884:	d871      	bhi.n	800196a <_usb_ep0in+0xfa>
 8001886:	a201      	add	r2, pc, #4	; (adr r2, 800188c <_usb_ep0in+0x1c>)
 8001888:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800188c:	0800192f 	.word	0x0800192f
 8001890:	080018a9 	.word	0x080018a9
 8001894:	080018f7 	.word	0x080018f7
 8001898:	0800192f 	.word	0x0800192f
 800189c:	0800192f 	.word	0x0800192f
 80018a0:	08001915 	.word	0x08001915
 80018a4:	0800193b 	.word	0x0800193b
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 80018a8:	9b01      	ldr	r3, [sp, #4]
 80018aa:	3362      	adds	r3, #98	; 0x62
 80018ac:	4618      	mov	r0, r3
 80018ae:	f001 fee7 	bl	8003680 <get_hword.9773>
 80018b2:	4603      	mov	r3, r0
 80018b4:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80018b6:	9b01      	ldr	r3, [sp, #4]
 80018b8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80018ba:	9b03      	ldr	r3, [sp, #12]
 80018bc:	429a      	cmp	r2, r3
 80018be:	d21a      	bcs.n	80018f6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 80018c0:	9b01      	ldr	r3, [sp, #4]
 80018c2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80018c4:	9a01      	ldr	r2, [sp, #4]
 80018c6:	68d2      	ldr	r2, [r2, #12]
 80018c8:	8a12      	ldrh	r2, [r2, #16]
 80018ca:	fbb3 f1f2 	udiv	r1, r3, r2
 80018ce:	fb02 f201 	mul.w	r2, r2, r1
 80018d2:	1a9b      	subs	r3, r3, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80018d4:	2b00      	cmp	r3, #0
 80018d6:	d10e      	bne.n	80018f6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
 80018d8:	f001 fec2 	bl	8003660 <osalSysLockFromISR.9767>
      usbStartTransmitI(usbp, 0, NULL, 0);
 80018dc:	9801      	ldr	r0, [sp, #4]
 80018de:	2100      	movs	r1, #0
 80018e0:	2200      	movs	r2, #0
 80018e2:	2300      	movs	r3, #0
 80018e4:	f002 f9f4 	bl	8003cd0 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80018e8:	f001 fec2 	bl	8003670 <osalSysUnlockFromISR.9771>
      usbp->ep0state = USB_EP0_WAITING_TX0;
 80018ec:	9b01      	ldr	r3, [sp, #4]
 80018ee:	2202      	movs	r2, #2
 80018f0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 80018f4:	e03f      	b.n	8001976 <_usb_ep0in+0x106>
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 80018f6:	9b01      	ldr	r3, [sp, #4]
 80018f8:	2203      	movs	r2, #3
 80018fa:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 80018fe:	f001 feaf 	bl	8003660 <osalSysLockFromISR.9767>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8001902:	9801      	ldr	r0, [sp, #4]
 8001904:	2100      	movs	r1, #0
 8001906:	2200      	movs	r2, #0
 8001908:	2300      	movs	r3, #0
 800190a:	f002 f991 	bl	8003c30 <usbStartReceiveI>
    osalSysUnlockFromISR();
 800190e:	f001 feaf 	bl	8003670 <osalSysUnlockFromISR.9771>
 8001912:	e030      	b.n	8001976 <_usb_ep0in+0x106>
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8001914:	9b01      	ldr	r3, [sp, #4]
 8001916:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001918:	2b00      	cmp	r3, #0
 800191a:	d003      	beq.n	8001924 <_usb_ep0in+0xb4>
      usbp->ep0endcb(usbp);
 800191c:	9b01      	ldr	r3, [sp, #4]
 800191e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001920:	9801      	ldr	r0, [sp, #4]
 8001922:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8001924:	9b01      	ldr	r3, [sp, #4]
 8001926:	2200      	movs	r2, #0
 8001928:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 800192c:	e023      	b.n	8001976 <_usb_ep0in+0x106>
    return;
  case USB_EP0_WAITING_SETUP:
  case USB_EP0_WAITING_STS:
  case USB_EP0_RX:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 800192e:	f647 00a0 	movw	r0, #30880	; 0x78a0
 8001932:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001936:	f003 fd7b 	bl	8005430 <chSysHalt>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800193a:	9801      	ldr	r0, [sp, #4]
 800193c:	2100      	movs	r1, #0
 800193e:	f7ff fe9f 	bl	8001680 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8001942:	9801      	ldr	r0, [sp, #4]
 8001944:	2100      	movs	r1, #0
 8001946:	f7ff fe7b 	bl	8001640 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800194a:	9b01      	ldr	r3, [sp, #4]
 800194c:	685b      	ldr	r3, [r3, #4]
 800194e:	681b      	ldr	r3, [r3, #0]
 8001950:	2b00      	cmp	r3, #0
 8001952:	d005      	beq.n	8001960 <_usb_ep0in+0xf0>
 8001954:	9b01      	ldr	r3, [sp, #4]
 8001956:	685b      	ldr	r3, [r3, #4]
 8001958:	681b      	ldr	r3, [r3, #0]
 800195a:	9801      	ldr	r0, [sp, #4]
 800195c:	2105      	movs	r1, #5
 800195e:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8001960:	9b01      	ldr	r3, [sp, #4]
 8001962:	2206      	movs	r2, #6
 8001964:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8001968:	e005      	b.n	8001976 <_usb_ep0in+0x106>
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 800196a:	f647 00a0 	movw	r0, #30880	; 0x78a0
 800196e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001972:	f003 fd5d 	bl	8005430 <chSysHalt>
  }
}
 8001976:	b005      	add	sp, #20
 8001978:	f85d fb04 	ldr.w	pc, [sp], #4
 800197c:	f3af 8000 	nop.w

08001980 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8001980:	b500      	push	{lr}
 8001982:	b083      	sub	sp, #12
 8001984:	9001      	str	r0, [sp, #4]
 8001986:	460b      	mov	r3, r1
 8001988:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 800198c:	9b01      	ldr	r3, [sp, #4]
 800198e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8001992:	2b06      	cmp	r3, #6
 8001994:	d850      	bhi.n	8001a38 <_usb_ep0out+0xb8>
 8001996:	a201      	add	r2, pc, #4	; (adr r2, 800199c <_usb_ep0out+0x1c>)
 8001998:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800199c:	080019fd 	.word	0x080019fd
 80019a0:	080019fd 	.word	0x080019fd
 80019a4:	080019fd 	.word	0x080019fd
 80019a8:	080019d7 	.word	0x080019d7
 80019ac:	080019b9 	.word	0x080019b9
 80019b0:	080019fd 	.word	0x080019fd
 80019b4:	08001a09 	.word	0x08001a09
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 80019b8:	9b01      	ldr	r3, [sp, #4]
 80019ba:	2205      	movs	r2, #5
 80019bc:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 80019c0:	f001 fe4e 	bl	8003660 <osalSysLockFromISR.9767>
    usbStartTransmitI(usbp, 0, NULL, 0);
 80019c4:	9801      	ldr	r0, [sp, #4]
 80019c6:	2100      	movs	r1, #0
 80019c8:	2200      	movs	r2, #0
 80019ca:	2300      	movs	r3, #0
 80019cc:	f002 f980 	bl	8003cd0 <usbStartTransmitI>
    osalSysUnlockFromISR();
 80019d0:	f001 fe4e 	bl	8003670 <osalSysUnlockFromISR.9771>
 80019d4:	e036      	b.n	8001a44 <_usb_ep0out+0xc4>
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80019d6:	9b01      	ldr	r3, [sp, #4]
 80019d8:	68db      	ldr	r3, [r3, #12]
 80019da:	699b      	ldr	r3, [r3, #24]
 80019dc:	685b      	ldr	r3, [r3, #4]
 80019de:	2b00      	cmp	r3, #0
 80019e0:	d130      	bne.n	8001a44 <_usb_ep0out+0xc4>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 80019e2:	9b01      	ldr	r3, [sp, #4]
 80019e4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80019e6:	2b00      	cmp	r3, #0
 80019e8:	d003      	beq.n	80019f2 <_usb_ep0out+0x72>
      usbp->ep0endcb(usbp);
 80019ea:	9b01      	ldr	r3, [sp, #4]
 80019ec:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80019ee:	9801      	ldr	r0, [sp, #4]
 80019f0:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 80019f2:	9b01      	ldr	r3, [sp, #4]
 80019f4:	2200      	movs	r2, #0
 80019f6:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 80019fa:	e023      	b.n	8001a44 <_usb_ep0out+0xc4>
  case USB_EP0_WAITING_SETUP:
  case USB_EP0_TX:
  case USB_EP0_WAITING_TX0:
  case USB_EP0_SENDING_STS:
    /* All the above are invalid states in the IN phase.*/
    osalDbgAssert(false, "EP0 state machine error");
 80019fc:	f647 00b0 	movw	r0, #30896	; 0x78b0
 8001a00:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001a04:	f003 fd14 	bl	8005430 <chSysHalt>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 8001a08:	9801      	ldr	r0, [sp, #4]
 8001a0a:	2100      	movs	r1, #0
 8001a0c:	f7ff fe38 	bl	8001680 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8001a10:	9801      	ldr	r0, [sp, #4]
 8001a12:	2100      	movs	r1, #0
 8001a14:	f7ff fe14 	bl	8001640 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8001a18:	9b01      	ldr	r3, [sp, #4]
 8001a1a:	685b      	ldr	r3, [r3, #4]
 8001a1c:	681b      	ldr	r3, [r3, #0]
 8001a1e:	2b00      	cmp	r3, #0
 8001a20:	d005      	beq.n	8001a2e <_usb_ep0out+0xae>
 8001a22:	9b01      	ldr	r3, [sp, #4]
 8001a24:	685b      	ldr	r3, [r3, #4]
 8001a26:	681b      	ldr	r3, [r3, #0]
 8001a28:	9801      	ldr	r0, [sp, #4]
 8001a2a:	2105      	movs	r1, #5
 8001a2c:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8001a2e:	9b01      	ldr	r3, [sp, #4]
 8001a30:	2206      	movs	r2, #6
 8001a32:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8001a36:	e005      	b.n	8001a44 <_usb_ep0out+0xc4>
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 8001a38:	f647 00b0 	movw	r0, #30896	; 0x78b0
 8001a3c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001a40:	f003 fcf6 	bl	8005430 <chSysHalt>
  }
}
 8001a44:	b003      	add	sp, #12
 8001a46:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a4a:	bf00      	nop
 8001a4c:	f3af 8000 	nop.w

08001a50 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8001a50:	b082      	sub	sp, #8
 8001a52:	9001      	str	r0, [sp, #4]
 8001a54:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001a56:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8001a5a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001a5e:	9a00      	ldr	r2, [sp, #0]
 8001a60:	b2d2      	uxtb	r2, r2
 8001a62:	0112      	lsls	r2, r2, #4
 8001a64:	b2d2      	uxtb	r2, r2
 8001a66:	9901      	ldr	r1, [sp, #4]
 8001a68:	440b      	add	r3, r1
 8001a6a:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8001a6e:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001a70:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8001a74:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001a78:	9a01      	ldr	r2, [sp, #4]
 8001a7a:	0952      	lsrs	r2, r2, #5
 8001a7c:	9901      	ldr	r1, [sp, #4]
 8001a7e:	f001 011f 	and.w	r1, r1, #31
 8001a82:	2001      	movs	r0, #1
 8001a84:	fa00 f101 	lsl.w	r1, r0, r1
 8001a88:	3260      	adds	r2, #96	; 0x60
 8001a8a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001a8e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8001a92:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8001a96:	9a01      	ldr	r2, [sp, #4]
 8001a98:	0952      	lsrs	r2, r2, #5
 8001a9a:	9901      	ldr	r1, [sp, #4]
 8001a9c:	f001 011f 	and.w	r1, r1, #31
 8001aa0:	2001      	movs	r0, #1
 8001aa2:	fa00 f101 	lsl.w	r1, r0, r1
 8001aa6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8001aaa:	b002      	add	sp, #8
 8001aac:	4770      	bx	lr
 8001aae:	bf00      	nop

08001ab0 <hal_lld_backup_domain_init.10299.4453>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001ab0:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8001ab4:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001ab8:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8001abc:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8001ac0:	6812      	ldr	r2, [r2, #0]
 8001ac2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001ac6:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8001ac8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001acc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001ad0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001ad2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8001ad6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8001ada:	d00c      	beq.n	8001af6 <hal_lld_backup_domain_init.10299.4453+0x46>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001adc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001ae0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001ae4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001ae8:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8001aea:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001aee:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001af2:	2200      	movs	r2, #0
 8001af4:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8001af6:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8001afa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001afe:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 8001b02:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8001b06:	6852      	ldr	r2, [r2, #4]
 8001b08:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001b0c:	605a      	str	r2, [r3, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8001b0e:	4770      	bx	lr

08001b10 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8001b10:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8001b12:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b16:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b1a:	691b      	ldr	r3, [r3, #16]
 8001b1c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b20:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b24:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001b28:	611a      	str	r2, [r3, #16]
 8001b2a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b2e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b32:	2200      	movs	r2, #0
 8001b34:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8001b36:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b3a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b3e:	695b      	ldr	r3, [r3, #20]
 8001b40:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b44:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b48:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001b4c:	615a      	str	r2, [r3, #20]
 8001b4e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b52:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b56:	2200      	movs	r2, #0
 8001b58:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8001b5a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b5e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b62:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001b66:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001b6a:	6a12      	ldr	r2, [r2, #32]
 8001b6c:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 8001b70:	621a      	str	r2, [r3, #32]
 8001b72:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b76:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b7a:	2200      	movs	r2, #0
 8001b7c:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8001b7e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b82:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b86:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001b88:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b8c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b90:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001b94:	625a      	str	r2, [r3, #36]	; 0x24
 8001b96:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001b9a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b9e:	2200      	movs	r2, #0
 8001ba0:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001ba2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001ba6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001baa:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001bae:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001bb2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8001bb4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001bb8:	641a      	str	r2, [r3, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8001bba:	f7ff ff79 	bl	8001ab0 <hal_lld_backup_domain_init.10299.4453>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8001bbe:	bd08      	pop	{r3, pc}

08001bc0 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001bc0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001bc4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001bc8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001bcc:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001bce:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8001bd2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001bd6:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8001bda:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001bdc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001be0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001be4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001be8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001bec:	6812      	ldr	r2, [r2, #0]
 8001bee:	f042 0201 	orr.w	r2, r2, #1
 8001bf2:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001bf4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001bf8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001bfc:	681b      	ldr	r3, [r3, #0]
 8001bfe:	f003 0302 	and.w	r3, r3, #2
 8001c02:	2b00      	cmp	r3, #0
 8001c04:	d0f6      	beq.n	8001bf4 <stm32_clock_init+0x34>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001c06:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001c0a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c0e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001c12:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001c16:	6892      	ldr	r2, [r2, #8]
 8001c18:	f022 0203 	bic.w	r2, r2, #3
 8001c1c:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001c1e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001c22:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c26:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001c2a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001c2e:	6892      	ldr	r2, [r2, #8]
 8001c30:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001c32:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001c36:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c3a:	689b      	ldr	r3, [r3, #8]
 8001c3c:	f003 030c 	and.w	r3, r3, #12
 8001c40:	2b00      	cmp	r3, #0
 8001c42:	d1f6      	bne.n	8001c32 <stm32_clock_init+0x72>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001c44:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001c48:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c4c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001c50:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001c54:	6812      	ldr	r2, [r2, #0]
 8001c56:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 8001c5a:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001c5c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001c60:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c64:	2200      	movs	r2, #0
 8001c66:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8001c68:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001c6c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c70:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001c74:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001c78:	6812      	ldr	r2, [r2, #0]
 8001c7a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001c7e:	601a      	str	r2, [r3, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8001c80:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001c84:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c88:	681b      	ldr	r3, [r3, #0]
 8001c8a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001c8e:	2b00      	cmp	r3, #0
 8001c90:	d0f6      	beq.n	8001c80 <stm32_clock_init+0xc0>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001c92:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001c96:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001c9a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001c9e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001ca2:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8001ca4:	f042 0201 	orr.w	r2, r2, #1
 8001ca8:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001caa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001cae:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001cb2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001cb4:	f003 0302 	and.w	r3, r3, #2
 8001cb8:	2b00      	cmp	r3, #0
 8001cba:	d0f6      	beq.n	8001caa <stm32_clock_init+0xea>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8001cbc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001cc0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001cc4:	f245 4208 	movw	r2, #21512	; 0x5408
 8001cc8:	f2c0 7240 	movt	r2, #1856	; 0x740
 8001ccc:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001cce:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001cd2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001cd6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001cda:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001cde:	6812      	ldr	r2, [r2, #0]
 8001ce0:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001ce4:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001ce6:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 8001cea:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001cee:	685b      	ldr	r3, [r3, #4]
 8001cf0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001cf4:	2b00      	cmp	r3, #0
 8001cf6:	d0f6      	beq.n	8001ce6 <stm32_clock_init+0x126>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001cf8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001cfc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d00:	681b      	ldr	r3, [r3, #0]
 8001d02:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8001d06:	2b00      	cmp	r3, #0
 8001d08:	d0f6      	beq.n	8001cf8 <stm32_clock_init+0x138>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8001d0a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001d0e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d12:	f44f 4214 	mov.w	r2, #37888	; 0x9400
 8001d16:	f6c3 0288 	movt	r2, #14472	; 0x3888
 8001d1a:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8001d1c:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8001d20:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d24:	f240 7205 	movw	r2, #1797	; 0x705
 8001d28:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8001d2a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001d2e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d32:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001d36:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001d3a:	6892      	ldr	r2, [r2, #8]
 8001d3c:	f042 0202 	orr.w	r2, r2, #2
 8001d40:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001d42:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001d46:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d4a:	689b      	ldr	r3, [r3, #8]
 8001d4c:	f003 030c 	and.w	r3, r3, #12
 8001d50:	2b08      	cmp	r3, #8
 8001d52:	d1f6      	bne.n	8001d42 <stm32_clock_init+0x182>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8001d54:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001d58:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d5c:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001d60:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001d64:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8001d66:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001d6a:	645a      	str	r2, [r3, #68]	; 0x44
 8001d6c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001d70:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001d74:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001d78:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001d7c:	6e52      	ldr	r2, [r2, #100]	; 0x64
 8001d7e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001d82:	665a      	str	r2, [r3, #100]	; 0x64
}
 8001d84:	4770      	bx	lr
 8001d86:	bf00      	nop
 8001d88:	f3af 8000 	nop.w
 8001d8c:	f3af 8000 	nop.w

08001d90 <port_lock.10354.4446>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001d90:	b082      	sub	sp, #8
 8001d92:	2320      	movs	r3, #32
 8001d94:	9301      	str	r3, [sp, #4]
 8001d96:	9b01      	ldr	r3, [sp, #4]
 8001d98:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001d9c:	b002      	add	sp, #8
 8001d9e:	4770      	bx	lr

08001da0 <port_unlock.10357.4444>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001da0:	b082      	sub	sp, #8
 8001da2:	2300      	movs	r3, #0
 8001da4:	9301      	str	r3, [sp, #4]
 8001da6:	9b01      	ldr	r3, [sp, #4]
 8001da8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001dac:	b002      	add	sp, #8
 8001dae:	4770      	bx	lr

08001db0 <port_lock_from_isr.10359.4442>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001db0:	b508      	push	{r3, lr}

  port_lock();
 8001db2:	f7ff ffed 	bl	8001d90 <port_lock.10354.4446>
}
 8001db6:	bd08      	pop	{r3, pc}
 8001db8:	f3af 8000 	nop.w
 8001dbc:	f3af 8000 	nop.w

08001dc0 <port_unlock_from_isr.10361.4440>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001dc0:	b508      	push	{r3, lr}

  port_unlock();
 8001dc2:	f7ff ffed 	bl	8001da0 <port_unlock.10357.4444>
}
 8001dc6:	bd08      	pop	{r3, pc}
 8001dc8:	f3af 8000 	nop.w
 8001dcc:	f3af 8000 	nop.w

08001dd0 <chSysLockFromISR.10363.4438>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001dd0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001dd2:	f7ff ffed 	bl	8001db0 <port_lock_from_isr.10359.4442>
  _stats_start_measure_crit_isr();
 8001dd6:	f004 fdc3 	bl	8006960 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8001dda:	f003 fc01 	bl	80055e0 <_dbg_check_lock_from_isr>
}
 8001dde:	bd08      	pop	{r3, pc}

08001de0 <chSysUnlockFromISR.10369.4436>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001de0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8001de2:	f003 fc1d 	bl	8005620 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8001de6:	f004 fdc3 	bl	8006970 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8001dea:	f7ff ffe9 	bl	8001dc0 <port_unlock_from_isr.10361.4440>
}
 8001dee:	bd08      	pop	{r3, pc}

08001df0 <osalSysLockFromISR.10365.4434>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8001df0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8001df2:	f7ff ffed 	bl	8001dd0 <chSysLockFromISR.10363.4438>
}
 8001df6:	bd08      	pop	{r3, pc}
 8001df8:	f3af 8000 	nop.w
 8001dfc:	f3af 8000 	nop.w

08001e00 <osalSysUnlockFromISR.10371.4432>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8001e00:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8001e02:	f7ff ffed 	bl	8001de0 <chSysUnlockFromISR.10369.4436>
}
 8001e06:	bd08      	pop	{r3, pc}
 8001e08:	f3af 8000 	nop.w
 8001e0c:	f3af 8000 	nop.w

08001e10 <osalOsTimerHandlerI.10367.4430>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8001e10:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8001e12:	f003 fb1d 	bl	8005450 <chSysTimerHandlerI>
}
 8001e16:	bd08      	pop	{r3, pc}
 8001e18:	f3af 8000 	nop.w
 8001e1c:	f3af 8000 	nop.w

08001e20 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001e20:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001e22:	f004 fd55 	bl	80068d0 <_stats_increase_irq>
 8001e26:	f003 fc1b 	bl	8005660 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001e2a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001e2e:	691b      	ldr	r3, [r3, #16]
 8001e30:	f003 0302 	and.w	r3, r3, #2
 8001e34:	2b00      	cmp	r3, #0
 8001e36:	d009      	beq.n	8001e4c <VectorB0+0x2c>
    STM32_ST_TIM->SR = 0U;
 8001e38:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001e3c:	2200      	movs	r2, #0
 8001e3e:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 8001e40:	f7ff ffd6 	bl	8001df0 <osalSysLockFromISR.10365.4434>
    osalOsTimerHandlerI();
 8001e44:	f7ff ffe4 	bl	8001e10 <osalOsTimerHandlerI.10367.4430>
    osalSysUnlockFromISR();
 8001e48:	f7ff ffda 	bl	8001e00 <osalSysUnlockFromISR.10371.4432>
  }

  OSAL_IRQ_EPILOGUE();
 8001e4c:	f003 fc30 	bl	80056b0 <_dbg_check_leave_isr>
 8001e50:	f002 f99e 	bl	8004190 <_port_irq_epilogue>
}
 8001e54:	bd08      	pop	{r3, pc}
 8001e56:	bf00      	nop
 8001e58:	f3af 8000 	nop.w
 8001e5c:	f3af 8000 	nop.w

08001e60 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8001e60:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001e62:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001e66:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001e6a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001e6e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001e72:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8001e74:	f042 0201 	orr.w	r2, r2, #1
 8001e78:	641a      	str	r2, [r3, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001e7a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001e7e:	f2ce 0304 	movt	r3, #57348	; 0xe004
 8001e82:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001e86:	f2ce 0204 	movt	r2, #57348	; 0xe004
 8001e8a:	6892      	ldr	r2, [r2, #8]
 8001e8c:	f042 0201 	orr.w	r2, r2, #1
 8001e90:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001e92:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001e96:	f242 02cf 	movw	r2, #8399	; 0x20cf
 8001e9a:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001e9c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001ea0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001ea4:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8001ea6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001eaa:	2200      	movs	r2, #0
 8001eac:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001eae:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001eb2:	2200      	movs	r2, #0
 8001eb4:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8001eb6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001eba:	2200      	movs	r2, #0
 8001ebc:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001ebe:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001ec2:	2200      	movs	r2, #0
 8001ec4:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001ec6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001eca:	2201      	movs	r2, #1
 8001ecc:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001ece:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001ed2:	2201      	movs	r2, #1
 8001ed4:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001ed6:	201c      	movs	r0, #28
 8001ed8:	2108      	movs	r1, #8
 8001eda:	f7ff fdb9 	bl	8001a50 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8001ede:	bd08      	pop	{r3, pc}

08001ee0 <initgpio.10453.4420>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8001ee0:	b082      	sub	sp, #8
 8001ee2:	9001      	str	r0, [sp, #4]
 8001ee4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8001ee6:	9b00      	ldr	r3, [sp, #0]
 8001ee8:	685a      	ldr	r2, [r3, #4]
 8001eea:	9b01      	ldr	r3, [sp, #4]
 8001eec:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001eee:	9b00      	ldr	r3, [sp, #0]
 8001ef0:	689a      	ldr	r2, [r3, #8]
 8001ef2:	9b01      	ldr	r3, [sp, #4]
 8001ef4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8001ef6:	9b00      	ldr	r3, [sp, #0]
 8001ef8:	68da      	ldr	r2, [r3, #12]
 8001efa:	9b01      	ldr	r3, [sp, #4]
 8001efc:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8001efe:	9b00      	ldr	r3, [sp, #0]
 8001f00:	691a      	ldr	r2, [r3, #16]
 8001f02:	9b01      	ldr	r3, [sp, #4]
 8001f04:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8001f06:	9b00      	ldr	r3, [sp, #0]
 8001f08:	695a      	ldr	r2, [r3, #20]
 8001f0a:	9b01      	ldr	r3, [sp, #4]
 8001f0c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8001f0e:	9b00      	ldr	r3, [sp, #0]
 8001f10:	699a      	ldr	r2, [r3, #24]
 8001f12:	9b01      	ldr	r3, [sp, #4]
 8001f14:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001f16:	9b00      	ldr	r3, [sp, #0]
 8001f18:	681a      	ldr	r2, [r3, #0]
 8001f1a:	9b01      	ldr	r3, [sp, #4]
 8001f1c:	601a      	str	r2, [r3, #0]
}
 8001f1e:	b002      	add	sp, #8
 8001f20:	4770      	bx	lr
 8001f22:	bf00      	nop
 8001f24:	f3af 8000 	nop.w
 8001f28:	f3af 8000 	nop.w
 8001f2c:	f3af 8000 	nop.w

08001f30 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8001f30:	b500      	push	{lr}
 8001f32:	b083      	sub	sp, #12
 8001f34:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8001f36:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001f3a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f3e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001f42:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001f46:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8001f48:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 8001f4c:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 8001f50:	631a      	str	r2, [r3, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8001f52:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001f56:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001f5a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001f5e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001f62:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8001f64:	ea6f 2252 	mvn.w	r2, r2, lsr #9
 8001f68:	ea6f 2242 	mvn.w	r2, r2, lsl #9
 8001f6c:	651a      	str	r2, [r3, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8001f6e:	9b01      	ldr	r3, [sp, #4]
 8001f70:	2000      	movs	r0, #0
 8001f72:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001f76:	4619      	mov	r1, r3
 8001f78:	f7ff ffb2 	bl	8001ee0 <initgpio.10453.4420>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 8001f7c:	9b01      	ldr	r3, [sp, #4]
 8001f7e:	331c      	adds	r3, #28
 8001f80:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001f84:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001f88:	4619      	mov	r1, r3
 8001f8a:	f7ff ffa9 	bl	8001ee0 <initgpio.10453.4420>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 8001f8e:	9b01      	ldr	r3, [sp, #4]
 8001f90:	3338      	adds	r3, #56	; 0x38
 8001f92:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8001f96:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001f9a:	4619      	mov	r1, r3
 8001f9c:	f7ff ffa0 	bl	8001ee0 <initgpio.10453.4420>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 8001fa0:	9b01      	ldr	r3, [sp, #4]
 8001fa2:	3354      	adds	r3, #84	; 0x54
 8001fa4:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8001fa8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001fac:	4619      	mov	r1, r3
 8001fae:	f7ff ff97 	bl	8001ee0 <initgpio.10453.4420>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 8001fb2:	9b01      	ldr	r3, [sp, #4]
 8001fb4:	3370      	adds	r3, #112	; 0x70
 8001fb6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001fba:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001fbe:	4619      	mov	r1, r3
 8001fc0:	f7ff ff8e 	bl	8001ee0 <initgpio.10453.4420>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 8001fc4:	9b01      	ldr	r3, [sp, #4]
 8001fc6:	338c      	adds	r3, #140	; 0x8c
 8001fc8:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
 8001fcc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001fd0:	4619      	mov	r1, r3
 8001fd2:	f7ff ff85 	bl	8001ee0 <initgpio.10453.4420>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 8001fd6:	9b01      	ldr	r3, [sp, #4]
 8001fd8:	33a8      	adds	r3, #168	; 0xa8
 8001fda:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 8001fde:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001fe2:	4619      	mov	r1, r3
 8001fe4:	f7ff ff7c 	bl	8001ee0 <initgpio.10453.4420>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 8001fe8:	9b01      	ldr	r3, [sp, #4]
 8001fea:	33c4      	adds	r3, #196	; 0xc4
 8001fec:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
 8001ff0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8001ff4:	4619      	mov	r1, r3
 8001ff6:	f7ff ff73 	bl	8001ee0 <initgpio.10453.4420>
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
 8001ffa:	9b01      	ldr	r3, [sp, #4]
 8001ffc:	33e0      	adds	r3, #224	; 0xe0
 8001ffe:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8002002:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002006:	4619      	mov	r1, r3
 8002008:	f7ff ff6a 	bl	8001ee0 <initgpio.10453.4420>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 800200c:	b003      	add	sp, #12
 800200e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002012:	bf00      	nop
 8002014:	f3af 8000 	nop.w
 8002018:	f3af 8000 	nop.w
 800201c:	f3af 8000 	nop.w

08002020 <port_lock.10545.4365>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002020:	b082      	sub	sp, #8
 8002022:	2320      	movs	r3, #32
 8002024:	9301      	str	r3, [sp, #4]
 8002026:	9b01      	ldr	r3, [sp, #4]
 8002028:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800202c:	b002      	add	sp, #8
 800202e:	4770      	bx	lr

08002030 <port_unlock.10548.4363>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002030:	b082      	sub	sp, #8
 8002032:	2300      	movs	r3, #0
 8002034:	9301      	str	r3, [sp, #4]
 8002036:	9b01      	ldr	r3, [sp, #4]
 8002038:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800203c:	b002      	add	sp, #8
 800203e:	4770      	bx	lr

08002040 <port_lock_from_isr.10550.4361>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002040:	b508      	push	{r3, lr}

  port_lock();
 8002042:	f7ff ffed 	bl	8002020 <port_lock.10545.4365>
}
 8002046:	bd08      	pop	{r3, pc}
 8002048:	f3af 8000 	nop.w
 800204c:	f3af 8000 	nop.w

08002050 <port_unlock_from_isr.10552.4359>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002050:	b508      	push	{r3, lr}

  port_unlock();
 8002052:	f7ff ffed 	bl	8002030 <port_unlock.10548.4363>
}
 8002056:	bd08      	pop	{r3, pc}
 8002058:	f3af 8000 	nop.w
 800205c:	f3af 8000 	nop.w

08002060 <chSysLock.10668.4357>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002060:	b508      	push	{r3, lr}

  port_lock();
 8002062:	f7ff ffdd 	bl	8002020 <port_lock.10545.4365>
  _stats_start_measure_crit_thd();
 8002066:	f004 fc6b 	bl	8006940 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800206a:	f003 fa79 	bl	8005560 <_dbg_check_lock>
}
 800206e:	bd08      	pop	{r3, pc}

08002070 <chSysUnlock.10664.4355>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002070:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8002072:	f003 fa95 	bl	80055a0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8002076:	f004 fc6b 	bl	8006950 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800207a:	f640 0308 	movw	r3, #2056	; 0x808
 800207e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002082:	681a      	ldr	r2, [r3, #0]
 8002084:	f640 0308 	movw	r3, #2056	; 0x808
 8002088:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800208c:	429a      	cmp	r2, r3
 800208e:	d013      	beq.n	80020b8 <chSysUnlock.10664.4355+0x48>
 8002090:	f640 0308 	movw	r3, #2056	; 0x808
 8002094:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002098:	699b      	ldr	r3, [r3, #24]
 800209a:	689a      	ldr	r2, [r3, #8]
 800209c:	f640 0308 	movw	r3, #2056	; 0x808
 80020a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80020a4:	681b      	ldr	r3, [r3, #0]
 80020a6:	689b      	ldr	r3, [r3, #8]
 80020a8:	429a      	cmp	r2, r3
 80020aa:	d205      	bcs.n	80020b8 <chSysUnlock.10664.4355+0x48>
 80020ac:	f647 1050 	movw	r0, #31056	; 0x7950
 80020b0:	f6c0 0000 	movt	r0, #2048	; 0x800
 80020b4:	f003 f9bc 	bl	8005430 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80020b8:	f7ff ffba 	bl	8002030 <port_unlock.10548.4363>
}
 80020bc:	bd08      	pop	{r3, pc}
 80020be:	bf00      	nop

080020c0 <chSysLockFromISR.10564.4353>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80020c0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80020c2:	f7ff ffbd 	bl	8002040 <port_lock_from_isr.10550.4361>
  _stats_start_measure_crit_isr();
 80020c6:	f004 fc4b 	bl	8006960 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80020ca:	f003 fa89 	bl	80055e0 <_dbg_check_lock_from_isr>
}
 80020ce:	bd08      	pop	{r3, pc}

080020d0 <chSysUnlockFromISR.10654.4351>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80020d0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 80020d2:	f003 faa5 	bl	8005620 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80020d6:	f004 fc4b 	bl	8006970 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 80020da:	f7ff ffb9 	bl	8002050 <port_unlock_from_isr.10552.4359>
}
 80020de:	bd08      	pop	{r3, pc}

080020e0 <chThdStartI.10658>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 80020e0:	b500      	push	{lr}
 80020e2:	b083      	sub	sp, #12
 80020e4:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");
 80020e6:	9b01      	ldr	r3, [sp, #4]
 80020e8:	f893 3020 	ldrb.w	r3, [r3, #32]
 80020ec:	2b02      	cmp	r3, #2
 80020ee:	d005      	beq.n	80020fc <chThdStartI.10658+0x1c>
 80020f0:	f647 1040 	movw	r0, #31040	; 0x7940
 80020f4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80020f8:	f003 f99a 	bl	8005430 <chSysHalt>

  return chSchReadyI(tp);
 80020fc:	9801      	ldr	r0, [sp, #4]
 80020fe:	f003 fdef 	bl	8005ce0 <chSchReadyI>
 8002102:	4603      	mov	r3, r0
}
 8002104:	4618      	mov	r0, r3
 8002106:	b003      	add	sp, #12
 8002108:	f85d fb04 	ldr.w	pc, [sp], #4
 800210c:	f3af 8000 	nop.w

08002110 <chRegSetThreadName.10554>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8002110:	b082      	sub	sp, #8
 8002112:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8002114:	f640 0308 	movw	r3, #2056	; 0x808
 8002118:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800211c:	699b      	ldr	r3, [r3, #24]
 800211e:	9a01      	ldr	r2, [sp, #4]
 8002120:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8002122:	b002      	add	sp, #8
 8002124:	4770      	bx	lr
 8002126:	bf00      	nop
 8002128:	f3af 8000 	nop.w
 800212c:	f3af 8000 	nop.w

08002130 <osalSysLock.10670>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8002130:	b508      	push	{r3, lr}

  chSysLock();
 8002132:	f7ff ff95 	bl	8002060 <chSysLock.10668.4357>
}
 8002136:	bd08      	pop	{r3, pc}
 8002138:	f3af 8000 	nop.w
 800213c:	f3af 8000 	nop.w

08002140 <osalSysUnlock.10666>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8002140:	b508      	push	{r3, lr}

  chSysUnlock();
 8002142:	f7ff ff95 	bl	8002070 <chSysUnlock.10664.4355>
}
 8002146:	bd08      	pop	{r3, pc}
 8002148:	f3af 8000 	nop.w
 800214c:	f3af 8000 	nop.w

08002150 <osalSysLockFromISR.10566.4339>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8002150:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8002152:	f7ff ffb5 	bl	80020c0 <chSysLockFromISR.10564.4353>
}
 8002156:	bd08      	pop	{r3, pc}
 8002158:	f3af 8000 	nop.w
 800215c:	f3af 8000 	nop.w

08002160 <osalSysUnlockFromISR.10656.4337>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8002160:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8002162:	f7ff ffb5 	bl	80020d0 <chSysUnlockFromISR.10654.4351>
}
 8002166:	bd08      	pop	{r3, pc}
 8002168:	f3af 8000 	nop.w
 800216c:	f3af 8000 	nop.w

08002170 <osalSysPolledDelayX.10558.4334>:
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8002170:	b500      	push	{lr}
 8002172:	b083      	sub	sp, #12
 8002174:	9001      	str	r0, [sp, #4]

  chSysPolledDelayX(cycles);
 8002176:	9801      	ldr	r0, [sp, #4]
 8002178:	f003 f98a 	bl	8005490 <chSysPolledDelayX>
}
 800217c:	b003      	add	sp, #12
 800217e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002182:	bf00      	nop
 8002184:	f3af 8000 	nop.w
 8002188:	f3af 8000 	nop.w
 800218c:	f3af 8000 	nop.w

08002190 <osalThreadSuspendS.10661>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 8002190:	b500      	push	{lr}
 8002192:	b083      	sub	sp, #12
 8002194:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 8002196:	9801      	ldr	r0, [sp, #4]
 8002198:	f004 fa02 	bl	80065a0 <chThdSuspendS>
 800219c:	4603      	mov	r3, r0
}
 800219e:	4618      	mov	r0, r3
 80021a0:	b003      	add	sp, #12
 80021a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80021a6:	bf00      	nop
 80021a8:	f3af 8000 	nop.w
 80021ac:	f3af 8000 	nop.w

080021b0 <osalThreadResumeI.10568.4327>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80021b0:	b500      	push	{lr}
 80021b2:	b083      	sub	sp, #12
 80021b4:	9001      	str	r0, [sp, #4]
 80021b6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 80021b8:	9801      	ldr	r0, [sp, #4]
 80021ba:	9900      	ldr	r1, [sp, #0]
 80021bc:	f004 fa18 	bl	80065f0 <chThdResumeI>
}
 80021c0:	b003      	add	sp, #12
 80021c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80021c6:	bf00      	nop
 80021c8:	f3af 8000 	nop.w
 80021cc:	f3af 8000 	nop.w

080021d0 <otg_core_reset.10672>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void otg_core_reset(USBDriver *usbp) {
 80021d0:	b500      	push	{lr}
 80021d2:	b085      	sub	sp, #20
 80021d4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80021d6:	9b01      	ldr	r3, [sp, #4]
 80021d8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80021da:	9303      	str	r3, [sp, #12]

  osalSysPolledDelayX(32);
 80021dc:	2020      	movs	r0, #32
 80021de:	f7ff ffc7 	bl	8002170 <osalSysPolledDelayX.10558.4334>

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 80021e2:	9b03      	ldr	r3, [sp, #12]
 80021e4:	2201      	movs	r2, #1
 80021e6:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 80021e8:	9b03      	ldr	r3, [sp, #12]
 80021ea:	691b      	ldr	r3, [r3, #16]
 80021ec:	f003 0301 	and.w	r3, r3, #1
 80021f0:	2b00      	cmp	r3, #0
 80021f2:	d1f9      	bne.n	80021e8 <otg_core_reset.10672+0x18>
    ;

  osalSysPolledDelayX(18);
 80021f4:	2012      	movs	r0, #18
 80021f6:	f7ff ffbb 	bl	8002170 <osalSysPolledDelayX.10558.4334>

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 80021fa:	9b03      	ldr	r3, [sp, #12]
 80021fc:	691b      	ldr	r3, [r3, #16]
 80021fe:	2b00      	cmp	r3, #0
 8002200:	dafb      	bge.n	80021fa <otg_core_reset.10672+0x2a>
    ;
}
 8002202:	b005      	add	sp, #20
 8002204:	f85d fb04 	ldr.w	pc, [sp], #4
 8002208:	f3af 8000 	nop.w
 800220c:	f3af 8000 	nop.w

08002210 <otg_disable_ep.10843>:

static void otg_disable_ep(USBDriver *usbp) {
 8002210:	b084      	sub	sp, #16
 8002212:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8002214:	9b01      	ldr	r3, [sp, #4]
 8002216:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8002218:	9302      	str	r3, [sp, #8]
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800221a:	2300      	movs	r3, #0
 800221c:	9303      	str	r3, [sp, #12]
 800221e:	e032      	b.n	8002286 <otg_disable_ep.10843+0x76>
    otgp->ie[i].DIEPCTL = 0;
 8002220:	9a02      	ldr	r2, [sp, #8]
 8002222:	9b03      	ldr	r3, [sp, #12]
 8002224:	3348      	adds	r3, #72	; 0x48
 8002226:	015b      	lsls	r3, r3, #5
 8002228:	4413      	add	r3, r2
 800222a:	2200      	movs	r2, #0
 800222c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 800222e:	9a02      	ldr	r2, [sp, #8]
 8002230:	9b03      	ldr	r3, [sp, #12]
 8002232:	015b      	lsls	r3, r3, #5
 8002234:	4413      	add	r3, r2
 8002236:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800223a:	2200      	movs	r2, #0
 800223c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800223e:	9a02      	ldr	r2, [sp, #8]
 8002240:	9b03      	ldr	r3, [sp, #12]
 8002242:	015b      	lsls	r3, r3, #5
 8002244:	4413      	add	r3, r2
 8002246:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800224a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800224e:	601a      	str	r2, [r3, #0]

    otgp->oe[i].DOEPCTL = 0;
 8002250:	9a02      	ldr	r2, [sp, #8]
 8002252:	9b03      	ldr	r3, [sp, #12]
 8002254:	3358      	adds	r3, #88	; 0x58
 8002256:	015b      	lsls	r3, r3, #5
 8002258:	4413      	add	r3, r2
 800225a:	2200      	movs	r2, #0
 800225c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 800225e:	9a02      	ldr	r2, [sp, #8]
 8002260:	9b03      	ldr	r3, [sp, #12]
 8002262:	015b      	lsls	r3, r3, #5
 8002264:	4413      	add	r3, r2
 8002266:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800226a:	2200      	movs	r2, #0
 800226c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800226e:	9a02      	ldr	r2, [sp, #8]
 8002270:	9b03      	ldr	r3, [sp, #12]
 8002272:	015b      	lsls	r3, r3, #5
 8002274:	4413      	add	r3, r2
 8002276:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800227a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800227e:	601a      	str	r2, [r3, #0]

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8002280:	9b03      	ldr	r3, [sp, #12]
 8002282:	3301      	adds	r3, #1
 8002284:	9303      	str	r3, [sp, #12]
 8002286:	9b01      	ldr	r3, [sp, #4]
 8002288:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800228a:	689a      	ldr	r2, [r3, #8]
 800228c:	9b03      	ldr	r3, [sp, #12]
 800228e:	429a      	cmp	r2, r3
 8002290:	d2c6      	bcs.n	8002220 <otg_disable_ep.10843+0x10>

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8002292:	9b02      	ldr	r3, [sp, #8]
 8002294:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8002298:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 800229c:	b004      	add	sp, #16
 800229e:	4770      	bx	lr

080022a0 <otg_rxfifo_flush.10846>:

static void otg_rxfifo_flush(USBDriver *usbp) {
 80022a0:	b500      	push	{lr}
 80022a2:	b085      	sub	sp, #20
 80022a4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80022a6:	9b01      	ldr	r3, [sp, #4]
 80022a8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80022aa:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80022ac:	9b03      	ldr	r3, [sp, #12]
 80022ae:	2210      	movs	r2, #16
 80022b0:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80022b2:	9b03      	ldr	r3, [sp, #12]
 80022b4:	691b      	ldr	r3, [r3, #16]
 80022b6:	f003 0310 	and.w	r3, r3, #16
 80022ba:	2b00      	cmp	r3, #0
 80022bc:	d1f9      	bne.n	80022b2 <otg_rxfifo_flush.10846+0x12>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 80022be:	2012      	movs	r0, #18
 80022c0:	f7ff ff56 	bl	8002170 <osalSysPolledDelayX.10558.4334>
}
 80022c4:	b005      	add	sp, #20
 80022c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80022ca:	bf00      	nop
 80022cc:	f3af 8000 	nop.w

080022d0 <otg_txfifo_flush.10849>:

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 80022d0:	b500      	push	{lr}
 80022d2:	b085      	sub	sp, #20
 80022d4:	9001      	str	r0, [sp, #4]
 80022d6:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 80022d8:	9b01      	ldr	r3, [sp, #4]
 80022da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80022dc:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80022de:	9b00      	ldr	r3, [sp, #0]
 80022e0:	019b      	lsls	r3, r3, #6
 80022e2:	f043 0220 	orr.w	r2, r3, #32
 80022e6:	9b03      	ldr	r3, [sp, #12]
 80022e8:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80022ea:	9b03      	ldr	r3, [sp, #12]
 80022ec:	691b      	ldr	r3, [r3, #16]
 80022ee:	f003 0320 	and.w	r3, r3, #32
 80022f2:	2b00      	cmp	r3, #0
 80022f4:	d1f9      	bne.n	80022ea <otg_txfifo_flush.10849+0x1a>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 80022f6:	2012      	movs	r0, #18
 80022f8:	f7ff ff3a 	bl	8002170 <osalSysPolledDelayX.10558.4334>
}
 80022fc:	b005      	add	sp, #20
 80022fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8002302:	bf00      	nop
 8002304:	f3af 8000 	nop.w
 8002308:	f3af 8000 	nop.w
 800230c:	f3af 8000 	nop.w

08002310 <otg_ram_reset.10853>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {
 8002310:	b082      	sub	sp, #8
 8002312:	9001      	str	r0, [sp, #4]

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8002314:	9b01      	ldr	r3, [sp, #4]
 8002316:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8002318:	681a      	ldr	r2, [r3, #0]
 800231a:	9b01      	ldr	r3, [sp, #4]
 800231c:	671a      	str	r2, [r3, #112]	; 0x70
}
 800231e:	b002      	add	sp, #8
 8002320:	4770      	bx	lr
 8002322:	bf00      	nop
 8002324:	f3af 8000 	nop.w
 8002328:	f3af 8000 	nop.w
 800232c:	f3af 8000 	nop.w

08002330 <otg_ram_alloc.10856>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] size      size of the packet buffer to allocate in words
 *
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 8002330:	b500      	push	{lr}
 8002332:	b085      	sub	sp, #20
 8002334:	9001      	str	r0, [sp, #4]
 8002336:	9100      	str	r1, [sp, #0]
  uint32_t next;

  next = usbp->pmnext;
 8002338:	9b01      	ldr	r3, [sp, #4]
 800233a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800233c:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 800233e:	9b01      	ldr	r3, [sp, #4]
 8002340:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002342:	9b00      	ldr	r3, [sp, #0]
 8002344:	441a      	add	r2, r3
 8002346:	9b01      	ldr	r3, [sp, #4]
 8002348:	671a      	str	r2, [r3, #112]	; 0x70
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800234a:	9b01      	ldr	r3, [sp, #4]
 800234c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800234e:	9b01      	ldr	r3, [sp, #4]
 8002350:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8002352:	685b      	ldr	r3, [r3, #4]
 8002354:	429a      	cmp	r2, r3
 8002356:	d905      	bls.n	8002364 <otg_ram_alloc.10856+0x34>
 8002358:	f647 1010 	movw	r0, #30992	; 0x7910
 800235c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002360:	f003 f866 	bl	8005430 <chSysHalt>
                "OTG FIFO memory overflow");
  return next;
 8002364:	9b03      	ldr	r3, [sp, #12]
}
 8002366:	4618      	mov	r0, r3
 8002368:	b005      	add	sp, #20
 800236a:	f85d fb04 	ldr.w	pc, [sp], #4
 800236e:	bf00      	nop

08002370 <otg_fifo_write_from_buffer.10860.4302>:
 *
 * @notapi
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {
 8002370:	b500      	push	{lr}
 8002372:	b085      	sub	sp, #20
 8002374:	9003      	str	r0, [sp, #12]
 8002376:	9102      	str	r1, [sp, #8]
 8002378:	9201      	str	r2, [sp, #4]

  osalDbgAssert(n > 0, "is zero");
 800237a:	9b01      	ldr	r3, [sp, #4]
 800237c:	2b00      	cmp	r3, #0
 800237e:	d105      	bne.n	800238c <otg_fifo_write_from_buffer.10860.4302+0x1c>
 8002380:	f647 1020 	movw	r0, #31008	; 0x7920
 8002384:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002388:	f003 f852 	bl	8005430 <chSysHalt>

  while (true) {
    *fifop = *((uint32_t *)buf);
 800238c:	9b02      	ldr	r3, [sp, #8]
 800238e:	681a      	ldr	r2, [r3, #0]
 8002390:	9b03      	ldr	r3, [sp, #12]
 8002392:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 8002394:	9b01      	ldr	r3, [sp, #4]
 8002396:	2b04      	cmp	r3, #4
 8002398:	d906      	bls.n	80023a8 <otg_fifo_write_from_buffer.10860.4302+0x38>
      break;
    }
    n -= 4;
 800239a:	9b01      	ldr	r3, [sp, #4]
 800239c:	3b04      	subs	r3, #4
 800239e:	9301      	str	r3, [sp, #4]
    buf += 4;
 80023a0:	9b02      	ldr	r3, [sp, #8]
 80023a2:	3304      	adds	r3, #4
 80023a4:	9302      	str	r3, [sp, #8]
 80023a6:	e7f1      	b.n	800238c <otg_fifo_write_from_buffer.10860.4302+0x1c>
  }
}
 80023a8:	b005      	add	sp, #20
 80023aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80023ae:	bf00      	nop

080023b0 <otg_fifo_read_to_buffer.10865.4296>:
 * @notapi
 */
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {
 80023b0:	b086      	sub	sp, #24
 80023b2:	9003      	str	r0, [sp, #12]
 80023b4:	9102      	str	r1, [sp, #8]
 80023b6:	9201      	str	r2, [sp, #4]
 80023b8:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 80023ba:	2300      	movs	r3, #0
 80023bc:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 80023be:	2300      	movs	r3, #0
 80023c0:	9304      	str	r3, [sp, #16]
 80023c2:	e017      	b.n	80023f4 <otg_fifo_read_to_buffer.10865.4296+0x44>

  while (i < n) {
    if ((i & 3) == 0){
 80023c4:	9b04      	ldr	r3, [sp, #16]
 80023c6:	f003 0303 	and.w	r3, r3, #3
 80023ca:	2b00      	cmp	r3, #0
 80023cc:	d102      	bne.n	80023d4 <otg_fifo_read_to_buffer.10865.4296+0x24>
      w = *fifop;
 80023ce:	9b03      	ldr	r3, [sp, #12]
 80023d0:	681b      	ldr	r3, [r3, #0]
 80023d2:	9305      	str	r3, [sp, #20]
    }
    if (i < max) {
 80023d4:	9a04      	ldr	r2, [sp, #16]
 80023d6:	9b00      	ldr	r3, [sp, #0]
 80023d8:	429a      	cmp	r2, r3
 80023da:	d208      	bcs.n	80023ee <otg_fifo_read_to_buffer.10865.4296+0x3e>
      *buf++ = (uint8_t)w;
 80023dc:	9b02      	ldr	r3, [sp, #8]
 80023de:	1c5a      	adds	r2, r3, #1
 80023e0:	9202      	str	r2, [sp, #8]
 80023e2:	9a05      	ldr	r2, [sp, #20]
 80023e4:	b2d2      	uxtb	r2, r2
 80023e6:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 80023e8:	9b05      	ldr	r3, [sp, #20]
 80023ea:	0a1b      	lsrs	r3, r3, #8
 80023ec:	9305      	str	r3, [sp, #20]
    }
    i++;
 80023ee:	9b04      	ldr	r3, [sp, #16]
 80023f0:	3301      	adds	r3, #1
 80023f2:	9304      	str	r3, [sp, #16]
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80023f4:	9a04      	ldr	r2, [sp, #16]
 80023f6:	9b01      	ldr	r3, [sp, #4]
 80023f8:	429a      	cmp	r2, r3
 80023fa:	d3e3      	bcc.n	80023c4 <otg_fifo_read_to_buffer.10865.4296+0x14>
      *buf++ = (uint8_t)w;
      w >>= 8;
    }
    i++;
  }
}
 80023fc:	b006      	add	sp, #24
 80023fe:	4770      	bx	lr

08002400 <otg_rxfifo_handler.10871>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
 8002400:	b510      	push	{r4, lr}
 8002402:	b086      	sub	sp, #24
 8002404:	9001      	str	r0, [sp, #4]
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 8002406:	9b01      	ldr	r3, [sp, #4]
 8002408:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800240a:	6a1b      	ldr	r3, [r3, #32]
 800240c:	9305      	str	r3, [sp, #20]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 800240e:	9b05      	ldr	r3, [sp, #20]
 8002410:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 8002414:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8002418:	d072      	beq.n	8002500 <otg_rxfifo_handler.10871+0x100>
 800241a:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 800241e:	d003      	beq.n	8002428 <otg_rxfifo_handler.10871+0x28>
 8002420:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8002424:	d01c      	beq.n	8002460 <otg_rxfifo_handler.10871+0x60>
 8002426:	e06b      	b.n	8002500 <otg_rxfifo_handler.10871+0x100>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8002428:	9a05      	ldr	r2, [sp, #20]
 800242a:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 800242e:	4013      	ands	r3, r2
 8002430:	091b      	lsrs	r3, r3, #4
 8002432:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8002434:	9b05      	ldr	r3, [sp, #20]
 8002436:	f003 030f 	and.w	r3, r3, #15
 800243a:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800243c:	9b01      	ldr	r3, [sp, #4]
 800243e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8002440:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8002444:	9901      	ldr	r1, [sp, #4]
 8002446:	9b03      	ldr	r3, [sp, #12]
 8002448:	3302      	adds	r3, #2
 800244a:	009b      	lsls	r3, r3, #2
 800244c:	440b      	add	r3, r1
 800244e:	685b      	ldr	r3, [r3, #4]
 8002450:	6a1b      	ldr	r3, [r3, #32]
 8002452:	4610      	mov	r0, r2
 8002454:	4619      	mov	r1, r3
 8002456:	9a04      	ldr	r2, [sp, #16]
 8002458:	2308      	movs	r3, #8
 800245a:	f7ff ffa9 	bl	80023b0 <otg_fifo_read_to_buffer.10865.4296>
 800245e:	e04f      	b.n	8002500 <otg_rxfifo_handler.10871+0x100>
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8002460:	9a05      	ldr	r2, [sp, #20]
 8002462:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8002466:	4013      	ands	r3, r2
 8002468:	091b      	lsrs	r3, r3, #4
 800246a:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800246c:	9b05      	ldr	r3, [sp, #20]
 800246e:	f003 030f 	and.w	r3, r3, #15
 8002472:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8002474:	9b01      	ldr	r3, [sp, #4]
 8002476:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8002478:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 800247c:	9a01      	ldr	r2, [sp, #4]
 800247e:	9b03      	ldr	r3, [sp, #12]
 8002480:	3302      	adds	r3, #2
 8002482:	009b      	lsls	r3, r3, #2
 8002484:	4413      	add	r3, r2
 8002486:	685b      	ldr	r3, [r3, #4]
 8002488:	699b      	ldr	r3, [r3, #24]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800248a:	689a      	ldr	r2, [r3, #8]
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
 800248c:	9801      	ldr	r0, [sp, #4]
 800248e:	9b03      	ldr	r3, [sp, #12]
 8002490:	3302      	adds	r3, #2
 8002492:	009b      	lsls	r3, r3, #2
 8002494:	4403      	add	r3, r0
 8002496:	685b      	ldr	r3, [r3, #4]
 8002498:	699b      	ldr	r3, [r3, #24]
 800249a:	6818      	ldr	r0, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 800249c:	9c01      	ldr	r4, [sp, #4]
 800249e:	9b03      	ldr	r3, [sp, #12]
 80024a0:	3302      	adds	r3, #2
 80024a2:	009b      	lsls	r3, r3, #2
 80024a4:	4423      	add	r3, r4
 80024a6:	685b      	ldr	r3, [r3, #4]
 80024a8:	699b      	ldr	r3, [r3, #24]
 80024aa:	685b      	ldr	r3, [r3, #4]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 80024ac:	1ac3      	subs	r3, r0, r3
 80024ae:	4608      	mov	r0, r1
 80024b0:	4611      	mov	r1, r2
 80024b2:	9a04      	ldr	r2, [sp, #16]
 80024b4:	f7ff ff7c 	bl	80023b0 <otg_fifo_read_to_buffer.10865.4296>
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 80024b8:	9a01      	ldr	r2, [sp, #4]
 80024ba:	9b03      	ldr	r3, [sp, #12]
 80024bc:	3302      	adds	r3, #2
 80024be:	009b      	lsls	r3, r3, #2
 80024c0:	4413      	add	r3, r2
 80024c2:	685b      	ldr	r3, [r3, #4]
 80024c4:	699a      	ldr	r2, [r3, #24]
 80024c6:	9901      	ldr	r1, [sp, #4]
 80024c8:	9b03      	ldr	r3, [sp, #12]
 80024ca:	3302      	adds	r3, #2
 80024cc:	009b      	lsls	r3, r3, #2
 80024ce:	440b      	add	r3, r1
 80024d0:	685b      	ldr	r3, [r3, #4]
 80024d2:	699b      	ldr	r3, [r3, #24]
 80024d4:	6899      	ldr	r1, [r3, #8]
 80024d6:	9b04      	ldr	r3, [sp, #16]
 80024d8:	440b      	add	r3, r1
 80024da:	6093      	str	r3, [r2, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80024dc:	9a01      	ldr	r2, [sp, #4]
 80024de:	9b03      	ldr	r3, [sp, #12]
 80024e0:	3302      	adds	r3, #2
 80024e2:	009b      	lsls	r3, r3, #2
 80024e4:	4413      	add	r3, r2
 80024e6:	685b      	ldr	r3, [r3, #4]
 80024e8:	699a      	ldr	r2, [r3, #24]
 80024ea:	9901      	ldr	r1, [sp, #4]
 80024ec:	9b03      	ldr	r3, [sp, #12]
 80024ee:	3302      	adds	r3, #2
 80024f0:	009b      	lsls	r3, r3, #2
 80024f2:	440b      	add	r3, r1
 80024f4:	685b      	ldr	r3, [r3, #4]
 80024f6:	699b      	ldr	r3, [r3, #24]
 80024f8:	6859      	ldr	r1, [r3, #4]
 80024fa:	9b04      	ldr	r3, [sp, #16]
 80024fc:	440b      	add	r3, r1
 80024fe:	6053      	str	r3, [r2, #4]
  case GRXSTSP_OUT_GLOBAL_NAK:
  case GRXSTSP_OUT_COMP:
  default:
    ;
  }
}
 8002500:	b006      	add	sp, #24
 8002502:	bd10      	pop	{r4, pc}
 8002504:	f3af 8000 	nop.w
 8002508:	f3af 8000 	nop.w
 800250c:	f3af 8000 	nop.w

08002510 <otg_txfifo_handler.10874>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 8002510:	b500      	push	{lr}
 8002512:	b085      	sub	sp, #20
 8002514:	9001      	str	r0, [sp, #4]
 8002516:	460b      	mov	r3, r1
 8002518:	f88d 3003 	strb.w	r3, [sp, #3]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 800251c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002520:	9a01      	ldr	r2, [sp, #4]
 8002522:	3302      	adds	r3, #2
 8002524:	009b      	lsls	r3, r3, #2
 8002526:	4413      	add	r3, r2
 8002528:	685b      	ldr	r3, [r3, #4]
 800252a:	695b      	ldr	r3, [r3, #20]
 800252c:	685a      	ldr	r2, [r3, #4]
 800252e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002532:	9901      	ldr	r1, [sp, #4]
 8002534:	3302      	adds	r3, #2
 8002536:	009b      	lsls	r3, r3, #2
 8002538:	440b      	add	r3, r1
 800253a:	685b      	ldr	r3, [r3, #4]
 800253c:	695b      	ldr	r3, [r3, #20]
 800253e:	681b      	ldr	r3, [r3, #0]
 8002540:	429a      	cmp	r2, r3
 8002542:	d301      	bcc.n	8002548 <otg_txfifo_handler.10874+0x38>
      return true;
 8002544:	2301      	movs	r3, #1
 8002546:	e076      	b.n	8002636 <otg_txfifo_handler.10874+0x126>

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8002548:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800254c:	9a01      	ldr	r2, [sp, #4]
 800254e:	3302      	adds	r3, #2
 8002550:	009b      	lsls	r3, r3, #2
 8002552:	4413      	add	r3, r2
 8002554:	685b      	ldr	r3, [r3, #4]
 8002556:	695b      	ldr	r3, [r3, #20]
 8002558:	681a      	ldr	r2, [r3, #0]
 800255a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800255e:	9901      	ldr	r1, [sp, #4]
 8002560:	3302      	adds	r3, #2
 8002562:	009b      	lsls	r3, r3, #2
 8002564:	440b      	add	r3, r1
 8002566:	685b      	ldr	r3, [r3, #4]
 8002568:	695b      	ldr	r3, [r3, #20]
 800256a:	685b      	ldr	r3, [r3, #4]
 800256c:	1ad3      	subs	r3, r2, r3
 800256e:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 8002570:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002574:	9a01      	ldr	r2, [sp, #4]
 8002576:	3302      	adds	r3, #2
 8002578:	009b      	lsls	r3, r3, #2
 800257a:	4413      	add	r3, r2
 800257c:	685b      	ldr	r3, [r3, #4]
 800257e:	8a1b      	ldrh	r3, [r3, #16]
 8002580:	461a      	mov	r2, r3
 8002582:	9b03      	ldr	r3, [sp, #12]
 8002584:	429a      	cmp	r2, r3
 8002586:	d208      	bcs.n	800259a <otg_txfifo_handler.10874+0x8a>
      n = usbp->epc[ep]->in_maxsize;
 8002588:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800258c:	9a01      	ldr	r2, [sp, #4]
 800258e:	3302      	adds	r3, #2
 8002590:	009b      	lsls	r3, r3, #2
 8002592:	4413      	add	r3, r2
 8002594:	685b      	ldr	r3, [r3, #4]
 8002596:	8a1b      	ldrh	r3, [r3, #16]
 8002598:	9303      	str	r3, [sp, #12]

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800259a:	9b01      	ldr	r3, [sp, #4]
 800259c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800259e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80025a2:	015b      	lsls	r3, r3, #5
 80025a4:	4413      	add	r3, r2
 80025a6:	f603 1318 	addw	r3, r3, #2328	; 0x918
 80025aa:	681b      	ldr	r3, [r3, #0]
 80025ac:	b29b      	uxth	r3, r3
 80025ae:	009a      	lsls	r2, r3, #2
 80025b0:	9b03      	ldr	r3, [sp, #12]
 80025b2:	429a      	cmp	r2, r3
 80025b4:	d201      	bcs.n	80025ba <otg_txfifo_handler.10874+0xaa>
      return false;
 80025b6:	2300      	movs	r3, #0
 80025b8:	e03d      	b.n	8002636 <otg_txfifo_handler.10874+0x126>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80025ba:	9b01      	ldr	r3, [sp, #4]
 80025bc:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80025be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80025c2:	3301      	adds	r3, #1
 80025c4:	031b      	lsls	r3, r3, #12
 80025c6:	441a      	add	r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 80025c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80025cc:	9901      	ldr	r1, [sp, #4]
 80025ce:	3302      	adds	r3, #2
 80025d0:	009b      	lsls	r3, r3, #2
 80025d2:	440b      	add	r3, r1
 80025d4:	685b      	ldr	r3, [r3, #4]
 80025d6:	695b      	ldr	r3, [r3, #20]
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80025d8:	689b      	ldr	r3, [r3, #8]
 80025da:	4610      	mov	r0, r2
 80025dc:	4619      	mov	r1, r3
 80025de:	9a03      	ldr	r2, [sp, #12]
 80025e0:	f7ff fec6 	bl	8002370 <otg_fifo_write_from_buffer.10860.4302>
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 80025e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80025e8:	9a01      	ldr	r2, [sp, #4]
 80025ea:	3302      	adds	r3, #2
 80025ec:	009b      	lsls	r3, r3, #2
 80025ee:	4413      	add	r3, r2
 80025f0:	685b      	ldr	r3, [r3, #4]
 80025f2:	695a      	ldr	r2, [r3, #20]
 80025f4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80025f8:	9901      	ldr	r1, [sp, #4]
 80025fa:	3302      	adds	r3, #2
 80025fc:	009b      	lsls	r3, r3, #2
 80025fe:	440b      	add	r3, r1
 8002600:	685b      	ldr	r3, [r3, #4]
 8002602:	695b      	ldr	r3, [r3, #20]
 8002604:	6899      	ldr	r1, [r3, #8]
 8002606:	9b03      	ldr	r3, [sp, #12]
 8002608:	440b      	add	r3, r1
 800260a:	6093      	str	r3, [r2, #8]
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 800260c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002610:	9a01      	ldr	r2, [sp, #4]
 8002612:	3302      	adds	r3, #2
 8002614:	009b      	lsls	r3, r3, #2
 8002616:	4413      	add	r3, r2
 8002618:	685b      	ldr	r3, [r3, #4]
 800261a:	695a      	ldr	r2, [r3, #20]
 800261c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002620:	9901      	ldr	r1, [sp, #4]
 8002622:	3302      	adds	r3, #2
 8002624:	009b      	lsls	r3, r3, #2
 8002626:	440b      	add	r3, r1
 8002628:	685b      	ldr	r3, [r3, #4]
 800262a:	695b      	ldr	r3, [r3, #20]
 800262c:	6859      	ldr	r1, [r3, #4]
 800262e:	9b03      	ldr	r3, [sp, #12]
 8002630:	440b      	add	r3, r1
 8002632:	6053      	str	r3, [r2, #4]
 8002634:	e772      	b.n	800251c <otg_txfifo_handler.10874+0xc>
  }
}
 8002636:	4618      	mov	r0, r3
 8002638:	b005      	add	sp, #20
 800263a:	f85d fb04 	ldr.w	pc, [sp], #4
 800263e:	bf00      	nop

08002640 <otg_epin_handler.10935.4285>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8002640:	b500      	push	{lr}
 8002642:	b087      	sub	sp, #28
 8002644:	9001      	str	r0, [sp, #4]
 8002646:	460b      	mov	r3, r1
 8002648:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800264c:	9b01      	ldr	r3, [sp, #4]
 800264e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8002650:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8002652:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002656:	9a05      	ldr	r2, [sp, #20]
 8002658:	015b      	lsls	r3, r3, #5
 800265a:	4413      	add	r3, r2
 800265c:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8002660:	681b      	ldr	r3, [r3, #0]
 8002662:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 8002664:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002668:	9a05      	ldr	r2, [sp, #20]
 800266a:	015b      	lsls	r3, r3, #5
 800266c:	4413      	add	r3, r2
 800266e:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8002672:	9a04      	ldr	r2, [sp, #16]
 8002674:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8002676:	9b04      	ldr	r3, [sp, #16]
 8002678:	f003 0301 	and.w	r3, r3, #1
 800267c:	2b00      	cmp	r3, #0
 800267e:	d051      	beq.n	8002724 <otg_epin_handler.10935.4285+0xe4>
 8002680:	9b05      	ldr	r3, [sp, #20]
 8002682:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 8002686:	f003 0301 	and.w	r3, r3, #1
 800268a:	2b00      	cmp	r3, #0
 800268c:	d04a      	beq.n	8002724 <otg_epin_handler.10935.4285+0xe4>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800268e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002692:	9a01      	ldr	r2, [sp, #4]
 8002694:	3302      	adds	r3, #2
 8002696:	009b      	lsls	r3, r3, #2
 8002698:	4413      	add	r3, r2
 800269a:	685b      	ldr	r3, [r3, #4]
 800269c:	695b      	ldr	r3, [r3, #20]
 800269e:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 80026a0:	9b03      	ldr	r3, [sp, #12]
 80026a2:	681a      	ldr	r2, [r3, #0]
 80026a4:	9b03      	ldr	r3, [sp, #12]
 80026a6:	68db      	ldr	r3, [r3, #12]
 80026a8:	429a      	cmp	r2, r3
 80026aa:	d214      	bcs.n	80026d6 <otg_epin_handler.10935.4285+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 80026ac:	9b03      	ldr	r3, [sp, #12]
 80026ae:	68da      	ldr	r2, [r3, #12]
 80026b0:	9b03      	ldr	r3, [sp, #12]
 80026b2:	681b      	ldr	r3, [r3, #0]
 80026b4:	1ad2      	subs	r2, r2, r3
 80026b6:	9b03      	ldr	r3, [sp, #12]
 80026b8:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 80026ba:	9b03      	ldr	r3, [sp, #12]
 80026bc:	2200      	movs	r2, #0
 80026be:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 80026c0:	f7ff fd46 	bl	8002150 <osalSysLockFromISR.10566.4339>
      usb_lld_start_in(usbp, ep);
 80026c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80026c8:	9801      	ldr	r0, [sp, #4]
 80026ca:	4619      	mov	r1, r3
 80026cc:	f7fe ff08 	bl	80014e0 <usb_lld_start_in>
      osalSysUnlockFromISR();
 80026d0:	f7ff fd46 	bl	8002160 <osalSysUnlockFromISR.10656.4337>
 80026d4:	e026      	b.n	8002724 <otg_epin_handler.10935.4285+0xe4>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 80026d6:	9b01      	ldr	r3, [sp, #4]
 80026d8:	891b      	ldrh	r3, [r3, #8]
 80026da:	b29a      	uxth	r2, r3
 80026dc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80026e0:	2101      	movs	r1, #1
 80026e2:	fa01 f303 	lsl.w	r3, r1, r3
 80026e6:	b29b      	uxth	r3, r3
 80026e8:	43db      	mvns	r3, r3
 80026ea:	b29b      	uxth	r3, r3
 80026ec:	4013      	ands	r3, r2
 80026ee:	b29b      	uxth	r3, r3
 80026f0:	b29a      	uxth	r2, r3
 80026f2:	9b01      	ldr	r3, [sp, #4]
 80026f4:	811a      	strh	r2, [r3, #8]
 80026f6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80026fa:	9a01      	ldr	r2, [sp, #4]
 80026fc:	3302      	adds	r3, #2
 80026fe:	009b      	lsls	r3, r3, #2
 8002700:	4413      	add	r3, r2
 8002702:	685b      	ldr	r3, [r3, #4]
 8002704:	689b      	ldr	r3, [r3, #8]
 8002706:	2b00      	cmp	r3, #0
 8002708:	d00c      	beq.n	8002724 <otg_epin_handler.10935.4285+0xe4>
 800270a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800270e:	9a01      	ldr	r2, [sp, #4]
 8002710:	3302      	adds	r3, #2
 8002712:	009b      	lsls	r3, r3, #2
 8002714:	4413      	add	r3, r2
 8002716:	685b      	ldr	r3, [r3, #4]
 8002718:	689b      	ldr	r3, [r3, #8]
 800271a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800271e:	9801      	ldr	r0, [sp, #4]
 8002720:	4611      	mov	r1, r2
 8002722:	4798      	blx	r3
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8002724:	9b04      	ldr	r3, [sp, #16]
 8002726:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800272a:	2b00      	cmp	r3, #0
 800272c:	d02b      	beq.n	8002786 <otg_epin_handler.10935.4285+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 800272e:	9b05      	ldr	r3, [sp, #20]
 8002730:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8002734:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002738:	2101      	movs	r1, #1
 800273a:	fa01 f303 	lsl.w	r3, r1, r3
 800273e:	4013      	ands	r3, r2
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8002740:	2b00      	cmp	r3, #0
 8002742:	d020      	beq.n	8002786 <otg_epin_handler.10935.4285+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
 8002744:	f7ff fd04 	bl	8002150 <osalSysLockFromISR.10566.4339>
    usbp->txpending |= (1 << ep);
 8002748:	9b01      	ldr	r3, [sp, #4]
 800274a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 800274c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002750:	2101      	movs	r1, #1
 8002752:	fa01 f303 	lsl.w	r3, r1, r3
 8002756:	431a      	orrs	r2, r3
 8002758:	9b01      	ldr	r3, [sp, #4]
 800275a:	675a      	str	r2, [r3, #116]	; 0x74
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800275c:	9b05      	ldr	r3, [sp, #20]
 800275e:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8002762:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002766:	2101      	movs	r1, #1
 8002768:	fa01 f303 	lsl.w	r3, r1, r3
 800276c:	43db      	mvns	r3, r3
 800276e:	401a      	ands	r2, r3
 8002770:	9b05      	ldr	r3, [sp, #20]
 8002772:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8002776:	9b01      	ldr	r3, [sp, #4]
 8002778:	3378      	adds	r3, #120	; 0x78
 800277a:	4618      	mov	r0, r3
 800277c:	2100      	movs	r1, #0
 800277e:	f7ff fd17 	bl	80021b0 <osalThreadResumeI.10568.4327>
    osalSysUnlockFromISR();
 8002782:	f7ff fced 	bl	8002160 <osalSysUnlockFromISR.10656.4337>
  }
}
 8002786:	b007      	add	sp, #28
 8002788:	f85d fb04 	ldr.w	pc, [sp], #4
 800278c:	f3af 8000 	nop.w

08002790 <otg_epout_handler.10927.4281>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8002790:	b500      	push	{lr}
 8002792:	b087      	sub	sp, #28
 8002794:	9001      	str	r0, [sp, #4]
 8002796:	460b      	mov	r3, r1
 8002798:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800279c:	9b01      	ldr	r3, [sp, #4]
 800279e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80027a0:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 80027a2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80027a6:	9a05      	ldr	r2, [sp, #20]
 80027a8:	015b      	lsls	r3, r3, #5
 80027aa:	4413      	add	r3, r2
 80027ac:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80027b0:	681b      	ldr	r3, [r3, #0]
 80027b2:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 80027b4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80027b8:	9a05      	ldr	r2, [sp, #20]
 80027ba:	015b      	lsls	r3, r3, #5
 80027bc:	4413      	add	r3, r2
 80027be:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80027c2:	9a04      	ldr	r2, [sp, #16]
 80027c4:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 80027c6:	9b04      	ldr	r3, [sp, #16]
 80027c8:	f003 0308 	and.w	r3, r3, #8
 80027cc:	2b00      	cmp	r3, #0
 80027ce:	d013      	beq.n	80027f8 <otg_epout_handler.10927.4281+0x68>
 80027d0:	9b05      	ldr	r3, [sp, #20]
 80027d2:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 80027d6:	f003 0308 	and.w	r3, r3, #8
 80027da:	2b00      	cmp	r3, #0
 80027dc:	d00c      	beq.n	80027f8 <otg_epout_handler.10927.4281+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 80027de:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80027e2:	9a01      	ldr	r2, [sp, #4]
 80027e4:	3302      	adds	r3, #2
 80027e6:	009b      	lsls	r3, r3, #2
 80027e8:	4413      	add	r3, r2
 80027ea:	685b      	ldr	r3, [r3, #4]
 80027ec:	685b      	ldr	r3, [r3, #4]
 80027ee:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80027f2:	9801      	ldr	r0, [sp, #4]
 80027f4:	4611      	mov	r1, r2
 80027f6:	4798      	blx	r3

  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 80027f8:	9b04      	ldr	r3, [sp, #16]
 80027fa:	f003 0301 	and.w	r3, r3, #1
 80027fe:	2b00      	cmp	r3, #0
 8002800:	d062      	beq.n	80028c8 <otg_epout_handler.10927.4281+0x138>
 8002802:	9b05      	ldr	r3, [sp, #20]
 8002804:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 8002808:	f003 0301 	and.w	r3, r3, #1
 800280c:	2b00      	cmp	r3, #0
 800280e:	d05b      	beq.n	80028c8 <otg_epout_handler.10927.4281+0x138>
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8002810:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002814:	9a01      	ldr	r2, [sp, #4]
 8002816:	3302      	adds	r3, #2
 8002818:	009b      	lsls	r3, r3, #2
 800281a:	4413      	add	r3, r2
 800281c:	685b      	ldr	r3, [r3, #4]
 800281e:	699b      	ldr	r3, [r3, #24]
 8002820:	9303      	str	r3, [sp, #12]

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8002822:	9b03      	ldr	r3, [sp, #12]
 8002824:	685a      	ldr	r2, [r3, #4]
 8002826:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800282a:	9901      	ldr	r1, [sp, #4]
 800282c:	3302      	adds	r3, #2
 800282e:	009b      	lsls	r3, r3, #2
 8002830:	440b      	add	r3, r1
 8002832:	685b      	ldr	r3, [r3, #4]
 8002834:	8a5b      	ldrh	r3, [r3, #18]
 8002836:	fbb2 f1f3 	udiv	r1, r2, r3
 800283a:	fb03 f301 	mul.w	r3, r3, r1
 800283e:	1ad3      	subs	r3, r2, r3
 8002840:	2b00      	cmp	r3, #0
 8002842:	d11a      	bne.n	800287a <otg_epout_handler.10927.4281+0xea>
        (osp->rxsize < osp->totsize)) {
 8002844:	9b03      	ldr	r3, [sp, #12]
 8002846:	681a      	ldr	r2, [r3, #0]
 8002848:	9b03      	ldr	r3, [sp, #12]
 800284a:	68db      	ldr	r3, [r3, #12]
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800284c:	429a      	cmp	r2, r3
 800284e:	d214      	bcs.n	800287a <otg_epout_handler.10927.4281+0xea>
        (osp->rxsize < osp->totsize)) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8002850:	9b03      	ldr	r3, [sp, #12]
 8002852:	68da      	ldr	r2, [r3, #12]
 8002854:	9b03      	ldr	r3, [sp, #12]
 8002856:	681b      	ldr	r3, [r3, #0]
 8002858:	1ad2      	subs	r2, r2, r3
 800285a:	9b03      	ldr	r3, [sp, #12]
 800285c:	601a      	str	r2, [r3, #0]
      osp->rxcnt  = 0;
 800285e:	9b03      	ldr	r3, [sp, #12]
 8002860:	2200      	movs	r2, #0
 8002862:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8002864:	f7ff fc74 	bl	8002150 <osalSysLockFromISR.10566.4339>
      usb_lld_start_out(usbp, ep);
 8002868:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800286c:	9801      	ldr	r0, [sp, #4]
 800286e:	4619      	mov	r1, r3
 8002870:	f7fe fd96 	bl	80013a0 <usb_lld_start_out>
      osalSysUnlockFromISR();
 8002874:	f7ff fc74 	bl	8002160 <osalSysUnlockFromISR.10656.4337>
 8002878:	e026      	b.n	80028c8 <otg_epout_handler.10927.4281+0x138>
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 800287a:	9b01      	ldr	r3, [sp, #4]
 800287c:	895b      	ldrh	r3, [r3, #10]
 800287e:	b29a      	uxth	r2, r3
 8002880:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002884:	2101      	movs	r1, #1
 8002886:	fa01 f303 	lsl.w	r3, r1, r3
 800288a:	b29b      	uxth	r3, r3
 800288c:	43db      	mvns	r3, r3
 800288e:	b29b      	uxth	r3, r3
 8002890:	4013      	ands	r3, r2
 8002892:	b29b      	uxth	r3, r3
 8002894:	b29a      	uxth	r2, r3
 8002896:	9b01      	ldr	r3, [sp, #4]
 8002898:	815a      	strh	r2, [r3, #10]
 800289a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800289e:	9a01      	ldr	r2, [sp, #4]
 80028a0:	3302      	adds	r3, #2
 80028a2:	009b      	lsls	r3, r3, #2
 80028a4:	4413      	add	r3, r2
 80028a6:	685b      	ldr	r3, [r3, #4]
 80028a8:	68db      	ldr	r3, [r3, #12]
 80028aa:	2b00      	cmp	r3, #0
 80028ac:	d00c      	beq.n	80028c8 <otg_epout_handler.10927.4281+0x138>
 80028ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80028b2:	9a01      	ldr	r2, [sp, #4]
 80028b4:	3302      	adds	r3, #2
 80028b6:	009b      	lsls	r3, r3, #2
 80028b8:	4413      	add	r3, r2
 80028ba:	685b      	ldr	r3, [r3, #4]
 80028bc:	68db      	ldr	r3, [r3, #12]
 80028be:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80028c2:	9801      	ldr	r0, [sp, #4]
 80028c4:	4611      	mov	r1, r2
 80028c6:	4798      	blx	r3
    }
  }
}
 80028c8:	b007      	add	sp, #28
 80028ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80028ce:	bf00      	nop

080028d0 <otg_isoc_in_failed_handler.10881.4278>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 80028d0:	b500      	push	{lr}
 80028d2:	b085      	sub	sp, #20
 80028d4:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 80028d6:	9b01      	ldr	r3, [sp, #4]
 80028d8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80028da:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80028dc:	2300      	movs	r3, #0
 80028de:	f88d 300f 	strb.w	r3, [sp, #15]
 80028e2:	e080      	b.n	80029e6 <otg_isoc_in_failed_handler.10881.4278+0x116>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 80028e4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80028e8:	9a02      	ldr	r2, [sp, #8]
 80028ea:	3348      	adds	r3, #72	; 0x48
 80028ec:	015b      	lsls	r3, r3, #5
 80028ee:	4413      	add	r3, r2
 80028f0:	681b      	ldr	r3, [r3, #0]
 80028f2:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 80028f6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80028fa:	d16f      	bne.n	80029dc <otg_isoc_in_failed_handler.10881.4278+0x10c>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 80028fc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002900:	9a02      	ldr	r2, [sp, #8]
 8002902:	3348      	adds	r3, #72	; 0x48
 8002904:	015b      	lsls	r3, r3, #5
 8002906:	4413      	add	r3, r2
 8002908:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 800290a:	2b00      	cmp	r3, #0
 800290c:	da66      	bge.n	80029dc <otg_isoc_in_failed_handler.10881.4278+0x10c>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 800290e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002912:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8002916:	9902      	ldr	r1, [sp, #8]
 8002918:	3248      	adds	r2, #72	; 0x48
 800291a:	0152      	lsls	r2, r2, #5
 800291c:	440a      	add	r2, r1
 800291e:	6812      	ldr	r2, [r2, #0]
 8002920:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 8002924:	9902      	ldr	r1, [sp, #8]
 8002926:	3348      	adds	r3, #72	; 0x48
 8002928:	015b      	lsls	r3, r3, #5
 800292a:	440b      	add	r3, r1
 800292c:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 800292e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002932:	9a02      	ldr	r2, [sp, #8]
 8002934:	3348      	adds	r3, #72	; 0x48
 8002936:	015b      	lsls	r3, r3, #5
 8002938:	4413      	add	r3, r2
 800293a:	681b      	ldr	r3, [r3, #0]
 800293c:	2b00      	cmp	r3, #0
 800293e:	dbf6      	blt.n	800292e <otg_isoc_in_failed_handler.10881.4278+0x5e>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 8002940:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002944:	9801      	ldr	r0, [sp, #4]
 8002946:	4619      	mov	r1, r3
 8002948:	f7ff fcc2 	bl	80022d0 <otg_txfifo_flush.10849>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 800294c:	9b01      	ldr	r3, [sp, #4]
 800294e:	891b      	ldrh	r3, [r3, #8]
 8002950:	b29a      	uxth	r2, r3
 8002952:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002956:	2101      	movs	r1, #1
 8002958:	fa01 f303 	lsl.w	r3, r1, r3
 800295c:	b29b      	uxth	r3, r3
 800295e:	43db      	mvns	r3, r3
 8002960:	b29b      	uxth	r3, r3
 8002962:	4013      	ands	r3, r2
 8002964:	b29b      	uxth	r3, r3
 8002966:	b29a      	uxth	r2, r3
 8002968:	9b01      	ldr	r3, [sp, #4]
 800296a:	811a      	strh	r2, [r3, #8]
 800296c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002970:	9a01      	ldr	r2, [sp, #4]
 8002972:	3302      	adds	r3, #2
 8002974:	009b      	lsls	r3, r3, #2
 8002976:	4413      	add	r3, r2
 8002978:	685b      	ldr	r3, [r3, #4]
 800297a:	689b      	ldr	r3, [r3, #8]
 800297c:	2b00      	cmp	r3, #0
 800297e:	d00c      	beq.n	800299a <otg_isoc_in_failed_handler.10881.4278+0xca>
 8002980:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002984:	9a01      	ldr	r2, [sp, #4]
 8002986:	3302      	adds	r3, #2
 8002988:	009b      	lsls	r3, r3, #2
 800298a:	4413      	add	r3, r2
 800298c:	685b      	ldr	r3, [r3, #4]
 800298e:	689b      	ldr	r3, [r3, #8]
 8002990:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8002994:	9801      	ldr	r0, [sp, #4]
 8002996:	4611      	mov	r1, r2
 8002998:	4798      	blx	r3

      /* Pump out data for next frame */
      osalSysLockFromISR();
 800299a:	f7ff fbd9 	bl	8002150 <osalSysLockFromISR.10566.4339>
      otgp->DIEPEMPMSK &= ~(1 << ep);
 800299e:	9b02      	ldr	r3, [sp, #8]
 80029a0:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 80029a4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80029a8:	2101      	movs	r1, #1
 80029aa:	fa01 f303 	lsl.w	r3, r1, r3
 80029ae:	43db      	mvns	r3, r3
 80029b0:	401a      	ands	r2, r3
 80029b2:	9b02      	ldr	r3, [sp, #8]
 80029b4:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 80029b8:	9b01      	ldr	r3, [sp, #4]
 80029ba:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80029bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80029c0:	2101      	movs	r1, #1
 80029c2:	fa01 f303 	lsl.w	r3, r1, r3
 80029c6:	431a      	orrs	r2, r3
 80029c8:	9b01      	ldr	r3, [sp, #4]
 80029ca:	675a      	str	r2, [r3, #116]	; 0x74
      osalThreadResumeI(&usbp->wait, MSG_OK);
 80029cc:	9b01      	ldr	r3, [sp, #4]
 80029ce:	3378      	adds	r3, #120	; 0x78
 80029d0:	4618      	mov	r0, r3
 80029d2:	2100      	movs	r1, #0
 80029d4:	f7ff fbec 	bl	80021b0 <osalThreadResumeI.10568.4327>
      osalSysUnlockFromISR();
 80029d8:	f7ff fbc2 	bl	8002160 <osalSysUnlockFromISR.10656.4337>
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80029dc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80029e0:	3301      	adds	r3, #1
 80029e2:	f88d 300f 	strb.w	r3, [sp, #15]
 80029e6:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80029ea:	9b01      	ldr	r3, [sp, #4]
 80029ec:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80029ee:	689b      	ldr	r3, [r3, #8]
 80029f0:	429a      	cmp	r2, r3
 80029f2:	f67f af77 	bls.w	80028e4 <otg_isoc_in_failed_handler.10881.4278+0x14>
      usbp->txpending |= (1 << ep);
      osalThreadResumeI(&usbp->wait, MSG_OK);
      osalSysUnlockFromISR();
    }
  }
}
 80029f6:	b005      	add	sp, #20
 80029f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80029fc:	f3af 8000 	nop.w

08002a00 <otg_isoc_out_failed_handler.10884.4275>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 8002a00:	b500      	push	{lr}
 8002a02:	b085      	sub	sp, #20
 8002a04:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8002a06:	9b01      	ldr	r3, [sp, #4]
 8002a08:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8002a0a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8002a0c:	2300      	movs	r3, #0
 8002a0e:	f88d 300f 	strb.w	r3, [sp, #15]
 8002a12:	e040      	b.n	8002a96 <otg_isoc_out_failed_handler.10884.4275+0x96>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8002a14:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002a18:	9a02      	ldr	r2, [sp, #8]
 8002a1a:	3358      	adds	r3, #88	; 0x58
 8002a1c:	015b      	lsls	r3, r3, #5
 8002a1e:	4413      	add	r3, r2
 8002a20:	681b      	ldr	r3, [r3, #0]
 8002a22:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8002a26:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8002a2a:	d12f      	bne.n	8002a8c <otg_isoc_out_failed_handler.10884.4275+0x8c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8002a2c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002a30:	9a02      	ldr	r2, [sp, #8]
 8002a32:	3358      	adds	r3, #88	; 0x58
 8002a34:	015b      	lsls	r3, r3, #5
 8002a36:	4413      	add	r3, r2
 8002a38:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8002a3a:	2b00      	cmp	r3, #0
 8002a3c:	da26      	bge.n	8002a8c <otg_isoc_out_failed_handler.10884.4275+0x8c>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 8002a3e:	9b01      	ldr	r3, [sp, #4]
 8002a40:	895b      	ldrh	r3, [r3, #10]
 8002a42:	b29a      	uxth	r2, r3
 8002a44:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002a48:	2101      	movs	r1, #1
 8002a4a:	fa01 f303 	lsl.w	r3, r1, r3
 8002a4e:	b29b      	uxth	r3, r3
 8002a50:	43db      	mvns	r3, r3
 8002a52:	b29b      	uxth	r3, r3
 8002a54:	4013      	ands	r3, r2
 8002a56:	b29b      	uxth	r3, r3
 8002a58:	b29a      	uxth	r2, r3
 8002a5a:	9b01      	ldr	r3, [sp, #4]
 8002a5c:	815a      	strh	r2, [r3, #10]
 8002a5e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002a62:	9a01      	ldr	r2, [sp, #4]
 8002a64:	3302      	adds	r3, #2
 8002a66:	009b      	lsls	r3, r3, #2
 8002a68:	4413      	add	r3, r2
 8002a6a:	685b      	ldr	r3, [r3, #4]
 8002a6c:	68db      	ldr	r3, [r3, #12]
 8002a6e:	2b00      	cmp	r3, #0
 8002a70:	d00c      	beq.n	8002a8c <otg_isoc_out_failed_handler.10884.4275+0x8c>
 8002a72:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002a76:	9a01      	ldr	r2, [sp, #4]
 8002a78:	3302      	adds	r3, #2
 8002a7a:	009b      	lsls	r3, r3, #2
 8002a7c:	4413      	add	r3, r2
 8002a7e:	685b      	ldr	r3, [r3, #4]
 8002a80:	68db      	ldr	r3, [r3, #12]
 8002a82:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8002a86:	9801      	ldr	r0, [sp, #4]
 8002a88:	4611      	mov	r1, r2
 8002a8a:	4798      	blx	r3
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8002a8c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002a90:	3301      	adds	r3, #1
 8002a92:	f88d 300f 	strb.w	r3, [sp, #15]
 8002a96:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8002a9a:	9b01      	ldr	r3, [sp, #4]
 8002a9c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8002a9e:	689b      	ldr	r3, [r3, #8]
 8002aa0:	429a      	cmp	r2, r3
 8002aa2:	d9b7      	bls.n	8002a14 <otg_isoc_out_failed_handler.10884.4275+0x14>
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
    }
  }
}
 8002aa4:	b005      	add	sp, #20
 8002aa6:	f85d fb04 	ldr.w	pc, [sp], #4
 8002aaa:	bf00      	nop
 8002aac:	f3af 8000 	nop.w

08002ab0 <usb_lld_serve_interrupt.10939>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8002ab0:	b500      	push	{lr}
 8002ab2:	b087      	sub	sp, #28
 8002ab4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8002ab6:	9b01      	ldr	r3, [sp, #4]
 8002ab8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8002aba:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 8002abc:	9b05      	ldr	r3, [sp, #20]
 8002abe:	695b      	ldr	r3, [r3, #20]
 8002ac0:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 8002ac2:	9b05      	ldr	r3, [sp, #20]
 8002ac4:	699b      	ldr	r3, [r3, #24]
 8002ac6:	9a04      	ldr	r2, [sp, #16]
 8002ac8:	4013      	ands	r3, r2
 8002aca:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 8002acc:	9b05      	ldr	r3, [sp, #20]
 8002ace:	9a04      	ldr	r2, [sp, #16]
 8002ad0:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8002ad2:	9b04      	ldr	r3, [sp, #16]
 8002ad4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8002ad8:	2b00      	cmp	r3, #0
 8002ada:	d006      	beq.n	8002aea <usb_lld_serve_interrupt.10939+0x3a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8002adc:	9b01      	ldr	r3, [sp, #4]
 8002ade:	2200      	movs	r2, #0
 8002ae0:	675a      	str	r2, [r3, #116]	; 0x74

    /* Default reset action.*/
    _usb_reset(usbp);
 8002ae2:	9801      	ldr	r0, [sp, #4]
 8002ae4:	f001 f944 	bl	8003d70 <_usb_reset>
 8002ae8:	e0f2      	b.n	8002cd0 <usb_lld_serve_interrupt.10939+0x220>
    /* Preventing execution of more handlers, the core has been reset.*/
    return;
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 8002aea:	9b04      	ldr	r3, [sp, #16]
 8002aec:	2b00      	cmp	r3, #0
 8002aee:	da19      	bge.n	8002b24 <usb_lld_serve_interrupt.10939+0x74>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8002af0:	9b05      	ldr	r3, [sp, #20]
 8002af2:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8002af6:	f003 0303 	and.w	r3, r3, #3
 8002afa:	2b00      	cmp	r3, #0
 8002afc:	d007      	beq.n	8002b0e <usb_lld_serve_interrupt.10939+0x5e>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8002afe:	9b05      	ldr	r3, [sp, #20]
 8002b00:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8002b04:	f023 0203 	bic.w	r2, r3, #3
 8002b08:	9b05      	ldr	r3, [sp, #20]
 8002b0a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL |= DCTL_RWUSIG;
 8002b0e:	9b05      	ldr	r3, [sp, #20]
 8002b10:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8002b14:	f043 0201 	orr.w	r2, r3, #1
 8002b18:	9b05      	ldr	r3, [sp, #20]
 8002b1a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 8002b1e:	9801      	ldr	r0, [sp, #4]
 8002b20:	f001 f97e 	bl	8003e20 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8002b24:	9b04      	ldr	r3, [sp, #16]
 8002b26:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8002b2a:	2b00      	cmp	r3, #0
 8002b2c:	d005      	beq.n	8002b3a <usb_lld_serve_interrupt.10939+0x8a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8002b2e:	9b01      	ldr	r3, [sp, #4]
 8002b30:	2200      	movs	r2, #0
 8002b32:	675a      	str	r2, [r3, #116]	; 0x74

    /* Default suspend action.*/
    _usb_suspend(usbp);
 8002b34:	9801      	ldr	r0, [sp, #4]
 8002b36:	f001 f95b 	bl	8003df0 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 8002b3a:	9b04      	ldr	r3, [sp, #16]
 8002b3c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8002b40:	2b00      	cmp	r3, #0
 8002b42:	d017      	beq.n	8002b74 <usb_lld_serve_interrupt.10939+0xc4>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8002b44:	9b05      	ldr	r3, [sp, #20]
 8002b46:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8002b4a:	f003 0306 	and.w	r3, r3, #6
 8002b4e:	2b00      	cmp	r3, #0
 8002b50:	d108      	bne.n	8002b64 <usb_lld_serve_interrupt.10939+0xb4>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8002b52:	9b05      	ldr	r3, [sp, #20]
 8002b54:	68db      	ldr	r3, [r3, #12]
 8002b56:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8002b5a:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 8002b5e:	9b05      	ldr	r3, [sp, #20]
 8002b60:	60da      	str	r2, [r3, #12]
 8002b62:	e007      	b.n	8002b74 <usb_lld_serve_interrupt.10939+0xc4>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8002b64:	9b05      	ldr	r3, [sp, #20]
 8002b66:	68db      	ldr	r3, [r3, #12]
 8002b68:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8002b6c:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 8002b70:	9b05      	ldr	r3, [sp, #20]
 8002b72:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 8002b74:	9b04      	ldr	r3, [sp, #16]
 8002b76:	f003 0308 	and.w	r3, r3, #8
 8002b7a:	2b00      	cmp	r3, #0
 8002b7c:	d009      	beq.n	8002b92 <usb_lld_serve_interrupt.10939+0xe2>
    _usb_isr_invoke_sof_cb(usbp);
 8002b7e:	9b01      	ldr	r3, [sp, #4]
 8002b80:	685b      	ldr	r3, [r3, #4]
 8002b82:	68db      	ldr	r3, [r3, #12]
 8002b84:	2b00      	cmp	r3, #0
 8002b86:	d004      	beq.n	8002b92 <usb_lld_serve_interrupt.10939+0xe2>
 8002b88:	9b01      	ldr	r3, [sp, #4]
 8002b8a:	685b      	ldr	r3, [r3, #4]
 8002b8c:	68db      	ldr	r3, [r3, #12]
 8002b8e:	9801      	ldr	r0, [sp, #4]
 8002b90:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 8002b92:	9b04      	ldr	r3, [sp, #16]
 8002b94:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8002b98:	2b00      	cmp	r3, #0
 8002b9a:	d002      	beq.n	8002ba2 <usb_lld_serve_interrupt.10939+0xf2>
    otg_isoc_in_failed_handler(usbp);
 8002b9c:	9801      	ldr	r0, [sp, #4]
 8002b9e:	f7ff fe97 	bl	80028d0 <otg_isoc_in_failed_handler.10881.4278>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 8002ba2:	9b04      	ldr	r3, [sp, #16]
 8002ba4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8002ba8:	2b00      	cmp	r3, #0
 8002baa:	d002      	beq.n	8002bb2 <usb_lld_serve_interrupt.10939+0x102>
    otg_isoc_out_failed_handler(usbp);
 8002bac:	9801      	ldr	r0, [sp, #4]
 8002bae:	f7ff ff27 	bl	8002a00 <otg_isoc_out_failed_handler.10884.4275>
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 8002bb2:	9b04      	ldr	r3, [sp, #16]
 8002bb4:	f003 0310 	and.w	r3, r3, #16
 8002bb8:	2b00      	cmp	r3, #0
 8002bba:	d00f      	beq.n	8002bdc <usb_lld_serve_interrupt.10939+0x12c>
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
 8002bbc:	f7ff fac8 	bl	8002150 <osalSysLockFromISR.10566.4339>
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 8002bc0:	9b05      	ldr	r3, [sp, #20]
 8002bc2:	699b      	ldr	r3, [r3, #24]
 8002bc4:	f023 0210 	bic.w	r2, r3, #16
 8002bc8:	9b05      	ldr	r3, [sp, #20]
 8002bca:	619a      	str	r2, [r3, #24]
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8002bcc:	9b01      	ldr	r3, [sp, #4]
 8002bce:	3378      	adds	r3, #120	; 0x78
 8002bd0:	4618      	mov	r0, r3
 8002bd2:	2100      	movs	r1, #0
 8002bd4:	f7ff faec 	bl	80021b0 <osalThreadResumeI.10568.4327>
    osalSysUnlockFromISR();
 8002bd8:	f7ff fac2 	bl	8002160 <osalSysUnlockFromISR.10656.4337>
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8002bdc:	9b05      	ldr	r3, [sp, #20]
 8002bde:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 8002be2:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_IEPINT) {
 8002be4:	9b04      	ldr	r3, [sp, #16]
 8002be6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8002bea:	2b00      	cmp	r3, #0
 8002bec:	d035      	beq.n	8002c5a <usb_lld_serve_interrupt.10939+0x1aa>
    if (src & (1 << 0))
 8002bee:	9b03      	ldr	r3, [sp, #12]
 8002bf0:	f003 0301 	and.w	r3, r3, #1
 8002bf4:	2b00      	cmp	r3, #0
 8002bf6:	d003      	beq.n	8002c00 <usb_lld_serve_interrupt.10939+0x150>
      otg_epin_handler(usbp, 0);
 8002bf8:	9801      	ldr	r0, [sp, #4]
 8002bfa:	2100      	movs	r1, #0
 8002bfc:	f7ff fd20 	bl	8002640 <otg_epin_handler.10935.4285>
    if (src & (1 << 1))
 8002c00:	9b03      	ldr	r3, [sp, #12]
 8002c02:	f003 0302 	and.w	r3, r3, #2
 8002c06:	2b00      	cmp	r3, #0
 8002c08:	d003      	beq.n	8002c12 <usb_lld_serve_interrupt.10939+0x162>
      otg_epin_handler(usbp, 1);
 8002c0a:	9801      	ldr	r0, [sp, #4]
 8002c0c:	2101      	movs	r1, #1
 8002c0e:	f7ff fd17 	bl	8002640 <otg_epin_handler.10935.4285>
    if (src & (1 << 2))
 8002c12:	9b03      	ldr	r3, [sp, #12]
 8002c14:	f003 0304 	and.w	r3, r3, #4
 8002c18:	2b00      	cmp	r3, #0
 8002c1a:	d003      	beq.n	8002c24 <usb_lld_serve_interrupt.10939+0x174>
      otg_epin_handler(usbp, 2);
 8002c1c:	9801      	ldr	r0, [sp, #4]
 8002c1e:	2102      	movs	r1, #2
 8002c20:	f7ff fd0e 	bl	8002640 <otg_epin_handler.10935.4285>
    if (src & (1 << 3))
 8002c24:	9b03      	ldr	r3, [sp, #12]
 8002c26:	f003 0308 	and.w	r3, r3, #8
 8002c2a:	2b00      	cmp	r3, #0
 8002c2c:	d003      	beq.n	8002c36 <usb_lld_serve_interrupt.10939+0x186>
      otg_epin_handler(usbp, 3);
 8002c2e:	9801      	ldr	r0, [sp, #4]
 8002c30:	2103      	movs	r1, #3
 8002c32:	f7ff fd05 	bl	8002640 <otg_epin_handler.10935.4285>
#if STM32_USB_USE_OTG2
    if (src & (1 << 4))
 8002c36:	9b03      	ldr	r3, [sp, #12]
 8002c38:	f003 0310 	and.w	r3, r3, #16
 8002c3c:	2b00      	cmp	r3, #0
 8002c3e:	d003      	beq.n	8002c48 <usb_lld_serve_interrupt.10939+0x198>
      otg_epin_handler(usbp, 4);
 8002c40:	9801      	ldr	r0, [sp, #4]
 8002c42:	2104      	movs	r1, #4
 8002c44:	f7ff fcfc 	bl	8002640 <otg_epin_handler.10935.4285>
    if (src & (1 << 5))
 8002c48:	9b03      	ldr	r3, [sp, #12]
 8002c4a:	f003 0320 	and.w	r3, r3, #32
 8002c4e:	2b00      	cmp	r3, #0
 8002c50:	d003      	beq.n	8002c5a <usb_lld_serve_interrupt.10939+0x1aa>
      otg_epin_handler(usbp, 5);
 8002c52:	9801      	ldr	r0, [sp, #4]
 8002c54:	2105      	movs	r1, #5
 8002c56:	f7ff fcf3 	bl	8002640 <otg_epin_handler.10935.4285>
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 8002c5a:	9b04      	ldr	r3, [sp, #16]
 8002c5c:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8002c60:	2b00      	cmp	r3, #0
 8002c62:	d035      	beq.n	8002cd0 <usb_lld_serve_interrupt.10939+0x220>
    if (src & (1 << 16))
 8002c64:	9b03      	ldr	r3, [sp, #12]
 8002c66:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002c6a:	2b00      	cmp	r3, #0
 8002c6c:	d003      	beq.n	8002c76 <usb_lld_serve_interrupt.10939+0x1c6>
      otg_epout_handler(usbp, 0);
 8002c6e:	9801      	ldr	r0, [sp, #4]
 8002c70:	2100      	movs	r1, #0
 8002c72:	f7ff fd8d 	bl	8002790 <otg_epout_handler.10927.4281>
    if (src & (1 << 17))
 8002c76:	9b03      	ldr	r3, [sp, #12]
 8002c78:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8002c7c:	2b00      	cmp	r3, #0
 8002c7e:	d003      	beq.n	8002c88 <usb_lld_serve_interrupt.10939+0x1d8>
      otg_epout_handler(usbp, 1);
 8002c80:	9801      	ldr	r0, [sp, #4]
 8002c82:	2101      	movs	r1, #1
 8002c84:	f7ff fd84 	bl	8002790 <otg_epout_handler.10927.4281>
    if (src & (1 << 18))
 8002c88:	9b03      	ldr	r3, [sp, #12]
 8002c8a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8002c8e:	2b00      	cmp	r3, #0
 8002c90:	d003      	beq.n	8002c9a <usb_lld_serve_interrupt.10939+0x1ea>
      otg_epout_handler(usbp, 2);
 8002c92:	9801      	ldr	r0, [sp, #4]
 8002c94:	2102      	movs	r1, #2
 8002c96:	f7ff fd7b 	bl	8002790 <otg_epout_handler.10927.4281>
    if (src & (1 << 19))
 8002c9a:	9b03      	ldr	r3, [sp, #12]
 8002c9c:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8002ca0:	2b00      	cmp	r3, #0
 8002ca2:	d003      	beq.n	8002cac <usb_lld_serve_interrupt.10939+0x1fc>
      otg_epout_handler(usbp, 3);
 8002ca4:	9801      	ldr	r0, [sp, #4]
 8002ca6:	2103      	movs	r1, #3
 8002ca8:	f7ff fd72 	bl	8002790 <otg_epout_handler.10927.4281>
#if STM32_USB_USE_OTG2
    if (src & (1 << 20))
 8002cac:	9b03      	ldr	r3, [sp, #12]
 8002cae:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8002cb2:	2b00      	cmp	r3, #0
 8002cb4:	d003      	beq.n	8002cbe <usb_lld_serve_interrupt.10939+0x20e>
      otg_epout_handler(usbp, 4);
 8002cb6:	9801      	ldr	r0, [sp, #4]
 8002cb8:	2104      	movs	r1, #4
 8002cba:	f7ff fd69 	bl	8002790 <otg_epout_handler.10927.4281>
    if (src & (1 << 21))
 8002cbe:	9b03      	ldr	r3, [sp, #12]
 8002cc0:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8002cc4:	2b00      	cmp	r3, #0
 8002cc6:	d003      	beq.n	8002cd0 <usb_lld_serve_interrupt.10939+0x220>
      otg_epout_handler(usbp, 5);
 8002cc8:	9801      	ldr	r0, [sp, #4]
 8002cca:	2105      	movs	r1, #5
 8002ccc:	f7ff fd60 	bl	8002790 <otg_epout_handler.10927.4281>
#endif
  }
}
 8002cd0:	b007      	add	sp, #28
 8002cd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002cd6:	bf00      	nop
 8002cd8:	f3af 8000 	nop.w
 8002cdc:	f3af 8000 	nop.w

08002ce0 <chSysLock.9374.4525>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002ce0:	b508      	push	{r3, lr}

  port_lock();
 8002ce2:	f002 f865 	bl	8004db0 <port_lock.9201>
  _stats_start_measure_crit_thd();
 8002ce6:	f003 fe2b 	bl	8006940 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8002cea:	f002 fc39 	bl	8005560 <_dbg_check_lock>
}
 8002cee:	bd08      	pop	{r3, pc}

08002cf0 <chSysUnlock.9378.4523>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002cf0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8002cf2:	f002 fc55 	bl	80055a0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8002cf6:	f003 fe2b 	bl	8006950 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002cfa:	f640 0308 	movw	r3, #2056	; 0x808
 8002cfe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d02:	681a      	ldr	r2, [r3, #0]
 8002d04:	f640 0308 	movw	r3, #2056	; 0x808
 8002d08:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d0c:	429a      	cmp	r2, r3
 8002d0e:	d013      	beq.n	8002d38 <chSysUnlock.9378.4523+0x48>
 8002d10:	f640 0308 	movw	r3, #2056	; 0x808
 8002d14:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d18:	699b      	ldr	r3, [r3, #24]
 8002d1a:	689a      	ldr	r2, [r3, #8]
 8002d1c:	f640 0308 	movw	r3, #2056	; 0x808
 8002d20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002d24:	681b      	ldr	r3, [r3, #0]
 8002d26:	689b      	ldr	r3, [r3, #8]
 8002d28:	429a      	cmp	r2, r3
 8002d2a:	d205      	bcs.n	8002d38 <chSysUnlock.9378.4523+0x48>
 8002d2c:	f247 70b0 	movw	r0, #30640	; 0x77b0
 8002d30:	f6c0 0000 	movt	r0, #2048	; 0x800
 8002d34:	f002 fb7c 	bl	8005430 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002d38:	f002 f842 	bl	8004dc0 <port_unlock.9204>
}
 8002d3c:	bd08      	pop	{r3, pc}
 8002d3e:	bf00      	nop

08002d40 <chSysLockFromISR.9388.4521>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002d40:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002d42:	f002 f845 	bl	8004dd0 <port_lock_from_isr.9206>
  _stats_start_measure_crit_isr();
 8002d46:	f003 fe0b 	bl	8006960 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8002d4a:	f002 fc49 	bl	80055e0 <_dbg_check_lock_from_isr>
}
 8002d4e:	bd08      	pop	{r3, pc}

08002d50 <chSysUnlockFromISR.9392.4519>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002d50:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8002d52:	f002 fc65 	bl	8005620 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8002d56:	f003 fe0b 	bl	8006970 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8002d5a:	f002 f841 	bl	8004de0 <port_unlock_from_isr.9208>
}
 8002d5e:	bd08      	pop	{r3, pc}

08002d60 <chEvtObjectInit.9210.4516>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8002d60:	b082      	sub	sp, #8
 8002d62:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8002d64:	9b01      	ldr	r3, [sp, #4]
 8002d66:	9a01      	ldr	r2, [sp, #4]
 8002d68:	601a      	str	r2, [r3, #0]
}
 8002d6a:	b002      	add	sp, #8
 8002d6c:	4770      	bx	lr
 8002d6e:	bf00      	nop

08002d70 <osalSysLock.9376.4514>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8002d70:	b508      	push	{r3, lr}

  chSysLock();
 8002d72:	f7ff ffb5 	bl	8002ce0 <chSysLock.9374.4525>
}
 8002d76:	bd08      	pop	{r3, pc}
 8002d78:	f3af 8000 	nop.w
 8002d7c:	f3af 8000 	nop.w

08002d80 <osalSysUnlock.9380.4512>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8002d80:	b508      	push	{r3, lr}

  chSysUnlock();
 8002d82:	f7ff ffb5 	bl	8002cf0 <chSysUnlock.9378.4523>
}
 8002d86:	bd08      	pop	{r3, pc}
 8002d88:	f3af 8000 	nop.w
 8002d8c:	f3af 8000 	nop.w

08002d90 <osalSysLockFromISR.9390.4510>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8002d90:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8002d92:	f7ff ffd5 	bl	8002d40 <chSysLockFromISR.9388.4521>
}
 8002d96:	bd08      	pop	{r3, pc}
 8002d98:	f3af 8000 	nop.w
 8002d9c:	f3af 8000 	nop.w

08002da0 <osalSysUnlockFromISR.9394.4508>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8002da0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8002da2:	f7ff ffd5 	bl	8002d50 <chSysUnlockFromISR.9392.4519>
}
 8002da6:	bd08      	pop	{r3, pc}
 8002da8:	f3af 8000 	nop.w
 8002dac:	f3af 8000 	nop.w

08002db0 <osalEventObjectInit.9310.4503>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8002db0:	b500      	push	{lr}
 8002db2:	b083      	sub	sp, #12
 8002db4:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8002db6:	9801      	ldr	r0, [sp, #4]
 8002db8:	f7ff ffd2 	bl	8002d60 <chEvtObjectInit.9210.4516>
}
 8002dbc:	b003      	add	sp, #12
 8002dbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8002dc2:	bf00      	nop
 8002dc4:	f3af 8000 	nop.w
 8002dc8:	f3af 8000 	nop.w
 8002dcc:	f3af 8000 	nop.w

08002dd0 <osalEventBroadcastFlagsI.9384.4499>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b083      	sub	sp, #12
 8002dd4:	9001      	str	r0, [sp, #4]
 8002dd6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8002dd8:	9801      	ldr	r0, [sp, #4]
 8002dda:	9900      	ldr	r1, [sp, #0]
 8002ddc:	f002 f808 	bl	8004df0 <chEvtBroadcastFlagsI>
}
 8002de0:	b003      	add	sp, #12
 8002de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002de6:	bf00      	nop
 8002de8:	f3af 8000 	nop.w
 8002dec:	f3af 8000 	nop.w

08002df0 <write.9313>:

/*
 * Interface implementation.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8002df0:	b500      	push	{lr}
 8002df2:	b085      	sub	sp, #20
 8002df4:	9003      	str	r0, [sp, #12]
 8002df6:	9102      	str	r1, [sp, #8]
 8002df8:	9201      	str	r2, [sp, #4]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8002dfa:	9b03      	ldr	r3, [sp, #12]
 8002dfc:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8002e00:	681b      	ldr	r3, [r3, #0]
 8002e02:	781b      	ldrb	r3, [r3, #0]
 8002e04:	2b04      	cmp	r3, #4
 8002e06:	d001      	beq.n	8002e0c <write.9313+0x1c>
    return 0;
 8002e08:	2300      	movs	r3, #0
 8002e0a:	e009      	b.n	8002e20 <write.9313+0x30>
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 8002e0c:	9b03      	ldr	r3, [sp, #12]
 8002e0e:	3340      	adds	r3, #64	; 0x40
 8002e10:	4618      	mov	r0, r3
 8002e12:	9902      	ldr	r1, [sp, #8]
 8002e14:	9a01      	ldr	r2, [sp, #4]
 8002e16:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002e1a:	f001 fee1 	bl	8004be0 <obqWriteTimeout>
 8002e1e:	4603      	mov	r3, r0
                         n, TIME_INFINITE);
}
 8002e20:	4618      	mov	r0, r3
 8002e22:	b005      	add	sp, #20
 8002e24:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e28:	f3af 8000 	nop.w
 8002e2c:	f3af 8000 	nop.w

08002e30 <read.9326>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8002e30:	b500      	push	{lr}
 8002e32:	b085      	sub	sp, #20
 8002e34:	9003      	str	r0, [sp, #12]
 8002e36:	9102      	str	r1, [sp, #8]
 8002e38:	9201      	str	r2, [sp, #4]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8002e3a:	9b03      	ldr	r3, [sp, #12]
 8002e3c:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8002e40:	681b      	ldr	r3, [r3, #0]
 8002e42:	781b      	ldrb	r3, [r3, #0]
 8002e44:	2b04      	cmp	r3, #4
 8002e46:	d001      	beq.n	8002e4c <read.9326+0x1c>
    return 0;
 8002e48:	2300      	movs	r3, #0
 8002e4a:	e009      	b.n	8002e60 <read.9326+0x30>
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 8002e4c:	9b03      	ldr	r3, [sp, #12]
 8002e4e:	330c      	adds	r3, #12
 8002e50:	4618      	mov	r0, r3
 8002e52:	9902      	ldr	r1, [sp, #8]
 8002e54:	9a01      	ldr	r2, [sp, #4]
 8002e56:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002e5a:	f001 fca9 	bl	80047b0 <ibqReadTimeout>
 8002e5e:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 8002e60:	4618      	mov	r0, r3
 8002e62:	b005      	add	sp, #20
 8002e64:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e68:	f3af 8000 	nop.w
 8002e6c:	f3af 8000 	nop.w

08002e70 <put.9337>:

static msg_t put(void *ip, uint8_t b) {
 8002e70:	b500      	push	{lr}
 8002e72:	b083      	sub	sp, #12
 8002e74:	9001      	str	r0, [sp, #4]
 8002e76:	460b      	mov	r3, r1
 8002e78:	f88d 3003 	strb.w	r3, [sp, #3]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8002e7c:	9b01      	ldr	r3, [sp, #4]
 8002e7e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8002e82:	681b      	ldr	r3, [r3, #0]
 8002e84:	781b      	ldrb	r3, [r3, #0]
 8002e86:	2b04      	cmp	r3, #4
 8002e88:	d002      	beq.n	8002e90 <put.9337+0x20>
    return MSG_RESET;
 8002e8a:	f06f 0301 	mvn.w	r3, #1
 8002e8e:	e00b      	b.n	8002ea8 <put.9337+0x38>
  }

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8002e90:	9b01      	ldr	r3, [sp, #4]
 8002e92:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8002e96:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002e9a:	4610      	mov	r0, r2
 8002e9c:	4619      	mov	r1, r3
 8002e9e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002ea2:	f001 fe65 	bl	8004b70 <obqPutTimeout>
 8002ea6:	4603      	mov	r3, r0
}
 8002ea8:	4618      	mov	r0, r3
 8002eaa:	b003      	add	sp, #12
 8002eac:	f85d fb04 	ldr.w	pc, [sp], #4

08002eb0 <get.9346>:

static msg_t get(void *ip) {
 8002eb0:	b500      	push	{lr}
 8002eb2:	b083      	sub	sp, #12
 8002eb4:	9001      	str	r0, [sp, #4]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8002eb6:	9b01      	ldr	r3, [sp, #4]
 8002eb8:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8002ebc:	681b      	ldr	r3, [r3, #0]
 8002ebe:	781b      	ldrb	r3, [r3, #0]
 8002ec0:	2b04      	cmp	r3, #4
 8002ec2:	d002      	beq.n	8002eca <get.9346+0x1a>
    return MSG_RESET;
 8002ec4:	f06f 0301 	mvn.w	r3, #1
 8002ec8:	e007      	b.n	8002eda <get.9346+0x2a>
  }

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 8002eca:	9b01      	ldr	r3, [sp, #4]
 8002ecc:	330c      	adds	r3, #12
 8002ece:	4618      	mov	r0, r3
 8002ed0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8002ed4:	f001 fc3c 	bl	8004750 <ibqGetTimeout>
 8002ed8:	4603      	mov	r3, r0
}
 8002eda:	4618      	mov	r0, r3
 8002edc:	b003      	add	sp, #12
 8002ede:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ee2:	bf00      	nop
 8002ee4:	f3af 8000 	nop.w
 8002ee8:	f3af 8000 	nop.w
 8002eec:	f3af 8000 	nop.w

08002ef0 <putt.9341>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8002ef0:	b500      	push	{lr}
 8002ef2:	b085      	sub	sp, #20
 8002ef4:	9003      	str	r0, [sp, #12]
 8002ef6:	460b      	mov	r3, r1
 8002ef8:	9201      	str	r2, [sp, #4]
 8002efa:	f88d 300b 	strb.w	r3, [sp, #11]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8002efe:	9b03      	ldr	r3, [sp, #12]
 8002f00:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8002f04:	681b      	ldr	r3, [r3, #0]
 8002f06:	781b      	ldrb	r3, [r3, #0]
 8002f08:	2b04      	cmp	r3, #4
 8002f0a:	d002      	beq.n	8002f12 <putt.9341+0x22>
    return MSG_RESET;
 8002f0c:	f06f 0301 	mvn.w	r3, #1
 8002f10:	e00a      	b.n	8002f28 <putt.9341+0x38>
  }

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8002f12:	9b03      	ldr	r3, [sp, #12]
 8002f14:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8002f18:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8002f1c:	4610      	mov	r0, r2
 8002f1e:	4619      	mov	r1, r3
 8002f20:	9a01      	ldr	r2, [sp, #4]
 8002f22:	f001 fe25 	bl	8004b70 <obqPutTimeout>
 8002f26:	4603      	mov	r3, r0
}
 8002f28:	4618      	mov	r0, r3
 8002f2a:	b005      	add	sp, #20
 8002f2c:	f85d fb04 	ldr.w	pc, [sp], #4

08002f30 <gett.9349>:

static msg_t gett(void *ip, systime_t timeout) {
 8002f30:	b500      	push	{lr}
 8002f32:	b083      	sub	sp, #12
 8002f34:	9001      	str	r0, [sp, #4]
 8002f36:	9100      	str	r1, [sp, #0]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8002f38:	9b01      	ldr	r3, [sp, #4]
 8002f3a:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8002f3e:	681b      	ldr	r3, [r3, #0]
 8002f40:	781b      	ldrb	r3, [r3, #0]
 8002f42:	2b04      	cmp	r3, #4
 8002f44:	d002      	beq.n	8002f4c <gett.9349+0x1c>
    return MSG_RESET;
 8002f46:	f06f 0301 	mvn.w	r3, #1
 8002f4a:	e006      	b.n	8002f5a <gett.9349+0x2a>
  }

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 8002f4c:	9b01      	ldr	r3, [sp, #4]
 8002f4e:	330c      	adds	r3, #12
 8002f50:	4618      	mov	r0, r3
 8002f52:	9900      	ldr	r1, [sp, #0]
 8002f54:	f001 fbfc 	bl	8004750 <ibqGetTimeout>
 8002f58:	4603      	mov	r3, r0
}
 8002f5a:	4618      	mov	r0, r3
 8002f5c:	b003      	add	sp, #12
 8002f5e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f62:	bf00      	nop
 8002f64:	f3af 8000 	nop.w
 8002f68:	f3af 8000 	nop.w
 8002f6c:	f3af 8000 	nop.w

08002f70 <writet.9319>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8002f70:	b500      	push	{lr}
 8002f72:	b085      	sub	sp, #20
 8002f74:	9003      	str	r0, [sp, #12]
 8002f76:	9102      	str	r1, [sp, #8]
 8002f78:	9201      	str	r2, [sp, #4]
 8002f7a:	9300      	str	r3, [sp, #0]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8002f7c:	9b03      	ldr	r3, [sp, #12]
 8002f7e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8002f82:	681b      	ldr	r3, [r3, #0]
 8002f84:	781b      	ldrb	r3, [r3, #0]
 8002f86:	2b04      	cmp	r3, #4
 8002f88:	d001      	beq.n	8002f8e <writet.9319+0x1e>
    return 0;
 8002f8a:	2300      	movs	r3, #0
 8002f8c:	e008      	b.n	8002fa0 <writet.9319+0x30>
  }

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 8002f8e:	9b03      	ldr	r3, [sp, #12]
 8002f90:	3340      	adds	r3, #64	; 0x40
 8002f92:	4618      	mov	r0, r3
 8002f94:	9902      	ldr	r1, [sp, #8]
 8002f96:	9a01      	ldr	r2, [sp, #4]
 8002f98:	9b00      	ldr	r3, [sp, #0]
 8002f9a:	f001 fe21 	bl	8004be0 <obqWriteTimeout>
 8002f9e:	4603      	mov	r3, r0
}
 8002fa0:	4618      	mov	r0, r3
 8002fa2:	b005      	add	sp, #20
 8002fa4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002fa8:	f3af 8000 	nop.w
 8002fac:	f3af 8000 	nop.w

08002fb0 <readt.9331>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8002fb0:	b500      	push	{lr}
 8002fb2:	b085      	sub	sp, #20
 8002fb4:	9003      	str	r0, [sp, #12]
 8002fb6:	9102      	str	r1, [sp, #8]
 8002fb8:	9201      	str	r2, [sp, #4]
 8002fba:	9300      	str	r3, [sp, #0]

  if (usbGetDriverStateI(((SerialUSBDriver *)ip)->config->usbp) != USB_ACTIVE) {
 8002fbc:	9b03      	ldr	r3, [sp, #12]
 8002fbe:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8002fc2:	681b      	ldr	r3, [r3, #0]
 8002fc4:	781b      	ldrb	r3, [r3, #0]
 8002fc6:	2b04      	cmp	r3, #4
 8002fc8:	d001      	beq.n	8002fce <readt.9331+0x1e>
    return 0;
 8002fca:	2300      	movs	r3, #0
 8002fcc:	e008      	b.n	8002fe0 <readt.9331+0x30>
  }

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 8002fce:	9b03      	ldr	r3, [sp, #12]
 8002fd0:	330c      	adds	r3, #12
 8002fd2:	4618      	mov	r0, r3
 8002fd4:	9902      	ldr	r1, [sp, #8]
 8002fd6:	9a01      	ldr	r2, [sp, #4]
 8002fd8:	9b00      	ldr	r3, [sp, #0]
 8002fda:	f001 fbe9 	bl	80047b0 <ibqReadTimeout>
 8002fde:	4603      	mov	r3, r0
}
 8002fe0:	4618      	mov	r0, r3
 8002fe2:	b005      	add	sp, #20
 8002fe4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002fe8:	f3af 8000 	nop.w
 8002fec:	f3af 8000 	nop.w

08002ff0 <ibnotify.9353.4453>:
/**
 * @brief   Notification of empty buffer released into the input buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void ibnotify(io_buffers_queue_t *bqp) {
 8002ff0:	b500      	push	{lr}
 8002ff2:	b085      	sub	sp, #20
 8002ff4:	9001      	str	r0, [sp, #4]
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8002ff6:	9b01      	ldr	r3, [sp, #4]
 8002ff8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002ffa:	9303      	str	r3, [sp, #12]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8002ffc:	9b03      	ldr	r3, [sp, #12]
 8002ffe:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8003002:	681b      	ldr	r3, [r3, #0]
 8003004:	781b      	ldrb	r3, [r3, #0]
 8003006:	2b04      	cmp	r3, #4
 8003008:	d12c      	bne.n	8003064 <ibnotify.9353.4453+0x74>
      (sdup->state != SDU_READY)) {
 800300a:	9b03      	ldr	r3, [sp, #12]
 800300c:	7a1b      	ldrb	r3, [r3, #8]
static void ibnotify(io_buffers_queue_t *bqp) {
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800300e:	2b02      	cmp	r3, #2
 8003010:	d128      	bne.n	8003064 <ibnotify.9353.4453+0x74>
      (sdup->state != SDU_READY)) {
    return;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 8003012:	9b03      	ldr	r3, [sp, #12]
 8003014:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8003018:	681b      	ldr	r3, [r3, #0]
 800301a:	895a      	ldrh	r2, [r3, #10]
 800301c:	9b03      	ldr	r3, [sp, #12]
 800301e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8003022:	795b      	ldrb	r3, [r3, #5]
 8003024:	2101      	movs	r1, #1
 8003026:	fa01 f303 	lsl.w	r3, r1, r3
 800302a:	b29b      	uxth	r3, r3
 800302c:	4013      	ands	r3, r2
 800302e:	b29b      	uxth	r3, r3
 8003030:	2b00      	cmp	r3, #0
 8003032:	d117      	bne.n	8003064 <ibnotify.9353.4453+0x74>
    /* Trying to get a free buffer.*/
    uint8_t *buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 8003034:	9b03      	ldr	r3, [sp, #12]
 8003036:	330c      	adds	r3, #12
 8003038:	4618      	mov	r0, r3
 800303a:	f001 faa9 	bl	8004590 <ibqGetEmptyBufferI>
 800303e:	9002      	str	r0, [sp, #8]
    if (buf != NULL) {
 8003040:	9b02      	ldr	r3, [sp, #8]
 8003042:	2b00      	cmp	r3, #0
 8003044:	d00e      	beq.n	8003064 <ibnotify.9353.4453+0x74>
      /* Buffer found, starting a new transaction.*/
      usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 8003046:	9b03      	ldr	r3, [sp, #12]
 8003048:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800304c:	681a      	ldr	r2, [r3, #0]
 800304e:	9b03      	ldr	r3, [sp, #12]
 8003050:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8003054:	795b      	ldrb	r3, [r3, #5]
 8003056:	4610      	mov	r0, r2
 8003058:	4619      	mov	r1, r3
 800305a:	9a02      	ldr	r2, [sp, #8]
 800305c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003060:	f000 fde6 	bl	8003c30 <usbStartReceiveI>
                       buf, SERIAL_USB_BUFFERS_SIZE);
    }
  }
}
 8003064:	b005      	add	sp, #20
 8003066:	f85d fb04 	ldr.w	pc, [sp], #4
 800306a:	bf00      	nop
 800306c:	f3af 8000 	nop.w

08003070 <obnotify.9371.4456>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 8003070:	b500      	push	{lr}
 8003072:	b087      	sub	sp, #28
 8003074:	9001      	str	r0, [sp, #4]
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8003076:	9b01      	ldr	r3, [sp, #4]
 8003078:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800307a:	9305      	str	r3, [sp, #20]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800307c:	9b05      	ldr	r3, [sp, #20]
 800307e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8003082:	681b      	ldr	r3, [r3, #0]
 8003084:	781b      	ldrb	r3, [r3, #0]
 8003086:	2b04      	cmp	r3, #4
 8003088:	d12f      	bne.n	80030ea <obnotify.9371.4456+0x7a>
      (sdup->state != SDU_READY)) {
 800308a:	9b05      	ldr	r3, [sp, #20]
 800308c:	7a1b      	ldrb	r3, [r3, #8]
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800308e:	2b02      	cmp	r3, #2
 8003090:	d12b      	bne.n	80030ea <obnotify.9371.4456+0x7a>
      (sdup->state != SDU_READY)) {
    return;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8003092:	9b05      	ldr	r3, [sp, #20]
 8003094:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8003098:	681b      	ldr	r3, [r3, #0]
 800309a:	891a      	ldrh	r2, [r3, #8]
 800309c:	9b05      	ldr	r3, [sp, #20]
 800309e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80030a2:	791b      	ldrb	r3, [r3, #4]
 80030a4:	2101      	movs	r1, #1
 80030a6:	fa01 f303 	lsl.w	r3, r1, r3
 80030aa:	b29b      	uxth	r3, r3
 80030ac:	4013      	ands	r3, r2
 80030ae:	b29b      	uxth	r3, r3
 80030b0:	2b00      	cmp	r3, #0
 80030b2:	d11b      	bne.n	80030ec <obnotify.9371.4456+0x7c>
    /* Trying to get a full buffer.*/
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80030b4:	9b05      	ldr	r3, [sp, #20]
 80030b6:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80030ba:	ab03      	add	r3, sp, #12
 80030bc:	4610      	mov	r0, r2
 80030be:	4619      	mov	r1, r3
 80030c0:	f001 fc6e 	bl	80049a0 <obqGetFullBufferI>
 80030c4:	9004      	str	r0, [sp, #16]
    if (buf != NULL) {
 80030c6:	9b04      	ldr	r3, [sp, #16]
 80030c8:	2b00      	cmp	r3, #0
 80030ca:	d00f      	beq.n	80030ec <obnotify.9371.4456+0x7c>
      /* Buffer found, starting a new transaction.*/
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80030cc:	9b05      	ldr	r3, [sp, #20]
 80030ce:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80030d2:	6819      	ldr	r1, [r3, #0]
 80030d4:	9b05      	ldr	r3, [sp, #20]
 80030d6:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80030da:	791a      	ldrb	r2, [r3, #4]
 80030dc:	9b03      	ldr	r3, [sp, #12]
 80030de:	4608      	mov	r0, r1
 80030e0:	4611      	mov	r1, r2
 80030e2:	9a04      	ldr	r2, [sp, #16]
 80030e4:	f000 fdf4 	bl	8003cd0 <usbStartTransmitI>
 80030e8:	e000      	b.n	80030ec <obnotify.9371.4456+0x7c>

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
      (sdup->state != SDU_READY)) {
    return;
 80030ea:	bf00      	nop
    if (buf != NULL) {
      /* Buffer found, starting a new transaction.*/
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
    }
  }
}
 80030ec:	b007      	add	sp, #28
 80030ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80030f2:	bf00      	nop
 80030f4:	f3af 8000 	nop.w
 80030f8:	f3af 8000 	nop.w
 80030fc:	f3af 8000 	nop.w

08003100 <sduInit>:
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
}
 8003100:	4770      	bx	lr
 8003102:	bf00      	nop
 8003104:	f3af 8000 	nop.w
 8003108:	f3af 8000 	nop.w
 800310c:	f3af 8000 	nop.w

08003110 <sduObjectInit>:
 *
 * @param[out] sdup     pointer to a @p SerialUSBDriver structure
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {
 8003110:	b500      	push	{lr}
 8003112:	b085      	sub	sp, #20
 8003114:	9003      	str	r0, [sp, #12]

  sdup->vmt = &vmt;
 8003116:	9a03      	ldr	r2, [sp, #12]
 8003118:	f247 7380 	movw	r3, #30592	; 0x7780
 800311c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003120:	6013      	str	r3, [r2, #0]
  osalEventObjectInit(&sdup->event);
 8003122:	9b03      	ldr	r3, [sp, #12]
 8003124:	3304      	adds	r3, #4
 8003126:	4618      	mov	r0, r3
 8003128:	f7ff fe42 	bl	8002db0 <osalEventObjectInit.9310.4503>
  sdup->state = SDU_STOP;
 800312c:	9b03      	ldr	r3, [sp, #12]
 800312e:	2201      	movs	r2, #1
 8003130:	721a      	strb	r2, [r3, #8]
  ibqObjectInit(&sdup->ibqueue, sdup->ib,
 8003132:	9b03      	ldr	r3, [sp, #12]
 8003134:	f103 010c 	add.w	r1, r3, #12
 8003138:	9b03      	ldr	r3, [sp, #12]
 800313a:	f103 0274 	add.w	r2, r3, #116	; 0x74
 800313e:	f642 73f1 	movw	r3, #12273	; 0x2ff1
 8003142:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003146:	9300      	str	r3, [sp, #0]
 8003148:	9b03      	ldr	r3, [sp, #12]
 800314a:	9301      	str	r3, [sp, #4]
 800314c:	4608      	mov	r0, r1
 800314e:	4611      	mov	r1, r2
 8003150:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003154:	2302      	movs	r3, #2
 8003156:	f001 f9b3 	bl	80044c0 <ibqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                ibnotify, sdup);
  obqObjectInit(&sdup->obqueue, sdup->ob,
 800315a:	9b03      	ldr	r3, [sp, #12]
 800315c:	f103 0140 	add.w	r1, r3, #64	; 0x40
 8003160:	9b03      	ldr	r3, [sp, #12]
 8003162:	f503 721f 	add.w	r2, r3, #636	; 0x27c
 8003166:	f243 0371 	movw	r3, #12401	; 0x3071
 800316a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800316e:	9300      	str	r3, [sp, #0]
 8003170:	9b03      	ldr	r3, [sp, #12]
 8003172:	9301      	str	r3, [sp, #4]
 8003174:	4608      	mov	r0, r1
 8003176:	4611      	mov	r1, r2
 8003178:	f44f 7280 	mov.w	r2, #256	; 0x100
 800317c:	2302      	movs	r3, #2
 800317e:	f001 fba7 	bl	80048d0 <obqObjectInit>
                SERIAL_USB_BUFFERS_SIZE, SERIAL_USB_BUFFERS_NUMBER,
                obnotify, sdup);
}
 8003182:	b005      	add	sp, #20
 8003184:	f85d fb04 	ldr.w	pc, [sp], #4
 8003188:	f3af 8000 	nop.w
 800318c:	f3af 8000 	nop.w

08003190 <sduStart>:
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 * @param[in] config    the serial over USB driver configuration
 *
 * @api
 */
void sduStart(SerialUSBDriver *sdup, const SerialUSBConfig *config) {
 8003190:	b500      	push	{lr}
 8003192:	b085      	sub	sp, #20
 8003194:	9001      	str	r0, [sp, #4]
 8003196:	9100      	str	r1, [sp, #0]
  USBDriver *usbp = config->usbp;
 8003198:	9b00      	ldr	r3, [sp, #0]
 800319a:	681b      	ldr	r3, [r3, #0]
 800319c:	9303      	str	r3, [sp, #12]

  osalDbgCheck(sdup != NULL);
 800319e:	9b01      	ldr	r3, [sp, #4]
 80031a0:	2b00      	cmp	r3, #0
 80031a2:	d105      	bne.n	80031b0 <sduStart+0x20>
 80031a4:	f247 70a0 	movw	r0, #30624	; 0x77a0
 80031a8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80031ac:	f002 f940 	bl	8005430 <chSysHalt>

  osalSysLock();
 80031b0:	f7ff fdde 	bl	8002d70 <osalSysLock.9376.4514>
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 80031b4:	9b01      	ldr	r3, [sp, #4]
 80031b6:	7a1b      	ldrb	r3, [r3, #8]
 80031b8:	2b01      	cmp	r3, #1
 80031ba:	d009      	beq.n	80031d0 <sduStart+0x40>
 80031bc:	9b01      	ldr	r3, [sp, #4]
 80031be:	7a1b      	ldrb	r3, [r3, #8]
 80031c0:	2b02      	cmp	r3, #2
 80031c2:	d005      	beq.n	80031d0 <sduStart+0x40>
 80031c4:	f247 70a0 	movw	r0, #30624	; 0x77a0
 80031c8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80031cc:	f002 f930 	bl	8005430 <chSysHalt>
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 80031d0:	9b00      	ldr	r3, [sp, #0]
 80031d2:	791b      	ldrb	r3, [r3, #4]
 80031d4:	3b01      	subs	r3, #1
 80031d6:	9a03      	ldr	r2, [sp, #12]
 80031d8:	3308      	adds	r3, #8
 80031da:	009b      	lsls	r3, r3, #2
 80031dc:	4413      	add	r3, r2
 80031de:	9a01      	ldr	r2, [sp, #4]
 80031e0:	605a      	str	r2, [r3, #4]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 80031e2:	9b00      	ldr	r3, [sp, #0]
 80031e4:	795b      	ldrb	r3, [r3, #5]
 80031e6:	1e5a      	subs	r2, r3, #1
 80031e8:	9b03      	ldr	r3, [sp, #12]
 80031ea:	320e      	adds	r2, #14
 80031ec:	9901      	ldr	r1, [sp, #4]
 80031ee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  if (config->int_in > 0U) {
 80031f2:	9b00      	ldr	r3, [sp, #0]
 80031f4:	799b      	ldrb	r3, [r3, #6]
 80031f6:	2b00      	cmp	r3, #0
 80031f8:	d008      	beq.n	800320c <sduStart+0x7c>
    usbp->in_params[config->int_in - 1U]  = sdup;
 80031fa:	9b00      	ldr	r3, [sp, #0]
 80031fc:	799b      	ldrb	r3, [r3, #6]
 80031fe:	3b01      	subs	r3, #1
 8003200:	9a03      	ldr	r2, [sp, #12]
 8003202:	3308      	adds	r3, #8
 8003204:	009b      	lsls	r3, r3, #2
 8003206:	4413      	add	r3, r2
 8003208:	9a01      	ldr	r2, [sp, #4]
 800320a:	605a      	str	r2, [r3, #4]
  }
  sdup->config = config;
 800320c:	9b01      	ldr	r3, [sp, #4]
 800320e:	9a00      	ldr	r2, [sp, #0]
 8003210:	f8c3 2484 	str.w	r2, [r3, #1156]	; 0x484
  sdup->state = SDU_READY;
 8003214:	9b01      	ldr	r3, [sp, #4]
 8003216:	2202      	movs	r2, #2
 8003218:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800321a:	f7ff fdb1 	bl	8002d80 <osalSysUnlock.9380.4512>
}
 800321e:	b005      	add	sp, #20
 8003220:	f85d fb04 	ldr.w	pc, [sp], #4
 8003224:	f3af 8000 	nop.w
 8003228:	f3af 8000 	nop.w
 800322c:	f3af 8000 	nop.w

08003230 <sduDisconnectI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduDisconnectI(SerialUSBDriver *sdup) {
 8003230:	b500      	push	{lr}
 8003232:	b083      	sub	sp, #12
 8003234:	9001      	str	r0, [sp, #4]

  /* Queues reset in order to signal the driver stop to the application.*/
  chnAddFlagsI(sdup, CHN_DISCONNECTED);
 8003236:	9b01      	ldr	r3, [sp, #4]
 8003238:	3304      	adds	r3, #4
 800323a:	4618      	mov	r0, r3
 800323c:	2102      	movs	r1, #2
 800323e:	f7ff fdc7 	bl	8002dd0 <osalEventBroadcastFlagsI.9384.4499>
  ibqResetI(&sdup->ibqueue);
 8003242:	9b01      	ldr	r3, [sp, #4]
 8003244:	330c      	adds	r3, #12
 8003246:	4618      	mov	r0, r3
 8003248:	f001 f982 	bl	8004550 <ibqResetI>
  obqResetI(&sdup->obqueue);
 800324c:	9b01      	ldr	r3, [sp, #4]
 800324e:	3340      	adds	r3, #64	; 0x40
 8003250:	4618      	mov	r0, r3
 8003252:	f001 fb85 	bl	8004960 <obqResetI>
}
 8003256:	b003      	add	sp, #12
 8003258:	f85d fb04 	ldr.w	pc, [sp], #4
 800325c:	f3af 8000 	nop.w

08003260 <sduConfigureHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
 8003260:	b500      	push	{lr}
 8003262:	b085      	sub	sp, #20
 8003264:	9001      	str	r0, [sp, #4]
  uint8_t *buf;

  ibqResetI(&sdup->ibqueue);
 8003266:	9b01      	ldr	r3, [sp, #4]
 8003268:	330c      	adds	r3, #12
 800326a:	4618      	mov	r0, r3
 800326c:	f001 f970 	bl	8004550 <ibqResetI>
  obqResetI(&sdup->obqueue);
 8003270:	9b01      	ldr	r3, [sp, #4]
 8003272:	3340      	adds	r3, #64	; 0x40
 8003274:	4618      	mov	r0, r3
 8003276:	f001 fb73 	bl	8004960 <obqResetI>
  chnAddFlagsI(sdup, CHN_CONNECTED);
 800327a:	9b01      	ldr	r3, [sp, #4]
 800327c:	3304      	adds	r3, #4
 800327e:	4618      	mov	r0, r3
 8003280:	2101      	movs	r1, #1
 8003282:	f7ff fda5 	bl	8002dd0 <osalEventBroadcastFlagsI.9384.4499>

  /* Starts the first OUT transaction immediately.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 8003286:	9b01      	ldr	r3, [sp, #4]
 8003288:	330c      	adds	r3, #12
 800328a:	4618      	mov	r0, r3
 800328c:	f001 f980 	bl	8004590 <ibqGetEmptyBufferI>
 8003290:	9003      	str	r0, [sp, #12]

  osalDbgAssert(buf != NULL, "no free buffer");
 8003292:	9b03      	ldr	r3, [sp, #12]
 8003294:	2b00      	cmp	r3, #0
 8003296:	d105      	bne.n	80032a4 <sduConfigureHookI+0x44>
 8003298:	f247 70c0 	movw	r0, #30656	; 0x77c0
 800329c:	f6c0 0000 	movt	r0, #2048	; 0x800
 80032a0:	f002 f8c6 	bl	8005430 <chSysHalt>

  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 80032a4:	9b01      	ldr	r3, [sp, #4]
 80032a6:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80032aa:	681a      	ldr	r2, [r3, #0]
 80032ac:	9b01      	ldr	r3, [sp, #4]
 80032ae:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80032b2:	795b      	ldrb	r3, [r3, #5]
 80032b4:	4610      	mov	r0, r2
 80032b6:	4619      	mov	r1, r3
 80032b8:	9a03      	ldr	r2, [sp, #12]
 80032ba:	f44f 7380 	mov.w	r3, #256	; 0x100
 80032be:	f000 fcb7 	bl	8003c30 <usbStartReceiveI>
                   buf, SERIAL_USB_BUFFERS_SIZE);
}
 80032c2:	b005      	add	sp, #20
 80032c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80032c8:	f3af 8000 	nop.w
 80032cc:	f3af 8000 	nop.w

080032d0 <sduRequestsHook>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The hook status.
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {
 80032d0:	b082      	sub	sp, #8
 80032d2:	9001      	str	r0, [sp, #4]

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 80032d4:	9b01      	ldr	r3, [sp, #4]
 80032d6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80032da:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80032de:	2b20      	cmp	r3, #32
 80032e0:	d132      	bne.n	8003348 <sduRequestsHook+0x78>
    switch (usbp->setup[1]) {
 80032e2:	9b01      	ldr	r3, [sp, #4]
 80032e4:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 80032e8:	2b21      	cmp	r3, #33	; 0x21
 80032ea:	d004      	beq.n	80032f6 <sduRequestsHook+0x26>
 80032ec:	2b22      	cmp	r3, #34	; 0x22
 80032ee:	d01e      	beq.n	800332e <sduRequestsHook+0x5e>
 80032f0:	2b20      	cmp	r3, #32
 80032f2:	d00e      	beq.n	8003312 <sduRequestsHook+0x42>
 80032f4:	e026      	b.n	8003344 <sduRequestsHook+0x74>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 80032f6:	9a01      	ldr	r2, [sp, #4]
 80032f8:	f640 0300 	movw	r3, #2048	; 0x800
 80032fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003300:	6513      	str	r3, [r2, #80]	; 0x50
 8003302:	9b01      	ldr	r3, [sp, #4]
 8003304:	2207      	movs	r2, #7
 8003306:	655a      	str	r2, [r3, #84]	; 0x54
 8003308:	9b01      	ldr	r3, [sp, #4]
 800330a:	2200      	movs	r2, #0
 800330c:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800330e:	2301      	movs	r3, #1
 8003310:	e01b      	b.n	800334a <sduRequestsHook+0x7a>
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8003312:	9a01      	ldr	r2, [sp, #4]
 8003314:	f640 0300 	movw	r3, #2048	; 0x800
 8003318:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800331c:	6513      	str	r3, [r2, #80]	; 0x50
 800331e:	9b01      	ldr	r3, [sp, #4]
 8003320:	2207      	movs	r2, #7
 8003322:	655a      	str	r2, [r3, #84]	; 0x54
 8003324:	9b01      	ldr	r3, [sp, #4]
 8003326:	2200      	movs	r2, #0
 8003328:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800332a:	2301      	movs	r3, #1
 800332c:	e00d      	b.n	800334a <sduRequestsHook+0x7a>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800332e:	9b01      	ldr	r3, [sp, #4]
 8003330:	2200      	movs	r2, #0
 8003332:	651a      	str	r2, [r3, #80]	; 0x50
 8003334:	9b01      	ldr	r3, [sp, #4]
 8003336:	2200      	movs	r2, #0
 8003338:	655a      	str	r2, [r3, #84]	; 0x54
 800333a:	9b01      	ldr	r3, [sp, #4]
 800333c:	2200      	movs	r2, #0
 800333e:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8003340:	2301      	movs	r3, #1
 8003342:	e002      	b.n	800334a <sduRequestsHook+0x7a>
    default:
      return false;
 8003344:	2300      	movs	r3, #0
 8003346:	e000      	b.n	800334a <sduRequestsHook+0x7a>
    }
  }
  return false;
 8003348:	2300      	movs	r3, #0
}
 800334a:	4618      	mov	r0, r3
 800334c:	b002      	add	sp, #8
 800334e:	4770      	bx	lr

08003350 <sduSOFHookI>:
 *
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduSOFHookI(SerialUSBDriver *sdup) {
 8003350:	b500      	push	{lr}
 8003352:	b085      	sub	sp, #20
 8003354:	9001      	str	r0, [sp, #4]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8003356:	9b01      	ldr	r3, [sp, #4]
 8003358:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800335c:	681b      	ldr	r3, [r3, #0]
 800335e:	781b      	ldrb	r3, [r3, #0]
 8003360:	2b04      	cmp	r3, #4
 8003362:	d13c      	bne.n	80033de <sduSOFHookI+0x8e>
      (sdup->state != SDU_READY)) {
 8003364:	9b01      	ldr	r3, [sp, #4]
 8003366:	7a1b      	ldrb	r3, [r3, #8]
 */
void sduSOFHookI(SerialUSBDriver *sdup) {

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8003368:	2b02      	cmp	r3, #2
 800336a:	d138      	bne.n	80033de <sduSOFHookI+0x8e>
    return;
  }

  /* If there is already a transaction ongoing then another one cannot be
     started.*/
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800336c:	9b01      	ldr	r3, [sp, #4]
 800336e:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8003372:	681b      	ldr	r3, [r3, #0]
 8003374:	891a      	ldrh	r2, [r3, #8]
 8003376:	9b01      	ldr	r3, [sp, #4]
 8003378:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800337c:	791b      	ldrb	r3, [r3, #4]
 800337e:	2101      	movs	r1, #1
 8003380:	fa01 f303 	lsl.w	r3, r1, r3
 8003384:	b29b      	uxth	r3, r3
 8003386:	4013      	ands	r3, r2
 8003388:	b29b      	uxth	r3, r3
 800338a:	2b00      	cmp	r3, #0
 800338c:	d127      	bne.n	80033de <sduSOFHookI+0x8e>
    return;
  }

  /* Checking if there only a buffer partially filled, if so then it is
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
 800338e:	9b01      	ldr	r3, [sp, #4]
 8003390:	3340      	adds	r3, #64	; 0x40
 8003392:	4618      	mov	r0, r3
 8003394:	f001 fcbc 	bl	8004d10 <obqTryFlushI>
 8003398:	4603      	mov	r3, r0
 800339a:	2b00      	cmp	r3, #0
 800339c:	d01f      	beq.n	80033de <sduSOFHookI+0x8e>
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 800339e:	9b01      	ldr	r3, [sp, #4]
 80033a0:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80033a4:	ab02      	add	r3, sp, #8
 80033a6:	4610      	mov	r0, r2
 80033a8:	4619      	mov	r1, r3
 80033aa:	f001 faf9 	bl	80049a0 <obqGetFullBufferI>
 80033ae:	9003      	str	r0, [sp, #12]

    osalDbgAssert(buf != NULL, "queue is empty");
 80033b0:	9b03      	ldr	r3, [sp, #12]
 80033b2:	2b00      	cmp	r3, #0
 80033b4:	d105      	bne.n	80033c2 <sduSOFHookI+0x72>
 80033b6:	f247 70e0 	movw	r0, #30688	; 0x77e0
 80033ba:	f6c0 0000 	movt	r0, #2048	; 0x800
 80033be:	f002 f837 	bl	8005430 <chSysHalt>

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80033c2:	9b01      	ldr	r3, [sp, #4]
 80033c4:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80033c8:	6819      	ldr	r1, [r3, #0]
 80033ca:	9b01      	ldr	r3, [sp, #4]
 80033cc:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 80033d0:	791a      	ldrb	r2, [r3, #4]
 80033d2:	9b02      	ldr	r3, [sp, #8]
 80033d4:	4608      	mov	r0, r1
 80033d6:	4611      	mov	r1, r2
 80033d8:	9a03      	ldr	r2, [sp, #12]
 80033da:	f000 fc79 	bl	8003cd0 <usbStartTransmitI>
  }
}
 80033de:	b005      	add	sp, #20
 80033e0:	f85d fb04 	ldr.w	pc, [sp], #4
 80033e4:	f3af 8000 	nop.w
 80033e8:	f3af 8000 	nop.w
 80033ec:	f3af 8000 	nop.w

080033f0 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 80033f0:	b500      	push	{lr}
 80033f2:	b087      	sub	sp, #28
 80033f4:	9001      	str	r0, [sp, #4]
 80033f6:	460b      	mov	r3, r1
 80033f8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 80033fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8003400:	3b01      	subs	r3, #1
 8003402:	9a01      	ldr	r2, [sp, #4]
 8003404:	3308      	adds	r3, #8
 8003406:	009b      	lsls	r3, r3, #2
 8003408:	4413      	add	r3, r2
 800340a:	685b      	ldr	r3, [r3, #4]
 800340c:	9305      	str	r3, [sp, #20]

  if (sdup == NULL) {
 800340e:	9b05      	ldr	r3, [sp, #20]
 8003410:	2b00      	cmp	r3, #0
 8003412:	d059      	beq.n	80034c8 <sduDataTransmitted+0xd8>
    return;
  }

  osalSysLockFromISR();
 8003414:	f7ff fcbc 	bl	8002d90 <osalSysLockFromISR.9390.4510>

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);
 8003418:	9b05      	ldr	r3, [sp, #20]
 800341a:	3304      	adds	r3, #4
 800341c:	4618      	mov	r0, r3
 800341e:	2108      	movs	r1, #8
 8003420:	f7ff fcd6 	bl	8002dd0 <osalEventBroadcastFlagsI.9384.4499>

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8003424:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8003428:	9a01      	ldr	r2, [sp, #4]
 800342a:	3302      	adds	r3, #2
 800342c:	009b      	lsls	r3, r3, #2
 800342e:	4413      	add	r3, r2
 8003430:	685b      	ldr	r3, [r3, #4]
 8003432:	695b      	ldr	r3, [r3, #20]
 8003434:	681b      	ldr	r3, [r3, #0]
 8003436:	2b00      	cmp	r3, #0
 8003438:	d004      	beq.n	8003444 <sduDataTransmitted+0x54>
    obqReleaseEmptyBufferI(&sdup->obqueue);
 800343a:	9b05      	ldr	r3, [sp, #20]
 800343c:	3340      	adds	r3, #64	; 0x40
 800343e:	4618      	mov	r0, r3
 8003440:	f001 fad6 	bl	80049f0 <obqReleaseEmptyBufferI>
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8003444:	9b05      	ldr	r3, [sp, #20]
 8003446:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800344a:	ab03      	add	r3, sp, #12
 800344c:	4610      	mov	r0, r2
 800344e:	4619      	mov	r1, r3
 8003450:	f001 faa6 	bl	80049a0 <obqGetFullBufferI>
 8003454:	9004      	str	r0, [sp, #16]

  if (buf != NULL) {
 8003456:	9b04      	ldr	r3, [sp, #16]
 8003458:	2b00      	cmp	r3, #0
 800345a:	d008      	beq.n	800346e <sduDataTransmitted+0x7e>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 800345c:	9b03      	ldr	r3, [sp, #12]
 800345e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8003462:	9801      	ldr	r0, [sp, #4]
 8003464:	4611      	mov	r1, r2
 8003466:	9a04      	ldr	r2, [sp, #16]
 8003468:	f000 fc32 	bl	8003cd0 <usbStartTransmitI>
 800346c:	e029      	b.n	80034c2 <sduDataTransmitted+0xd2>
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800346e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8003472:	9a01      	ldr	r2, [sp, #4]
 8003474:	3302      	adds	r3, #2
 8003476:	009b      	lsls	r3, r3, #2
 8003478:	4413      	add	r3, r2
 800347a:	685b      	ldr	r3, [r3, #4]
 800347c:	695b      	ldr	r3, [r3, #20]
 800347e:	681b      	ldr	r3, [r3, #0]
 8003480:	2b00      	cmp	r3, #0
 8003482:	d01e      	beq.n	80034c2 <sduDataTransmitted+0xd2>
           ((usbp->epc[ep]->in_state->txsize &
 8003484:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8003488:	9a01      	ldr	r2, [sp, #4]
 800348a:	3302      	adds	r3, #2
 800348c:	009b      	lsls	r3, r3, #2
 800348e:	4413      	add	r3, r2
 8003490:	685b      	ldr	r3, [r3, #4]
 8003492:	695b      	ldr	r3, [r3, #20]
 8003494:	681a      	ldr	r2, [r3, #0]
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 8003496:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800349a:	9901      	ldr	r1, [sp, #4]
 800349c:	3302      	adds	r3, #2
 800349e:	009b      	lsls	r3, r3, #2
 80034a0:	440b      	add	r3, r1
 80034a2:	685b      	ldr	r3, [r3, #4]
 80034a4:	8a1b      	ldrh	r3, [r3, #16]
 80034a6:	3b01      	subs	r3, #1
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
           ((usbp->epc[ep]->in_state->txsize &
 80034a8:	4013      	ands	r3, r2
  if (buf != NULL) {
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80034aa:	2b00      	cmp	r3, #0
 80034ac:	d109      	bne.n	80034c2 <sduDataTransmitted+0xd2>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
    /* Transmit zero sized packet in case the last one has maximum allowed
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 80034ae:	9b01      	ldr	r3, [sp, #4]
 80034b0:	335c      	adds	r3, #92	; 0x5c
 80034b2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80034b6:	9801      	ldr	r0, [sp, #4]
 80034b8:	4611      	mov	r1, r2
 80034ba:	461a      	mov	r2, r3
 80034bc:	2300      	movs	r3, #0
 80034be:	f000 fc07 	bl	8003cd0 <usbStartTransmitI>
  }
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
 80034c2:	f7ff fc6d 	bl	8002da0 <osalSysUnlockFromISR.9394.4508>
 80034c6:	e000      	b.n	80034ca <sduDataTransmitted+0xda>
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];

  if (sdup == NULL) {
    return;
 80034c8:	bf00      	nop
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
}
 80034ca:	b007      	add	sp, #28
 80034cc:	f85d fb04 	ldr.w	pc, [sp], #4

080034d0 <sduDataReceived>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 80034d0:	b500      	push	{lr}
 80034d2:	b085      	sub	sp, #20
 80034d4:	9001      	str	r0, [sp, #4]
 80034d6:	460b      	mov	r3, r1
 80034d8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint8_t *buf;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80034dc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80034e0:	1e5a      	subs	r2, r3, #1
 80034e2:	9b01      	ldr	r3, [sp, #4]
 80034e4:	320e      	adds	r2, #14
 80034e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80034ea:	9303      	str	r3, [sp, #12]

  if (sdup == NULL) {
 80034ec:	9b03      	ldr	r3, [sp, #12]
 80034ee:	2b00      	cmp	r3, #0
 80034f0:	d036      	beq.n	8003560 <sduDataReceived+0x90>
    return;
  }

  osalSysLockFromISR();
 80034f2:	f7ff fc4d 	bl	8002d90 <osalSysLockFromISR.9390.4510>

  /* Signaling that data is available in the input queue.*/
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);
 80034f6:	9b03      	ldr	r3, [sp, #12]
 80034f8:	3304      	adds	r3, #4
 80034fa:	4618      	mov	r0, r3
 80034fc:	2104      	movs	r1, #4
 80034fe:	f7ff fc67 	bl	8002dd0 <osalEventBroadcastFlagsI.9384.4499>

  /* Posting the filled buffer in the queue.*/
  ibqPostFullBufferI(&sdup->ibqueue,
 8003502:	9b03      	ldr	r3, [sp, #12]
 8003504:	f103 020c 	add.w	r2, r3, #12
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 8003508:	9b03      	ldr	r3, [sp, #12]
 800350a:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800350e:	6819      	ldr	r1, [r3, #0]
 8003510:	9b03      	ldr	r3, [sp, #12]
 8003512:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8003516:	795b      	ldrb	r3, [r3, #5]
 8003518:	3302      	adds	r3, #2
 800351a:	009b      	lsls	r3, r3, #2
 800351c:	440b      	add	r3, r1
 800351e:	685b      	ldr	r3, [r3, #4]
 8003520:	699b      	ldr	r3, [r3, #24]

  /* Signaling that data is available in the input queue.*/
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Posting the filled buffer in the queue.*/
  ibqPostFullBufferI(&sdup->ibqueue,
 8003522:	685b      	ldr	r3, [r3, #4]
 8003524:	4610      	mov	r0, r2
 8003526:	4619      	mov	r1, r3
 8003528:	f001 f852 	bl	80045d0 <ibqPostFullBufferI>
                                                   sdup->config->bulk_out));

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
 800352c:	9b03      	ldr	r3, [sp, #12]
 800352e:	330c      	adds	r3, #12
 8003530:	4618      	mov	r0, r3
 8003532:	f001 f82d 	bl	8004590 <ibqGetEmptyBufferI>
 8003536:	9002      	str	r0, [sp, #8]
  if (buf != NULL) {
 8003538:	9b02      	ldr	r3, [sp, #8]
 800353a:	2b00      	cmp	r3, #0
 800353c:	d00e      	beq.n	800355c <sduDataReceived+0x8c>
    /* Buffer found, starting a new transaction.*/
    usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 800353e:	9b03      	ldr	r3, [sp, #12]
 8003540:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 8003544:	681a      	ldr	r2, [r3, #0]
 8003546:	9b03      	ldr	r3, [sp, #12]
 8003548:	f8d3 3484 	ldr.w	r3, [r3, #1156]	; 0x484
 800354c:	795b      	ldrb	r3, [r3, #5]
 800354e:	4610      	mov	r0, r2
 8003550:	4619      	mov	r1, r3
 8003552:	9a02      	ldr	r2, [sp, #8]
 8003554:	f44f 7380 	mov.w	r3, #256	; 0x100
 8003558:	f000 fb6a 	bl	8003c30 <usbStartReceiveI>
                     buf, SERIAL_USB_BUFFERS_SIZE);
  }
  osalSysUnlockFromISR();
 800355c:	f7ff fc20 	bl	8002da0 <osalSysUnlockFromISR.9394.4508>
}
 8003560:	b005      	add	sp, #20
 8003562:	f85d fb04 	ldr.w	pc, [sp], #4
 8003566:	bf00      	nop
 8003568:	f3af 8000 	nop.w
 800356c:	f3af 8000 	nop.w

08003570 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 8003570:	b082      	sub	sp, #8
 8003572:	9001      	str	r0, [sp, #4]
 8003574:	460b      	mov	r3, r1
 8003576:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)usbp;
  (void)ep;
}
 800357a:	b002      	add	sp, #8
 800357c:	4770      	bx	lr
 800357e:	bf00      	nop

08003580 <port_lock.9746.4358>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003580:	b082      	sub	sp, #8
 8003582:	2320      	movs	r3, #32
 8003584:	9301      	str	r3, [sp, #4]
 8003586:	9b01      	ldr	r3, [sp, #4]
 8003588:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800358c:	b002      	add	sp, #8
 800358e:	4770      	bx	lr

08003590 <port_unlock.9749.4356>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003590:	b082      	sub	sp, #8
 8003592:	2300      	movs	r3, #0
 8003594:	9301      	str	r3, [sp, #4]
 8003596:	9b01      	ldr	r3, [sp, #4]
 8003598:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800359c:	b002      	add	sp, #8
 800359e:	4770      	bx	lr

080035a0 <port_lock_from_isr.9751.4354>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80035a0:	b508      	push	{r3, lr}

  port_lock();
 80035a2:	f7ff ffed 	bl	8003580 <port_lock.9746.4358>
}
 80035a6:	bd08      	pop	{r3, pc}
 80035a8:	f3af 8000 	nop.w
 80035ac:	f3af 8000 	nop.w

080035b0 <port_unlock_from_isr.9753.4352>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80035b0:	b508      	push	{r3, lr}

  port_unlock();
 80035b2:	f7ff ffed 	bl	8003590 <port_unlock.9749.4356>
}
 80035b6:	bd08      	pop	{r3, pc}
 80035b8:	f3af 8000 	nop.w
 80035bc:	f3af 8000 	nop.w

080035c0 <chSysLock.9755.4350>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80035c0:	b508      	push	{r3, lr}

  port_lock();
 80035c2:	f7ff ffdd 	bl	8003580 <port_lock.9746.4358>
  _stats_start_measure_crit_thd();
 80035c6:	f003 f9bb 	bl	8006940 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80035ca:	f001 ffc9 	bl	8005560 <_dbg_check_lock>
}
 80035ce:	bd08      	pop	{r3, pc}

080035d0 <chSysUnlock.9759.4348>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80035d0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80035d2:	f001 ffe5 	bl	80055a0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80035d6:	f003 f9bb 	bl	8006950 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80035da:	f640 0308 	movw	r3, #2056	; 0x808
 80035de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035e2:	681a      	ldr	r2, [r3, #0]
 80035e4:	f640 0308 	movw	r3, #2056	; 0x808
 80035e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035ec:	429a      	cmp	r2, r3
 80035ee:	d013      	beq.n	8003618 <chSysUnlock.9759.4348+0x48>
 80035f0:	f640 0308 	movw	r3, #2056	; 0x808
 80035f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80035f8:	699b      	ldr	r3, [r3, #24]
 80035fa:	689a      	ldr	r2, [r3, #8]
 80035fc:	f640 0308 	movw	r3, #2056	; 0x808
 8003600:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003604:	681b      	ldr	r3, [r3, #0]
 8003606:	689b      	ldr	r3, [r3, #8]
 8003608:	429a      	cmp	r2, r3
 800360a:	d205      	bcs.n	8003618 <chSysUnlock.9759.4348+0x48>
 800360c:	f647 0030 	movw	r0, #30768	; 0x7830
 8003610:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003614:	f001 ff0c 	bl	8005430 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003618:	f7ff ffba 	bl	8003590 <port_unlock.9749.4356>
}
 800361c:	bd08      	pop	{r3, pc}
 800361e:	bf00      	nop

08003620 <chSysLockFromISR.9765.4346>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8003620:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8003622:	f7ff ffbd 	bl	80035a0 <port_lock_from_isr.9751.4354>
  _stats_start_measure_crit_isr();
 8003626:	f003 f99b 	bl	8006960 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800362a:	f001 ffd9 	bl	80055e0 <_dbg_check_lock_from_isr>
}
 800362e:	bd08      	pop	{r3, pc}

08003630 <chSysUnlockFromISR.9769.4344>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8003630:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8003632:	f001 fff5 	bl	8005620 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8003636:	f003 f99b 	bl	8006970 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800363a:	f7ff ffb9 	bl	80035b0 <port_unlock_from_isr.9753.4352>
}
 800363e:	bd08      	pop	{r3, pc}

08003640 <osalSysLock.9757.4342>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8003640:	b508      	push	{r3, lr}

  chSysLock();
 8003642:	f7ff ffbd 	bl	80035c0 <chSysLock.9755.4350>
}
 8003646:	bd08      	pop	{r3, pc}
 8003648:	f3af 8000 	nop.w
 800364c:	f3af 8000 	nop.w

08003650 <osalSysUnlock.9761.4340>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003650:	b508      	push	{r3, lr}

  chSysUnlock();
 8003652:	f7ff ffbd 	bl	80035d0 <chSysUnlock.9759.4348>
}
 8003656:	bd08      	pop	{r3, pc}
 8003658:	f3af 8000 	nop.w
 800365c:	f3af 8000 	nop.w

08003660 <osalSysLockFromISR.9767>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8003660:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8003662:	f7ff ffdd 	bl	8003620 <chSysLockFromISR.9765.4346>
}
 8003666:	bd08      	pop	{r3, pc}
 8003668:	f3af 8000 	nop.w
 800366c:	f3af 8000 	nop.w

08003670 <osalSysUnlockFromISR.9771>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8003670:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8003672:	f7ff ffdd 	bl	8003630 <chSysUnlockFromISR.9769.4344>
}
 8003676:	bd08      	pop	{r3, pc}
 8003678:	f3af 8000 	nop.w
 800367c:	f3af 8000 	nop.w

08003680 <get_hword.9773>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 8003680:	b084      	sub	sp, #16
 8003682:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 8003684:	9b01      	ldr	r3, [sp, #4]
 8003686:	1c5a      	adds	r2, r3, #1
 8003688:	9201      	str	r2, [sp, #4]
 800368a:	781b      	ldrb	r3, [r3, #0]
 800368c:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 8003690:	9b01      	ldr	r3, [sp, #4]
 8003692:	781b      	ldrb	r3, [r3, #0]
 8003694:	021b      	lsls	r3, r3, #8
 8003696:	b29a      	uxth	r2, r3
 8003698:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800369c:	4313      	orrs	r3, r2
 800369e:	b29b      	uxth	r3, r3
 80036a0:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 80036a4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 80036a8:	4618      	mov	r0, r3
 80036aa:	b004      	add	sp, #16
 80036ac:	4770      	bx	lr
 80036ae:	bf00      	nop

080036b0 <set_address.9780.4328>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 80036b0:	b500      	push	{lr}
 80036b2:	b083      	sub	sp, #12
 80036b4:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 80036b6:	9b01      	ldr	r3, [sp, #4]
 80036b8:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 80036bc:	9b01      	ldr	r3, [sp, #4]
 80036be:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usb_lld_set_address(usbp);
 80036c2:	9801      	ldr	r0, [sp, #4]
 80036c4:	f7fd fccc 	bl	8001060 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80036c8:	9b01      	ldr	r3, [sp, #4]
 80036ca:	685b      	ldr	r3, [r3, #4]
 80036cc:	681b      	ldr	r3, [r3, #0]
 80036ce:	2b00      	cmp	r3, #0
 80036d0:	d005      	beq.n	80036de <set_address.9780.4328+0x2e>
 80036d2:	9b01      	ldr	r3, [sp, #4]
 80036d4:	685b      	ldr	r3, [r3, #4]
 80036d6:	681b      	ldr	r3, [r3, #0]
 80036d8:	9801      	ldr	r0, [sp, #4]
 80036da:	2101      	movs	r1, #1
 80036dc:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 80036de:	9b01      	ldr	r3, [sp, #4]
 80036e0:	2203      	movs	r2, #3
 80036e2:	701a      	strb	r2, [r3, #0]
}
 80036e4:	b003      	add	sp, #12
 80036e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80036ea:	bf00      	nop
 80036ec:	f3af 8000 	nop.w

080036f0 <default_handler.10033.4325>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 80036f0:	b570      	push	{r4, r5, r6, lr}
 80036f2:	b084      	sub	sp, #16
 80036f4:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80036f6:	9b01      	ldr	r3, [sp, #4]
 80036f8:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80036fc:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8003700:	9b01      	ldr	r3, [sp, #4]
 8003702:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8003706:	021b      	lsls	r3, r3, #8
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
 8003708:	4313      	orrs	r3, r2
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800370a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800370e:	d05a      	beq.n	80037c6 <default_handler.10033.4325+0xd6>
 8003710:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8003714:	d812      	bhi.n	800373c <default_handler.10033.4325+0x4c>
 8003716:	2b02      	cmp	r3, #2
 8003718:	f000 80f1 	beq.w	80038fe <default_handler.10033.4325+0x20e>
 800371c:	2b02      	cmp	r3, #2
 800371e:	d805      	bhi.n	800372c <default_handler.10033.4325+0x3c>
 8003720:	2b00      	cmp	r3, #0
 8003722:	d028      	beq.n	8003776 <default_handler.10033.4325+0x86>
 8003724:	2b01      	cmp	r3, #1
 8003726:	f000 80dc 	beq.w	80038e2 <default_handler.10033.4325+0x1f2>
 800372a:	e1b5      	b.n	8003a98 <default_handler.10033.4325+0x3a8>
 800372c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8003730:	d02e      	beq.n	8003790 <default_handler.10033.4325+0xa0>
 8003732:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8003736:	f000 8145 	beq.w	80039c4 <default_handler.10033.4325+0x2d4>
 800373a:	e1ad      	b.n	8003a98 <default_handler.10033.4325+0x3a8>
 800373c:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8003740:	d074      	beq.n	800382c <default_handler.10033.4325+0x13c>
 8003742:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8003746:	d808      	bhi.n	800375a <default_handler.10033.4325+0x6a>
 8003748:	f240 3202 	movw	r2, #770	; 0x302
 800374c:	4293      	cmp	r3, r2
 800374e:	f000 816e 	beq.w	8003a2e <default_handler.10033.4325+0x33e>
 8003752:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8003756:	d051      	beq.n	80037fc <default_handler.10033.4325+0x10c>
 8003758:	e19e      	b.n	8003a98 <default_handler.10033.4325+0x3a8>
 800375a:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 800375e:	f000 8098 	beq.w	8003892 <default_handler.10033.4325+0x1a2>
 8003762:	f640 4202 	movw	r2, #3074	; 0xc02
 8003766:	4293      	cmp	r3, r2
 8003768:	f000 80bb 	beq.w	80038e2 <default_handler.10033.4325+0x1f2>
 800376c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8003770:	f000 8082 	beq.w	8003878 <default_handler.10033.4325+0x188>
 8003774:	e190      	b.n	8003a98 <default_handler.10033.4325+0x3a8>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8003776:	9b01      	ldr	r3, [sp, #4]
 8003778:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800377c:	9b01      	ldr	r3, [sp, #4]
 800377e:	651a      	str	r2, [r3, #80]	; 0x50
 8003780:	9b01      	ldr	r3, [sp, #4]
 8003782:	2202      	movs	r2, #2
 8003784:	655a      	str	r2, [r3, #84]	; 0x54
 8003786:	9b01      	ldr	r3, [sp, #4]
 8003788:	2200      	movs	r2, #0
 800378a:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800378c:	2301      	movs	r3, #1
 800378e:	e184      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8003790:	9b01      	ldr	r3, [sp, #4]
 8003792:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8003796:	2b01      	cmp	r3, #1
 8003798:	d113      	bne.n	80037c2 <default_handler.10033.4325+0xd2>
      usbp->status &= ~2U;
 800379a:	9b01      	ldr	r3, [sp, #4]
 800379c:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 80037a0:	f023 0302 	bic.w	r3, r3, #2
 80037a4:	b29a      	uxth	r2, r3
 80037a6:	9b01      	ldr	r3, [sp, #4]
 80037a8:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80037ac:	9b01      	ldr	r3, [sp, #4]
 80037ae:	2200      	movs	r2, #0
 80037b0:	651a      	str	r2, [r3, #80]	; 0x50
 80037b2:	9b01      	ldr	r3, [sp, #4]
 80037b4:	2200      	movs	r2, #0
 80037b6:	655a      	str	r2, [r3, #84]	; 0x54
 80037b8:	9b01      	ldr	r3, [sp, #4]
 80037ba:	2200      	movs	r2, #0
 80037bc:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 80037be:	2301      	movs	r3, #1
 80037c0:	e16b      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
    }
    return false;
 80037c2:	2300      	movs	r3, #0
 80037c4:	e169      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80037c6:	9b01      	ldr	r3, [sp, #4]
 80037c8:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 80037cc:	2b01      	cmp	r3, #1
 80037ce:	d113      	bne.n	80037f8 <default_handler.10033.4325+0x108>
      usbp->status |= 2U;
 80037d0:	9b01      	ldr	r3, [sp, #4]
 80037d2:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 80037d6:	f043 0302 	orr.w	r3, r3, #2
 80037da:	b29a      	uxth	r2, r3
 80037dc:	9b01      	ldr	r3, [sp, #4]
 80037de:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80037e2:	9b01      	ldr	r3, [sp, #4]
 80037e4:	2200      	movs	r2, #0
 80037e6:	651a      	str	r2, [r3, #80]	; 0x50
 80037e8:	9b01      	ldr	r3, [sp, #4]
 80037ea:	2200      	movs	r2, #0
 80037ec:	655a      	str	r2, [r3, #84]	; 0x54
 80037ee:	9b01      	ldr	r3, [sp, #4]
 80037f0:	2200      	movs	r2, #0
 80037f2:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 80037f4:	2301      	movs	r3, #1
 80037f6:	e150      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
    }
    return false;
 80037f8:	2300      	movs	r3, #0
 80037fa:	e14e      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 80037fc:	9b01      	ldr	r3, [sp, #4]
 80037fe:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8003802:	2b00      	cmp	r3, #0
 8003804:	d107      	bne.n	8003816 <default_handler.10033.4325+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 8003806:	9b01      	ldr	r3, [sp, #4]
 8003808:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800380c:	2b05      	cmp	r3, #5
 800380e:	d102      	bne.n	8003816 <default_handler.10033.4325+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
      set_address(usbp);
 8003810:	9801      	ldr	r0, [sp, #4]
 8003812:	f7ff ff4d 	bl	80036b0 <set_address.9780.4328>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8003816:	9b01      	ldr	r3, [sp, #4]
 8003818:	2200      	movs	r2, #0
 800381a:	651a      	str	r2, [r3, #80]	; 0x50
 800381c:	9b01      	ldr	r3, [sp, #4]
 800381e:	2200      	movs	r2, #0
 8003820:	655a      	str	r2, [r3, #84]	; 0x54
 8003822:	9b01      	ldr	r3, [sp, #4]
 8003824:	2200      	movs	r2, #0
 8003826:	659a      	str	r2, [r3, #88]	; 0x58
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 8003828:	2301      	movs	r3, #1
 800382a:	e136      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800382c:	9b01      	ldr	r3, [sp, #4]
 800382e:	685b      	ldr	r3, [r3, #4]
 8003830:	685c      	ldr	r4, [r3, #4]
 8003832:	9b01      	ldr	r3, [sp, #4]
 8003834:	f893 605f 	ldrb.w	r6, [r3, #95]	; 0x5f
 8003838:	9b01      	ldr	r3, [sp, #4]
 800383a:	f893 505e 	ldrb.w	r5, [r3, #94]	; 0x5e
 800383e:	9b01      	ldr	r3, [sp, #4]
 8003840:	3360      	adds	r3, #96	; 0x60
 8003842:	4618      	mov	r0, r3
 8003844:	f7ff ff1c 	bl	8003680 <get_hword.9773>
 8003848:	4603      	mov	r3, r0
 800384a:	9801      	ldr	r0, [sp, #4]
 800384c:	4631      	mov	r1, r6
 800384e:	462a      	mov	r2, r5
 8003850:	47a0      	blx	r4
 8003852:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8003854:	9b03      	ldr	r3, [sp, #12]
 8003856:	2b00      	cmp	r3, #0
 8003858:	d101      	bne.n	800385e <default_handler.10033.4325+0x16e>
      return false;
 800385a:	2300      	movs	r3, #0
 800385c:	e11d      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800385e:	9b03      	ldr	r3, [sp, #12]
 8003860:	685a      	ldr	r2, [r3, #4]
 8003862:	9b01      	ldr	r3, [sp, #4]
 8003864:	651a      	str	r2, [r3, #80]	; 0x50
 8003866:	9b03      	ldr	r3, [sp, #12]
 8003868:	681a      	ldr	r2, [r3, #0]
 800386a:	9b01      	ldr	r3, [sp, #4]
 800386c:	655a      	str	r2, [r3, #84]	; 0x54
 800386e:	9b01      	ldr	r3, [sp, #4]
 8003870:	2200      	movs	r2, #0
 8003872:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 8003874:	2301      	movs	r3, #1
 8003876:	e110      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8003878:	9b01      	ldr	r3, [sp, #4]
 800387a:	f103 0267 	add.w	r2, r3, #103	; 0x67
 800387e:	9b01      	ldr	r3, [sp, #4]
 8003880:	651a      	str	r2, [r3, #80]	; 0x50
 8003882:	9b01      	ldr	r3, [sp, #4]
 8003884:	2201      	movs	r2, #1
 8003886:	655a      	str	r2, [r3, #84]	; 0x54
 8003888:	9b01      	ldr	r3, [sp, #4]
 800388a:	2200      	movs	r2, #0
 800388c:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 800388e:	2301      	movs	r3, #1
 8003890:	e103      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host.*/
    usbp->configuration = usbp->setup[2];
 8003892:	9b01      	ldr	r3, [sp, #4]
 8003894:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 8003898:	9b01      	ldr	r3, [sp, #4]
 800389a:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
    if (usbp->configuration == 0U) {
 800389e:	9b01      	ldr	r3, [sp, #4]
 80038a0:	f893 3067 	ldrb.w	r3, [r3, #103]	; 0x67
 80038a4:	2b00      	cmp	r3, #0
 80038a6:	d103      	bne.n	80038b0 <default_handler.10033.4325+0x1c0>
      usbp->state = USB_SELECTED;
 80038a8:	9b01      	ldr	r3, [sp, #4]
 80038aa:	2203      	movs	r2, #3
 80038ac:	701a      	strb	r2, [r3, #0]
 80038ae:	e002      	b.n	80038b6 <default_handler.10033.4325+0x1c6>
    }
    else {
      usbp->state = USB_ACTIVE;
 80038b0:	9b01      	ldr	r3, [sp, #4]
 80038b2:	2204      	movs	r2, #4
 80038b4:	701a      	strb	r2, [r3, #0]
    }
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 80038b6:	9b01      	ldr	r3, [sp, #4]
 80038b8:	685b      	ldr	r3, [r3, #4]
 80038ba:	681b      	ldr	r3, [r3, #0]
 80038bc:	2b00      	cmp	r3, #0
 80038be:	d005      	beq.n	80038cc <default_handler.10033.4325+0x1dc>
 80038c0:	9b01      	ldr	r3, [sp, #4]
 80038c2:	685b      	ldr	r3, [r3, #4]
 80038c4:	681b      	ldr	r3, [r3, #0]
 80038c6:	9801      	ldr	r0, [sp, #4]
 80038c8:	2102      	movs	r1, #2
 80038ca:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80038cc:	9b01      	ldr	r3, [sp, #4]
 80038ce:	2200      	movs	r2, #0
 80038d0:	651a      	str	r2, [r3, #80]	; 0x50
 80038d2:	9b01      	ldr	r3, [sp, #4]
 80038d4:	2200      	movs	r2, #0
 80038d6:	655a      	str	r2, [r3, #84]	; 0x54
 80038d8:	9b01      	ldr	r3, [sp, #4]
 80038da:	2200      	movs	r2, #0
 80038dc:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 80038de:	2301      	movs	r3, #1
 80038e0:	e0db      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 80038e2:	9a01      	ldr	r2, [sp, #4]
 80038e4:	f247 73f0 	movw	r3, #30704	; 0x77f0
 80038e8:	f6c0 0300 	movt	r3, #2048	; 0x800
 80038ec:	6513      	str	r3, [r2, #80]	; 0x50
 80038ee:	9b01      	ldr	r3, [sp, #4]
 80038f0:	2202      	movs	r2, #2
 80038f2:	655a      	str	r2, [r3, #84]	; 0x54
 80038f4:	9b01      	ldr	r3, [sp, #4]
 80038f6:	2200      	movs	r2, #0
 80038f8:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 80038fa:	2301      	movs	r3, #1
 80038fc:	e0cd      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80038fe:	9b01      	ldr	r3, [sp, #4]
 8003900:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8003904:	b2db      	uxtb	r3, r3
 8003906:	b25b      	sxtb	r3, r3
 8003908:	2b00      	cmp	r3, #0
 800390a:	da2d      	bge.n	8003968 <default_handler.10033.4325+0x278>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 800390c:	9b01      	ldr	r3, [sp, #4]
 800390e:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8003912:	f003 030f 	and.w	r3, r3, #15
 8003916:	b2db      	uxtb	r3, r3
 8003918:	9801      	ldr	r0, [sp, #4]
 800391a:	4619      	mov	r1, r3
 800391c:	f7fd fd08 	bl	8001330 <usb_lld_get_status_in>
 8003920:	4603      	mov	r3, r0
 8003922:	2b01      	cmp	r3, #1
 8003924:	d002      	beq.n	800392c <default_handler.10033.4325+0x23c>
 8003926:	2b02      	cmp	r3, #2
 8003928:	d00e      	beq.n	8003948 <default_handler.10033.4325+0x258>
 800392a:	e01b      	b.n	8003964 <default_handler.10033.4325+0x274>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 800392c:	9a01      	ldr	r2, [sp, #4]
 800392e:	f647 0310 	movw	r3, #30736	; 0x7810
 8003932:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003936:	6513      	str	r3, [r2, #80]	; 0x50
 8003938:	9b01      	ldr	r3, [sp, #4]
 800393a:	2202      	movs	r2, #2
 800393c:	655a      	str	r2, [r3, #84]	; 0x54
 800393e:	9b01      	ldr	r3, [sp, #4]
 8003940:	2200      	movs	r2, #0
 8003942:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8003944:	2301      	movs	r3, #1
 8003946:	e0a8      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8003948:	9a01      	ldr	r2, [sp, #4]
 800394a:	f647 0300 	movw	r3, #30720	; 0x7800
 800394e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003952:	6513      	str	r3, [r2, #80]	; 0x50
 8003954:	9b01      	ldr	r3, [sp, #4]
 8003956:	2202      	movs	r2, #2
 8003958:	655a      	str	r2, [r3, #84]	; 0x54
 800395a:	9b01      	ldr	r3, [sp, #4]
 800395c:	2200      	movs	r2, #0
 800395e:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8003960:	2301      	movs	r3, #1
 8003962:	e09a      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8003964:	2300      	movs	r3, #0
 8003966:	e098      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8003968:	9b01      	ldr	r3, [sp, #4]
 800396a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 800396e:	f003 030f 	and.w	r3, r3, #15
 8003972:	b2db      	uxtb	r3, r3
 8003974:	9801      	ldr	r0, [sp, #4]
 8003976:	4619      	mov	r1, r3
 8003978:	f7fd fcba 	bl	80012f0 <usb_lld_get_status_out>
 800397c:	4603      	mov	r3, r0
 800397e:	2b01      	cmp	r3, #1
 8003980:	d002      	beq.n	8003988 <default_handler.10033.4325+0x298>
 8003982:	2b02      	cmp	r3, #2
 8003984:	d00e      	beq.n	80039a4 <default_handler.10033.4325+0x2b4>
 8003986:	e01b      	b.n	80039c0 <default_handler.10033.4325+0x2d0>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8003988:	9a01      	ldr	r2, [sp, #4]
 800398a:	f647 0310 	movw	r3, #30736	; 0x7810
 800398e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8003992:	6513      	str	r3, [r2, #80]	; 0x50
 8003994:	9b01      	ldr	r3, [sp, #4]
 8003996:	2202      	movs	r2, #2
 8003998:	655a      	str	r2, [r3, #84]	; 0x54
 800399a:	9b01      	ldr	r3, [sp, #4]
 800399c:	2200      	movs	r2, #0
 800399e:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 80039a0:	2301      	movs	r3, #1
 80039a2:	e07a      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 80039a4:	9a01      	ldr	r2, [sp, #4]
 80039a6:	f647 0300 	movw	r3, #30720	; 0x7800
 80039aa:	f6c0 0300 	movt	r3, #2048	; 0x800
 80039ae:	6513      	str	r3, [r2, #80]	; 0x50
 80039b0:	9b01      	ldr	r3, [sp, #4]
 80039b2:	2202      	movs	r2, #2
 80039b4:	655a      	str	r2, [r3, #84]	; 0x54
 80039b6:	9b01      	ldr	r3, [sp, #4]
 80039b8:	2200      	movs	r2, #0
 80039ba:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 80039bc:	2301      	movs	r3, #1
 80039be:	e06c      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
      case EP_STATUS_DISABLED:
      default:
        return false;
 80039c0:	2300      	movs	r3, #0
 80039c2:	e06a      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80039c4:	9b01      	ldr	r3, [sp, #4]
 80039c6:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 80039ca:	2b00      	cmp	r3, #0
 80039cc:	d001      	beq.n	80039d2 <default_handler.10033.4325+0x2e2>
      return false;
 80039ce:	2300      	movs	r3, #0
 80039d0:	e063      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80039d2:	9b01      	ldr	r3, [sp, #4]
 80039d4:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80039d8:	f003 030f 	and.w	r3, r3, #15
 80039dc:	2b00      	cmp	r3, #0
 80039de:	d01b      	beq.n	8003a18 <default_handler.10033.4325+0x328>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80039e0:	9b01      	ldr	r3, [sp, #4]
 80039e2:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80039e6:	b2db      	uxtb	r3, r3
 80039e8:	b25b      	sxtb	r3, r3
 80039ea:	2b00      	cmp	r3, #0
 80039ec:	da0a      	bge.n	8003a04 <default_handler.10033.4325+0x314>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 80039ee:	9b01      	ldr	r3, [sp, #4]
 80039f0:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 80039f4:	f003 030f 	and.w	r3, r3, #15
 80039f8:	b2db      	uxtb	r3, r3
 80039fa:	9801      	ldr	r0, [sp, #4]
 80039fc:	4619      	mov	r1, r3
 80039fe:	f7fd fe7f 	bl	8001700 <usb_lld_clear_in>
 8003a02:	e009      	b.n	8003a18 <default_handler.10033.4325+0x328>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 8003a04:	9b01      	ldr	r3, [sp, #4]
 8003a06:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8003a0a:	f003 030f 	and.w	r3, r3, #15
 8003a0e:	b2db      	uxtb	r3, r3
 8003a10:	9801      	ldr	r0, [sp, #4]
 8003a12:	4619      	mov	r1, r3
 8003a14:	f7fd fe54 	bl	80016c0 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8003a18:	9b01      	ldr	r3, [sp, #4]
 8003a1a:	2200      	movs	r2, #0
 8003a1c:	651a      	str	r2, [r3, #80]	; 0x50
 8003a1e:	9b01      	ldr	r3, [sp, #4]
 8003a20:	2200      	movs	r2, #0
 8003a22:	655a      	str	r2, [r3, #84]	; 0x54
 8003a24:	9b01      	ldr	r3, [sp, #4]
 8003a26:	2200      	movs	r2, #0
 8003a28:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8003a2a:	2301      	movs	r3, #1
 8003a2c:	e035      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8003a2e:	9b01      	ldr	r3, [sp, #4]
 8003a30:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8003a34:	2b00      	cmp	r3, #0
 8003a36:	d001      	beq.n	8003a3c <default_handler.10033.4325+0x34c>
      return false;
 8003a38:	2300      	movs	r3, #0
 8003a3a:	e02e      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8003a3c:	9b01      	ldr	r3, [sp, #4]
 8003a3e:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8003a42:	f003 030f 	and.w	r3, r3, #15
 8003a46:	2b00      	cmp	r3, #0
 8003a48:	d01b      	beq.n	8003a82 <default_handler.10033.4325+0x392>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8003a4a:	9b01      	ldr	r3, [sp, #4]
 8003a4c:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8003a50:	b2db      	uxtb	r3, r3
 8003a52:	b25b      	sxtb	r3, r3
 8003a54:	2b00      	cmp	r3, #0
 8003a56:	da0a      	bge.n	8003a6e <default_handler.10033.4325+0x37e>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 8003a58:	9b01      	ldr	r3, [sp, #4]
 8003a5a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8003a5e:	f003 030f 	and.w	r3, r3, #15
 8003a62:	b2db      	uxtb	r3, r3
 8003a64:	9801      	ldr	r0, [sp, #4]
 8003a66:	4619      	mov	r1, r3
 8003a68:	f7fd fe0a 	bl	8001680 <usb_lld_stall_in>
 8003a6c:	e009      	b.n	8003a82 <default_handler.10033.4325+0x392>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8003a6e:	9b01      	ldr	r3, [sp, #4]
 8003a70:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8003a74:	f003 030f 	and.w	r3, r3, #15
 8003a78:	b2db      	uxtb	r3, r3
 8003a7a:	9801      	ldr	r0, [sp, #4]
 8003a7c:	4619      	mov	r1, r3
 8003a7e:	f7fd fddf 	bl	8001640 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8003a82:	9b01      	ldr	r3, [sp, #4]
 8003a84:	2200      	movs	r2, #0
 8003a86:	651a      	str	r2, [r3, #80]	; 0x50
 8003a88:	9b01      	ldr	r3, [sp, #4]
 8003a8a:	2200      	movs	r2, #0
 8003a8c:	655a      	str	r2, [r3, #84]	; 0x54
 8003a8e:	9b01      	ldr	r3, [sp, #4]
 8003a90:	2200      	movs	r2, #0
 8003a92:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8003a94:	2301      	movs	r3, #1
 8003a96:	e000      	b.n	8003a9a <default_handler.10033.4325+0x3aa>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 8003a98:	2300      	movs	r3, #0
  }
}
 8003a9a:	4618      	mov	r0, r3
 8003a9c:	b004      	add	sp, #16
 8003a9e:	bd70      	pop	{r4, r5, r6, pc}

08003aa0 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 8003aa0:	b508      	push	{r3, lr}

  usb_lld_init();
 8003aa2:	f7fd f8dd 	bl	8000c60 <usb_lld_init>
}
 8003aa6:	bd08      	pop	{r3, pc}
 8003aa8:	f3af 8000 	nop.w
 8003aac:	f3af 8000 	nop.w

08003ab0 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 8003ab0:	b084      	sub	sp, #16
 8003ab2:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 8003ab4:	9b01      	ldr	r3, [sp, #4]
 8003ab6:	2201      	movs	r2, #1
 8003ab8:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 8003aba:	9b01      	ldr	r3, [sp, #4]
 8003abc:	2200      	movs	r2, #0
 8003abe:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003ac0:	2300      	movs	r3, #0
 8003ac2:	9303      	str	r3, [sp, #12]
 8003ac4:	e00f      	b.n	8003ae6 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 8003ac6:	9a01      	ldr	r2, [sp, #4]
 8003ac8:	9b03      	ldr	r3, [sp, #12]
 8003aca:	3308      	adds	r3, #8
 8003acc:	009b      	lsls	r3, r3, #2
 8003ace:	4413      	add	r3, r2
 8003ad0:	2200      	movs	r2, #0
 8003ad2:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 8003ad4:	9b01      	ldr	r3, [sp, #4]
 8003ad6:	9a03      	ldr	r2, [sp, #12]
 8003ad8:	320e      	adds	r2, #14
 8003ada:	2100      	movs	r1, #0
 8003adc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003ae0:	9b03      	ldr	r3, [sp, #12]
 8003ae2:	3301      	adds	r3, #1
 8003ae4:	9303      	str	r3, [sp, #12]
 8003ae6:	9b03      	ldr	r3, [sp, #12]
 8003ae8:	2b04      	cmp	r3, #4
 8003aea:	d9ec      	bls.n	8003ac6 <usbObjectInit+0x16>
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 8003aec:	9b01      	ldr	r3, [sp, #4]
 8003aee:	2200      	movs	r2, #0
 8003af0:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 8003af2:	9b01      	ldr	r3, [sp, #4]
 8003af4:	2200      	movs	r2, #0
 8003af6:	815a      	strh	r2, [r3, #10]
}
 8003af8:	b004      	add	sp, #16
 8003afa:	4770      	bx	lr
 8003afc:	f3af 8000 	nop.w

08003b00 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 8003b00:	b500      	push	{lr}
 8003b02:	b085      	sub	sp, #20
 8003b04:	9001      	str	r0, [sp, #4]
 8003b06:	9100      	str	r1, [sp, #0]
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));
 8003b08:	9b01      	ldr	r3, [sp, #4]
 8003b0a:	2b00      	cmp	r3, #0
 8003b0c:	d002      	beq.n	8003b14 <usbStart+0x14>
 8003b0e:	9b00      	ldr	r3, [sp, #0]
 8003b10:	2b00      	cmp	r3, #0
 8003b12:	d105      	bne.n	8003b20 <usbStart+0x20>
 8003b14:	f647 0020 	movw	r0, #30752	; 0x7820
 8003b18:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003b1c:	f001 fc88 	bl	8005430 <chSysHalt>

  osalSysLock();
 8003b20:	f7ff fd8e 	bl	8003640 <osalSysLock.9757.4342>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 8003b24:	9b01      	ldr	r3, [sp, #4]
 8003b26:	781b      	ldrb	r3, [r3, #0]
 8003b28:	2b01      	cmp	r3, #1
 8003b2a:	d009      	beq.n	8003b40 <usbStart+0x40>
 8003b2c:	9b01      	ldr	r3, [sp, #4]
 8003b2e:	781b      	ldrb	r3, [r3, #0]
 8003b30:	2b02      	cmp	r3, #2
 8003b32:	d005      	beq.n	8003b40 <usbStart+0x40>
 8003b34:	f647 0020 	movw	r0, #30752	; 0x7820
 8003b38:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003b3c:	f001 fc78 	bl	8005430 <chSysHalt>
                "invalid state");
  usbp->config = config;
 8003b40:	9b01      	ldr	r3, [sp, #4]
 8003b42:	9a00      	ldr	r2, [sp, #0]
 8003b44:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003b46:	2300      	movs	r3, #0
 8003b48:	9303      	str	r3, [sp, #12]
 8003b4a:	e009      	b.n	8003b60 <usbStart+0x60>
    usbp->epc[i] = NULL;
 8003b4c:	9a01      	ldr	r2, [sp, #4]
 8003b4e:	9b03      	ldr	r3, [sp, #12]
 8003b50:	3302      	adds	r3, #2
 8003b52:	009b      	lsls	r3, r3, #2
 8003b54:	4413      	add	r3, r2
 8003b56:	2200      	movs	r2, #0
 8003b58:	605a      	str	r2, [r3, #4]

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003b5a:	9b03      	ldr	r3, [sp, #12]
 8003b5c:	3301      	adds	r3, #1
 8003b5e:	9303      	str	r3, [sp, #12]
 8003b60:	9b03      	ldr	r3, [sp, #12]
 8003b62:	2b05      	cmp	r3, #5
 8003b64:	d9f2      	bls.n	8003b4c <usbStart+0x4c>
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
 8003b66:	9801      	ldr	r0, [sp, #4]
 8003b68:	f7fd f8f2 	bl	8000d50 <usb_lld_start>
  usbp->state = USB_READY;
 8003b6c:	9b01      	ldr	r3, [sp, #4]
 8003b6e:	2202      	movs	r2, #2
 8003b70:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8003b72:	f7ff fd6d 	bl	8003650 <osalSysUnlock.9761.4340>
}
 8003b76:	b005      	add	sp, #20
 8003b78:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b7c:	f3af 8000 	nop.w

08003b80 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8003b80:	b500      	push	{lr}
 8003b82:	b085      	sub	sp, #20
 8003b84:	9003      	str	r0, [sp, #12]
 8003b86:	460b      	mov	r3, r1
 8003b88:	9201      	str	r2, [sp, #4]
 8003b8a:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheckClassI();
 8003b8e:	f001 fdb7 	bl	8005700 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 8003b92:	9b03      	ldr	r3, [sp, #12]
 8003b94:	2b00      	cmp	r3, #0
 8003b96:	d002      	beq.n	8003b9e <usbInitEndpointI+0x1e>
 8003b98:	9b01      	ldr	r3, [sp, #4]
 8003b9a:	2b00      	cmp	r3, #0
 8003b9c:	d105      	bne.n	8003baa <usbInitEndpointI+0x2a>
 8003b9e:	f647 0040 	movw	r0, #30784	; 0x7840
 8003ba2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003ba6:	f001 fc43 	bl	8005430 <chSysHalt>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 8003baa:	9b03      	ldr	r3, [sp, #12]
 8003bac:	781b      	ldrb	r3, [r3, #0]
 8003bae:	2b04      	cmp	r3, #4
 8003bb0:	d005      	beq.n	8003bbe <usbInitEndpointI+0x3e>
 8003bb2:	f647 0040 	movw	r0, #30784	; 0x7840
 8003bb6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003bba:	f001 fc39 	bl	8005430 <chSysHalt>
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 8003bbe:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003bc2:	9a03      	ldr	r2, [sp, #12]
 8003bc4:	3302      	adds	r3, #2
 8003bc6:	009b      	lsls	r3, r3, #2
 8003bc8:	4413      	add	r3, r2
 8003bca:	685b      	ldr	r3, [r3, #4]
 8003bcc:	2b00      	cmp	r3, #0
 8003bce:	d005      	beq.n	8003bdc <usbInitEndpointI+0x5c>
 8003bd0:	f647 0040 	movw	r0, #30784	; 0x7840
 8003bd4:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003bd8:	f001 fc2a 	bl	8005430 <chSysHalt>

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 8003bdc:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003be0:	9a03      	ldr	r2, [sp, #12]
 8003be2:	3302      	adds	r3, #2
 8003be4:	009b      	lsls	r3, r3, #2
 8003be6:	4413      	add	r3, r2
 8003be8:	9a01      	ldr	r2, [sp, #4]
 8003bea:	605a      	str	r2, [r3, #4]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 8003bec:	9b01      	ldr	r3, [sp, #4]
 8003bee:	695b      	ldr	r3, [r3, #20]
 8003bf0:	2b00      	cmp	r3, #0
 8003bf2:	d006      	beq.n	8003c02 <usbInitEndpointI+0x82>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8003bf4:	9b01      	ldr	r3, [sp, #4]
 8003bf6:	695b      	ldr	r3, [r3, #20]
 8003bf8:	4618      	mov	r0, r3
 8003bfa:	2100      	movs	r1, #0
 8003bfc:	2210      	movs	r2, #16
 8003bfe:	f002 febf 	bl	8006980 <memset>
  }
  if (epcp->out_state != NULL) {
 8003c02:	9b01      	ldr	r3, [sp, #4]
 8003c04:	699b      	ldr	r3, [r3, #24]
 8003c06:	2b00      	cmp	r3, #0
 8003c08:	d006      	beq.n	8003c18 <usbInitEndpointI+0x98>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8003c0a:	9b01      	ldr	r3, [sp, #4]
 8003c0c:	699b      	ldr	r3, [r3, #24]
 8003c0e:	4618      	mov	r0, r3
 8003c10:	2100      	movs	r1, #0
 8003c12:	2210      	movs	r2, #16
 8003c14:	f002 feb4 	bl	8006980 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 8003c18:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003c1c:	9803      	ldr	r0, [sp, #12]
 8003c1e:	4619      	mov	r1, r3
 8003c20:	f7fd fa36 	bl	8001090 <usb_lld_init_endpoint>
}
 8003c24:	b005      	add	sp, #20
 8003c26:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c2a:	bf00      	nop
 8003c2c:	f3af 8000 	nop.w

08003c30 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8003c30:	b500      	push	{lr}
 8003c32:	b087      	sub	sp, #28
 8003c34:	9003      	str	r0, [sp, #12]
 8003c36:	9201      	str	r2, [sp, #4]
 8003c38:	9300      	str	r3, [sp, #0]
 8003c3a:	460b      	mov	r3, r1
 8003c3c:	f88d 300b 	strb.w	r3, [sp, #11]
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
 8003c40:	f001 fd5e 	bl	8005700 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8003c44:	9b03      	ldr	r3, [sp, #12]
 8003c46:	2b00      	cmp	r3, #0
 8003c48:	d003      	beq.n	8003c52 <usbStartReceiveI+0x22>
 8003c4a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003c4e:	2b05      	cmp	r3, #5
 8003c50:	d905      	bls.n	8003c5e <usbStartReceiveI+0x2e>
 8003c52:	f647 0060 	movw	r0, #30816	; 0x7860
 8003c56:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003c5a:	f001 fbe9 	bl	8005430 <chSysHalt>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8003c5e:	9b03      	ldr	r3, [sp, #12]
 8003c60:	895a      	ldrh	r2, [r3, #10]
 8003c62:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003c66:	2101      	movs	r1, #1
 8003c68:	fa01 f303 	lsl.w	r3, r1, r3
 8003c6c:	b29b      	uxth	r3, r3
 8003c6e:	4013      	ands	r3, r2
 8003c70:	b29b      	uxth	r3, r3
 8003c72:	2b00      	cmp	r3, #0
 8003c74:	d005      	beq.n	8003c82 <usbStartReceiveI+0x52>
 8003c76:	f647 0060 	movw	r0, #30816	; 0x7860
 8003c7a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003c7e:	f001 fbd7 	bl	8005430 <chSysHalt>

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003c82:	9b03      	ldr	r3, [sp, #12]
 8003c84:	895a      	ldrh	r2, [r3, #10]
 8003c86:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003c8a:	2101      	movs	r1, #1
 8003c8c:	fa01 f303 	lsl.w	r3, r1, r3
 8003c90:	b29b      	uxth	r3, r3
 8003c92:	4313      	orrs	r3, r2
 8003c94:	b29a      	uxth	r2, r3
 8003c96:	9b03      	ldr	r3, [sp, #12]
 8003c98:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8003c9a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003c9e:	9a03      	ldr	r2, [sp, #12]
 8003ca0:	3302      	adds	r3, #2
 8003ca2:	009b      	lsls	r3, r3, #2
 8003ca4:	4413      	add	r3, r2
 8003ca6:	685b      	ldr	r3, [r3, #4]
 8003ca8:	699b      	ldr	r3, [r3, #24]
 8003caa:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 8003cac:	9b05      	ldr	r3, [sp, #20]
 8003cae:	9a01      	ldr	r2, [sp, #4]
 8003cb0:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8003cb2:	9b05      	ldr	r3, [sp, #20]
 8003cb4:	9a00      	ldr	r2, [sp, #0]
 8003cb6:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 8003cb8:	9b05      	ldr	r3, [sp, #20]
 8003cba:	2200      	movs	r2, #0
 8003cbc:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8003cbe:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003cc2:	9803      	ldr	r0, [sp, #12]
 8003cc4:	4619      	mov	r1, r3
 8003cc6:	f7fd fb6b 	bl	80013a0 <usb_lld_start_out>
}
 8003cca:	b007      	add	sp, #28
 8003ccc:	f85d fb04 	ldr.w	pc, [sp], #4

08003cd0 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8003cd0:	b500      	push	{lr}
 8003cd2:	b087      	sub	sp, #28
 8003cd4:	9003      	str	r0, [sp, #12]
 8003cd6:	9201      	str	r2, [sp, #4]
 8003cd8:	9300      	str	r3, [sp, #0]
 8003cda:	460b      	mov	r3, r1
 8003cdc:	f88d 300b 	strb.w	r3, [sp, #11]
  USBInEndpointState *isp;

  osalDbgCheckClassI();
 8003ce0:	f001 fd0e 	bl	8005700 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8003ce4:	9b03      	ldr	r3, [sp, #12]
 8003ce6:	2b00      	cmp	r3, #0
 8003ce8:	d003      	beq.n	8003cf2 <usbStartTransmitI+0x22>
 8003cea:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003cee:	2b05      	cmp	r3, #5
 8003cf0:	d905      	bls.n	8003cfe <usbStartTransmitI+0x2e>
 8003cf2:	f647 0080 	movw	r0, #30848	; 0x7880
 8003cf6:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003cfa:	f001 fb99 	bl	8005430 <chSysHalt>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 8003cfe:	9b03      	ldr	r3, [sp, #12]
 8003d00:	891a      	ldrh	r2, [r3, #8]
 8003d02:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003d06:	2101      	movs	r1, #1
 8003d08:	fa01 f303 	lsl.w	r3, r1, r3
 8003d0c:	b29b      	uxth	r3, r3
 8003d0e:	4013      	ands	r3, r2
 8003d10:	b29b      	uxth	r3, r3
 8003d12:	2b00      	cmp	r3, #0
 8003d14:	d005      	beq.n	8003d22 <usbStartTransmitI+0x52>
 8003d16:	f647 0080 	movw	r0, #30848	; 0x7880
 8003d1a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003d1e:	f001 fb87 	bl	8005430 <chSysHalt>

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8003d22:	9b03      	ldr	r3, [sp, #12]
 8003d24:	891a      	ldrh	r2, [r3, #8]
 8003d26:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003d2a:	2101      	movs	r1, #1
 8003d2c:	fa01 f303 	lsl.w	r3, r1, r3
 8003d30:	b29b      	uxth	r3, r3
 8003d32:	4313      	orrs	r3, r2
 8003d34:	b29a      	uxth	r2, r3
 8003d36:	9b03      	ldr	r3, [sp, #12]
 8003d38:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8003d3a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003d3e:	9a03      	ldr	r2, [sp, #12]
 8003d40:	3302      	adds	r3, #2
 8003d42:	009b      	lsls	r3, r3, #2
 8003d44:	4413      	add	r3, r2
 8003d46:	685b      	ldr	r3, [r3, #4]
 8003d48:	695b      	ldr	r3, [r3, #20]
 8003d4a:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 8003d4c:	9b05      	ldr	r3, [sp, #20]
 8003d4e:	9a01      	ldr	r2, [sp, #4]
 8003d50:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8003d52:	9b05      	ldr	r3, [sp, #20]
 8003d54:	9a00      	ldr	r2, [sp, #0]
 8003d56:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 8003d58:	9b05      	ldr	r3, [sp, #20]
 8003d5a:	2200      	movs	r2, #0
 8003d5c:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8003d5e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8003d62:	9803      	ldr	r0, [sp, #12]
 8003d64:	4619      	mov	r1, r3
 8003d66:	f7fd fbbb 	bl	80014e0 <usb_lld_start_in>
}
 8003d6a:	b007      	add	sp, #28
 8003d6c:	f85d fb04 	ldr.w	pc, [sp], #4

08003d70 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8003d70:	b500      	push	{lr}
 8003d72:	b085      	sub	sp, #20
 8003d74:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8003d76:	9b01      	ldr	r3, [sp, #4]
 8003d78:	2202      	movs	r2, #2
 8003d7a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 8003d7c:	9b01      	ldr	r3, [sp, #4]
 8003d7e:	2200      	movs	r2, #0
 8003d80:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
  usbp->address       = 0;
 8003d84:	9b01      	ldr	r3, [sp, #4]
 8003d86:	2200      	movs	r2, #0
 8003d88:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usbp->configuration = 0;
 8003d8c:	9b01      	ldr	r3, [sp, #4]
 8003d8e:	2200      	movs	r2, #0
 8003d90:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
  usbp->transmitting  = 0;
 8003d94:	9b01      	ldr	r3, [sp, #4]
 8003d96:	2200      	movs	r2, #0
 8003d98:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 8003d9a:	9b01      	ldr	r3, [sp, #4]
 8003d9c:	2200      	movs	r2, #0
 8003d9e:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003da0:	2300      	movs	r3, #0
 8003da2:	9303      	str	r3, [sp, #12]
 8003da4:	e009      	b.n	8003dba <_usb_reset+0x4a>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8003da6:	9a01      	ldr	r2, [sp, #4]
 8003da8:	9b03      	ldr	r3, [sp, #12]
 8003daa:	3302      	adds	r3, #2
 8003dac:	009b      	lsls	r3, r3, #2
 8003dae:	4413      	add	r3, r2
 8003db0:	2200      	movs	r2, #0
 8003db2:	605a      	str	r2, [r3, #4]
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8003db4:	9b03      	ldr	r3, [sp, #12]
 8003db6:	3301      	adds	r3, #1
 8003db8:	9303      	str	r3, [sp, #12]
 8003dba:	9b03      	ldr	r3, [sp, #12]
 8003dbc:	2b05      	cmp	r3, #5
 8003dbe:	d9f2      	bls.n	8003da6 <_usb_reset+0x36>
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8003dc0:	9b01      	ldr	r3, [sp, #4]
 8003dc2:	2200      	movs	r2, #0
 8003dc4:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8003dc8:	9801      	ldr	r0, [sp, #4]
 8003dca:	f7fd f8b1 	bl	8000f30 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8003dce:	9b01      	ldr	r3, [sp, #4]
 8003dd0:	685b      	ldr	r3, [r3, #4]
 8003dd2:	681b      	ldr	r3, [r3, #0]
 8003dd4:	2b00      	cmp	r3, #0
 8003dd6:	d005      	beq.n	8003de4 <_usb_reset+0x74>
 8003dd8:	9b01      	ldr	r3, [sp, #4]
 8003dda:	685b      	ldr	r3, [r3, #4]
 8003ddc:	681b      	ldr	r3, [r3, #0]
 8003dde:	9801      	ldr	r0, [sp, #4]
 8003de0:	2100      	movs	r1, #0
 8003de2:	4798      	blx	r3
}
 8003de4:	b005      	add	sp, #20
 8003de6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003dea:	bf00      	nop
 8003dec:	f3af 8000 	nop.w

08003df0 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8003df0:	b500      	push	{lr}
 8003df2:	b083      	sub	sp, #12
 8003df4:	9001      	str	r0, [sp, #4]

  /* State transition.*/
  usbp->state = USB_SUSPENDED;
 8003df6:	9b01      	ldr	r3, [sp, #4]
 8003df8:	2205      	movs	r2, #5
 8003dfa:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003dfc:	9b01      	ldr	r3, [sp, #4]
 8003dfe:	685b      	ldr	r3, [r3, #4]
 8003e00:	681b      	ldr	r3, [r3, #0]
 8003e02:	2b00      	cmp	r3, #0
 8003e04:	d005      	beq.n	8003e12 <_usb_suspend+0x22>
 8003e06:	9b01      	ldr	r3, [sp, #4]
 8003e08:	685b      	ldr	r3, [r3, #4]
 8003e0a:	681b      	ldr	r3, [r3, #0]
 8003e0c:	9801      	ldr	r0, [sp, #4]
 8003e0e:	2103      	movs	r1, #3
 8003e10:	4798      	blx	r3
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 8003e12:	b003      	add	sp, #12
 8003e14:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e18:	f3af 8000 	nop.w
 8003e1c:	f3af 8000 	nop.w

08003e20 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 8003e20:	b500      	push	{lr}
 8003e22:	b083      	sub	sp, #12
 8003e24:	9001      	str	r0, [sp, #4]

  /* State transition.*/
  usbp->state = USB_ACTIVE;
 8003e26:	9b01      	ldr	r3, [sp, #4]
 8003e28:	2204      	movs	r2, #4
 8003e2a:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8003e2c:	9b01      	ldr	r3, [sp, #4]
 8003e2e:	685b      	ldr	r3, [r3, #4]
 8003e30:	681b      	ldr	r3, [r3, #0]
 8003e32:	2b00      	cmp	r3, #0
 8003e34:	d005      	beq.n	8003e42 <_usb_wakeup+0x22>
 8003e36:	9b01      	ldr	r3, [sp, #4]
 8003e38:	685b      	ldr	r3, [r3, #4]
 8003e3a:	681b      	ldr	r3, [r3, #0]
 8003e3c:	9801      	ldr	r0, [sp, #4]
 8003e3e:	2104      	movs	r1, #4
 8003e40:	4798      	blx	r3
}
 8003e42:	b003      	add	sp, #12
 8003e44:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e48:	f3af 8000 	nop.w
 8003e4c:	f3af 8000 	nop.w

08003e50 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8003e50:	b500      	push	{lr}
 8003e52:	b085      	sub	sp, #20
 8003e54:	9001      	str	r0, [sp, #4]
 8003e56:	460b      	mov	r3, r1
 8003e58:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8003e5c:	9b01      	ldr	r3, [sp, #4]
 8003e5e:	2200      	movs	r2, #0
 8003e60:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  usbReadSetup(usbp, ep, usbp->setup);
 8003e64:	9b01      	ldr	r3, [sp, #4]
 8003e66:	335c      	adds	r3, #92	; 0x5c
 8003e68:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8003e6c:	9801      	ldr	r0, [sp, #4]
 8003e6e:	4611      	mov	r1, r2
 8003e70:	461a      	mov	r2, r3
 8003e72:	f7fd fa7d 	bl	8001370 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8003e76:	9b01      	ldr	r3, [sp, #4]
 8003e78:	685b      	ldr	r3, [r3, #4]
 8003e7a:	689b      	ldr	r3, [r3, #8]
 8003e7c:	2b00      	cmp	r3, #0
 8003e7e:	d00a      	beq.n	8003e96 <_usb_ep0setup+0x46>
      !(usbp->config->requests_hook_cb(usbp))) {
 8003e80:	9b01      	ldr	r3, [sp, #4]
 8003e82:	685b      	ldr	r3, [r3, #4]
 8003e84:	689b      	ldr	r3, [r3, #8]
 8003e86:	9801      	ldr	r0, [sp, #4]
 8003e88:	4798      	blx	r3
 8003e8a:	4603      	mov	r3, r0
 8003e8c:	f083 0301 	eor.w	r3, r3, #1
 8003e90:	b2db      	uxtb	r3, r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8003e92:	2b00      	cmp	r3, #0
 8003e94:	d027      	beq.n	8003ee6 <_usb_ep0setup+0x96>
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8003e96:	9b01      	ldr	r3, [sp, #4]
 8003e98:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8003e9c:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8003ea0:	2b00      	cmp	r3, #0
 8003ea2:	d108      	bne.n	8003eb6 <_usb_ep0setup+0x66>
        !default_handler(usbp)) {
 8003ea4:	9801      	ldr	r0, [sp, #4]
 8003ea6:	f7ff fc23 	bl	80036f0 <default_handler.10033.4325>
 8003eaa:	4603      	mov	r3, r0
 8003eac:	f083 0301 	eor.w	r3, r3, #1
 8003eb0:	b2db      	uxtb	r3, r3
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8003eb2:	2b00      	cmp	r3, #0
 8003eb4:	d017      	beq.n	8003ee6 <_usb_ep0setup+0x96>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8003eb6:	9801      	ldr	r0, [sp, #4]
 8003eb8:	2100      	movs	r1, #0
 8003eba:	f7fd fbe1 	bl	8001680 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 8003ebe:	9801      	ldr	r0, [sp, #4]
 8003ec0:	2100      	movs	r1, #0
 8003ec2:	f7fd fbbd 	bl	8001640 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8003ec6:	9b01      	ldr	r3, [sp, #4]
 8003ec8:	685b      	ldr	r3, [r3, #4]
 8003eca:	681b      	ldr	r3, [r3, #0]
 8003ecc:	2b00      	cmp	r3, #0
 8003ece:	d005      	beq.n	8003edc <_usb_ep0setup+0x8c>
 8003ed0:	9b01      	ldr	r3, [sp, #4]
 8003ed2:	685b      	ldr	r3, [r3, #4]
 8003ed4:	681b      	ldr	r3, [r3, #0]
 8003ed6:	9801      	ldr	r0, [sp, #4]
 8003ed8:	2105      	movs	r1, #5
 8003eda:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8003edc:	9b01      	ldr	r3, [sp, #4]
 8003ede:	2206      	movs	r2, #6
 8003ee0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
 8003ee4:	e05c      	b.n	8003fa0 <_usb_ep0setup+0x150>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8003ee6:	9b01      	ldr	r3, [sp, #4]
 8003ee8:	3362      	adds	r3, #98	; 0x62
 8003eea:	4618      	mov	r0, r3
 8003eec:	f7ff fbc8 	bl	8003680 <get_hword.9773>
 8003ef0:	4603      	mov	r3, r0
 8003ef2:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8003ef4:	9b01      	ldr	r3, [sp, #4]
 8003ef6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8003ef8:	9b03      	ldr	r3, [sp, #12]
 8003efa:	429a      	cmp	r2, r3
 8003efc:	d902      	bls.n	8003f04 <_usb_ep0setup+0xb4>
    usbp->ep0n = max;
 8003efe:	9b01      	ldr	r3, [sp, #4]
 8003f00:	9a03      	ldr	r2, [sp, #12]
 8003f02:	655a      	str	r2, [r3, #84]	; 0x54
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8003f04:	9b01      	ldr	r3, [sp, #4]
 8003f06:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8003f0a:	b2db      	uxtb	r3, r3
 8003f0c:	b25b      	sxtb	r3, r3
 8003f0e:	2b00      	cmp	r3, #0
 8003f10:	da23      	bge.n	8003f5a <_usb_ep0setup+0x10a>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8003f12:	9b01      	ldr	r3, [sp, #4]
 8003f14:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003f16:	2b00      	cmp	r3, #0
 8003f18:	d010      	beq.n	8003f3c <_usb_ep0setup+0xec>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8003f1a:	9b01      	ldr	r3, [sp, #4]
 8003f1c:	2201      	movs	r2, #1
 8003f1e:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 8003f22:	f7ff fb9d 	bl	8003660 <osalSysLockFromISR.9767>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8003f26:	9b01      	ldr	r3, [sp, #4]
 8003f28:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003f2a:	9b01      	ldr	r3, [sp, #4]
 8003f2c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003f2e:	9801      	ldr	r0, [sp, #4]
 8003f30:	2100      	movs	r1, #0
 8003f32:	f7ff fecd 	bl	8003cd0 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8003f36:	f7ff fb9b 	bl	8003670 <osalSysUnlockFromISR.9771>
 8003f3a:	e031      	b.n	8003fa0 <_usb_ep0setup+0x150>
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 8003f3c:	9b01      	ldr	r3, [sp, #4]
 8003f3e:	2203      	movs	r2, #3
 8003f40:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8003f44:	f7ff fb8c 	bl	8003660 <osalSysLockFromISR.9767>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8003f48:	9801      	ldr	r0, [sp, #4]
 8003f4a:	2100      	movs	r1, #0
 8003f4c:	2200      	movs	r2, #0
 8003f4e:	2300      	movs	r3, #0
 8003f50:	f7ff fe6e 	bl	8003c30 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8003f54:	f7ff fb8c 	bl	8003670 <osalSysUnlockFromISR.9771>
 8003f58:	e022      	b.n	8003fa0 <_usb_ep0setup+0x150>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8003f5a:	9b01      	ldr	r3, [sp, #4]
 8003f5c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003f5e:	2b00      	cmp	r3, #0
 8003f60:	d010      	beq.n	8003f84 <_usb_ep0setup+0x134>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8003f62:	9b01      	ldr	r3, [sp, #4]
 8003f64:	2204      	movs	r2, #4
 8003f66:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 8003f6a:	f7ff fb79 	bl	8003660 <osalSysLockFromISR.9767>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8003f6e:	9b01      	ldr	r3, [sp, #4]
 8003f70:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003f72:	9b01      	ldr	r3, [sp, #4]
 8003f74:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003f76:	9801      	ldr	r0, [sp, #4]
 8003f78:	2100      	movs	r1, #0
 8003f7a:	f7ff fe59 	bl	8003c30 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8003f7e:	f7ff fb77 	bl	8003670 <osalSysUnlockFromISR.9771>
 8003f82:	e00d      	b.n	8003fa0 <_usb_ep0setup+0x150>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8003f84:	9b01      	ldr	r3, [sp, #4]
 8003f86:	2205      	movs	r2, #5
 8003f88:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8003f8c:	f7ff fb68 	bl	8003660 <osalSysLockFromISR.9767>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8003f90:	9801      	ldr	r0, [sp, #4]
 8003f92:	2100      	movs	r1, #0
 8003f94:	2200      	movs	r2, #0
 8003f96:	2300      	movs	r3, #0
 8003f98:	f7ff fe9a 	bl	8003cd0 <usbStartTransmitI>
      osalSysUnlockFromISR();
 8003f9c:	f7ff fb68 	bl	8003670 <osalSysUnlockFromISR.9771>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8003fa0:	b005      	add	sp, #20
 8003fa2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fa6:	bf00      	nop
 8003fa8:	f3af 8000 	nop.w
 8003fac:	f3af 8000 	nop.w

08003fb0 <chSysLock.8114.4446>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003fb0:	b508      	push	{r3, lr}

  port_lock();
 8003fb2:	f000 ff8d 	bl	8004ed0 <port_lock.8109>
  _stats_start_measure_crit_thd();
 8003fb6:	f002 fcc3 	bl	8006940 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8003fba:	f001 fad1 	bl	8005560 <_dbg_check_lock>
}
 8003fbe:	bd08      	pop	{r3, pc}

08003fc0 <chSysUnlock.8116.4444>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003fc0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8003fc2:	f001 faed 	bl	80055a0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8003fc6:	f002 fcc3 	bl	8006950 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8003fca:	f640 0308 	movw	r3, #2056	; 0x808
 8003fce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fd2:	681a      	ldr	r2, [r3, #0]
 8003fd4:	f640 0308 	movw	r3, #2056	; 0x808
 8003fd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fdc:	429a      	cmp	r2, r3
 8003fde:	d013      	beq.n	8004008 <chSysUnlock.8116.4444+0x48>
 8003fe0:	f640 0308 	movw	r3, #2056	; 0x808
 8003fe4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003fe8:	699b      	ldr	r3, [r3, #24]
 8003fea:	689a      	ldr	r2, [r3, #8]
 8003fec:	f640 0308 	movw	r3, #2056	; 0x808
 8003ff0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ff4:	681b      	ldr	r3, [r3, #0]
 8003ff6:	689b      	ldr	r3, [r3, #8]
 8003ff8:	429a      	cmp	r2, r3
 8003ffa:	d205      	bcs.n	8004008 <chSysUnlock.8116.4444+0x48>
 8003ffc:	f247 6060 	movw	r0, #30304	; 0x7660
 8004000:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004004:	f001 fa14 	bl	8005430 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8004008:	f000 ff6a 	bl	8004ee0 <port_unlock.8112>
}
 800400c:	bd08      	pop	{r3, pc}
 800400e:	bf00      	nop

08004010 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8004010:	f241 63a8 	movw	r3, #5800	; 0x16a8
 8004014:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004018:	3307      	adds	r3, #7
 800401a:	f023 0307 	bic.w	r3, r3, #7
 800401e:	461a      	mov	r2, r3
 8004020:	f640 53e0 	movw	r3, #3552	; 0xde0
 8004024:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004028:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800402a:	f240 0300 	movw	r3, #0
 800402e:	f2c2 0302 	movt	r3, #8194	; 0x2002
 8004032:	f023 0307 	bic.w	r3, r3, #7
 8004036:	461a      	mov	r2, r3
 8004038:	f640 53e4 	movw	r3, #3556	; 0xde4
 800403c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004040:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 8004042:	4770      	bx	lr
 8004044:	f3af 8000 	nop.w
 8004048:	f3af 8000 	nop.w
 800404c:	f3af 8000 	nop.w

08004050 <chCoreAlloc.4433>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8004050:	b500      	push	{lr}
 8004052:	b085      	sub	sp, #20
 8004054:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8004056:	f7ff ffab 	bl	8003fb0 <chSysLock.8114.4446>
  p = chCoreAllocI(size);
 800405a:	9801      	ldr	r0, [sp, #4]
 800405c:	f000 f808 	bl	8004070 <chCoreAllocI.4439>
 8004060:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8004062:	f7ff ffad 	bl	8003fc0 <chSysUnlock.8116.4444>

  return p;
 8004066:	9b03      	ldr	r3, [sp, #12]
}
 8004068:	4618      	mov	r0, r3
 800406a:	b005      	add	sp, #20
 800406c:	f85d fb04 	ldr.w	pc, [sp], #4

08004070 <chCoreAllocI.4439>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8004070:	b500      	push	{lr}
 8004072:	b085      	sub	sp, #20
 8004074:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();
 8004076:	f001 fb43 	bl	8005700 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
 800407a:	9b01      	ldr	r3, [sp, #4]
 800407c:	3307      	adds	r3, #7
 800407e:	f023 0307 	bic.w	r3, r3, #7
 8004082:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8004084:	f640 53e4 	movw	r3, #3556	; 0xde4
 8004088:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800408c:	681b      	ldr	r3, [r3, #0]
 800408e:	461a      	mov	r2, r3
 8004090:	f640 53e0 	movw	r3, #3552	; 0xde0
 8004094:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004098:	681b      	ldr	r3, [r3, #0]
 800409a:	1ad3      	subs	r3, r2, r3
 800409c:	461a      	mov	r2, r3
 800409e:	9b01      	ldr	r3, [sp, #4]
 80040a0:	429a      	cmp	r2, r3
 80040a2:	d201      	bcs.n	80040a8 <chCoreAllocI.4439+0x38>
  /*lint -restore*/
    return NULL;
 80040a4:	2300      	movs	r3, #0
 80040a6:	e012      	b.n	80040ce <chCoreAllocI.4439+0x5e>
  }
  p = nextmem;
 80040a8:	f640 53e0 	movw	r3, #3552	; 0xde0
 80040ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040b0:	681b      	ldr	r3, [r3, #0]
 80040b2:	9303      	str	r3, [sp, #12]
  nextmem += size;
 80040b4:	f640 53e0 	movw	r3, #3552	; 0xde0
 80040b8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040bc:	681a      	ldr	r2, [r3, #0]
 80040be:	9b01      	ldr	r3, [sp, #4]
 80040c0:	441a      	add	r2, r3
 80040c2:	f640 53e0 	movw	r3, #3552	; 0xde0
 80040c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040ca:	601a      	str	r2, [r3, #0]

  return p;
 80040cc:	9b03      	ldr	r3, [sp, #12]
}
 80040ce:	4618      	mov	r0, r3
 80040d0:	b005      	add	sp, #20
 80040d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80040d6:	bf00      	nop
 80040d8:	f3af 8000 	nop.w
 80040dc:	f3af 8000 	nop.w

080040e0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 80040e0:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 80040e2:	f640 53e8 	movw	r3, #3560	; 0xde8
 80040e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040ea:	f244 0251 	movw	r2, #16465	; 0x4051
 80040ee:	f6c0 0200 	movt	r2, #2048	; 0x800
 80040f2:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 80040f4:	f640 53e8 	movw	r3, #3560	; 0xde8
 80040f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80040fc:	2200      	movs	r2, #0
 80040fe:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8004100:	f640 53e8 	movw	r3, #3560	; 0xde8
 8004104:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004108:	2200      	movs	r2, #0
 800410a:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 800410c:	4801      	ldr	r0, [pc, #4]	; (8004114 <_heap_init+0x34>)
 800410e:	f000 feff 	bl	8004f10 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 8004112:	bd08      	pop	{r3, pc}
 8004114:	20000df8 	.word	0x20000df8
 8004118:	f3af 8000 	nop.w
 800411c:	f3af 8000 	nop.w

08004120 <port_lock.8630.4352>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004120:	b082      	sub	sp, #8
 8004122:	2320      	movs	r3, #32
 8004124:	9301      	str	r3, [sp, #4]
 8004126:	9b01      	ldr	r3, [sp, #4]
 8004128:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800412c:	b002      	add	sp, #8
 800412e:	4770      	bx	lr

08004130 <port_unlock.8633.4350>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004130:	b082      	sub	sp, #8
 8004132:	2300      	movs	r3, #0
 8004134:	9301      	str	r3, [sp, #4]
 8004136:	9b01      	ldr	r3, [sp, #4]
 8004138:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800413c:	b002      	add	sp, #8
 800413e:	4770      	bx	lr

08004140 <port_lock_from_isr.8635.4348>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8004140:	b508      	push	{r3, lr}

  port_lock();
 8004142:	f7ff ffed 	bl	8004120 <port_lock.8630.4352>
}
 8004146:	bd08      	pop	{r3, pc}
 8004148:	f3af 8000 	nop.w
 800414c:	f3af 8000 	nop.w

08004150 <port_unlock_from_isr.8637.4346>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8004150:	b508      	push	{r3, lr}

  port_unlock();
 8004152:	f7ff ffed 	bl	8004130 <port_unlock.8633.4350>
}
 8004156:	bd08      	pop	{r3, pc}
 8004158:	f3af 8000 	nop.w
 800415c:	f3af 8000 	nop.w

08004160 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8004160:	b510      	push	{r4, lr}
 8004162:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8004164:	f3ef 8309 	mrs	r3, PSP
 8004168:	461c      	mov	r4, r3
  return(result);
 800416a:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 800416c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800416e:	9b01      	ldr	r3, [sp, #4]
 8004170:	3320      	adds	r3, #32
 8004172:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8004174:	9b01      	ldr	r3, [sp, #4]
 8004176:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8004178:	9b00      	ldr	r3, [sp, #0]
 800417a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 800417e:	f7ff ffe7 	bl	8004150 <port_unlock_from_isr.8637.4346>
}
 8004182:	b002      	add	sp, #8
 8004184:	bd10      	pop	{r4, pc}
 8004186:	bf00      	nop
 8004188:	f3af 8000 	nop.w
 800418c:	f3af 8000 	nop.w

08004190 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8004190:	b510      	push	{r4, lr}
 8004192:	b082      	sub	sp, #8

  port_lock_from_isr();
 8004194:	f7ff ffd4 	bl	8004140 <port_lock_from_isr.8635.4348>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8004198:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800419c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80041a0:	685b      	ldr	r3, [r3, #4]
 80041a2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80041a6:	2b00      	cmp	r3, #0
 80041a8:	d023      	beq.n	80041f2 <_port_irq_epilogue+0x62>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80041aa:	f3ef 8309 	mrs	r3, PSP
 80041ae:	461c      	mov	r4, r3
  return(result);
 80041b0:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 80041b2:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80041b4:	9b01      	ldr	r3, [sp, #4]
 80041b6:	3b20      	subs	r3, #32
 80041b8:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80041ba:	9b01      	ldr	r3, [sp, #4]
 80041bc:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80041c0:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 80041c2:	9b01      	ldr	r3, [sp, #4]
 80041c4:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80041c6:	9b00      	ldr	r3, [sp, #0]
 80041c8:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80041cc:	f001 ff18 	bl	8006000 <chSchIsPreemptionRequired>
 80041d0:	4603      	mov	r3, r0
 80041d2:	2b00      	cmp	r3, #0
 80041d4:	d006      	beq.n	80041e4 <_port_irq_epilogue+0x54>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80041d6:	9a01      	ldr	r2, [sp, #4]
 80041d8:	f240 23f9 	movw	r3, #761	; 0x2f9
 80041dc:	f6c0 0300 	movt	r3, #2048	; 0x800
 80041e0:	6193      	str	r3, [r2, #24]
 80041e2:	e008      	b.n	80041f6 <_port_irq_epilogue+0x66>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80041e4:	9a01      	ldr	r2, [sp, #4]
 80041e6:	f240 330c 	movw	r3, #780	; 0x30c
 80041ea:	f6c0 0300 	movt	r3, #2048	; 0x800
 80041ee:	6193      	str	r3, [r2, #24]
 80041f0:	e001      	b.n	80041f6 <_port_irq_epilogue+0x66>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 80041f2:	f7ff ffad 	bl	8004150 <port_unlock_from_isr.8637.4346>
}
 80041f6:	b002      	add	sp, #8
 80041f8:	bd10      	pop	{r4, pc}
 80041fa:	bf00      	nop
 80041fc:	f3af 8000 	nop.w

08004200 <osalInit.8696.4337>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8004200:	4770      	bx	lr
 8004202:	bf00      	nop
 8004204:	f3af 8000 	nop.w
 8004208:	f3af 8000 	nop.w
 800420c:	f3af 8000 	nop.w

08004210 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8004210:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8004212:	f7ff fff5 	bl	8004200 <osalInit.8696.4337>

  /* Platform low level initializations.*/
  hal_lld_init();
 8004216:	f7fd fc7b 	bl	8001b10 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 800421a:	f647 1060 	movw	r0, #31072	; 0x7960
 800421e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004222:	f7fd fe85 	bl	8001f30 <_pal_lld_init>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8004226:	f7ff fc3b 	bl	8003aa0 <usbInit>
#endif
#if (HAL_USE_MMC_SPI == TRUE) || defined(__DOXYGEN__)
  mmcInit();
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
 800422a:	f7fe ff69 	bl	8003100 <sduInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 800422e:	f7fd fb17 	bl	8001860 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8004232:	f000 f835 	bl	80042a0 <stInit.4320>
#endif
}
 8004236:	bd08      	pop	{r3, pc}
 8004238:	f3af 8000 	nop.w
 800423c:	f3af 8000 	nop.w

08004240 <st_lld_start_alarm.8730.4331>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8004240:	b082      	sub	sp, #8
 8004242:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004244:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004248:	9a01      	ldr	r2, [sp, #4]
 800424a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800424c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004250:	2200      	movs	r2, #0
 8004252:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8004254:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004258:	2202      	movs	r2, #2
 800425a:	60da      	str	r2, [r3, #12]
}
 800425c:	b002      	add	sp, #8
 800425e:	4770      	bx	lr

08004260 <st_lld_stop_alarm.8737.4329>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8004260:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004264:	2200      	movs	r2, #0
 8004266:	60da      	str	r2, [r3, #12]
}
 8004268:	4770      	bx	lr
 800426a:	bf00      	nop
 800426c:	f3af 8000 	nop.w

08004270 <st_lld_set_alarm.8739.4326>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8004270:	b082      	sub	sp, #8
 8004272:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8004274:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004278:	9a01      	ldr	r2, [sp, #4]
 800427a:	635a      	str	r2, [r3, #52]	; 0x34
}
 800427c:	b002      	add	sp, #8
 800427e:	4770      	bx	lr

08004280 <st_lld_is_alarm_active.8744.4322>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8004280:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004284:	68db      	ldr	r3, [r3, #12]
 8004286:	f003 0302 	and.w	r3, r3, #2
 800428a:	2b00      	cmp	r3, #0
 800428c:	bf0c      	ite	eq
 800428e:	2300      	moveq	r3, #0
 8004290:	2301      	movne	r3, #1
 8004292:	b2db      	uxtb	r3, r3
}
 8004294:	4618      	mov	r0, r3
 8004296:	4770      	bx	lr
 8004298:	f3af 8000 	nop.w
 800429c:	f3af 8000 	nop.w

080042a0 <stInit.4320>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80042a0:	b508      	push	{r3, lr}

  st_lld_init();
 80042a2:	f7fd fddd 	bl	8001e60 <st_lld_init>
}
 80042a6:	bd08      	pop	{r3, pc}
 80042a8:	f3af 8000 	nop.w
 80042ac:	f3af 8000 	nop.w

080042b0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 80042b0:	b500      	push	{lr}
 80042b2:	b083      	sub	sp, #12
 80042b4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80042b6:	f7ff ffe3 	bl	8004280 <st_lld_is_alarm_active.8744.4322>
 80042ba:	4603      	mov	r3, r0
 80042bc:	2b00      	cmp	r3, #0
 80042be:	d005      	beq.n	80042cc <stStartAlarm+0x1c>
 80042c0:	f247 6070 	movw	r0, #30320	; 0x7670
 80042c4:	f6c0 0000 	movt	r0, #2048	; 0x800
 80042c8:	f001 f8b2 	bl	8005430 <chSysHalt>

  st_lld_start_alarm(abstime);
 80042cc:	9801      	ldr	r0, [sp, #4]
 80042ce:	f7ff ffb7 	bl	8004240 <st_lld_start_alarm.8730.4331>
}
 80042d2:	b003      	add	sp, #12
 80042d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80042d8:	f3af 8000 	nop.w
 80042dc:	f3af 8000 	nop.w

080042e0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 80042e0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 80042e2:	f7ff ffbd 	bl	8004260 <st_lld_stop_alarm.8737.4329>
}
 80042e6:	bd08      	pop	{r3, pc}
 80042e8:	f3af 8000 	nop.w
 80042ec:	f3af 8000 	nop.w

080042f0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 80042f0:	b500      	push	{lr}
 80042f2:	b083      	sub	sp, #12
 80042f4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80042f6:	f7ff ffc3 	bl	8004280 <st_lld_is_alarm_active.8744.4322>
 80042fa:	4603      	mov	r3, r0
 80042fc:	f083 0301 	eor.w	r3, r3, #1
 8004300:	b2db      	uxtb	r3, r3
 8004302:	2b00      	cmp	r3, #0
 8004304:	d005      	beq.n	8004312 <stSetAlarm+0x22>
 8004306:	f247 6080 	movw	r0, #30336	; 0x7680
 800430a:	f6c0 0000 	movt	r0, #2048	; 0x800
 800430e:	f001 f88f 	bl	8005430 <chSysHalt>

  st_lld_set_alarm(abstime);
 8004312:	9801      	ldr	r0, [sp, #4]
 8004314:	f7ff ffac 	bl	8004270 <st_lld_set_alarm.8739.4326>
}
 8004318:	b003      	add	sp, #12
 800431a:	f85d fb04 	ldr.w	pc, [sp], #4
 800431e:	bf00      	nop

08004320 <port_lock.8790.4307>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004320:	b082      	sub	sp, #8
 8004322:	2320      	movs	r3, #32
 8004324:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8004326:	9b01      	ldr	r3, [sp, #4]
 8004328:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800432c:	b002      	add	sp, #8
 800432e:	4770      	bx	lr

08004330 <port_unlock.8793.4305>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004330:	b082      	sub	sp, #8
 8004332:	2300      	movs	r3, #0
 8004334:	9301      	str	r3, [sp, #4]
 8004336:	9b01      	ldr	r3, [sp, #4]
 8004338:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800433c:	b002      	add	sp, #8
 800433e:	4770      	bx	lr

08004340 <st_lld_get_counter.8795.4303>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004340:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004344:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8004346:	4618      	mov	r0, r3
 8004348:	4770      	bx	lr
 800434a:	bf00      	nop
 800434c:	f3af 8000 	nop.w

08004350 <port_timer_get_time.8800.4301>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8004350:	b508      	push	{r3, lr}

  return stGetCounter();
 8004352:	f7ff fff5 	bl	8004340 <st_lld_get_counter.8795.4303>
 8004356:	4603      	mov	r3, r0
}
 8004358:	4618      	mov	r0, r3
 800435a:	bd08      	pop	{r3, pc}
 800435c:	f3af 8000 	nop.w

08004360 <queue_init.8802.4298>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8004360:	b082      	sub	sp, #8
 8004362:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8004364:	9b01      	ldr	r3, [sp, #4]
 8004366:	9a01      	ldr	r2, [sp, #4]
 8004368:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800436a:	9b01      	ldr	r3, [sp, #4]
 800436c:	9a01      	ldr	r2, [sp, #4]
 800436e:	605a      	str	r2, [r3, #4]
}
 8004370:	b002      	add	sp, #8
 8004372:	4770      	bx	lr
 8004374:	f3af 8000 	nop.w
 8004378:	f3af 8000 	nop.w
 800437c:	f3af 8000 	nop.w

08004380 <chSysLock.8907.4296>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8004380:	b508      	push	{r3, lr}

  port_lock();
 8004382:	f7ff ffcd 	bl	8004320 <port_lock.8790.4307>
  _stats_start_measure_crit_thd();
 8004386:	f002 fadb 	bl	8006940 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800438a:	f001 f8e9 	bl	8005560 <_dbg_check_lock>
}
 800438e:	bd08      	pop	{r3, pc}

08004390 <chSysUnlock.8911.4294>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8004390:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8004392:	f001 f905 	bl	80055a0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8004396:	f002 fadb 	bl	8006950 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800439a:	f640 0308 	movw	r3, #2056	; 0x808
 800439e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043a2:	681a      	ldr	r2, [r3, #0]
 80043a4:	f640 0308 	movw	r3, #2056	; 0x808
 80043a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043ac:	429a      	cmp	r2, r3
 80043ae:	d013      	beq.n	80043d8 <chSysUnlock.8911.4294+0x48>
 80043b0:	f640 0308 	movw	r3, #2056	; 0x808
 80043b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043b8:	699b      	ldr	r3, [r3, #24]
 80043ba:	689a      	ldr	r2, [r3, #8]
 80043bc:	f640 0308 	movw	r3, #2056	; 0x808
 80043c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80043c4:	681b      	ldr	r3, [r3, #0]
 80043c6:	689b      	ldr	r3, [r3, #8]
 80043c8:	429a      	cmp	r2, r3
 80043ca:	d205      	bcs.n	80043d8 <chSysUnlock.8911.4294+0x48>
 80043cc:	f247 60c0 	movw	r0, #30400	; 0x76c0
 80043d0:	f6c0 0000 	movt	r0, #2048	; 0x800
 80043d4:	f001 f82c 	bl	8005430 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80043d8:	f7ff ffaa 	bl	8004330 <port_unlock.8793.4305>
}
 80043dc:	bd08      	pop	{r3, pc}
 80043de:	bf00      	nop

080043e0 <chVTGetSystemTimeX.8889.4292>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80043e0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80043e2:	f7ff ffb5 	bl	8004350 <port_timer_get_time.8800.4301>
 80043e6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80043e8:	4618      	mov	r0, r3
 80043ea:	bd08      	pop	{r3, pc}
 80043ec:	f3af 8000 	nop.w

080043f0 <chThdQueueObjectInit.8891.4289>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 80043f0:	b500      	push	{lr}
 80043f2:	b083      	sub	sp, #12
 80043f4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 80043f6:	9801      	ldr	r0, [sp, #4]
 80043f8:	f7ff ffb2 	bl	8004360 <queue_init.8802.4298>
}
 80043fc:	b003      	add	sp, #12
 80043fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004402:	bf00      	nop
 8004404:	f3af 8000 	nop.w
 8004408:	f3af 8000 	nop.w
 800440c:	f3af 8000 	nop.w

08004410 <osalSysLock.8909.4287>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8004410:	b508      	push	{r3, lr}

  chSysLock();
 8004412:	f7ff ffb5 	bl	8004380 <chSysLock.8907.4296>
}
 8004416:	bd08      	pop	{r3, pc}
 8004418:	f3af 8000 	nop.w
 800441c:	f3af 8000 	nop.w

08004420 <osalSysUnlock.8913.4285>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8004420:	b508      	push	{r3, lr}

  chSysUnlock();
 8004422:	f7ff ffb5 	bl	8004390 <chSysUnlock.8911.4294>
}
 8004426:	bd08      	pop	{r3, pc}
 8004428:	f3af 8000 	nop.w
 800442c:	f3af 8000 	nop.w

08004430 <osalOsGetSystemTimeX.8894.4283>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 8004430:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 8004432:	f7ff ffd5 	bl	80043e0 <chVTGetSystemTimeX.8889.4292>
 8004436:	4603      	mov	r3, r0
}
 8004438:	4618      	mov	r0, r3
 800443a:	bd08      	pop	{r3, pc}
 800443c:	f3af 8000 	nop.w

08004440 <osalThreadQueueObjectInit.8896.4280>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8004440:	b500      	push	{lr}
 8004442:	b083      	sub	sp, #12
 8004444:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8004446:	9801      	ldr	r0, [sp, #4]
 8004448:	f7ff ffd2 	bl	80043f0 <chThdQueueObjectInit.8891.4289>
}
 800444c:	b003      	add	sp, #12
 800444e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004452:	bf00      	nop
 8004454:	f3af 8000 	nop.w
 8004458:	f3af 8000 	nop.w
 800445c:	f3af 8000 	nop.w

08004460 <osalThreadEnqueueTimeoutS.8915.4276>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 8004460:	b500      	push	{lr}
 8004462:	b083      	sub	sp, #12
 8004464:	9001      	str	r0, [sp, #4]
 8004466:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 8004468:	9801      	ldr	r0, [sp, #4]
 800446a:	9900      	ldr	r1, [sp, #0]
 800446c:	f002 f8e8 	bl	8006640 <chThdEnqueueTimeoutS>
 8004470:	4603      	mov	r3, r0
}
 8004472:	4618      	mov	r0, r3
 8004474:	b003      	add	sp, #12
 8004476:	f85d fb04 	ldr.w	pc, [sp], #4
 800447a:	bf00      	nop
 800447c:	f3af 8000 	nop.w

08004480 <osalThreadDequeueNextI.8903.4272>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8004480:	b500      	push	{lr}
 8004482:	b083      	sub	sp, #12
 8004484:	9001      	str	r0, [sp, #4]
 8004486:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8004488:	9801      	ldr	r0, [sp, #4]
 800448a:	9900      	ldr	r1, [sp, #0]
 800448c:	f002 f8f8 	bl	8006680 <chThdDequeueNextI>
}
 8004490:	b003      	add	sp, #12
 8004492:	f85d fb04 	ldr.w	pc, [sp], #4
 8004496:	bf00      	nop
 8004498:	f3af 8000 	nop.w
 800449c:	f3af 8000 	nop.w

080044a0 <osalThreadDequeueAllI.8899.4268>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80044a0:	b500      	push	{lr}
 80044a2:	b083      	sub	sp, #12
 80044a4:	9001      	str	r0, [sp, #4]
 80044a6:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 80044a8:	9801      	ldr	r0, [sp, #4]
 80044aa:	9900      	ldr	r1, [sp, #0]
 80044ac:	f002 f900 	bl	80066b0 <chThdDequeueAllI>
}
 80044b0:	b003      	add	sp, #12
 80044b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80044b6:	bf00      	nop
 80044b8:	f3af 8000 	nop.w
 80044bc:	f3af 8000 	nop.w

080044c0 <ibqObjectInit>:
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t infy, void *link) {
 80044c0:	b500      	push	{lr}
 80044c2:	b085      	sub	sp, #20
 80044c4:	9003      	str	r0, [sp, #12]
 80044c6:	9102      	str	r1, [sp, #8]
 80044c8:	9201      	str	r2, [sp, #4]
 80044ca:	9300      	str	r3, [sp, #0]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));
 80044cc:	9b03      	ldr	r3, [sp, #12]
 80044ce:	2b00      	cmp	r3, #0
 80044d0:	d005      	beq.n	80044de <ibqObjectInit+0x1e>
 80044d2:	9b02      	ldr	r3, [sp, #8]
 80044d4:	2b00      	cmp	r3, #0
 80044d6:	d002      	beq.n	80044de <ibqObjectInit+0x1e>
 80044d8:	9b01      	ldr	r3, [sp, #4]
 80044da:	2b01      	cmp	r3, #1
 80044dc:	d805      	bhi.n	80044ea <ibqObjectInit+0x2a>
 80044de:	f247 6090 	movw	r0, #30352	; 0x7690
 80044e2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80044e6:	f000 ffa3 	bl	8005430 <chSysHalt>

  osalThreadQueueObjectInit(&ibqp->waiting);
 80044ea:	9b03      	ldr	r3, [sp, #12]
 80044ec:	4618      	mov	r0, r3
 80044ee:	f7ff ffa7 	bl	8004440 <osalThreadQueueObjectInit.8896.4280>
  ibqp->bcounter = 0;
 80044f2:	9b03      	ldr	r3, [sp, #12]
 80044f4:	2200      	movs	r2, #0
 80044f6:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = bp;
 80044f8:	9b03      	ldr	r3, [sp, #12]
 80044fa:	9a02      	ldr	r2, [sp, #8]
 80044fc:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = bp;
 80044fe:	9b03      	ldr	r3, [sp, #12]
 8004500:	9a02      	ldr	r2, [sp, #8]
 8004502:	60da      	str	r2, [r3, #12]
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8004504:	9b01      	ldr	r3, [sp, #4]
 8004506:	3304      	adds	r3, #4
 8004508:	9a00      	ldr	r2, [sp, #0]
 800450a:	fb02 f303 	mul.w	r3, r2, r3
 800450e:	9a02      	ldr	r2, [sp, #8]
 8004510:	441a      	add	r2, r3
 8004512:	9b03      	ldr	r3, [sp, #12]
 8004514:	615a      	str	r2, [r3, #20]
  ibqp->bsize    = size + sizeof (size_t);
 8004516:	9b01      	ldr	r3, [sp, #4]
 8004518:	1d1a      	adds	r2, r3, #4
 800451a:	9b03      	ldr	r3, [sp, #12]
 800451c:	619a      	str	r2, [r3, #24]
  ibqp->bn       = n;
 800451e:	9b03      	ldr	r3, [sp, #12]
 8004520:	9a00      	ldr	r2, [sp, #0]
 8004522:	61da      	str	r2, [r3, #28]
  ibqp->buffers  = bp;
 8004524:	9b03      	ldr	r3, [sp, #12]
 8004526:	9a02      	ldr	r2, [sp, #8]
 8004528:	621a      	str	r2, [r3, #32]
  ibqp->ptr      = NULL;
 800452a:	9b03      	ldr	r3, [sp, #12]
 800452c:	2200      	movs	r2, #0
 800452e:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8004530:	9b03      	ldr	r3, [sp, #12]
 8004532:	2200      	movs	r2, #0
 8004534:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->notify   = infy;
 8004536:	9b03      	ldr	r3, [sp, #12]
 8004538:	9a06      	ldr	r2, [sp, #24]
 800453a:	62da      	str	r2, [r3, #44]	; 0x2c
  ibqp->link     = link;
 800453c:	9b03      	ldr	r3, [sp, #12]
 800453e:	9a07      	ldr	r2, [sp, #28]
 8004540:	631a      	str	r2, [r3, #48]	; 0x30
}
 8004542:	b005      	add	sp, #20
 8004544:	f85d fb04 	ldr.w	pc, [sp], #4
 8004548:	f3af 8000 	nop.w
 800454c:	f3af 8000 	nop.w

08004550 <ibqResetI>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {
 8004550:	b500      	push	{lr}
 8004552:	b083      	sub	sp, #12
 8004554:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8004556:	f001 f8d3 	bl	8005700 <chDbgCheckClassI>

  ibqp->bcounter = 0;
 800455a:	9b01      	ldr	r3, [sp, #4]
 800455c:	2200      	movs	r2, #0
 800455e:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = ibqp->buffers;
 8004560:	9b01      	ldr	r3, [sp, #4]
 8004562:	6a1a      	ldr	r2, [r3, #32]
 8004564:	9b01      	ldr	r3, [sp, #4]
 8004566:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = ibqp->buffers;
 8004568:	9b01      	ldr	r3, [sp, #4]
 800456a:	6a1a      	ldr	r2, [r3, #32]
 800456c:	9b01      	ldr	r3, [sp, #4]
 800456e:	60da      	str	r2, [r3, #12]
  ibqp->ptr      = NULL;
 8004570:	9b01      	ldr	r3, [sp, #4]
 8004572:	2200      	movs	r2, #0
 8004574:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8004576:	9b01      	ldr	r3, [sp, #4]
 8004578:	2200      	movs	r2, #0
 800457a:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 800457c:	9b01      	ldr	r3, [sp, #4]
 800457e:	4618      	mov	r0, r3
 8004580:	f06f 0101 	mvn.w	r1, #1
 8004584:	f7ff ff8c 	bl	80044a0 <osalThreadDequeueAllI.8899.4268>
}
 8004588:	b003      	add	sp, #12
 800458a:	f85d fb04 	ldr.w	pc, [sp], #4
 800458e:	bf00      	nop

08004590 <ibqGetEmptyBufferI>:
 * @return              A pointer to the next buffer to be filled.
 * @retval NULL         if the queue is full.
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {
 8004590:	b500      	push	{lr}
 8004592:	b083      	sub	sp, #12
 8004594:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8004596:	f001 f8b3 	bl	8005700 <chDbgCheckClassI>

  if (ibqIsFullI(ibqp)) {
 800459a:	9b01      	ldr	r3, [sp, #4]
 800459c:	68da      	ldr	r2, [r3, #12]
 800459e:	9b01      	ldr	r3, [sp, #4]
 80045a0:	691b      	ldr	r3, [r3, #16]
 80045a2:	429a      	cmp	r2, r3
 80045a4:	d105      	bne.n	80045b2 <ibqGetEmptyBufferI+0x22>
 80045a6:	9b01      	ldr	r3, [sp, #4]
 80045a8:	689b      	ldr	r3, [r3, #8]
 80045aa:	2b00      	cmp	r3, #0
 80045ac:	d001      	beq.n	80045b2 <ibqGetEmptyBufferI+0x22>
 80045ae:	2301      	movs	r3, #1
 80045b0:	e000      	b.n	80045b4 <ibqGetEmptyBufferI+0x24>
 80045b2:	2300      	movs	r3, #0
 80045b4:	f003 0301 	and.w	r3, r3, #1
 80045b8:	b2db      	uxtb	r3, r3
 80045ba:	2b00      	cmp	r3, #0
 80045bc:	d001      	beq.n	80045c2 <ibqGetEmptyBufferI+0x32>
    return NULL;
 80045be:	2300      	movs	r3, #0
 80045c0:	e002      	b.n	80045c8 <ibqGetEmptyBufferI+0x38>
  }

  return ibqp->bwrptr + sizeof (size_t);
 80045c2:	9b01      	ldr	r3, [sp, #4]
 80045c4:	68db      	ldr	r3, [r3, #12]
 80045c6:	3304      	adds	r3, #4
}
 80045c8:	4618      	mov	r0, r3
 80045ca:	b003      	add	sp, #12
 80045cc:	f85d fb04 	ldr.w	pc, [sp], #4

080045d0 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 80045d0:	b500      	push	{lr}
 80045d2:	b083      	sub	sp, #12
 80045d4:	9001      	str	r0, [sp, #4]
 80045d6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 80045d8:	f001 f892 	bl	8005700 <chDbgCheckClassI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 80045dc:	9b00      	ldr	r3, [sp, #0]
 80045de:	2b00      	cmp	r3, #0
 80045e0:	d005      	beq.n	80045ee <ibqPostFullBufferI+0x1e>
 80045e2:	9b01      	ldr	r3, [sp, #4]
 80045e4:	699b      	ldr	r3, [r3, #24]
 80045e6:	1f1a      	subs	r2, r3, #4
 80045e8:	9b00      	ldr	r3, [sp, #0]
 80045ea:	429a      	cmp	r2, r3
 80045ec:	d205      	bcs.n	80045fa <ibqPostFullBufferI+0x2a>
 80045ee:	f247 60a0 	movw	r0, #30368	; 0x76a0
 80045f2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80045f6:	f000 ff1b 	bl	8005430 <chSysHalt>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 80045fa:	9b01      	ldr	r3, [sp, #4]
 80045fc:	68da      	ldr	r2, [r3, #12]
 80045fe:	9b01      	ldr	r3, [sp, #4]
 8004600:	691b      	ldr	r3, [r3, #16]
 8004602:	429a      	cmp	r2, r3
 8004604:	d105      	bne.n	8004612 <ibqPostFullBufferI+0x42>
 8004606:	9b01      	ldr	r3, [sp, #4]
 8004608:	689b      	ldr	r3, [r3, #8]
 800460a:	2b00      	cmp	r3, #0
 800460c:	d001      	beq.n	8004612 <ibqPostFullBufferI+0x42>
 800460e:	2301      	movs	r3, #1
 8004610:	e000      	b.n	8004614 <ibqPostFullBufferI+0x44>
 8004612:	2300      	movs	r3, #0
 8004614:	f003 0301 	and.w	r3, r3, #1
 8004618:	b2db      	uxtb	r3, r3
 800461a:	2b00      	cmp	r3, #0
 800461c:	d005      	beq.n	800462a <ibqPostFullBufferI+0x5a>
 800461e:	f247 60a0 	movw	r0, #30368	; 0x76a0
 8004622:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004626:	f000 ff03 	bl	8005430 <chSysHalt>

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 800462a:	9b01      	ldr	r3, [sp, #4]
 800462c:	68db      	ldr	r3, [r3, #12]
 800462e:	9a00      	ldr	r2, [sp, #0]
 8004630:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 8004632:	9b01      	ldr	r3, [sp, #4]
 8004634:	689b      	ldr	r3, [r3, #8]
 8004636:	1c5a      	adds	r2, r3, #1
 8004638:	9b01      	ldr	r3, [sp, #4]
 800463a:	609a      	str	r2, [r3, #8]
  ibqp->bwrptr += ibqp->bsize;
 800463c:	9b01      	ldr	r3, [sp, #4]
 800463e:	68da      	ldr	r2, [r3, #12]
 8004640:	9b01      	ldr	r3, [sp, #4]
 8004642:	699b      	ldr	r3, [r3, #24]
 8004644:	441a      	add	r2, r3
 8004646:	9b01      	ldr	r3, [sp, #4]
 8004648:	60da      	str	r2, [r3, #12]
  if (ibqp->bwrptr >= ibqp->btop) {
 800464a:	9b01      	ldr	r3, [sp, #4]
 800464c:	68da      	ldr	r2, [r3, #12]
 800464e:	9b01      	ldr	r3, [sp, #4]
 8004650:	695b      	ldr	r3, [r3, #20]
 8004652:	429a      	cmp	r2, r3
 8004654:	d303      	bcc.n	800465e <ibqPostFullBufferI+0x8e>
    ibqp->bwrptr = ibqp->buffers;
 8004656:	9b01      	ldr	r3, [sp, #4]
 8004658:	6a1a      	ldr	r2, [r3, #32]
 800465a:	9b01      	ldr	r3, [sp, #4]
 800465c:	60da      	str	r2, [r3, #12]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 800465e:	9b01      	ldr	r3, [sp, #4]
 8004660:	4618      	mov	r0, r3
 8004662:	2100      	movs	r1, #0
 8004664:	f7ff ff0c 	bl	8004480 <osalThreadDequeueNextI.8903.4272>
}
 8004668:	b003      	add	sp, #12
 800466a:	f85d fb04 	ldr.w	pc, [sp], #4
 800466e:	bf00      	nop

08004670 <ibqGetFullBufferTimeoutS.4242>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 8004670:	b500      	push	{lr}
 8004672:	b085      	sub	sp, #20
 8004674:	9001      	str	r0, [sp, #4]
 8004676:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 8004678:	f001 f85a 	bl	8005730 <chDbgCheckClassS>
 800467c:	e00a      	b.n	8004694 <ibqGetFullBufferTimeoutS.4242+0x24>

  while (ibqIsEmptyI(ibqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 800467e:	9b01      	ldr	r3, [sp, #4]
 8004680:	4618      	mov	r0, r3
 8004682:	9900      	ldr	r1, [sp, #0]
 8004684:	f7ff feec 	bl	8004460 <osalThreadEnqueueTimeoutS.8915.4276>
 8004688:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 800468a:	9b03      	ldr	r3, [sp, #12]
 800468c:	2b00      	cmp	r3, #0
 800468e:	da01      	bge.n	8004694 <ibqGetFullBufferTimeoutS.4242+0x24>
       return msg;
 8004690:	9b03      	ldr	r3, [sp, #12]
 8004692:	e01b      	b.n	80046cc <ibqGetFullBufferTimeoutS.4242+0x5c>
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8004694:	9b01      	ldr	r3, [sp, #4]
 8004696:	689b      	ldr	r3, [r3, #8]
 8004698:	2b00      	cmp	r3, #0
 800469a:	d0f0      	beq.n	800467e <ibqGetFullBufferTimeoutS.4242+0xe>
    if (msg < MSG_OK) {
       return msg;
    }
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 800469c:	9b01      	ldr	r3, [sp, #4]
 800469e:	689b      	ldr	r3, [r3, #8]
 80046a0:	2b00      	cmp	r3, #0
 80046a2:	d105      	bne.n	80046b0 <ibqGetFullBufferTimeoutS.4242+0x40>
 80046a4:	f247 60d0 	movw	r0, #30416	; 0x76d0
 80046a8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80046ac:	f000 fec0 	bl	8005430 <chSysHalt>

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80046b0:	9b01      	ldr	r3, [sp, #4]
 80046b2:	691b      	ldr	r3, [r3, #16]
 80046b4:	1d1a      	adds	r2, r3, #4
 80046b6:	9b01      	ldr	r3, [sp, #4]
 80046b8:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 80046ba:	9b01      	ldr	r3, [sp, #4]
 80046bc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80046be:	9b01      	ldr	r3, [sp, #4]
 80046c0:	691b      	ldr	r3, [r3, #16]
 80046c2:	681b      	ldr	r3, [r3, #0]
 80046c4:	441a      	add	r2, r3
 80046c6:	9b01      	ldr	r3, [sp, #4]
 80046c8:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 80046ca:	2300      	movs	r3, #0
}
 80046cc:	4618      	mov	r0, r3
 80046ce:	b005      	add	sp, #20
 80046d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80046d4:	f3af 8000 	nop.w
 80046d8:	f3af 8000 	nop.w
 80046dc:	f3af 8000 	nop.w

080046e0 <ibqReleaseEmptyBufferS.4236>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 80046e0:	b500      	push	{lr}
 80046e2:	b083      	sub	sp, #12
 80046e4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassS();
 80046e6:	f001 f823 	bl	8005730 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 80046ea:	9b01      	ldr	r3, [sp, #4]
 80046ec:	689b      	ldr	r3, [r3, #8]
 80046ee:	2b00      	cmp	r3, #0
 80046f0:	d105      	bne.n	80046fe <ibqReleaseEmptyBufferS.4236+0x1e>
 80046f2:	f247 60f0 	movw	r0, #30448	; 0x76f0
 80046f6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80046fa:	f000 fe99 	bl	8005430 <chSysHalt>

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 80046fe:	9b01      	ldr	r3, [sp, #4]
 8004700:	689b      	ldr	r3, [r3, #8]
 8004702:	1e5a      	subs	r2, r3, #1
 8004704:	9b01      	ldr	r3, [sp, #4]
 8004706:	609a      	str	r2, [r3, #8]
  ibqp->brdptr += ibqp->bsize;
 8004708:	9b01      	ldr	r3, [sp, #4]
 800470a:	691a      	ldr	r2, [r3, #16]
 800470c:	9b01      	ldr	r3, [sp, #4]
 800470e:	699b      	ldr	r3, [r3, #24]
 8004710:	441a      	add	r2, r3
 8004712:	9b01      	ldr	r3, [sp, #4]
 8004714:	611a      	str	r2, [r3, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 8004716:	9b01      	ldr	r3, [sp, #4]
 8004718:	691a      	ldr	r2, [r3, #16]
 800471a:	9b01      	ldr	r3, [sp, #4]
 800471c:	695b      	ldr	r3, [r3, #20]
 800471e:	429a      	cmp	r2, r3
 8004720:	d303      	bcc.n	800472a <ibqReleaseEmptyBufferS.4236+0x4a>
    ibqp->brdptr = ibqp->buffers;
 8004722:	9b01      	ldr	r3, [sp, #4]
 8004724:	6a1a      	ldr	r2, [r3, #32]
 8004726:	9b01      	ldr	r3, [sp, #4]
 8004728:	611a      	str	r2, [r3, #16]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 800472a:	9b01      	ldr	r3, [sp, #4]
 800472c:	2200      	movs	r2, #0
 800472e:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8004730:	9b01      	ldr	r3, [sp, #4]
 8004732:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004734:	2b00      	cmp	r3, #0
 8004736:	d003      	beq.n	8004740 <ibqReleaseEmptyBufferS.4236+0x60>
    ibqp->notify(ibqp);
 8004738:	9b01      	ldr	r3, [sp, #4]
 800473a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800473c:	9801      	ldr	r0, [sp, #4]
 800473e:	4798      	blx	r3
  }
}
 8004740:	b003      	add	sp, #12
 8004742:	f85d fb04 	ldr.w	pc, [sp], #4
 8004746:	bf00      	nop
 8004748:	f3af 8000 	nop.w
 800474c:	f3af 8000 	nop.w

08004750 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8004750:	b500      	push	{lr}
 8004752:	b085      	sub	sp, #20
 8004754:	9001      	str	r0, [sp, #4]
 8004756:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8004758:	f7ff fe5a 	bl	8004410 <osalSysLock.8909.4287>

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 800475c:	9b01      	ldr	r3, [sp, #4]
 800475e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004760:	2b00      	cmp	r3, #0
 8004762:	d10b      	bne.n	800477c <ibqGetTimeout+0x2c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8004764:	9801      	ldr	r0, [sp, #4]
 8004766:	9900      	ldr	r1, [sp, #0]
 8004768:	f7ff ff82 	bl	8004670 <ibqGetFullBufferTimeoutS.4242>
 800476c:	9003      	str	r0, [sp, #12]
    if (msg != MSG_OK) {
 800476e:	9b03      	ldr	r3, [sp, #12]
 8004770:	2b00      	cmp	r3, #0
 8004772:	d003      	beq.n	800477c <ibqGetTimeout+0x2c>
      osalSysUnlock();
 8004774:	f7ff fe54 	bl	8004420 <osalSysUnlock.8913.4285>
      return msg;
 8004778:	9b03      	ldr	r3, [sp, #12]
 800477a:	e014      	b.n	80047a6 <ibqGetTimeout+0x56>
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 800477c:	9b01      	ldr	r3, [sp, #4]
 800477e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004780:	781b      	ldrb	r3, [r3, #0]
 8004782:	9303      	str	r3, [sp, #12]
  ibqp->ptr++;
 8004784:	9b01      	ldr	r3, [sp, #4]
 8004786:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004788:	1c5a      	adds	r2, r3, #1
 800478a:	9b01      	ldr	r3, [sp, #4]
 800478c:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 800478e:	9b01      	ldr	r3, [sp, #4]
 8004790:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004792:	9b01      	ldr	r3, [sp, #4]
 8004794:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004796:	429a      	cmp	r2, r3
 8004798:	d302      	bcc.n	80047a0 <ibqGetTimeout+0x50>
    ibqReleaseEmptyBufferS(ibqp);
 800479a:	9801      	ldr	r0, [sp, #4]
 800479c:	f7ff ffa0 	bl	80046e0 <ibqReleaseEmptyBufferS.4236>
  }

  osalSysUnlock();
 80047a0:	f7ff fe3e 	bl	8004420 <osalSysUnlock.8913.4285>
  return msg;
 80047a4:	9b03      	ldr	r3, [sp, #12]
}
 80047a6:	4618      	mov	r0, r3
 80047a8:	b005      	add	sp, #20
 80047aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80047ae:	bf00      	nop

080047b0 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 80047b0:	b500      	push	{lr}
 80047b2:	b08b      	sub	sp, #44	; 0x2c
 80047b4:	9003      	str	r0, [sp, #12]
 80047b6:	9102      	str	r1, [sp, #8]
 80047b8:	9201      	str	r2, [sp, #4]
 80047ba:	9300      	str	r3, [sp, #0]
  size_t r = 0;
 80047bc:	2300      	movs	r3, #0
 80047be:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 80047c0:	f7ff fe26 	bl	8004410 <osalSysLock.8909.4287>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80047c4:	f7ff fe34 	bl	8004430 <osalOsGetSystemTimeX.8894.4283>
 80047c8:	4602      	mov	r2, r0
 80047ca:	9b00      	ldr	r3, [sp, #0]
 80047cc:	4413      	add	r3, r2
 80047ce:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 80047d0:	9b03      	ldr	r3, [sp, #12]
 80047d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80047d4:	2b00      	cmp	r3, #0
 80047d6:	d126      	bne.n	8004826 <ibqReadTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80047d8:	9b00      	ldr	r3, [sp, #0]
 80047da:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80047de:	d002      	beq.n	80047e6 <ibqReadTimeout+0x36>
 80047e0:	9b00      	ldr	r3, [sp, #0]
 80047e2:	2b00      	cmp	r3, #0
 80047e4:	d105      	bne.n	80047f2 <ibqReadTimeout+0x42>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80047e6:	9803      	ldr	r0, [sp, #12]
 80047e8:	9900      	ldr	r1, [sp, #0]
 80047ea:	f7ff ff41 	bl	8004670 <ibqGetFullBufferTimeoutS.4242>
 80047ee:	9007      	str	r0, [sp, #28]
 80047f0:	e012      	b.n	8004818 <ibqReadTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80047f2:	f7ff fe1d 	bl	8004430 <osalOsGetSystemTimeX.8894.4283>
 80047f6:	4603      	mov	r3, r0
 80047f8:	9a06      	ldr	r2, [sp, #24]
 80047fa:	1ad3      	subs	r3, r2, r3
 80047fc:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80047fe:	9a05      	ldr	r2, [sp, #20]
 8004800:	9b00      	ldr	r3, [sp, #0]
 8004802:	429a      	cmp	r2, r3
 8004804:	d903      	bls.n	800480e <ibqReadTimeout+0x5e>
          osalSysUnlock();
 8004806:	f7ff fe0b 	bl	8004420 <osalSysUnlock.8913.4285>
          return r;
 800480a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800480c:	e05c      	b.n	80048c8 <ibqReadTimeout+0x118>
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 800480e:	9803      	ldr	r0, [sp, #12]
 8004810:	9905      	ldr	r1, [sp, #20]
 8004812:	f7ff ff2d 	bl	8004670 <ibqGetFullBufferTimeoutS.4242>
 8004816:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8004818:	9b07      	ldr	r3, [sp, #28]
 800481a:	2b00      	cmp	r3, #0
 800481c:	d003      	beq.n	8004826 <ibqReadTimeout+0x76>
        osalSysUnlock();
 800481e:	f7ff fdff 	bl	8004420 <osalSysUnlock.8913.4285>
        return r;
 8004822:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004824:	e050      	b.n	80048c8 <ibqReadTimeout+0x118>
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8004826:	9b03      	ldr	r3, [sp, #12]
 8004828:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800482a:	461a      	mov	r2, r3
 800482c:	9b03      	ldr	r3, [sp, #12]
 800482e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004830:	1ad3      	subs	r3, r2, r3
 8004832:	9308      	str	r3, [sp, #32]
    if (size > (n - r)) {
 8004834:	9a01      	ldr	r2, [sp, #4]
 8004836:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004838:	1ad2      	subs	r2, r2, r3
 800483a:	9b08      	ldr	r3, [sp, #32]
 800483c:	429a      	cmp	r2, r3
 800483e:	d203      	bcs.n	8004848 <ibqReadTimeout+0x98>
      size = n - r;
 8004840:	9a01      	ldr	r2, [sp, #4]
 8004842:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004844:	1ad3      	subs	r3, r2, r3
 8004846:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8004848:	9b08      	ldr	r3, [sp, #32]
 800484a:	2b40      	cmp	r3, #64	; 0x40
 800484c:	d913      	bls.n	8004876 <ibqReadTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 800484e:	9b03      	ldr	r3, [sp, #12]
 8004850:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004852:	9802      	ldr	r0, [sp, #8]
 8004854:	4619      	mov	r1, r3
 8004856:	2240      	movs	r2, #64	; 0x40
 8004858:	f7fb fd5a 	bl	8000310 <memcpy>
      bp        += 64U;
 800485c:	9b02      	ldr	r3, [sp, #8]
 800485e:	3340      	adds	r3, #64	; 0x40
 8004860:	9302      	str	r3, [sp, #8]
      ibqp->ptr += 64U;
 8004862:	9b03      	ldr	r3, [sp, #12]
 8004864:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004866:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800486a:	9b03      	ldr	r3, [sp, #12]
 800486c:	625a      	str	r2, [r3, #36]	; 0x24
      r         += 64U;
 800486e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004870:	3340      	adds	r3, #64	; 0x40
 8004872:	9309      	str	r3, [sp, #36]	; 0x24
 8004874:	e014      	b.n	80048a0 <ibqReadTimeout+0xf0>
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 8004876:	9b03      	ldr	r3, [sp, #12]
 8004878:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800487a:	9802      	ldr	r0, [sp, #8]
 800487c:	4619      	mov	r1, r3
 800487e:	9a08      	ldr	r2, [sp, #32]
 8004880:	f7fb fd46 	bl	8000310 <memcpy>
      bp        += size;
 8004884:	9a02      	ldr	r2, [sp, #8]
 8004886:	9b08      	ldr	r3, [sp, #32]
 8004888:	4413      	add	r3, r2
 800488a:	9302      	str	r3, [sp, #8]
      ibqp->ptr += size;
 800488c:	9b03      	ldr	r3, [sp, #12]
 800488e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004890:	9b08      	ldr	r3, [sp, #32]
 8004892:	441a      	add	r2, r3
 8004894:	9b03      	ldr	r3, [sp, #12]
 8004896:	625a      	str	r2, [r3, #36]	; 0x24
      r         += size;
 8004898:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800489a:	9b08      	ldr	r3, [sp, #32]
 800489c:	4413      	add	r3, r2
 800489e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 80048a0:	9b03      	ldr	r3, [sp, #12]
 80048a2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80048a4:	9b03      	ldr	r3, [sp, #12]
 80048a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80048a8:	429a      	cmp	r2, r3
 80048aa:	d302      	bcc.n	80048b2 <ibqReadTimeout+0x102>
      ibqReleaseEmptyBufferS(ibqp);
 80048ac:	9803      	ldr	r0, [sp, #12]
 80048ae:	f7ff ff17 	bl	80046e0 <ibqReleaseEmptyBufferS.4236>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 80048b2:	f7ff fdb5 	bl	8004420 <osalSysUnlock.8913.4285>
    if (r >= n) {
 80048b6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80048b8:	9b01      	ldr	r3, [sp, #4]
 80048ba:	429a      	cmp	r2, r3
 80048bc:	d301      	bcc.n	80048c2 <ibqReadTimeout+0x112>
      return r;
 80048be:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80048c0:	e002      	b.n	80048c8 <ibqReadTimeout+0x118>
    }
    osalSysLock();
 80048c2:	f7ff fda5 	bl	8004410 <osalSysLock.8909.4287>
 80048c6:	e783      	b.n	80047d0 <ibqReadTimeout+0x20>
  }
}
 80048c8:	4618      	mov	r0, r3
 80048ca:	b00b      	add	sp, #44	; 0x2c
 80048cc:	f85d fb04 	ldr.w	pc, [sp], #4

080048d0 <obqObjectInit>:
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t onfy, void *link) {
 80048d0:	b500      	push	{lr}
 80048d2:	b085      	sub	sp, #20
 80048d4:	9003      	str	r0, [sp, #12]
 80048d6:	9102      	str	r1, [sp, #8]
 80048d8:	9201      	str	r2, [sp, #4]
 80048da:	9300      	str	r3, [sp, #0]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));
 80048dc:	9b03      	ldr	r3, [sp, #12]
 80048de:	2b00      	cmp	r3, #0
 80048e0:	d005      	beq.n	80048ee <obqObjectInit+0x1e>
 80048e2:	9b02      	ldr	r3, [sp, #8]
 80048e4:	2b00      	cmp	r3, #0
 80048e6:	d002      	beq.n	80048ee <obqObjectInit+0x1e>
 80048e8:	9b01      	ldr	r3, [sp, #4]
 80048ea:	2b01      	cmp	r3, #1
 80048ec:	d805      	bhi.n	80048fa <obqObjectInit+0x2a>
 80048ee:	f247 7010 	movw	r0, #30480	; 0x7710
 80048f2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80048f6:	f000 fd9b 	bl	8005430 <chSysHalt>

  osalThreadQueueObjectInit(&obqp->waiting);
 80048fa:	9b03      	ldr	r3, [sp, #12]
 80048fc:	4618      	mov	r0, r3
 80048fe:	f7ff fd9f 	bl	8004440 <osalThreadQueueObjectInit.8896.4280>
  obqp->bcounter = n;
 8004902:	9b03      	ldr	r3, [sp, #12]
 8004904:	9a00      	ldr	r2, [sp, #0]
 8004906:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = bp;
 8004908:	9b03      	ldr	r3, [sp, #12]
 800490a:	9a02      	ldr	r2, [sp, #8]
 800490c:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = bp;
 800490e:	9b03      	ldr	r3, [sp, #12]
 8004910:	9a02      	ldr	r2, [sp, #8]
 8004912:	60da      	str	r2, [r3, #12]
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8004914:	9b01      	ldr	r3, [sp, #4]
 8004916:	3304      	adds	r3, #4
 8004918:	9a00      	ldr	r2, [sp, #0]
 800491a:	fb02 f303 	mul.w	r3, r2, r3
 800491e:	9a02      	ldr	r2, [sp, #8]
 8004920:	441a      	add	r2, r3
 8004922:	9b03      	ldr	r3, [sp, #12]
 8004924:	615a      	str	r2, [r3, #20]
  obqp->bsize    = size + sizeof (size_t);
 8004926:	9b01      	ldr	r3, [sp, #4]
 8004928:	1d1a      	adds	r2, r3, #4
 800492a:	9b03      	ldr	r3, [sp, #12]
 800492c:	619a      	str	r2, [r3, #24]
  obqp->bn       = n;
 800492e:	9b03      	ldr	r3, [sp, #12]
 8004930:	9a00      	ldr	r2, [sp, #0]
 8004932:	61da      	str	r2, [r3, #28]
  obqp->buffers  = bp;
 8004934:	9b03      	ldr	r3, [sp, #12]
 8004936:	9a02      	ldr	r2, [sp, #8]
 8004938:	621a      	str	r2, [r3, #32]
  obqp->ptr      = NULL;
 800493a:	9b03      	ldr	r3, [sp, #12]
 800493c:	2200      	movs	r2, #0
 800493e:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8004940:	9b03      	ldr	r3, [sp, #12]
 8004942:	2200      	movs	r2, #0
 8004944:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->notify   = onfy;
 8004946:	9b03      	ldr	r3, [sp, #12]
 8004948:	9a06      	ldr	r2, [sp, #24]
 800494a:	62da      	str	r2, [r3, #44]	; 0x2c
  obqp->link     = link;
 800494c:	9b03      	ldr	r3, [sp, #12]
 800494e:	9a07      	ldr	r2, [sp, #28]
 8004950:	631a      	str	r2, [r3, #48]	; 0x30
}
 8004952:	b005      	add	sp, #20
 8004954:	f85d fb04 	ldr.w	pc, [sp], #4
 8004958:	f3af 8000 	nop.w
 800495c:	f3af 8000 	nop.w

08004960 <obqResetI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 8004960:	b500      	push	{lr}
 8004962:	b083      	sub	sp, #12
 8004964:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8004966:	f000 fecb 	bl	8005700 <chDbgCheckClassI>

  obqp->bcounter = bqSizeX(obqp);
 800496a:	9b01      	ldr	r3, [sp, #4]
 800496c:	69da      	ldr	r2, [r3, #28]
 800496e:	9b01      	ldr	r3, [sp, #4]
 8004970:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = obqp->buffers;
 8004972:	9b01      	ldr	r3, [sp, #4]
 8004974:	6a1a      	ldr	r2, [r3, #32]
 8004976:	9b01      	ldr	r3, [sp, #4]
 8004978:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = obqp->buffers;
 800497a:	9b01      	ldr	r3, [sp, #4]
 800497c:	6a1a      	ldr	r2, [r3, #32]
 800497e:	9b01      	ldr	r3, [sp, #4]
 8004980:	60da      	str	r2, [r3, #12]
  obqp->ptr      = NULL;
 8004982:	9b01      	ldr	r3, [sp, #4]
 8004984:	2200      	movs	r2, #0
 8004986:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8004988:	9b01      	ldr	r3, [sp, #4]
 800498a:	2200      	movs	r2, #0
 800498c:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800498e:	9b01      	ldr	r3, [sp, #4]
 8004990:	4618      	mov	r0, r3
 8004992:	f06f 0101 	mvn.w	r1, #1
 8004996:	f7ff fd83 	bl	80044a0 <osalThreadDequeueAllI.8899.4268>
}
 800499a:	b003      	add	sp, #12
 800499c:	f85d fb04 	ldr.w	pc, [sp], #4

080049a0 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 80049a0:	b500      	push	{lr}
 80049a2:	b083      	sub	sp, #12
 80049a4:	9001      	str	r0, [sp, #4]
 80049a6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();
 80049a8:	f000 feaa 	bl	8005700 <chDbgCheckClassI>

  if (obqIsEmptyI(obqp)) {
 80049ac:	9b01      	ldr	r3, [sp, #4]
 80049ae:	68da      	ldr	r2, [r3, #12]
 80049b0:	9b01      	ldr	r3, [sp, #4]
 80049b2:	691b      	ldr	r3, [r3, #16]
 80049b4:	429a      	cmp	r2, r3
 80049b6:	d105      	bne.n	80049c4 <obqGetFullBufferI+0x24>
 80049b8:	9b01      	ldr	r3, [sp, #4]
 80049ba:	689b      	ldr	r3, [r3, #8]
 80049bc:	2b00      	cmp	r3, #0
 80049be:	d001      	beq.n	80049c4 <obqGetFullBufferI+0x24>
 80049c0:	2301      	movs	r3, #1
 80049c2:	e000      	b.n	80049c6 <obqGetFullBufferI+0x26>
 80049c4:	2300      	movs	r3, #0
 80049c6:	f003 0301 	and.w	r3, r3, #1
 80049ca:	b2db      	uxtb	r3, r3
 80049cc:	2b00      	cmp	r3, #0
 80049ce:	d001      	beq.n	80049d4 <obqGetFullBufferI+0x34>
    return NULL;
 80049d0:	2300      	movs	r3, #0
 80049d2:	e007      	b.n	80049e4 <obqGetFullBufferI+0x44>
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 80049d4:	9b01      	ldr	r3, [sp, #4]
 80049d6:	691b      	ldr	r3, [r3, #16]
 80049d8:	681a      	ldr	r2, [r3, #0]
 80049da:	9b00      	ldr	r3, [sp, #0]
 80049dc:	601a      	str	r2, [r3, #0]

  return obqp->brdptr + sizeof (size_t);
 80049de:	9b01      	ldr	r3, [sp, #4]
 80049e0:	691b      	ldr	r3, [r3, #16]
 80049e2:	3304      	adds	r3, #4
}
 80049e4:	4618      	mov	r0, r3
 80049e6:	b003      	add	sp, #12
 80049e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80049ec:	f3af 8000 	nop.w

080049f0 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 80049f0:	b500      	push	{lr}
 80049f2:	b083      	sub	sp, #12
 80049f4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 80049f6:	f000 fe83 	bl	8005700 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 80049fa:	9b01      	ldr	r3, [sp, #4]
 80049fc:	68da      	ldr	r2, [r3, #12]
 80049fe:	9b01      	ldr	r3, [sp, #4]
 8004a00:	691b      	ldr	r3, [r3, #16]
 8004a02:	429a      	cmp	r2, r3
 8004a04:	d105      	bne.n	8004a12 <obqReleaseEmptyBufferI+0x22>
 8004a06:	9b01      	ldr	r3, [sp, #4]
 8004a08:	689b      	ldr	r3, [r3, #8]
 8004a0a:	2b00      	cmp	r3, #0
 8004a0c:	d001      	beq.n	8004a12 <obqReleaseEmptyBufferI+0x22>
 8004a0e:	2301      	movs	r3, #1
 8004a10:	e000      	b.n	8004a14 <obqReleaseEmptyBufferI+0x24>
 8004a12:	2300      	movs	r3, #0
 8004a14:	f003 0301 	and.w	r3, r3, #1
 8004a18:	b2db      	uxtb	r3, r3
 8004a1a:	2b00      	cmp	r3, #0
 8004a1c:	d005      	beq.n	8004a2a <obqReleaseEmptyBufferI+0x3a>
 8004a1e:	f247 7020 	movw	r0, #30496	; 0x7720
 8004a22:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004a26:	f000 fd03 	bl	8005430 <chSysHalt>

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 8004a2a:	9b01      	ldr	r3, [sp, #4]
 8004a2c:	689b      	ldr	r3, [r3, #8]
 8004a2e:	1c5a      	adds	r2, r3, #1
 8004a30:	9b01      	ldr	r3, [sp, #4]
 8004a32:	609a      	str	r2, [r3, #8]
  obqp->brdptr += obqp->bsize;
 8004a34:	9b01      	ldr	r3, [sp, #4]
 8004a36:	691a      	ldr	r2, [r3, #16]
 8004a38:	9b01      	ldr	r3, [sp, #4]
 8004a3a:	699b      	ldr	r3, [r3, #24]
 8004a3c:	441a      	add	r2, r3
 8004a3e:	9b01      	ldr	r3, [sp, #4]
 8004a40:	611a      	str	r2, [r3, #16]
  if (obqp->brdptr >= obqp->btop) {
 8004a42:	9b01      	ldr	r3, [sp, #4]
 8004a44:	691a      	ldr	r2, [r3, #16]
 8004a46:	9b01      	ldr	r3, [sp, #4]
 8004a48:	695b      	ldr	r3, [r3, #20]
 8004a4a:	429a      	cmp	r2, r3
 8004a4c:	d303      	bcc.n	8004a56 <obqReleaseEmptyBufferI+0x66>
    obqp->brdptr = obqp->buffers;
 8004a4e:	9b01      	ldr	r3, [sp, #4]
 8004a50:	6a1a      	ldr	r2, [r3, #32]
 8004a52:	9b01      	ldr	r3, [sp, #4]
 8004a54:	611a      	str	r2, [r3, #16]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 8004a56:	9b01      	ldr	r3, [sp, #4]
 8004a58:	4618      	mov	r0, r3
 8004a5a:	2100      	movs	r1, #0
 8004a5c:	f7ff fd10 	bl	8004480 <osalThreadDequeueNextI.8903.4272>
}
 8004a60:	b003      	add	sp, #12
 8004a62:	f85d fb04 	ldr.w	pc, [sp], #4
 8004a66:	bf00      	nop
 8004a68:	f3af 8000 	nop.w
 8004a6c:	f3af 8000 	nop.w

08004a70 <obqGetEmptyBufferTimeoutS.4199>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {
 8004a70:	b500      	push	{lr}
 8004a72:	b085      	sub	sp, #20
 8004a74:	9001      	str	r0, [sp, #4]
 8004a76:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 8004a78:	f000 fe5a 	bl	8005730 <chDbgCheckClassS>
 8004a7c:	e00a      	b.n	8004a94 <obqGetEmptyBufferTimeoutS.4199+0x24>

  while (obqIsFullI(obqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 8004a7e:	9b01      	ldr	r3, [sp, #4]
 8004a80:	4618      	mov	r0, r3
 8004a82:	9900      	ldr	r1, [sp, #0]
 8004a84:	f7ff fcec 	bl	8004460 <osalThreadEnqueueTimeoutS.8915.4276>
 8004a88:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8004a8a:	9b03      	ldr	r3, [sp, #12]
 8004a8c:	2b00      	cmp	r3, #0
 8004a8e:	da01      	bge.n	8004a94 <obqGetEmptyBufferTimeoutS.4199+0x24>
      return msg;
 8004a90:	9b03      	ldr	r3, [sp, #12]
 8004a92:	e01a      	b.n	8004aca <obqGetEmptyBufferTimeoutS.4199+0x5a>
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8004a94:	9b01      	ldr	r3, [sp, #4]
 8004a96:	689b      	ldr	r3, [r3, #8]
 8004a98:	2b00      	cmp	r3, #0
 8004a9a:	d0f0      	beq.n	8004a7e <obqGetEmptyBufferTimeoutS.4199+0xe>
    if (msg < MSG_OK) {
      return msg;
    }
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");
 8004a9c:	9b01      	ldr	r3, [sp, #4]
 8004a9e:	689b      	ldr	r3, [r3, #8]
 8004aa0:	2b00      	cmp	r3, #0
 8004aa2:	d105      	bne.n	8004ab0 <obqGetEmptyBufferTimeoutS.4199+0x40>
 8004aa4:	f247 7040 	movw	r0, #30528	; 0x7740
 8004aa8:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004aac:	f000 fcc0 	bl	8005430 <chSysHalt>

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8004ab0:	9b01      	ldr	r3, [sp, #4]
 8004ab2:	68db      	ldr	r3, [r3, #12]
 8004ab4:	1d1a      	adds	r2, r3, #4
 8004ab6:	9b01      	ldr	r3, [sp, #4]
 8004ab8:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top = obqp->bwrptr + obqp->bsize;
 8004aba:	9b01      	ldr	r3, [sp, #4]
 8004abc:	68da      	ldr	r2, [r3, #12]
 8004abe:	9b01      	ldr	r3, [sp, #4]
 8004ac0:	699b      	ldr	r3, [r3, #24]
 8004ac2:	441a      	add	r2, r3
 8004ac4:	9b01      	ldr	r3, [sp, #4]
 8004ac6:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8004ac8:	2300      	movs	r3, #0
}
 8004aca:	4618      	mov	r0, r3
 8004acc:	b005      	add	sp, #20
 8004ace:	f85d fb04 	ldr.w	pc, [sp], #4
 8004ad2:	bf00      	nop
 8004ad4:	f3af 8000 	nop.w
 8004ad8:	f3af 8000 	nop.w
 8004adc:	f3af 8000 	nop.w

08004ae0 <obqPostFullBufferS.4191>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8004ae0:	b500      	push	{lr}
 8004ae2:	b083      	sub	sp, #12
 8004ae4:	9001      	str	r0, [sp, #4]
 8004ae6:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();
 8004ae8:	f000 fe22 	bl	8005730 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 8004aec:	9b00      	ldr	r3, [sp, #0]
 8004aee:	2b00      	cmp	r3, #0
 8004af0:	d005      	beq.n	8004afe <obqPostFullBufferS.4191+0x1e>
 8004af2:	9b01      	ldr	r3, [sp, #4]
 8004af4:	699b      	ldr	r3, [r3, #24]
 8004af6:	1f1a      	subs	r2, r3, #4
 8004af8:	9b00      	ldr	r3, [sp, #0]
 8004afa:	429a      	cmp	r2, r3
 8004afc:	d205      	bcs.n	8004b0a <obqPostFullBufferS.4191+0x2a>
 8004afe:	f247 7060 	movw	r0, #30560	; 0x7760
 8004b02:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004b06:	f000 fc93 	bl	8005430 <chSysHalt>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8004b0a:	9b01      	ldr	r3, [sp, #4]
 8004b0c:	689b      	ldr	r3, [r3, #8]
 8004b0e:	2b00      	cmp	r3, #0
 8004b10:	d105      	bne.n	8004b1e <obqPostFullBufferS.4191+0x3e>
 8004b12:	f247 7060 	movw	r0, #30560	; 0x7760
 8004b16:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004b1a:	f000 fc89 	bl	8005430 <chSysHalt>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8004b1e:	9b01      	ldr	r3, [sp, #4]
 8004b20:	68db      	ldr	r3, [r3, #12]
 8004b22:	9a00      	ldr	r2, [sp, #0]
 8004b24:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 8004b26:	9b01      	ldr	r3, [sp, #4]
 8004b28:	689b      	ldr	r3, [r3, #8]
 8004b2a:	1e5a      	subs	r2, r3, #1
 8004b2c:	9b01      	ldr	r3, [sp, #4]
 8004b2e:	609a      	str	r2, [r3, #8]
  obqp->bwrptr += obqp->bsize;
 8004b30:	9b01      	ldr	r3, [sp, #4]
 8004b32:	68da      	ldr	r2, [r3, #12]
 8004b34:	9b01      	ldr	r3, [sp, #4]
 8004b36:	699b      	ldr	r3, [r3, #24]
 8004b38:	441a      	add	r2, r3
 8004b3a:	9b01      	ldr	r3, [sp, #4]
 8004b3c:	60da      	str	r2, [r3, #12]
  if (obqp->bwrptr >= obqp->btop) {
 8004b3e:	9b01      	ldr	r3, [sp, #4]
 8004b40:	68da      	ldr	r2, [r3, #12]
 8004b42:	9b01      	ldr	r3, [sp, #4]
 8004b44:	695b      	ldr	r3, [r3, #20]
 8004b46:	429a      	cmp	r2, r3
 8004b48:	d303      	bcc.n	8004b52 <obqPostFullBufferS.4191+0x72>
    obqp->bwrptr = obqp->buffers;
 8004b4a:	9b01      	ldr	r3, [sp, #4]
 8004b4c:	6a1a      	ldr	r2, [r3, #32]
 8004b4e:	9b01      	ldr	r3, [sp, #4]
 8004b50:	60da      	str	r2, [r3, #12]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 8004b52:	9b01      	ldr	r3, [sp, #4]
 8004b54:	2200      	movs	r2, #0
 8004b56:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 8004b58:	9b01      	ldr	r3, [sp, #4]
 8004b5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004b5c:	2b00      	cmp	r3, #0
 8004b5e:	d003      	beq.n	8004b68 <obqPostFullBufferS.4191+0x88>
    obqp->notify(obqp);
 8004b60:	9b01      	ldr	r3, [sp, #4]
 8004b62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004b64:	9801      	ldr	r0, [sp, #4]
 8004b66:	4798      	blx	r3
  }
}
 8004b68:	b003      	add	sp, #12
 8004b6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8004b6e:	bf00      	nop

08004b70 <obqPutTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 8004b70:	b500      	push	{lr}
 8004b72:	b087      	sub	sp, #28
 8004b74:	9003      	str	r0, [sp, #12]
 8004b76:	460b      	mov	r3, r1
 8004b78:	9201      	str	r2, [sp, #4]
 8004b7a:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 8004b7e:	f7ff fc47 	bl	8004410 <osalSysLock.8909.4287>

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 8004b82:	9b03      	ldr	r3, [sp, #12]
 8004b84:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004b86:	2b00      	cmp	r3, #0
 8004b88:	d10b      	bne.n	8004ba2 <obqPutTimeout+0x32>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8004b8a:	9803      	ldr	r0, [sp, #12]
 8004b8c:	9901      	ldr	r1, [sp, #4]
 8004b8e:	f7ff ff6f 	bl	8004a70 <obqGetEmptyBufferTimeoutS.4199>
 8004b92:	9005      	str	r0, [sp, #20]
    if (msg != MSG_OK) {
 8004b94:	9b05      	ldr	r3, [sp, #20]
 8004b96:	2b00      	cmp	r3, #0
 8004b98:	d003      	beq.n	8004ba2 <obqPutTimeout+0x32>
      osalSysUnlock();
 8004b9a:	f7ff fc41 	bl	8004420 <osalSysUnlock.8913.4285>
      return msg;
 8004b9e:	9b05      	ldr	r3, [sp, #20]
 8004ba0:	e019      	b.n	8004bd6 <obqPutTimeout+0x66>
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8004ba2:	9b03      	ldr	r3, [sp, #12]
 8004ba4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004ba6:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8004baa:	701a      	strb	r2, [r3, #0]
  obqp->ptr++;
 8004bac:	9b03      	ldr	r3, [sp, #12]
 8004bae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004bb0:	1c5a      	adds	r2, r3, #1
 8004bb2:	9b03      	ldr	r3, [sp, #12]
 8004bb4:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8004bb6:	9b03      	ldr	r3, [sp, #12]
 8004bb8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004bba:	9b03      	ldr	r3, [sp, #12]
 8004bbc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004bbe:	429a      	cmp	r2, r3
 8004bc0:	d306      	bcc.n	8004bd0 <obqPutTimeout+0x60>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8004bc2:	9b03      	ldr	r3, [sp, #12]
 8004bc4:	699b      	ldr	r3, [r3, #24]
 8004bc6:	3b04      	subs	r3, #4
 8004bc8:	9803      	ldr	r0, [sp, #12]
 8004bca:	4619      	mov	r1, r3
 8004bcc:	f7ff ff88 	bl	8004ae0 <obqPostFullBufferS.4191>
  }

  osalSysUnlock();
 8004bd0:	f7ff fc26 	bl	8004420 <osalSysUnlock.8913.4285>
  return MSG_OK;
 8004bd4:	2300      	movs	r3, #0
}
 8004bd6:	4618      	mov	r0, r3
 8004bd8:	b007      	add	sp, #28
 8004bda:	f85d fb04 	ldr.w	pc, [sp], #4
 8004bde:	bf00      	nop

08004be0 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8004be0:	b500      	push	{lr}
 8004be2:	b08b      	sub	sp, #44	; 0x2c
 8004be4:	9003      	str	r0, [sp, #12]
 8004be6:	9102      	str	r1, [sp, #8]
 8004be8:	9201      	str	r2, [sp, #4]
 8004bea:	9300      	str	r3, [sp, #0]
  size_t w = 0;
 8004bec:	2300      	movs	r3, #0
 8004bee:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 8004bf0:	f7ff fc0e 	bl	8004410 <osalSysLock.8909.4287>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004bf4:	f7ff fc1c 	bl	8004430 <osalOsGetSystemTimeX.8894.4283>
 8004bf8:	4602      	mov	r2, r0
 8004bfa:	9b00      	ldr	r3, [sp, #0]
 8004bfc:	4413      	add	r3, r2
 8004bfe:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8004c00:	9b03      	ldr	r3, [sp, #12]
 8004c02:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004c04:	2b00      	cmp	r3, #0
 8004c06:	d126      	bne.n	8004c56 <obqWriteTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8004c08:	9b00      	ldr	r3, [sp, #0]
 8004c0a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004c0e:	d002      	beq.n	8004c16 <obqWriteTimeout+0x36>
 8004c10:	9b00      	ldr	r3, [sp, #0]
 8004c12:	2b00      	cmp	r3, #0
 8004c14:	d105      	bne.n	8004c22 <obqWriteTimeout+0x42>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8004c16:	9803      	ldr	r0, [sp, #12]
 8004c18:	9900      	ldr	r1, [sp, #0]
 8004c1a:	f7ff ff29 	bl	8004a70 <obqGetEmptyBufferTimeoutS.4199>
 8004c1e:	9007      	str	r0, [sp, #28]
 8004c20:	e012      	b.n	8004c48 <obqWriteTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8004c22:	f7ff fc05 	bl	8004430 <osalOsGetSystemTimeX.8894.4283>
 8004c26:	4603      	mov	r3, r0
 8004c28:	9a06      	ldr	r2, [sp, #24]
 8004c2a:	1ad3      	subs	r3, r2, r3
 8004c2c:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8004c2e:	9a05      	ldr	r2, [sp, #20]
 8004c30:	9b00      	ldr	r3, [sp, #0]
 8004c32:	429a      	cmp	r2, r3
 8004c34:	d903      	bls.n	8004c3e <obqWriteTimeout+0x5e>
          osalSysUnlock();
 8004c36:	f7ff fbf3 	bl	8004420 <osalSysUnlock.8913.4285>
          return w;
 8004c3a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004c3c:	e060      	b.n	8004d00 <obqWriteTimeout+0x120>
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 8004c3e:	9803      	ldr	r0, [sp, #12]
 8004c40:	9905      	ldr	r1, [sp, #20]
 8004c42:	f7ff ff15 	bl	8004a70 <obqGetEmptyBufferTimeoutS.4199>
 8004c46:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8004c48:	9b07      	ldr	r3, [sp, #28]
 8004c4a:	2b00      	cmp	r3, #0
 8004c4c:	d003      	beq.n	8004c56 <obqWriteTimeout+0x76>
        osalSysUnlock();
 8004c4e:	f7ff fbe7 	bl	8004420 <osalSysUnlock.8913.4285>
        return w;
 8004c52:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004c54:	e054      	b.n	8004d00 <obqWriteTimeout+0x120>
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8004c56:	9b03      	ldr	r3, [sp, #12]
 8004c58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004c5a:	461a      	mov	r2, r3
 8004c5c:	9b03      	ldr	r3, [sp, #12]
 8004c5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004c60:	1ad3      	subs	r3, r2, r3
 8004c62:	9308      	str	r3, [sp, #32]
    if (size > (n - w)) {
 8004c64:	9a01      	ldr	r2, [sp, #4]
 8004c66:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004c68:	1ad2      	subs	r2, r2, r3
 8004c6a:	9b08      	ldr	r3, [sp, #32]
 8004c6c:	429a      	cmp	r2, r3
 8004c6e:	d203      	bcs.n	8004c78 <obqWriteTimeout+0x98>
      size = n - w;
 8004c70:	9a01      	ldr	r2, [sp, #4]
 8004c72:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004c74:	1ad3      	subs	r3, r2, r3
 8004c76:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8004c78:	9b08      	ldr	r3, [sp, #32]
 8004c7a:	2b40      	cmp	r3, #64	; 0x40
 8004c7c:	d913      	bls.n	8004ca6 <obqWriteTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 8004c7e:	9b03      	ldr	r3, [sp, #12]
 8004c80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004c82:	4618      	mov	r0, r3
 8004c84:	9902      	ldr	r1, [sp, #8]
 8004c86:	2240      	movs	r2, #64	; 0x40
 8004c88:	f7fb fb42 	bl	8000310 <memcpy>
      bp        += 64U;
 8004c8c:	9b02      	ldr	r3, [sp, #8]
 8004c8e:	3340      	adds	r3, #64	; 0x40
 8004c90:	9302      	str	r3, [sp, #8]
      obqp->ptr += 64U;
 8004c92:	9b03      	ldr	r3, [sp, #12]
 8004c94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004c96:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8004c9a:	9b03      	ldr	r3, [sp, #12]
 8004c9c:	625a      	str	r2, [r3, #36]	; 0x24
      w         += 64U;
 8004c9e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004ca0:	3340      	adds	r3, #64	; 0x40
 8004ca2:	9309      	str	r3, [sp, #36]	; 0x24
 8004ca4:	e014      	b.n	8004cd0 <obqWriteTimeout+0xf0>
    }
    else {
      memcpy(obqp->ptr, bp, size);
 8004ca6:	9b03      	ldr	r3, [sp, #12]
 8004ca8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004caa:	4618      	mov	r0, r3
 8004cac:	9902      	ldr	r1, [sp, #8]
 8004cae:	9a08      	ldr	r2, [sp, #32]
 8004cb0:	f7fb fb2e 	bl	8000310 <memcpy>
      bp        += size;
 8004cb4:	9a02      	ldr	r2, [sp, #8]
 8004cb6:	9b08      	ldr	r3, [sp, #32]
 8004cb8:	4413      	add	r3, r2
 8004cba:	9302      	str	r3, [sp, #8]
      obqp->ptr += size;
 8004cbc:	9b03      	ldr	r3, [sp, #12]
 8004cbe:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004cc0:	9b08      	ldr	r3, [sp, #32]
 8004cc2:	441a      	add	r2, r3
 8004cc4:	9b03      	ldr	r3, [sp, #12]
 8004cc6:	625a      	str	r2, [r3, #36]	; 0x24
      w         += size;
 8004cc8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8004cca:	9b08      	ldr	r3, [sp, #32]
 8004ccc:	4413      	add	r3, r2
 8004cce:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8004cd0:	9b03      	ldr	r3, [sp, #12]
 8004cd2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004cd4:	9b03      	ldr	r3, [sp, #12]
 8004cd6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004cd8:	429a      	cmp	r2, r3
 8004cda:	d306      	bcc.n	8004cea <obqWriteTimeout+0x10a>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8004cdc:	9b03      	ldr	r3, [sp, #12]
 8004cde:	699b      	ldr	r3, [r3, #24]
 8004ce0:	3b04      	subs	r3, #4
 8004ce2:	9803      	ldr	r0, [sp, #12]
 8004ce4:	4619      	mov	r1, r3
 8004ce6:	f7ff fefb 	bl	8004ae0 <obqPostFullBufferS.4191>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 8004cea:	f7ff fb99 	bl	8004420 <osalSysUnlock.8913.4285>
    if (w >= n) {
 8004cee:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8004cf0:	9b01      	ldr	r3, [sp, #4]
 8004cf2:	429a      	cmp	r2, r3
 8004cf4:	d301      	bcc.n	8004cfa <obqWriteTimeout+0x11a>
      return w;
 8004cf6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004cf8:	e002      	b.n	8004d00 <obqWriteTimeout+0x120>
    }
    osalSysLock();
 8004cfa:	f7ff fb89 	bl	8004410 <osalSysLock.8909.4287>
 8004cfe:	e77f      	b.n	8004c00 <obqWriteTimeout+0x20>
  }
}
 8004d00:	4618      	mov	r0, r3
 8004d02:	b00b      	add	sp, #44	; 0x2c
 8004d04:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d08:	f3af 8000 	nop.w
 8004d0c:	f3af 8000 	nop.w

08004d10 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 8004d10:	b500      	push	{lr}
 8004d12:	b085      	sub	sp, #20
 8004d14:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
 8004d16:	f000 fcf3 	bl	8005700 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8004d1a:	9b01      	ldr	r3, [sp, #4]
 8004d1c:	68da      	ldr	r2, [r3, #12]
 8004d1e:	9b01      	ldr	r3, [sp, #4]
 8004d20:	691b      	ldr	r3, [r3, #16]
 8004d22:	429a      	cmp	r2, r3
 8004d24:	d105      	bne.n	8004d32 <obqTryFlushI+0x22>
 8004d26:	9b01      	ldr	r3, [sp, #4]
 8004d28:	689b      	ldr	r3, [r3, #8]
 8004d2a:	2b00      	cmp	r3, #0
 8004d2c:	d001      	beq.n	8004d32 <obqTryFlushI+0x22>
 8004d2e:	2301      	movs	r3, #1
 8004d30:	e000      	b.n	8004d34 <obqTryFlushI+0x24>
 8004d32:	2300      	movs	r3, #0
 8004d34:	f003 0301 	and.w	r3, r3, #1
 8004d38:	b2db      	uxtb	r3, r3
 8004d3a:	2b00      	cmp	r3, #0
 8004d3c:	d02d      	beq.n	8004d9a <obqTryFlushI+0x8a>
 8004d3e:	9b01      	ldr	r3, [sp, #4]
 8004d40:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004d42:	2b00      	cmp	r3, #0
 8004d44:	d029      	beq.n	8004d9a <obqTryFlushI+0x8a>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 8004d46:	9b01      	ldr	r3, [sp, #4]
 8004d48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004d4a:	461a      	mov	r2, r3
 8004d4c:	9b01      	ldr	r3, [sp, #4]
 8004d4e:	68db      	ldr	r3, [r3, #12]
 8004d50:	1ad3      	subs	r3, r2, r3
 8004d52:	3b04      	subs	r3, #4
 8004d54:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 8004d56:	9b03      	ldr	r3, [sp, #12]
 8004d58:	2b00      	cmp	r3, #0
 8004d5a:	d01e      	beq.n	8004d9a <obqTryFlushI+0x8a>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 8004d5c:	9b01      	ldr	r3, [sp, #4]
 8004d5e:	68db      	ldr	r3, [r3, #12]
 8004d60:	9a03      	ldr	r2, [sp, #12]
 8004d62:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8004d64:	9b01      	ldr	r3, [sp, #4]
 8004d66:	689b      	ldr	r3, [r3, #8]
 8004d68:	1e5a      	subs	r2, r3, #1
 8004d6a:	9b01      	ldr	r3, [sp, #4]
 8004d6c:	609a      	str	r2, [r3, #8]
      obqp->bwrptr += obqp->bsize;
 8004d6e:	9b01      	ldr	r3, [sp, #4]
 8004d70:	68da      	ldr	r2, [r3, #12]
 8004d72:	9b01      	ldr	r3, [sp, #4]
 8004d74:	699b      	ldr	r3, [r3, #24]
 8004d76:	441a      	add	r2, r3
 8004d78:	9b01      	ldr	r3, [sp, #4]
 8004d7a:	60da      	str	r2, [r3, #12]
      if (obqp->bwrptr >= obqp->btop) {
 8004d7c:	9b01      	ldr	r3, [sp, #4]
 8004d7e:	68da      	ldr	r2, [r3, #12]
 8004d80:	9b01      	ldr	r3, [sp, #4]
 8004d82:	695b      	ldr	r3, [r3, #20]
 8004d84:	429a      	cmp	r2, r3
 8004d86:	d303      	bcc.n	8004d90 <obqTryFlushI+0x80>
        obqp->bwrptr = obqp->buffers;
 8004d88:	9b01      	ldr	r3, [sp, #4]
 8004d8a:	6a1a      	ldr	r2, [r3, #32]
 8004d8c:	9b01      	ldr	r3, [sp, #4]
 8004d8e:	60da      	str	r2, [r3, #12]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 8004d90:	9b01      	ldr	r3, [sp, #4]
 8004d92:	2200      	movs	r2, #0
 8004d94:	625a      	str	r2, [r3, #36]	; 0x24

      return true;
 8004d96:	2301      	movs	r3, #1
 8004d98:	e000      	b.n	8004d9c <obqTryFlushI+0x8c>
    }
  }
  return false;
 8004d9a:	2300      	movs	r3, #0
}
 8004d9c:	4618      	mov	r0, r3
 8004d9e:	b005      	add	sp, #20
 8004da0:	f85d fb04 	ldr.w	pc, [sp], #4
 8004da4:	f3af 8000 	nop.w
 8004da8:	f3af 8000 	nop.w
 8004dac:	f3af 8000 	nop.w

08004db0 <port_lock.9201>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004db0:	b082      	sub	sp, #8
 8004db2:	2320      	movs	r3, #32
 8004db4:	9301      	str	r3, [sp, #4]
 8004db6:	9b01      	ldr	r3, [sp, #4]
 8004db8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004dbc:	b002      	add	sp, #8
 8004dbe:	4770      	bx	lr

08004dc0 <port_unlock.9204>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004dc0:	b082      	sub	sp, #8
 8004dc2:	2300      	movs	r3, #0
 8004dc4:	9301      	str	r3, [sp, #4]
 8004dc6:	9b01      	ldr	r3, [sp, #4]
 8004dc8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004dcc:	b002      	add	sp, #8
 8004dce:	4770      	bx	lr

08004dd0 <port_lock_from_isr.9206>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8004dd0:	b508      	push	{r3, lr}

  port_lock();
 8004dd2:	f7ff ffed 	bl	8004db0 <port_lock.9201>
}
 8004dd6:	bd08      	pop	{r3, pc}
 8004dd8:	f3af 8000 	nop.w
 8004ddc:	f3af 8000 	nop.w

08004de0 <port_unlock_from_isr.9208>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8004de0:	b508      	push	{r3, lr}

  port_unlock();
 8004de2:	f7ff ffed 	bl	8004dc0 <port_unlock.9204>
}
 8004de6:	bd08      	pop	{r3, pc}
 8004de8:	f3af 8000 	nop.w
 8004dec:	f3af 8000 	nop.w

08004df0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8004df0:	b500      	push	{lr}
 8004df2:	b085      	sub	sp, #20
 8004df4:	9001      	str	r0, [sp, #4]
 8004df6:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
 8004df8:	f000 fc82 	bl	8005700 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8004dfc:	9b01      	ldr	r3, [sp, #4]
 8004dfe:	2b00      	cmp	r3, #0
 8004e00:	d105      	bne.n	8004e0e <chEvtBroadcastFlagsI+0x1e>
 8004e02:	f247 6030 	movw	r0, #30256	; 0x7630
 8004e06:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004e0a:	f000 fb11 	bl	8005430 <chSysHalt>

  elp = esp->es_next;
 8004e0e:	9b01      	ldr	r3, [sp, #4]
 8004e10:	681b      	ldr	r3, [r3, #0]
 8004e12:	9303      	str	r3, [sp, #12]
 8004e14:	e01a      	b.n	8004e4c <chEvtBroadcastFlagsI+0x5c>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
 8004e16:	9b03      	ldr	r3, [sp, #12]
 8004e18:	68da      	ldr	r2, [r3, #12]
 8004e1a:	9b00      	ldr	r3, [sp, #0]
 8004e1c:	431a      	orrs	r2, r3
 8004e1e:	9b03      	ldr	r3, [sp, #12]
 8004e20:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8004e22:	9b00      	ldr	r3, [sp, #0]
 8004e24:	2b00      	cmp	r3, #0
 8004e26:	d006      	beq.n	8004e36 <chEvtBroadcastFlagsI+0x46>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8004e28:	9b03      	ldr	r3, [sp, #12]
 8004e2a:	68da      	ldr	r2, [r3, #12]
 8004e2c:	9b03      	ldr	r3, [sp, #12]
 8004e2e:	691b      	ldr	r3, [r3, #16]
 8004e30:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8004e32:	2b00      	cmp	r3, #0
 8004e34:	d007      	beq.n	8004e46 <chEvtBroadcastFlagsI+0x56>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8004e36:	9b03      	ldr	r3, [sp, #12]
 8004e38:	685a      	ldr	r2, [r3, #4]
 8004e3a:	9b03      	ldr	r3, [sp, #12]
 8004e3c:	689b      	ldr	r3, [r3, #8]
 8004e3e:	4610      	mov	r0, r2
 8004e40:	4619      	mov	r1, r3
 8004e42:	f000 f80d 	bl	8004e60 <chEvtSignalI.4355>
    }
    elp = elp->el_next;
 8004e46:	9b03      	ldr	r3, [sp, #12]
 8004e48:	681b      	ldr	r3, [r3, #0]
 8004e4a:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8004e4c:	9a03      	ldr	r2, [sp, #12]
 8004e4e:	9b01      	ldr	r3, [sp, #4]
 8004e50:	429a      	cmp	r2, r3
 8004e52:	d1e0      	bne.n	8004e16 <chEvtBroadcastFlagsI+0x26>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 8004e54:	b005      	add	sp, #20
 8004e56:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e5a:	bf00      	nop
 8004e5c:	f3af 8000 	nop.w

08004e60 <chEvtSignalI.4355>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8004e60:	b500      	push	{lr}
 8004e62:	b083      	sub	sp, #12
 8004e64:	9001      	str	r0, [sp, #4]
 8004e66:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8004e68:	f000 fc4a 	bl	8005700 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8004e6c:	9b01      	ldr	r3, [sp, #4]
 8004e6e:	2b00      	cmp	r3, #0
 8004e70:	d105      	bne.n	8004e7e <chEvtSignalI.4355+0x1e>
 8004e72:	f247 6050 	movw	r0, #30288	; 0x7650
 8004e76:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004e7a:	f000 fad9 	bl	8005430 <chSysHalt>

  tp->p_epending |= events;
 8004e7e:	9b01      	ldr	r3, [sp, #4]
 8004e80:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004e82:	9b00      	ldr	r3, [sp, #0]
 8004e84:	431a      	orrs	r2, r3
 8004e86:	9b01      	ldr	r3, [sp, #4]
 8004e88:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8004e8a:	9b01      	ldr	r3, [sp, #4]
 8004e8c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8004e90:	2b0a      	cmp	r3, #10
 8004e92:	d106      	bne.n	8004ea2 <chEvtSignalI.4355+0x42>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8004e94:	9b01      	ldr	r3, [sp, #4]
 8004e96:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004e98:	9b01      	ldr	r3, [sp, #4]
 8004e9a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004e9c:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8004e9e:	2b00      	cmp	r3, #0
 8004ea0:	d10d      	bne.n	8004ebe <chEvtSignalI.4355+0x5e>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8004ea2:	9b01      	ldr	r3, [sp, #4]
 8004ea4:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8004ea8:	2b0b      	cmp	r3, #11
 8004eaa:	d10e      	bne.n	8004eca <chEvtSignalI.4355+0x6a>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8004eac:	9b01      	ldr	r3, [sp, #4]
 8004eae:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004eb0:	9b01      	ldr	r3, [sp, #4]
 8004eb2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004eb4:	401a      	ands	r2, r3
 8004eb6:	9b01      	ldr	r3, [sp, #4]
 8004eb8:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8004eba:	429a      	cmp	r2, r3
 8004ebc:	d105      	bne.n	8004eca <chEvtSignalI.4355+0x6a>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8004ebe:	9b01      	ldr	r3, [sp, #4]
 8004ec0:	2200      	movs	r2, #0
 8004ec2:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8004ec4:	9801      	ldr	r0, [sp, #4]
 8004ec6:	f000 ff0b 	bl	8005ce0 <chSchReadyI>
  }
}
 8004eca:	b003      	add	sp, #12
 8004ecc:	f85d fb04 	ldr.w	pc, [sp], #4

08004ed0 <port_lock.8109>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004ed0:	b082      	sub	sp, #8
 8004ed2:	2320      	movs	r3, #32
 8004ed4:	9301      	str	r3, [sp, #4]
 8004ed6:	9b01      	ldr	r3, [sp, #4]
 8004ed8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004edc:	b002      	add	sp, #8
 8004ede:	4770      	bx	lr

08004ee0 <port_unlock.8112>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004ee0:	b082      	sub	sp, #8
 8004ee2:	2300      	movs	r3, #0
 8004ee4:	9301      	str	r3, [sp, #4]
 8004ee6:	9b01      	ldr	r3, [sp, #4]
 8004ee8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8004eec:	b002      	add	sp, #8
 8004eee:	4770      	bx	lr

08004ef0 <queue_init.6678.4214>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8004ef0:	b082      	sub	sp, #8
 8004ef2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8004ef4:	9b01      	ldr	r3, [sp, #4]
 8004ef6:	9a01      	ldr	r2, [sp, #4]
 8004ef8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8004efa:	9b01      	ldr	r3, [sp, #4]
 8004efc:	9a01      	ldr	r2, [sp, #4]
 8004efe:	605a      	str	r2, [r3, #4]
}
 8004f00:	b002      	add	sp, #8
 8004f02:	4770      	bx	lr
 8004f04:	f3af 8000 	nop.w
 8004f08:	f3af 8000 	nop.w
 8004f0c:	f3af 8000 	nop.w

08004f10 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8004f10:	b500      	push	{lr}
 8004f12:	b083      	sub	sp, #12
 8004f14:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8004f16:	9b01      	ldr	r3, [sp, #4]
 8004f18:	2b00      	cmp	r3, #0
 8004f1a:	d105      	bne.n	8004f28 <chMtxObjectInit+0x18>
 8004f1c:	f247 6020 	movw	r0, #30240	; 0x7620
 8004f20:	f6c0 0000 	movt	r0, #2048	; 0x800
 8004f24:	f000 fa84 	bl	8005430 <chSysHalt>

  queue_init(&mp->m_queue);
 8004f28:	9b01      	ldr	r3, [sp, #4]
 8004f2a:	4618      	mov	r0, r3
 8004f2c:	f7ff ffe0 	bl	8004ef0 <queue_init.6678.4214>
  mp->m_owner = NULL;
 8004f30:	9b01      	ldr	r3, [sp, #4]
 8004f32:	2200      	movs	r2, #0
 8004f34:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8004f36:	b003      	add	sp, #12
 8004f38:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f3c:	f3af 8000 	nop.w

08004f40 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8004f40:	4770      	bx	lr
 8004f42:	bf00      	nop
 8004f44:	f3af 8000 	nop.w
 8004f48:	f3af 8000 	nop.w
 8004f4c:	f3af 8000 	nop.w

08004f50 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8004f50:	4770      	bx	lr
 8004f52:	bf00      	nop
 8004f54:	f3af 8000 	nop.w
 8004f58:	f3af 8000 	nop.w
 8004f5c:	f3af 8000 	nop.w

08004f60 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8004f60:	e7fe      	b.n	8004f60 <__default_exit>
 8004f62:	bf00      	nop
 8004f64:	f3af 8000 	nop.w
 8004f68:	f3af 8000 	nop.w
 8004f6c:	f3af 8000 	nop.w

08004f70 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8004f70:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8004f72:	f247 43b0 	movw	r3, #29872	; 0x74b0
 8004f76:	f6c0 0300 	movt	r3, #2048	; 0x800
 8004f7a:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8004f7c:	9b03      	ldr	r3, [sp, #12]
 8004f7e:	681b      	ldr	r3, [r3, #0]
 8004f80:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 8004f82:	9b03      	ldr	r3, [sp, #12]
 8004f84:	685b      	ldr	r3, [r3, #4]
 8004f86:	9301      	str	r3, [sp, #4]
 8004f88:	e009      	b.n	8004f9e <__init_ram_areas+0x2e>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8004f8a:	9b02      	ldr	r3, [sp, #8]
 8004f8c:	681a      	ldr	r2, [r3, #0]
 8004f8e:	9b01      	ldr	r3, [sp, #4]
 8004f90:	601a      	str	r2, [r3, #0]
      p++;
 8004f92:	9b01      	ldr	r3, [sp, #4]
 8004f94:	3304      	adds	r3, #4
 8004f96:	9301      	str	r3, [sp, #4]
      tp++;
 8004f98:	9b02      	ldr	r3, [sp, #8]
 8004f9a:	3304      	adds	r3, #4
 8004f9c:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8004f9e:	9b03      	ldr	r3, [sp, #12]
 8004fa0:	689a      	ldr	r2, [r3, #8]
 8004fa2:	9b01      	ldr	r3, [sp, #4]
 8004fa4:	429a      	cmp	r2, r3
 8004fa6:	d8f0      	bhi.n	8004f8a <__init_ram_areas+0x1a>
 8004fa8:	e005      	b.n	8004fb6 <__init_ram_areas+0x46>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8004faa:	9b01      	ldr	r3, [sp, #4]
 8004fac:	2200      	movs	r2, #0
 8004fae:	601a      	str	r2, [r3, #0]
      p++;
 8004fb0:	9b01      	ldr	r3, [sp, #4]
 8004fb2:	3304      	adds	r3, #4
 8004fb4:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8004fb6:	9b03      	ldr	r3, [sp, #12]
 8004fb8:	68da      	ldr	r2, [r3, #12]
 8004fba:	9b01      	ldr	r3, [sp, #4]
 8004fbc:	429a      	cmp	r2, r3
 8004fbe:	d8f4      	bhi.n	8004faa <__init_ram_areas+0x3a>
      *p = 0;
      p++;
    }
    rap++;
 8004fc0:	9b03      	ldr	r3, [sp, #12]
 8004fc2:	3310      	adds	r3, #16
 8004fc4:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8004fc6:	9a03      	ldr	r2, [sp, #12]
 8004fc8:	4b02      	ldr	r3, [pc, #8]	; (8004fd4 <__init_ram_areas+0x64>)
 8004fca:	429a      	cmp	r2, r3
 8004fcc:	d3d6      	bcc.n	8004f7c <__init_ram_areas+0xc>
#endif
}
 8004fce:	b004      	add	sp, #16
 8004fd0:	4770      	bx	lr
 8004fd2:	bf00      	nop
 8004fd4:	08007530 	.word	0x08007530
 8004fd8:	f3af 8000 	nop.w
 8004fdc:	f3af 8000 	nop.w

08004fe0 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8004fe0:	e7fe      	b.n	8004fe0 <BusFault_Handler>
 8004fe2:	bf00      	nop
 8004fe4:	f3af 8000 	nop.w
 8004fe8:	f3af 8000 	nop.w
 8004fec:	f3af 8000 	nop.w

08004ff0 <NVIC_SetPriorityGrouping.4201.4533>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8004ff0:	b084      	sub	sp, #16
 8004ff2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8004ff4:	9b01      	ldr	r3, [sp, #4]
 8004ff6:	f003 0307 	and.w	r3, r3, #7
 8004ffa:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8004ffc:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8005000:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8005004:	68db      	ldr	r3, [r3, #12]
 8005006:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8005008:	9a02      	ldr	r2, [sp, #8]
 800500a:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800500e:	4013      	ands	r3, r2
 8005010:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 8005012:	9b03      	ldr	r3, [sp, #12]
 8005014:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8005016:	9b02      	ldr	r3, [sp, #8]
 8005018:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800501a:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800501e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005022:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8005024:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8005028:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800502c:	9a02      	ldr	r2, [sp, #8]
 800502e:	60da      	str	r2, [r3, #12]
}
 8005030:	b004      	add	sp, #16
 8005032:	4770      	bx	lr
 8005034:	f3af 8000 	nop.w
 8005038:	f3af 8000 	nop.w
 800503c:	f3af 8000 	nop.w

08005040 <NVIC_SetPriority.4207.4527>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8005040:	b082      	sub	sp, #8
 8005042:	4603      	mov	r3, r0
 8005044:	9100      	str	r1, [sp, #0]
 8005046:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
 800504a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800504e:	2b00      	cmp	r3, #0
 8005050:	da0f      	bge.n	8005072 <NVIC_SetPriority.4207.4527+0x32>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005052:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8005056:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800505a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800505e:	f002 020f 	and.w	r2, r2, #15
 8005062:	1f11      	subs	r1, r2, #4
 8005064:	9a00      	ldr	r2, [sp, #0]
 8005066:	b2d2      	uxtb	r2, r2
 8005068:	0112      	lsls	r2, r2, #4
 800506a:	b2d2      	uxtb	r2, r2
 800506c:	440b      	add	r3, r1
 800506e:	761a      	strb	r2, [r3, #24]
 8005070:	e00c      	b.n	800508c <NVIC_SetPriority.4207.4527+0x4c>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005072:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8005076:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800507a:	f99d 1007 	ldrsb.w	r1, [sp, #7]
 800507e:	9a00      	ldr	r2, [sp, #0]
 8005080:	b2d2      	uxtb	r2, r2
 8005082:	0112      	lsls	r2, r2, #4
 8005084:	b2d2      	uxtb	r2, r2
 8005086:	440b      	add	r3, r1
 8005088:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 800508c:	b002      	add	sp, #8
 800508e:	4770      	bx	lr

08005090 <port_init.4213.4525>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8005090:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8005092:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8005096:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800509a:	2200      	movs	r2, #0
 800509c:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 800509e:	2003      	movs	r0, #3
 80050a0:	f7ff ffa6 	bl	8004ff0 <NVIC_SetPriorityGrouping.4201.4533>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80050a4:	f64e 53f0 	movw	r3, #60912	; 0xedf0
 80050a8:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80050ac:	f64e 52f0 	movw	r2, #60912	; 0xedf0
 80050b0:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80050b4:	68d2      	ldr	r2, [r2, #12]
 80050b6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80050ba:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80050bc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80050c0:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80050c4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80050c8:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80050cc:	6812      	ldr	r2, [r2, #0]
 80050ce:	f042 0201 	orr.w	r2, r2, #1
 80050d2:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 80050d4:	f06f 0004 	mvn.w	r0, #4
 80050d8:	2101      	movs	r1, #1
 80050da:	f7ff ffb1 	bl	8005040 <NVIC_SetPriority.4207.4527>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 80050de:	f06f 0001 	mvn.w	r0, #1
 80050e2:	2102      	movs	r1, #2
 80050e4:	f7ff ffac 	bl	8005040 <NVIC_SetPriority.4207.4527>
}
 80050e8:	bd08      	pop	{r3, pc}
 80050ea:	bf00      	nop
 80050ec:	f3af 8000 	nop.w

080050f0 <port_lock.4224.4516>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80050f0:	b082      	sub	sp, #8
 80050f2:	2320      	movs	r3, #32
 80050f4:	9301      	str	r3, [sp, #4]
 80050f6:	9b01      	ldr	r3, [sp, #4]
 80050f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80050fc:	b002      	add	sp, #8
 80050fe:	4770      	bx	lr

08005100 <port_unlock.4226.4514>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005100:	b082      	sub	sp, #8
 8005102:	2300      	movs	r3, #0
 8005104:	9301      	str	r3, [sp, #4]
 8005106:	9b01      	ldr	r3, [sp, #4]
 8005108:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800510c:	b002      	add	sp, #8
 800510e:	4770      	bx	lr

08005110 <port_lock_from_isr.4228.4512>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8005110:	b508      	push	{r3, lr}

  port_lock();
 8005112:	f7ff ffed 	bl	80050f0 <port_lock.4224.4516>
}
 8005116:	bd08      	pop	{r3, pc}
 8005118:	f3af 8000 	nop.w
 800511c:	f3af 8000 	nop.w

08005120 <port_unlock_from_isr.4230.4510>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8005120:	b508      	push	{r3, lr}

  port_unlock();
 8005122:	f7ff ffed 	bl	8005100 <port_unlock.4226.4514>
}
 8005126:	bd08      	pop	{r3, pc}
 8005128:	f3af 8000 	nop.w
 800512c:	f3af 8000 	nop.w

08005130 <port_disable.4232.4508>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005130:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8005132:	4770      	bx	lr
 8005134:	f3af 8000 	nop.w
 8005138:	f3af 8000 	nop.w
 800513c:	f3af 8000 	nop.w

08005140 <port_enable.4234.4506>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8005140:	b082      	sub	sp, #8
 8005142:	2300      	movs	r3, #0
 8005144:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8005146:	9b01      	ldr	r3, [sp, #4]
 8005148:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800514c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800514e:	b002      	add	sp, #8
 8005150:	4770      	bx	lr
 8005152:	bf00      	nop
 8005154:	f3af 8000 	nop.w
 8005158:	f3af 8000 	nop.w
 800515c:	f3af 8000 	nop.w

08005160 <port_wait_for_interrupt.4236.4504>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8005160:	4770      	bx	lr
 8005162:	bf00      	nop
 8005164:	f3af 8000 	nop.w
 8005168:	f3af 8000 	nop.w
 800516c:	f3af 8000 	nop.w

08005170 <port_rt_get_counter_value.4238.4502>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8005170:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005174:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8005178:	685b      	ldr	r3, [r3, #4]
}
 800517a:	4618      	mov	r0, r3
 800517c:	4770      	bx	lr
 800517e:	bf00      	nop

08005180 <st_lld_get_counter.4241.4500>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005180:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005184:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8005186:	4618      	mov	r0, r3
 8005188:	4770      	bx	lr
 800518a:	bf00      	nop
 800518c:	f3af 8000 	nop.w

08005190 <port_timer_stop_alarm.4343.4498>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8005190:	b508      	push	{r3, lr}

  stStopAlarm();
 8005192:	f7ff f8a5 	bl	80042e0 <stStopAlarm>
}
 8005196:	bd08      	pop	{r3, pc}
 8005198:	f3af 8000 	nop.w
 800519c:	f3af 8000 	nop.w

080051a0 <port_timer_set_alarm.4349.4495>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 80051a0:	b500      	push	{lr}
 80051a2:	b083      	sub	sp, #12
 80051a4:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 80051a6:	9801      	ldr	r0, [sp, #4]
 80051a8:	f7ff f8a2 	bl	80042f0 <stSetAlarm>
}
 80051ac:	b003      	add	sp, #12
 80051ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80051b2:	bf00      	nop
 80051b4:	f3af 8000 	nop.w
 80051b8:	f3af 8000 	nop.w
 80051bc:	f3af 8000 	nop.w

080051c0 <port_timer_get_time.4244.4493>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80051c0:	b508      	push	{r3, lr}

  return stGetCounter();
 80051c2:	f7ff ffdd 	bl	8005180 <st_lld_get_counter.4241.4500>
 80051c6:	4603      	mov	r3, r0
}
 80051c8:	4618      	mov	r0, r3
 80051ca:	bd08      	pop	{r3, pc}
 80051cc:	f3af 8000 	nop.w

080051d0 <chSysEnable.4341.4491>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 80051d0:	b508      	push	{r3, lr}

  _dbg_check_enable();
 80051d2:	f000 f9ad 	bl	8005530 <_dbg_check_enable>
  port_enable();
 80051d6:	f7ff ffb3 	bl	8005140 <port_enable.4234.4506>
}
 80051da:	bd08      	pop	{r3, pc}
 80051dc:	f3af 8000 	nop.w

080051e0 <chSysLockFromISR.4347.4485>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80051e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80051e2:	f7ff ff95 	bl	8005110 <port_lock_from_isr.4228.4512>
  _stats_start_measure_crit_isr();
 80051e6:	f001 fbbb 	bl	8006960 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 80051ea:	f000 f9f9 	bl	80055e0 <_dbg_check_lock_from_isr>
}
 80051ee:	bd08      	pop	{r3, pc}

080051f0 <chSysUnlockFromISR.4345.4483>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80051f0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 80051f2:	f000 fa15 	bl	8005620 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 80051f6:	f001 fbbb 	bl	8006970 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 80051fa:	f7ff ff91 	bl	8005120 <port_unlock_from_isr.4230.4510>
}
 80051fe:	bd08      	pop	{r3, pc}

08005200 <chVTGetSystemTimeX.4246.4481>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8005200:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8005202:	f7ff ffdd 	bl	80051c0 <port_timer_get_time.4244.4493>
 8005206:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005208:	4618      	mov	r0, r3
 800520a:	bd08      	pop	{r3, pc}
 800520c:	f3af 8000 	nop.w

08005210 <chVTDoTickI.4359.4479>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8005210:	b500      	push	{lr}
 8005212:	b085      	sub	sp, #20

  chDbgCheckClassI();
 8005214:	f000 fa74 	bl	8005700 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8005218:	f640 0308 	movw	r3, #2056	; 0x808
 800521c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005220:	69db      	ldr	r3, [r3, #28]
 8005222:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 8005224:	f7ff ffec 	bl	8005200 <chVTGetSystemTimeX.4246.4481>
 8005228:	9002      	str	r0, [sp, #8]
 800522a:	e039      	b.n	80052a0 <chVTDoTickI.4359.4479+0x90>
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 800522c:	f640 0308 	movw	r3, #2056	; 0x808
 8005230:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005234:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005236:	9b03      	ldr	r3, [sp, #12]
 8005238:	689b      	ldr	r3, [r3, #8]
 800523a:	441a      	add	r2, r3
 800523c:	f640 0308 	movw	r3, #2056	; 0x808
 8005240:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005244:	629a      	str	r2, [r3, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8005246:	9b03      	ldr	r3, [sp, #12]
 8005248:	681b      	ldr	r3, [r3, #0]
 800524a:	4a38      	ldr	r2, [pc, #224]	; (800532c <chVTDoTickI.4359.4479+0x11c>)
 800524c:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 800524e:	9b03      	ldr	r3, [sp, #12]
 8005250:	681a      	ldr	r2, [r3, #0]
 8005252:	f640 0308 	movw	r3, #2056	; 0x808
 8005256:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800525a:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
 800525c:	9b03      	ldr	r3, [sp, #12]
 800525e:	68db      	ldr	r3, [r3, #12]
 8005260:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
 8005262:	9b03      	ldr	r3, [sp, #12]
 8005264:	2200      	movs	r2, #0
 8005266:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8005268:	f640 0308 	movw	r3, #2056	; 0x808
 800526c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005270:	69da      	ldr	r2, [r3, #28]
 8005272:	4b2e      	ldr	r3, [pc, #184]	; (800532c <chVTDoTickI.4359.4479+0x11c>)
 8005274:	429a      	cmp	r2, r3
 8005276:	d101      	bne.n	800527c <chVTDoTickI.4359.4479+0x6c>
      port_timer_stop_alarm();
 8005278:	f7ff ff8a 	bl	8005190 <port_timer_stop_alarm.4343.4498>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 800527c:	f7ff ffb8 	bl	80051f0 <chSysUnlockFromISR.4345.4483>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8005280:	9b03      	ldr	r3, [sp, #12]
 8005282:	691a      	ldr	r2, [r3, #16]
 8005284:	9b00      	ldr	r3, [sp, #0]
 8005286:	4610      	mov	r0, r2
 8005288:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 800528a:	f7ff ffa9 	bl	80051e0 <chSysLockFromISR.4347.4485>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 800528e:	f640 0308 	movw	r3, #2056	; 0x808
 8005292:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005296:	69db      	ldr	r3, [r3, #28]
 8005298:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 800529a:	f7ff ffb1 	bl	8005200 <chVTGetSystemTimeX.4246.4481>
 800529e:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80052a0:	9b03      	ldr	r3, [sp, #12]
 80052a2:	689a      	ldr	r2, [r3, #8]
 80052a4:	f640 0308 	movw	r3, #2056	; 0x808
 80052a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80052ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80052ae:	9902      	ldr	r1, [sp, #8]
 80052b0:	1acb      	subs	r3, r1, r3
 80052b2:	429a      	cmp	r2, r3
 80052b4:	d9ba      	bls.n	800522c <chVTDoTickI.4359.4479+0x1c>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80052b6:	f640 0308 	movw	r3, #2056	; 0x808
 80052ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80052be:	69da      	ldr	r2, [r3, #28]
 80052c0:	4b1a      	ldr	r3, [pc, #104]	; (800532c <chVTDoTickI.4359.4479+0x11c>)
 80052c2:	429a      	cmp	r2, r3
 80052c4:	d02f      	beq.n	8005326 <chVTDoTickI.4359.4479+0x116>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 80052c6:	f640 0308 	movw	r3, #2056	; 0x808
 80052ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80052ce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80052d0:	9b03      	ldr	r3, [sp, #12]
 80052d2:	689b      	ldr	r3, [r3, #8]
 80052d4:	441a      	add	r2, r3
 80052d6:	9b02      	ldr	r3, [sp, #8]
 80052d8:	1ad3      	subs	r3, r2, r3
 80052da:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80052dc:	9b01      	ldr	r3, [sp, #4]
 80052de:	2b01      	cmp	r3, #1
 80052e0:	d801      	bhi.n	80052e6 <chVTDoTickI.4359.4479+0xd6>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80052e2:	2302      	movs	r3, #2
 80052e4:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 80052e6:	9a02      	ldr	r2, [sp, #8]
 80052e8:	9b01      	ldr	r3, [sp, #4]
 80052ea:	4413      	add	r3, r2
 80052ec:	4618      	mov	r0, r3
 80052ee:	f7ff ff57 	bl	80051a0 <port_timer_set_alarm.4349.4495>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
 80052f2:	f7ff ff85 	bl	8005200 <chVTGetSystemTimeX.4246.4481>
 80052f6:	4602      	mov	r2, r0
 80052f8:	f640 0308 	movw	r3, #2056	; 0x808
 80052fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005300:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005302:	1ad2      	subs	r2, r2, r3
 8005304:	9902      	ldr	r1, [sp, #8]
 8005306:	9b01      	ldr	r3, [sp, #4]
 8005308:	4419      	add	r1, r3
 800530a:	f640 0308 	movw	r3, #2056	; 0x808
 800530e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005312:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005314:	1acb      	subs	r3, r1, r3
 8005316:	429a      	cmp	r2, r3
 8005318:	d905      	bls.n	8005326 <chVTDoTickI.4359.4479+0x116>
 800531a:	f247 5030 	movw	r0, #30000	; 0x7530
 800531e:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005322:	f000 f885 	bl	8005430 <chSysHalt>
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005326:	b005      	add	sp, #20
 8005328:	f85d fb04 	ldr.w	pc, [sp], #4
 800532c:	20000824 	.word	0x20000824

08005330 <chRegSetThreadName.4248.4476>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8005330:	b082      	sub	sp, #8
 8005332:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8005334:	f640 0308 	movw	r3, #2056	; 0x808
 8005338:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800533c:	699b      	ldr	r3, [r3, #24]
 800533e:	9a01      	ldr	r2, [sp, #4]
 8005340:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8005342:	b002      	add	sp, #8
 8005344:	4770      	bx	lr
 8005346:	bf00      	nop
 8005348:	f3af 8000 	nop.w
 800534c:	f3af 8000 	nop.w

08005350 <chRegSetThreadNameX.4252.4472>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8005350:	b082      	sub	sp, #8
 8005352:	9001      	str	r0, [sp, #4]
 8005354:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8005356:	9b01      	ldr	r3, [sp, #4]
 8005358:	9a00      	ldr	r2, [sp, #0]
 800535a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800535c:	b002      	add	sp, #8
 800535e:	4770      	bx	lr

08005360 <_idle_thread.4338.4469>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8005360:	b500      	push	{lr}
 8005362:	b083      	sub	sp, #12
 8005364:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8005366:	f7ff fefb 	bl	8005160 <port_wait_for_interrupt.4236.4504>
 800536a:	e7fc      	b.n	8005366 <_idle_thread.4338.4469+0x6>
 800536c:	f3af 8000 	nop.w

08005370 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8005370:	b500      	push	{lr}
 8005372:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8005374:	f7ff fe8c 	bl	8005090 <port_init.4213.4525>
  _scheduler_init();
 8005378:	f000 fc92 	bl	8005ca0 <_scheduler_init.4336>
  _vt_init();
 800537c:	f000 fa88 	bl	8005890 <_vt_init.4387>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 8005380:	f001 f9ee 	bl	8006760 <_tm_init.4147>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8005384:	f7fe fe44 	bl	8004010 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8005388:	f7fe feaa 	bl	80040e0 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
 800538c:	f001 fa80 	bl	8006890 <_stats_init.4123>
#endif
#if CH_DBG_ENABLE_TRACE == TRUE
  _dbg_trace_init();
 8005390:	f000 f9e6 	bl	8005760 <_dbg_trace_init.4407>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8005394:	4821      	ldr	r0, [pc, #132]	; (800541c <chSysInit+0xac>)
 8005396:	2140      	movs	r1, #64	; 0x40
 8005398:	f000 ffca 	bl	8006330 <_thread_init.4241>
 800539c:	4602      	mov	r2, r0
 800539e:	f640 0308 	movw	r3, #2056	; 0x808
 80053a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053a6:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80053a8:	f640 0308 	movw	r3, #2056	; 0x808
 80053ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053b0:	699b      	ldr	r3, [r3, #24]
 80053b2:	2201      	movs	r2, #1
 80053b4:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 80053b8:	f640 0308 	movw	r3, #2056	; 0x808
 80053bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053c0:	699a      	ldr	r2, [r3, #24]
 80053c2:	f240 4300 	movw	r3, #1024	; 0x400
 80053c6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053ca:	61d3      	str	r3, [r2, #28]
#endif

#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
 80053cc:	f640 0308 	movw	r3, #2056	; 0x808
 80053d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80053d4:	699b      	ldr	r3, [r3, #24]
 80053d6:	3348      	adds	r3, #72	; 0x48
 80053d8:	4618      	mov	r0, r3
 80053da:	f001 f9f9 	bl	80067d0 <chTMStartMeasurementX.4141>
#endif

  chSysEnable();
 80053de:	f7ff fef7 	bl	80051d0 <chSysEnable.4341.4491>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 80053e2:	f247 6000 	movw	r0, #30208	; 0x7600
 80053e6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80053ea:	f7ff ffa1 	bl	8005330 <chRegSetThreadName.4248.4476>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80053ee:	2300      	movs	r3, #0
 80053f0:	9300      	str	r3, [sp, #0]
 80053f2:	480b      	ldr	r0, [pc, #44]	; (8005420 <chSysInit+0xb0>)
 80053f4:	21f8      	movs	r1, #248	; 0xf8
 80053f6:	2201      	movs	r2, #1
 80053f8:	f245 3361 	movw	r3, #21345	; 0x5361
 80053fc:	f6c0 0300 	movt	r3, #2048	; 0x800
 8005400:	f001 f83e 	bl	8006480 <chThdCreateStatic>
 8005404:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 8005406:	9803      	ldr	r0, [sp, #12]
 8005408:	f247 4140 	movw	r1, #29760	; 0x7440
 800540c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8005410:	f7ff ff9e 	bl	8005350 <chRegSetThreadNameX.4252.4472>
  }
#endif
}
 8005414:	b005      	add	sp, #20
 8005416:	f85d fb04 	ldr.w	pc, [sp], #4
 800541a:	bf00      	nop
 800541c:	20000c48 	.word	0x20000c48
 8005420:	20000ce8 	.word	0x20000ce8
 8005424:	f3af 8000 	nop.w
 8005428:	f3af 8000 	nop.w
 800542c:	f3af 8000 	nop.w

08005430 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8005430:	b500      	push	{lr}
 8005432:	b083      	sub	sp, #12
 8005434:	9001      	str	r0, [sp, #4]

  port_disable();
 8005436:	f7ff fe7b 	bl	8005130 <port_disable.4232.4508>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800543a:	f640 0308 	movw	r3, #2056	; 0x808
 800543e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005442:	9a01      	ldr	r2, [sp, #4]
 8005444:	62da      	str	r2, [r3, #44]	; 0x2c
 8005446:	e7fe      	b.n	8005446 <chSysHalt+0x16>
 8005448:	f3af 8000 	nop.w
 800544c:	f3af 8000 	nop.w

08005450 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8005450:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 8005452:	f000 f955 	bl	8005700 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 8005456:	f7ff fedb 	bl	8005210 <chVTDoTickI.4359.4479>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 800545a:	bd08      	pop	{r3, pc}
 800545c:	f3af 8000 	nop.w

08005460 <chSysIsCounterWithinX.4448>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 8005460:	b084      	sub	sp, #16
 8005462:	9003      	str	r0, [sp, #12]
 8005464:	9102      	str	r1, [sp, #8]
 8005466:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 8005468:	9a03      	ldr	r2, [sp, #12]
 800546a:	9b02      	ldr	r3, [sp, #8]
 800546c:	1ad2      	subs	r2, r2, r3
 800546e:	9901      	ldr	r1, [sp, #4]
 8005470:	9b02      	ldr	r3, [sp, #8]
 8005472:	1acb      	subs	r3, r1, r3
 8005474:	429a      	cmp	r2, r3
 8005476:	bf2c      	ite	cs
 8005478:	2300      	movcs	r3, #0
 800547a:	2301      	movcc	r3, #1
 800547c:	b2db      	uxtb	r3, r3
}
 800547e:	4618      	mov	r0, r3
 8005480:	b004      	add	sp, #16
 8005482:	4770      	bx	lr
 8005484:	f3af 8000 	nop.w
 8005488:	f3af 8000 	nop.w
 800548c:	f3af 8000 	nop.w

08005490 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8005490:	b500      	push	{lr}
 8005492:	b085      	sub	sp, #20
 8005494:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8005496:	f7ff fe6b 	bl	8005170 <port_rt_get_counter_value.4238.4502>
 800549a:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800549c:	9a03      	ldr	r2, [sp, #12]
 800549e:	9b01      	ldr	r3, [sp, #4]
 80054a0:	4413      	add	r3, r2
 80054a2:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80054a4:	f7ff fe64 	bl	8005170 <port_rt_get_counter_value.4238.4502>
 80054a8:	4603      	mov	r3, r0
 80054aa:	4618      	mov	r0, r3
 80054ac:	9903      	ldr	r1, [sp, #12]
 80054ae:	9a02      	ldr	r2, [sp, #8]
 80054b0:	f7ff ffd6 	bl	8005460 <chSysIsCounterWithinX.4448>
 80054b4:	4603      	mov	r3, r0
 80054b6:	2b00      	cmp	r3, #0
 80054b8:	d1f4      	bne.n	80054a4 <chSysPolledDelayX+0x14>
  }
}
 80054ba:	b005      	add	sp, #20
 80054bc:	f85d fb04 	ldr.w	pc, [sp], #4

080054c0 <port_lock.4605.4443>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80054c0:	b082      	sub	sp, #8
 80054c2:	2320      	movs	r3, #32
 80054c4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80054c6:	9b01      	ldr	r3, [sp, #4]
 80054c8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80054cc:	b002      	add	sp, #8
 80054ce:	4770      	bx	lr

080054d0 <port_unlock.4608.4441>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80054d0:	b082      	sub	sp, #8
 80054d2:	2300      	movs	r3, #0
 80054d4:	9301      	str	r3, [sp, #4]
 80054d6:	9b01      	ldr	r3, [sp, #4]
 80054d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80054dc:	b002      	add	sp, #8
 80054de:	4770      	bx	lr

080054e0 <port_lock_from_isr.4610.4439>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80054e0:	b508      	push	{r3, lr}

  port_lock();
 80054e2:	f7ff ffed 	bl	80054c0 <port_lock.4605.4443>
}
 80054e6:	bd08      	pop	{r3, pc}
 80054e8:	f3af 8000 	nop.w
 80054ec:	f3af 8000 	nop.w

080054f0 <port_unlock_from_isr.4612.4437>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80054f0:	b508      	push	{r3, lr}

  port_unlock();
 80054f2:	f7ff ffed 	bl	80054d0 <port_unlock.4608.4441>
}
 80054f6:	bd08      	pop	{r3, pc}
 80054f8:	f3af 8000 	nop.w
 80054fc:	f3af 8000 	nop.w

08005500 <st_lld_get_counter.4614.4435>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005500:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005504:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8005506:	4618      	mov	r0, r3
 8005508:	4770      	bx	lr
 800550a:	bf00      	nop
 800550c:	f3af 8000 	nop.w

08005510 <port_timer_get_time.4619.4433>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8005510:	b508      	push	{r3, lr}

  return stGetCounter();
 8005512:	f7ff fff5 	bl	8005500 <st_lld_get_counter.4614.4435>
 8005516:	4603      	mov	r3, r0
}
 8005518:	4618      	mov	r0, r3
 800551a:	bd08      	pop	{r3, pc}
 800551c:	f3af 8000 	nop.w

08005520 <chVTGetSystemTimeX.4621.4431>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8005520:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8005522:	f7ff fff5 	bl	8005510 <port_timer_get_time.4619.4433>
 8005526:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005528:	4618      	mov	r0, r3
 800552a:	bd08      	pop	{r3, pc}
 800552c:	f3af 8000 	nop.w

08005530 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 8005530:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005532:	f640 0308 	movw	r3, #2056	; 0x808
 8005536:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800553a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800553c:	2b00      	cmp	r3, #0
 800553e:	d106      	bne.n	800554e <_dbg_check_enable+0x1e>
 8005540:	f640 0308 	movw	r3, #2056	; 0x808
 8005544:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005548:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800554a:	2b00      	cmp	r3, #0
 800554c:	d005      	beq.n	800555a <_dbg_check_enable+0x2a>
    chSysHalt("SV#3");
 800554e:	f247 4058 	movw	r0, #29784	; 0x7458
 8005552:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005556:	f7ff ff6b 	bl	8005430 <chSysHalt>
  }
}
 800555a:	bd08      	pop	{r3, pc}
 800555c:	f3af 8000 	nop.w

08005560 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 8005560:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005562:	f640 0308 	movw	r3, #2056	; 0x808
 8005566:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800556a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800556c:	2b00      	cmp	r3, #0
 800556e:	d106      	bne.n	800557e <_dbg_check_lock+0x1e>
 8005570:	f640 0308 	movw	r3, #2056	; 0x808
 8005574:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005578:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800557a:	2b00      	cmp	r3, #0
 800557c:	d005      	beq.n	800558a <_dbg_check_lock+0x2a>
    chSysHalt("SV#4");
 800557e:	f247 4060 	movw	r0, #29792	; 0x7460
 8005582:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005586:	f7ff ff53 	bl	8005430 <chSysHalt>
  }
  _dbg_enter_lock();
 800558a:	f640 0308 	movw	r3, #2056	; 0x808
 800558e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005592:	2201      	movs	r2, #1
 8005594:	635a      	str	r2, [r3, #52]	; 0x34
}
 8005596:	bd08      	pop	{r3, pc}
 8005598:	f3af 8000 	nop.w
 800559c:	f3af 8000 	nop.w

080055a0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 80055a0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80055a2:	f640 0308 	movw	r3, #2056	; 0x808
 80055a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80055ac:	2b00      	cmp	r3, #0
 80055ae:	d106      	bne.n	80055be <_dbg_check_unlock+0x1e>
 80055b0:	f640 0308 	movw	r3, #2056	; 0x808
 80055b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055b8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80055ba:	2b00      	cmp	r3, #0
 80055bc:	dc05      	bgt.n	80055ca <_dbg_check_unlock+0x2a>
    chSysHalt("SV#5");
 80055be:	f247 4068 	movw	r0, #29800	; 0x7468
 80055c2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80055c6:	f7ff ff33 	bl	8005430 <chSysHalt>
  }
  _dbg_leave_lock();
 80055ca:	f640 0308 	movw	r3, #2056	; 0x808
 80055ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055d2:	2200      	movs	r2, #0
 80055d4:	635a      	str	r2, [r3, #52]	; 0x34
}
 80055d6:	bd08      	pop	{r3, pc}
 80055d8:	f3af 8000 	nop.w
 80055dc:	f3af 8000 	nop.w

080055e0 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 80055e0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80055e2:	f640 0308 	movw	r3, #2056	; 0x808
 80055e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80055ec:	2b00      	cmp	r3, #0
 80055ee:	dd06      	ble.n	80055fe <_dbg_check_lock_from_isr+0x1e>
 80055f0:	f640 0308 	movw	r3, #2056	; 0x808
 80055f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80055f8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80055fa:	2b00      	cmp	r3, #0
 80055fc:	d005      	beq.n	800560a <_dbg_check_lock_from_isr+0x2a>
    chSysHalt("SV#6");
 80055fe:	f247 4070 	movw	r0, #29808	; 0x7470
 8005602:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005606:	f7ff ff13 	bl	8005430 <chSysHalt>
  }
  _dbg_enter_lock();
 800560a:	f640 0308 	movw	r3, #2056	; 0x808
 800560e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005612:	2201      	movs	r2, #1
 8005614:	635a      	str	r2, [r3, #52]	; 0x34
}
 8005616:	bd08      	pop	{r3, pc}
 8005618:	f3af 8000 	nop.w
 800561c:	f3af 8000 	nop.w

08005620 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 8005620:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005622:	f640 0308 	movw	r3, #2056	; 0x808
 8005626:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800562a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800562c:	2b00      	cmp	r3, #0
 800562e:	dd06      	ble.n	800563e <_dbg_check_unlock_from_isr+0x1e>
 8005630:	f640 0308 	movw	r3, #2056	; 0x808
 8005634:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005638:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800563a:	2b00      	cmp	r3, #0
 800563c:	dc05      	bgt.n	800564a <_dbg_check_unlock_from_isr+0x2a>
    chSysHalt("SV#7");
 800563e:	f247 4078 	movw	r0, #29816	; 0x7478
 8005642:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005646:	f7ff fef3 	bl	8005430 <chSysHalt>
  }
  _dbg_leave_lock();
 800564a:	f640 0308 	movw	r3, #2056	; 0x808
 800564e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005652:	2200      	movs	r2, #0
 8005654:	635a      	str	r2, [r3, #52]	; 0x34
}
 8005656:	bd08      	pop	{r3, pc}
 8005658:	f3af 8000 	nop.w
 800565c:	f3af 8000 	nop.w

08005660 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 8005660:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8005662:	f7ff ff3d 	bl	80054e0 <port_lock_from_isr.4610.4439>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005666:	f640 0308 	movw	r3, #2056	; 0x808
 800566a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800566e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005670:	2b00      	cmp	r3, #0
 8005672:	db06      	blt.n	8005682 <_dbg_check_enter_isr+0x22>
 8005674:	f640 0308 	movw	r3, #2056	; 0x808
 8005678:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800567c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800567e:	2b00      	cmp	r3, #0
 8005680:	d005      	beq.n	800568e <_dbg_check_enter_isr+0x2e>
    chSysHalt("SV#8");
 8005682:	f247 4080 	movw	r0, #29824	; 0x7480
 8005686:	f6c0 0000 	movt	r0, #2048	; 0x800
 800568a:	f7ff fed1 	bl	8005430 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800568e:	f640 0308 	movw	r3, #2056	; 0x808
 8005692:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005696:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005698:	1c5a      	adds	r2, r3, #1
 800569a:	f640 0308 	movw	r3, #2056	; 0x808
 800569e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056a2:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 80056a4:	f7ff ff24 	bl	80054f0 <port_unlock_from_isr.4612.4437>
}
 80056a8:	bd08      	pop	{r3, pc}
 80056aa:	bf00      	nop
 80056ac:	f3af 8000 	nop.w

080056b0 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 80056b0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80056b2:	f7ff ff15 	bl	80054e0 <port_lock_from_isr.4610.4439>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80056b6:	f640 0308 	movw	r3, #2056	; 0x808
 80056ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80056c0:	2b00      	cmp	r3, #0
 80056c2:	dd06      	ble.n	80056d2 <_dbg_check_leave_isr+0x22>
 80056c4:	f640 0308 	movw	r3, #2056	; 0x808
 80056c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056cc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80056ce:	2b00      	cmp	r3, #0
 80056d0:	d005      	beq.n	80056de <_dbg_check_leave_isr+0x2e>
    chSysHalt("SV#9");
 80056d2:	f247 4088 	movw	r0, #29832	; 0x7488
 80056d6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80056da:	f7ff fea9 	bl	8005430 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 80056de:	f640 0308 	movw	r3, #2056	; 0x808
 80056e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056e6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80056e8:	1e5a      	subs	r2, r3, #1
 80056ea:	f640 0308 	movw	r3, #2056	; 0x808
 80056ee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80056f2:	631a      	str	r2, [r3, #48]	; 0x30
  port_unlock_from_isr();
 80056f4:	f7ff fefc 	bl	80054f0 <port_unlock_from_isr.4612.4437>
}
 80056f8:	bd08      	pop	{r3, pc}
 80056fa:	bf00      	nop
 80056fc:	f3af 8000 	nop.w

08005700 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8005700:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005702:	f640 0308 	movw	r3, #2056	; 0x808
 8005706:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800570a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800570c:	2b00      	cmp	r3, #0
 800570e:	db06      	blt.n	800571e <chDbgCheckClassI+0x1e>
 8005710:	f640 0308 	movw	r3, #2056	; 0x808
 8005714:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005718:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800571a:	2b00      	cmp	r3, #0
 800571c:	dc05      	bgt.n	800572a <chDbgCheckClassI+0x2a>
    chSysHalt("SV#10");
 800571e:	f247 4090 	movw	r0, #29840	; 0x7490
 8005722:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005726:	f7ff fe83 	bl	8005430 <chSysHalt>
  }
}
 800572a:	bd08      	pop	{r3, pc}
 800572c:	f3af 8000 	nop.w

08005730 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8005730:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005732:	f640 0308 	movw	r3, #2056	; 0x808
 8005736:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800573a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800573c:	2b00      	cmp	r3, #0
 800573e:	d106      	bne.n	800574e <chDbgCheckClassS+0x1e>
 8005740:	f640 0308 	movw	r3, #2056	; 0x808
 8005744:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005748:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800574a:	2b00      	cmp	r3, #0
 800574c:	dc05      	bgt.n	800575a <chDbgCheckClassS+0x2a>
    chSysHalt("SV#11");
 800574e:	f247 4098 	movw	r0, #29848	; 0x7498
 8005752:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005756:	f7ff fe6b 	bl	8005430 <chSysHalt>
  }
}
 800575a:	bd08      	pop	{r3, pc}
 800575c:	f3af 8000 	nop.w

08005760 <_dbg_trace_init.4407>:
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 8005760:	f640 0308 	movw	r3, #2056	; 0x808
 8005764:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005768:	2240      	movs	r2, #64	; 0x40
 800576a:	639a      	str	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 800576c:	f640 0308 	movw	r3, #2056	; 0x808
 8005770:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005774:	4a01      	ldr	r2, [pc, #4]	; (800577c <_dbg_trace_init.4407+0x1c>)
 8005776:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8005778:	4770      	bx	lr
 800577a:	bf00      	nop
 800577c:	20000848 	.word	0x20000848

08005780 <_dbg_trace.4403>:
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
 8005780:	b510      	push	{r4, lr}
 8005782:	b082      	sub	sp, #8
 8005784:	9001      	str	r0, [sp, #4]

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 8005786:	f640 0308 	movw	r3, #2056	; 0x808
 800578a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800578e:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 8005790:	f7ff fec6 	bl	8005520 <chVTGetSystemTimeX.4621.4431>
 8005794:	4603      	mov	r3, r0
 8005796:	6023      	str	r3, [r4, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
 8005798:	f640 0308 	movw	r3, #2056	; 0x808
 800579c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057a0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80057a2:	f640 0308 	movw	r3, #2056	; 0x808
 80057a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057aa:	699b      	ldr	r3, [r3, #24]
 80057ac:	6053      	str	r3, [r2, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 80057ae:	f640 0308 	movw	r3, #2056	; 0x808
 80057b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80057b8:	9a01      	ldr	r2, [sp, #4]
 80057ba:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80057bc:	609a      	str	r2, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 80057be:	f640 0308 	movw	r3, #2056	; 0x808
 80057c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80057c8:	9a01      	ldr	r2, [sp, #4]
 80057ca:	f892 2020 	ldrb.w	r2, [r2, #32]
 80057ce:	731a      	strb	r2, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 80057d0:	f640 0308 	movw	r3, #2056	; 0x808
 80057d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80057da:	f103 0210 	add.w	r2, r3, #16
 80057de:	f640 0308 	movw	r3, #2056	; 0x808
 80057e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057e6:	63da      	str	r2, [r3, #60]	; 0x3c
 80057e8:	f640 0308 	movw	r3, #2056	; 0x808
 80057ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80057f0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80057f2:	4b05      	ldr	r3, [pc, #20]	; (8005808 <_dbg_trace.4403+0x88>)
 80057f4:	429a      	cmp	r2, r3
 80057f6:	d305      	bcc.n	8005804 <_dbg_trace.4403+0x84>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 80057f8:	f640 0308 	movw	r3, #2056	; 0x808
 80057fc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005800:	4a02      	ldr	r2, [pc, #8]	; (800580c <_dbg_trace.4403+0x8c>)
 8005802:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 8005804:	b002      	add	sp, #8
 8005806:	bd10      	pop	{r4, pc}
 8005808:	20000c48 	.word	0x20000c48
 800580c:	20000848 	.word	0x20000848

08005810 <st_lld_get_counter.4821.4401>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005810:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005814:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8005816:	4618      	mov	r0, r3
 8005818:	4770      	bx	lr
 800581a:	bf00      	nop
 800581c:	f3af 8000 	nop.w

08005820 <port_timer_start_alarm.4831.4398>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8005820:	b500      	push	{lr}
 8005822:	b083      	sub	sp, #12
 8005824:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 8005826:	9801      	ldr	r0, [sp, #4]
 8005828:	f7fe fd42 	bl	80042b0 <stStartAlarm>
}
 800582c:	b003      	add	sp, #12
 800582e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005832:	bf00      	nop
 8005834:	f3af 8000 	nop.w
 8005838:	f3af 8000 	nop.w
 800583c:	f3af 8000 	nop.w

08005840 <port_timer_stop_alarm.4837.4396>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8005840:	b508      	push	{r3, lr}

  stStopAlarm();
 8005842:	f7fe fd4d 	bl	80042e0 <stStopAlarm>
}
 8005846:	bd08      	pop	{r3, pc}
 8005848:	f3af 8000 	nop.w
 800584c:	f3af 8000 	nop.w

08005850 <port_timer_set_alarm.4834.4393>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8005850:	b500      	push	{lr}
 8005852:	b083      	sub	sp, #12
 8005854:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 8005856:	9801      	ldr	r0, [sp, #4]
 8005858:	f7fe fd4a 	bl	80042f0 <stSetAlarm>
}
 800585c:	b003      	add	sp, #12
 800585e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005862:	bf00      	nop
 8005864:	f3af 8000 	nop.w
 8005868:	f3af 8000 	nop.w
 800586c:	f3af 8000 	nop.w

08005870 <port_timer_get_time.4827.4391>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8005870:	b508      	push	{r3, lr}

  return stGetCounter();
 8005872:	f7ff ffcd 	bl	8005810 <st_lld_get_counter.4821.4401>
 8005876:	4603      	mov	r3, r0
}
 8005878:	4618      	mov	r0, r3
 800587a:	bd08      	pop	{r3, pc}
 800587c:	f3af 8000 	nop.w

08005880 <chVTGetSystemTimeX.4829.4389>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8005880:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8005882:	f7ff fff5 	bl	8005870 <port_timer_get_time.4827.4391>
 8005886:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005888:	4618      	mov	r0, r3
 800588a:	bd08      	pop	{r3, pc}
 800588c:	f3af 8000 	nop.w

08005890 <_vt_init.4387>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8005890:	f640 0308 	movw	r3, #2056	; 0x808
 8005894:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005898:	4a0a      	ldr	r2, [pc, #40]	; (80058c4 <_vt_init.4387+0x34>)
 800589a:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 800589c:	f640 0308 	movw	r3, #2056	; 0x808
 80058a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058a4:	4a07      	ldr	r2, [pc, #28]	; (80058c4 <_vt_init.4387+0x34>)
 80058a6:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 80058a8:	f640 0308 	movw	r3, #2056	; 0x808
 80058ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058b0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80058b4:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 80058b6:	f640 0308 	movw	r3, #2056	; 0x808
 80058ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80058be:	2200      	movs	r2, #0
 80058c0:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80058c2:	4770      	bx	lr
 80058c4:	20000824 	.word	0x20000824
 80058c8:	f3af 8000 	nop.w
 80058cc:	f3af 8000 	nop.w

080058d0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80058d0:	b500      	push	{lr}
 80058d2:	b089      	sub	sp, #36	; 0x24
 80058d4:	9003      	str	r0, [sp, #12]
 80058d6:	9102      	str	r1, [sp, #8]
 80058d8:	9201      	str	r2, [sp, #4]
 80058da:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 80058dc:	f7ff ff10 	bl	8005700 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 80058e0:	9b03      	ldr	r3, [sp, #12]
 80058e2:	2b00      	cmp	r3, #0
 80058e4:	d005      	beq.n	80058f2 <chVTDoSetI+0x22>
 80058e6:	9b01      	ldr	r3, [sp, #4]
 80058e8:	2b00      	cmp	r3, #0
 80058ea:	d002      	beq.n	80058f2 <chVTDoSetI+0x22>
 80058ec:	9b02      	ldr	r3, [sp, #8]
 80058ee:	2b00      	cmp	r3, #0
 80058f0:	d105      	bne.n	80058fe <chVTDoSetI+0x2e>
 80058f2:	f247 5040 	movw	r0, #30016	; 0x7540
 80058f6:	f6c0 0000 	movt	r0, #2048	; 0x800
 80058fa:	f7ff fd99 	bl	8005430 <chSysHalt>

  vtp->vt_par = par;
 80058fe:	9b03      	ldr	r3, [sp, #12]
 8005900:	9a00      	ldr	r2, [sp, #0]
 8005902:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 8005904:	9b03      	ldr	r3, [sp, #12]
 8005906:	9a01      	ldr	r2, [sp, #4]
 8005908:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 800590a:	f7ff ffb9 	bl	8005880 <chVTGetSystemTimeX.4829.4389>
 800590e:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8005910:	9b02      	ldr	r3, [sp, #8]
 8005912:	2b01      	cmp	r3, #1
 8005914:	d801      	bhi.n	800591a <chVTDoSetI+0x4a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8005916:	2302      	movs	r3, #2
 8005918:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800591a:	f640 0308 	movw	r3, #2056	; 0x808
 800591e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005922:	69da      	ldr	r2, [r3, #28]
 8005924:	4b3d      	ldr	r3, [pc, #244]	; (8005a1c <chVTDoSetI+0x14c>)
 8005926:	429a      	cmp	r2, r3
 8005928:	d125      	bne.n	8005976 <chVTDoSetI+0xa6>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 800592a:	f640 0308 	movw	r3, #2056	; 0x808
 800592e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005932:	9a05      	ldr	r2, [sp, #20]
 8005934:	629a      	str	r2, [r3, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 8005936:	f640 0308 	movw	r3, #2056	; 0x808
 800593a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800593e:	9a03      	ldr	r2, [sp, #12]
 8005940:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
 8005942:	f640 0308 	movw	r3, #2056	; 0x808
 8005946:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800594a:	9a03      	ldr	r2, [sp, #12]
 800594c:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 800594e:	9b03      	ldr	r3, [sp, #12]
 8005950:	4a32      	ldr	r2, [pc, #200]	; (8005a1c <chVTDoSetI+0x14c>)
 8005952:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8005954:	9b03      	ldr	r3, [sp, #12]
 8005956:	4a31      	ldr	r2, [pc, #196]	; (8005a1c <chVTDoSetI+0x14c>)
 8005958:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
 800595a:	9b03      	ldr	r3, [sp, #12]
 800595c:	9a02      	ldr	r2, [sp, #8]
 800595e:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8005960:	f640 0308 	movw	r3, #2056	; 0x808
 8005964:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005968:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800596a:	9b02      	ldr	r3, [sp, #8]
 800596c:	4413      	add	r3, r2
 800596e:	4618      	mov	r0, r3
 8005970:	f7ff ff56 	bl	8005820 <port_timer_start_alarm.4831.4398>
 8005974:	e04f      	b.n	8005a16 <chVTDoSetI+0x146>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8005976:	9a05      	ldr	r2, [sp, #20]
 8005978:	9b02      	ldr	r3, [sp, #8]
 800597a:	441a      	add	r2, r3
 800597c:	f640 0308 	movw	r3, #2056	; 0x808
 8005980:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005984:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005986:	1ad3      	subs	r3, r2, r3
 8005988:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
 800598a:	f640 0308 	movw	r3, #2056	; 0x808
 800598e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005992:	69db      	ldr	r3, [r3, #28]
 8005994:	689a      	ldr	r2, [r3, #8]
 8005996:	9b06      	ldr	r3, [sp, #24]
 8005998:	429a      	cmp	r2, r3
 800599a:	d909      	bls.n	80059b0 <chVTDoSetI+0xe0>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 800599c:	f640 0308 	movw	r3, #2056	; 0x808
 80059a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059a4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80059a6:	9b06      	ldr	r3, [sp, #24]
 80059a8:	4413      	add	r3, r2
 80059aa:	4618      	mov	r0, r3
 80059ac:	f7ff ff50 	bl	8005850 <port_timer_set_alarm.4834.4393>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 80059b0:	f640 0308 	movw	r3, #2056	; 0x808
 80059b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80059b8:	69db      	ldr	r3, [r3, #28]
 80059ba:	9307      	str	r3, [sp, #28]
 80059bc:	e007      	b.n	80059ce <chVTDoSetI+0xfe>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 80059be:	9b07      	ldr	r3, [sp, #28]
 80059c0:	689b      	ldr	r3, [r3, #8]
 80059c2:	9a06      	ldr	r2, [sp, #24]
 80059c4:	1ad3      	subs	r3, r2, r3
 80059c6:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
 80059c8:	9b07      	ldr	r3, [sp, #28]
 80059ca:	681b      	ldr	r3, [r3, #0]
 80059cc:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 80059ce:	9b07      	ldr	r3, [sp, #28]
 80059d0:	689a      	ldr	r2, [r3, #8]
 80059d2:	9b06      	ldr	r3, [sp, #24]
 80059d4:	429a      	cmp	r2, r3
 80059d6:	d3f2      	bcc.n	80059be <chVTDoSetI+0xee>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80059d8:	9b03      	ldr	r3, [sp, #12]
 80059da:	9a07      	ldr	r2, [sp, #28]
 80059dc:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80059de:	9b03      	ldr	r3, [sp, #12]
 80059e0:	681b      	ldr	r3, [r3, #0]
 80059e2:	685a      	ldr	r2, [r3, #4]
 80059e4:	9b03      	ldr	r3, [sp, #12]
 80059e6:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 80059e8:	9b03      	ldr	r3, [sp, #12]
 80059ea:	685b      	ldr	r3, [r3, #4]
 80059ec:	9a03      	ldr	r2, [sp, #12]
 80059ee:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 80059f0:	9b07      	ldr	r3, [sp, #28]
 80059f2:	9a03      	ldr	r2, [sp, #12]
 80059f4:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 80059f6:	9b03      	ldr	r3, [sp, #12]
 80059f8:	9a06      	ldr	r2, [sp, #24]
 80059fa:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80059fc:	9b07      	ldr	r3, [sp, #28]
 80059fe:	689a      	ldr	r2, [r3, #8]
 8005a00:	9b06      	ldr	r3, [sp, #24]
 8005a02:	1ad2      	subs	r2, r2, r3
 8005a04:	9b07      	ldr	r3, [sp, #28]
 8005a06:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8005a08:	f640 0308 	movw	r3, #2056	; 0x808
 8005a0c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a10:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005a14:	625a      	str	r2, [r3, #36]	; 0x24
}
 8005a16:	b009      	add	sp, #36	; 0x24
 8005a18:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a1c:	20000824 	.word	0x20000824

08005a20 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8005a20:	b500      	push	{lr}
 8005a22:	b085      	sub	sp, #20
 8005a24:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005a26:	f7ff fe6b 	bl	8005700 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8005a2a:	9b01      	ldr	r3, [sp, #4]
 8005a2c:	2b00      	cmp	r3, #0
 8005a2e:	d105      	bne.n	8005a3c <chVTDoResetI+0x1c>
 8005a30:	f247 5050 	movw	r0, #30032	; 0x7550
 8005a34:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005a38:	f7ff fcfa 	bl	8005430 <chSysHalt>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
 8005a3c:	9b01      	ldr	r3, [sp, #4]
 8005a3e:	68db      	ldr	r3, [r3, #12]
 8005a40:	2b00      	cmp	r3, #0
 8005a42:	d105      	bne.n	8005a50 <chVTDoResetI+0x30>
 8005a44:	f247 5050 	movw	r0, #30032	; 0x7550
 8005a48:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005a4c:	f7ff fcf0 	bl	8005430 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8005a50:	f640 0308 	movw	r3, #2056	; 0x808
 8005a54:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005a58:	69da      	ldr	r2, [r3, #28]
 8005a5a:	9b01      	ldr	r3, [sp, #4]
 8005a5c:	429a      	cmp	r2, r3
 8005a5e:	d01b      	beq.n	8005a98 <chVTDoResetI+0x78>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8005a60:	9b01      	ldr	r3, [sp, #4]
 8005a62:	685b      	ldr	r3, [r3, #4]
 8005a64:	9a01      	ldr	r2, [sp, #4]
 8005a66:	6812      	ldr	r2, [r2, #0]
 8005a68:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8005a6a:	9b01      	ldr	r3, [sp, #4]
 8005a6c:	681b      	ldr	r3, [r3, #0]
 8005a6e:	9a01      	ldr	r2, [sp, #4]
 8005a70:	6852      	ldr	r2, [r2, #4]
 8005a72:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 8005a74:	9b01      	ldr	r3, [sp, #4]
 8005a76:	2200      	movs	r2, #0
 8005a78:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8005a7a:	9b01      	ldr	r3, [sp, #4]
 8005a7c:	681a      	ldr	r2, [r3, #0]
 8005a7e:	4b34      	ldr	r3, [pc, #208]	; (8005b50 <chVTDoResetI+0x130>)
 8005a80:	429a      	cmp	r2, r3
 8005a82:	d061      	beq.n	8005b48 <chVTDoResetI+0x128>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8005a84:	9b01      	ldr	r3, [sp, #4]
 8005a86:	681b      	ldr	r3, [r3, #0]
 8005a88:	9a01      	ldr	r2, [sp, #4]
 8005a8a:	6812      	ldr	r2, [r2, #0]
 8005a8c:	6891      	ldr	r1, [r2, #8]
 8005a8e:	9a01      	ldr	r2, [sp, #4]
 8005a90:	6892      	ldr	r2, [r2, #8]
 8005a92:	440a      	add	r2, r1
 8005a94:	609a      	str	r2, [r3, #8]
 8005a96:	e057      	b.n	8005b48 <chVTDoResetI+0x128>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8005a98:	9b01      	ldr	r3, [sp, #4]
 8005a9a:	681a      	ldr	r2, [r3, #0]
 8005a9c:	f640 0308 	movw	r3, #2056	; 0x808
 8005aa0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005aa4:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8005aa6:	f640 0308 	movw	r3, #2056	; 0x808
 8005aaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005aae:	69db      	ldr	r3, [r3, #28]
 8005ab0:	4a27      	ldr	r2, [pc, #156]	; (8005b50 <chVTDoResetI+0x130>)
 8005ab2:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 8005ab4:	9b01      	ldr	r3, [sp, #4]
 8005ab6:	2200      	movs	r2, #0
 8005ab8:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8005aba:	f640 0308 	movw	r3, #2056	; 0x808
 8005abe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ac2:	69da      	ldr	r2, [r3, #28]
 8005ac4:	4b22      	ldr	r3, [pc, #136]	; (8005b50 <chVTDoResetI+0x130>)
 8005ac6:	429a      	cmp	r2, r3
 8005ac8:	d102      	bne.n	8005ad0 <chVTDoResetI+0xb0>
    port_timer_stop_alarm();
 8005aca:	f7ff feb9 	bl	8005840 <port_timer_stop_alarm.4837.4396>
 8005ace:	e03b      	b.n	8005b48 <chVTDoResetI+0x128>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8005ad0:	f640 0308 	movw	r3, #2056	; 0x808
 8005ad4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ad8:	69da      	ldr	r2, [r3, #28]
 8005ada:	f640 0308 	movw	r3, #2056	; 0x808
 8005ade:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ae2:	69db      	ldr	r3, [r3, #28]
 8005ae4:	6899      	ldr	r1, [r3, #8]
 8005ae6:	9b01      	ldr	r3, [sp, #4]
 8005ae8:	689b      	ldr	r3, [r3, #8]
 8005aea:	440b      	add	r3, r1
 8005aec:	6093      	str	r3, [r2, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8005aee:	f7ff fec7 	bl	8005880 <chVTGetSystemTimeX.4829.4389>
 8005af2:	4602      	mov	r2, r0
 8005af4:	f640 0308 	movw	r3, #2056	; 0x808
 8005af8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005afc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005afe:	1ad3      	subs	r3, r2, r3
 8005b00:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8005b02:	f640 0308 	movw	r3, #2056	; 0x808
 8005b06:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b0a:	69db      	ldr	r3, [r3, #28]
 8005b0c:	689a      	ldr	r2, [r3, #8]
 8005b0e:	9b02      	ldr	r3, [sp, #8]
 8005b10:	429a      	cmp	r2, r3
 8005b12:	d919      	bls.n	8005b48 <chVTDoResetI+0x128>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 8005b14:	f640 0308 	movw	r3, #2056	; 0x808
 8005b18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b1c:	69db      	ldr	r3, [r3, #28]
 8005b1e:	689a      	ldr	r2, [r3, #8]
 8005b20:	9b02      	ldr	r3, [sp, #8]
 8005b22:	1ad3      	subs	r3, r2, r3
 8005b24:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8005b26:	9b03      	ldr	r3, [sp, #12]
 8005b28:	2b01      	cmp	r3, #1
 8005b2a:	d801      	bhi.n	8005b30 <chVTDoResetI+0x110>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8005b2c:	2302      	movs	r3, #2
 8005b2e:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8005b30:	f640 0308 	movw	r3, #2056	; 0x808
 8005b34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005b38:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005b3a:	9b02      	ldr	r3, [sp, #8]
 8005b3c:	441a      	add	r2, r3
 8005b3e:	9b03      	ldr	r3, [sp, #12]
 8005b40:	4413      	add	r3, r2
 8005b42:	4618      	mov	r0, r3
 8005b44:	f7ff fe84 	bl	8005850 <port_timer_set_alarm.4834.4393>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005b48:	b005      	add	sp, #20
 8005b4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b4e:	bf00      	nop
 8005b50:	20000824 	.word	0x20000824
 8005b54:	f3af 8000 	nop.w
 8005b58:	f3af 8000 	nop.w
 8005b5c:	f3af 8000 	nop.w

08005b60 <port_lock.5026.4375>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005b60:	b082      	sub	sp, #8
 8005b62:	2320      	movs	r3, #32
 8005b64:	9301      	str	r3, [sp, #4]
 8005b66:	9b01      	ldr	r3, [sp, #4]
 8005b68:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005b6c:	b002      	add	sp, #8
 8005b6e:	4770      	bx	lr

08005b70 <port_unlock.5029.4373>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005b70:	b082      	sub	sp, #8
 8005b72:	2300      	movs	r3, #0
 8005b74:	9301      	str	r3, [sp, #4]
 8005b76:	9b01      	ldr	r3, [sp, #4]
 8005b78:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005b7c:	b002      	add	sp, #8
 8005b7e:	4770      	bx	lr

08005b80 <port_lock_from_isr.5031.4371>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8005b80:	b508      	push	{r3, lr}

  port_lock();
 8005b82:	f7ff ffed 	bl	8005b60 <port_lock.5026.4375>
}
 8005b86:	bd08      	pop	{r3, pc}
 8005b88:	f3af 8000 	nop.w
 8005b8c:	f3af 8000 	nop.w

08005b90 <port_unlock_from_isr.5033.4369>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8005b90:	b508      	push	{r3, lr}

  port_unlock();
 8005b92:	f7ff ffed 	bl	8005b70 <port_unlock.5029.4373>
}
 8005b96:	bd08      	pop	{r3, pc}
 8005b98:	f3af 8000 	nop.w
 8005b9c:	f3af 8000 	nop.w

08005ba0 <queue_init.5035.4366>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8005ba0:	b082      	sub	sp, #8
 8005ba2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8005ba4:	9b01      	ldr	r3, [sp, #4]
 8005ba6:	9a01      	ldr	r2, [sp, #4]
 8005ba8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8005baa:	9b01      	ldr	r3, [sp, #4]
 8005bac:	9a01      	ldr	r2, [sp, #4]
 8005bae:	605a      	str	r2, [r3, #4]
}
 8005bb0:	b002      	add	sp, #8
 8005bb2:	4770      	bx	lr
 8005bb4:	f3af 8000 	nop.w
 8005bb8:	f3af 8000 	nop.w
 8005bbc:	f3af 8000 	nop.w

08005bc0 <queue_fifo_remove.5124.4363>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8005bc0:	b084      	sub	sp, #16
 8005bc2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8005bc4:	9b01      	ldr	r3, [sp, #4]
 8005bc6:	681b      	ldr	r3, [r3, #0]
 8005bc8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8005bca:	9b03      	ldr	r3, [sp, #12]
 8005bcc:	681a      	ldr	r2, [r3, #0]
 8005bce:	9b01      	ldr	r3, [sp, #4]
 8005bd0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8005bd2:	9b01      	ldr	r3, [sp, #4]
 8005bd4:	681b      	ldr	r3, [r3, #0]
 8005bd6:	9a01      	ldr	r2, [sp, #4]
 8005bd8:	605a      	str	r2, [r3, #4]

  return tp;
 8005bda:	9b03      	ldr	r3, [sp, #12]
}
 8005bdc:	4618      	mov	r0, r3
 8005bde:	b004      	add	sp, #16
 8005be0:	4770      	bx	lr
 8005be2:	bf00      	nop
 8005be4:	f3af 8000 	nop.w
 8005be8:	f3af 8000 	nop.w
 8005bec:	f3af 8000 	nop.w

08005bf0 <queue_dequeue.5127.4360>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8005bf0:	b082      	sub	sp, #8
 8005bf2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8005bf4:	9b01      	ldr	r3, [sp, #4]
 8005bf6:	685b      	ldr	r3, [r3, #4]
 8005bf8:	9a01      	ldr	r2, [sp, #4]
 8005bfa:	6812      	ldr	r2, [r2, #0]
 8005bfc:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8005bfe:	9b01      	ldr	r3, [sp, #4]
 8005c00:	681b      	ldr	r3, [r3, #0]
 8005c02:	9a01      	ldr	r2, [sp, #4]
 8005c04:	6852      	ldr	r2, [r2, #4]
 8005c06:	605a      	str	r2, [r3, #4]

  return tp;
 8005c08:	9b01      	ldr	r3, [sp, #4]
}
 8005c0a:	4618      	mov	r0, r3
 8005c0c:	b002      	add	sp, #8
 8005c0e:	4770      	bx	lr

08005c10 <chSchIsRescRequiredI.5147.4358>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 8005c10:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 8005c12:	f7ff fd75 	bl	8005700 <chDbgCheckClassI>

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8005c16:	f640 0308 	movw	r3, #2056	; 0x808
 8005c1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c1e:	681b      	ldr	r3, [r3, #0]
 8005c20:	689a      	ldr	r2, [r3, #8]
 8005c22:	f640 0308 	movw	r3, #2056	; 0x808
 8005c26:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005c2a:	699b      	ldr	r3, [r3, #24]
 8005c2c:	689b      	ldr	r3, [r3, #8]
 8005c2e:	429a      	cmp	r2, r3
 8005c30:	bf94      	ite	ls
 8005c32:	2300      	movls	r3, #0
 8005c34:	2301      	movhi	r3, #1
 8005c36:	b2db      	uxtb	r3, r3
}
 8005c38:	4618      	mov	r0, r3
 8005c3a:	bd08      	pop	{r3, pc}
 8005c3c:	f3af 8000 	nop.w

08005c40 <chSysLockFromISR.5149.4356>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8005c40:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8005c42:	f7ff ff9d 	bl	8005b80 <port_lock_from_isr.5031.4371>
  _stats_start_measure_crit_isr();
 8005c46:	f000 fe8b 	bl	8006960 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 8005c4a:	f7ff fcc9 	bl	80055e0 <_dbg_check_lock_from_isr>
}
 8005c4e:	bd08      	pop	{r3, pc}

08005c50 <chSysUnlockFromISR.5151.4354>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8005c50:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8005c52:	f7ff fce5 	bl	8005620 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8005c56:	f000 fe8b 	bl	8006970 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 8005c5a:	f7ff ff99 	bl	8005b90 <port_unlock_from_isr.5033.4369>
}
 8005c5e:	bd08      	pop	{r3, pc}

08005c60 <chVTIsArmedI.5134.4343>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8005c60:	b500      	push	{lr}
 8005c62:	b083      	sub	sp, #12
 8005c64:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005c66:	f7ff fd4b 	bl	8005700 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
 8005c6a:	9b01      	ldr	r3, [sp, #4]
 8005c6c:	68db      	ldr	r3, [r3, #12]
 8005c6e:	2b00      	cmp	r3, #0
 8005c70:	bf0c      	ite	eq
 8005c72:	2300      	moveq	r3, #0
 8005c74:	2301      	movne	r3, #1
 8005c76:	b2db      	uxtb	r3, r3
}
 8005c78:	4618      	mov	r0, r3
 8005c7a:	b003      	add	sp, #12
 8005c7c:	f85d fb04 	ldr.w	pc, [sp], #4

08005c80 <chSemFastSignalI.5130.4338>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8005c80:	b500      	push	{lr}
 8005c82:	b083      	sub	sp, #12
 8005c84:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005c86:	f7ff fd3b 	bl	8005700 <chDbgCheckClassI>

  sp->s_cnt++;
 8005c8a:	9b01      	ldr	r3, [sp, #4]
 8005c8c:	689b      	ldr	r3, [r3, #8]
 8005c8e:	1c5a      	adds	r2, r3, #1
 8005c90:	9b01      	ldr	r3, [sp, #4]
 8005c92:	609a      	str	r2, [r3, #8]
}
 8005c94:	b003      	add	sp, #12
 8005c96:	f85d fb04 	ldr.w	pc, [sp], #4
 8005c9a:	bf00      	nop
 8005c9c:	f3af 8000 	nop.w

08005ca0 <_scheduler_init.4336>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8005ca0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 8005ca2:	f640 0008 	movw	r0, #2056	; 0x808
 8005ca6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005caa:	f7ff ff79 	bl	8005ba0 <queue_init.5035.4366>
  ch.rlist.r_prio = NOPRIO;
 8005cae:	f640 0308 	movw	r3, #2056	; 0x808
 8005cb2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cb6:	2200      	movs	r2, #0
 8005cb8:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8005cba:	f640 0308 	movw	r3, #2056	; 0x808
 8005cbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cc2:	f640 0208 	movw	r2, #2056	; 0x808
 8005cc6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005cca:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8005ccc:	f640 0308 	movw	r3, #2056	; 0x808
 8005cd0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005cd4:	f640 0208 	movw	r2, #2056	; 0x808
 8005cd8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8005cdc:	615a      	str	r2, [r3, #20]
#endif
}
 8005cde:	bd08      	pop	{r3, pc}

08005ce0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8005ce0:	b500      	push	{lr}
 8005ce2:	b085      	sub	sp, #20
 8005ce4:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 8005ce6:	f7ff fd0b 	bl	8005700 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8005cea:	9b01      	ldr	r3, [sp, #4]
 8005cec:	2b00      	cmp	r3, #0
 8005cee:	d105      	bne.n	8005cfc <chSchReadyI+0x1c>
 8005cf0:	f247 5060 	movw	r0, #30048	; 0x7560
 8005cf4:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005cf8:	f7ff fb9a 	bl	8005430 <chSysHalt>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 8005cfc:	9b01      	ldr	r3, [sp, #4]
 8005cfe:	f893 3020 	ldrb.w	r3, [r3, #32]
 8005d02:	2b00      	cmp	r3, #0
 8005d04:	d004      	beq.n	8005d10 <chSchReadyI+0x30>
 8005d06:	9b01      	ldr	r3, [sp, #4]
 8005d08:	f893 3020 	ldrb.w	r3, [r3, #32]
 8005d0c:	2b0f      	cmp	r3, #15
 8005d0e:	d105      	bne.n	8005d1c <chSchReadyI+0x3c>
 8005d10:	f247 5060 	movw	r0, #30048	; 0x7560
 8005d14:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005d18:	f7ff fb8a 	bl	8005430 <chSysHalt>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8005d1c:	9b01      	ldr	r3, [sp, #4]
 8005d1e:	2200      	movs	r2, #0
 8005d20:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 8005d24:	f640 0308 	movw	r3, #2056	; 0x808
 8005d28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d2c:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8005d2e:	9b03      	ldr	r3, [sp, #12]
 8005d30:	681b      	ldr	r3, [r3, #0]
 8005d32:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8005d34:	9b03      	ldr	r3, [sp, #12]
 8005d36:	689a      	ldr	r2, [r3, #8]
 8005d38:	9b01      	ldr	r3, [sp, #4]
 8005d3a:	689b      	ldr	r3, [r3, #8]
 8005d3c:	429a      	cmp	r2, r3
 8005d3e:	d2f6      	bcs.n	8005d2e <chSchReadyI+0x4e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8005d40:	9b01      	ldr	r3, [sp, #4]
 8005d42:	9a03      	ldr	r2, [sp, #12]
 8005d44:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8005d46:	9b03      	ldr	r3, [sp, #12]
 8005d48:	685a      	ldr	r2, [r3, #4]
 8005d4a:	9b01      	ldr	r3, [sp, #4]
 8005d4c:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8005d4e:	9b01      	ldr	r3, [sp, #4]
 8005d50:	685b      	ldr	r3, [r3, #4]
 8005d52:	9a01      	ldr	r2, [sp, #4]
 8005d54:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8005d56:	9b03      	ldr	r3, [sp, #12]
 8005d58:	9a01      	ldr	r2, [sp, #4]
 8005d5a:	605a      	str	r2, [r3, #4]

  return tp;
 8005d5c:	9b01      	ldr	r3, [sp, #4]
}
 8005d5e:	4618      	mov	r0, r3
 8005d60:	b005      	add	sp, #20
 8005d62:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d66:	bf00      	nop
 8005d68:	f3af 8000 	nop.w
 8005d6c:	f3af 8000 	nop.w

08005d70 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8005d70:	b510      	push	{r4, lr}
 8005d72:	b084      	sub	sp, #16
 8005d74:	4603      	mov	r3, r0
 8005d76:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();
 8005d7a:	f7ff fcd9 	bl	8005730 <chDbgCheckClassS>

  otp = currp;
 8005d7e:	f640 0308 	movw	r3, #2056	; 0x808
 8005d82:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005d86:	699b      	ldr	r3, [r3, #24]
 8005d88:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8005d8a:	9b03      	ldr	r3, [sp, #12]
 8005d8c:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8005d90:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8005d94:	f640 0008 	movw	r0, #2056	; 0x808
 8005d98:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8005d9c:	f7ff ff10 	bl	8005bc0 <queue_fifo_remove.5124.4363>
 8005da0:	4602      	mov	r2, r0
 8005da2:	f640 0308 	movw	r3, #2056	; 0x808
 8005da6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005daa:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8005dac:	f640 0308 	movw	r3, #2056	; 0x808
 8005db0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005db4:	699b      	ldr	r3, [r3, #24]
 8005db6:	2201      	movs	r2, #1
 8005db8:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
 8005dbc:	9803      	ldr	r0, [sp, #12]
 8005dbe:	f7ff fcdf 	bl	8005780 <_dbg_trace.4403>
 8005dc2:	f640 0308 	movw	r3, #2056	; 0x808
 8005dc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005dca:	699b      	ldr	r3, [r3, #24]
 8005dcc:	4618      	mov	r0, r3
 8005dce:	9903      	ldr	r1, [sp, #12]
 8005dd0:	f000 fd96 	bl	8006900 <_stats_ctxswc.4028>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8005dd4:	f3ef 8309 	mrs	r3, PSP
 8005dd8:	461c      	mov	r4, r3
  return(result);
 8005dda:	4623      	mov	r3, r4
 8005ddc:	9302      	str	r3, [sp, #8]
 8005dde:	9b02      	ldr	r3, [sp, #8]
 8005de0:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8005de4:	9b03      	ldr	r3, [sp, #12]
 8005de6:	69db      	ldr	r3, [r3, #28]
 8005de8:	429a      	cmp	r2, r3
 8005dea:	d205      	bcs.n	8005df8 <chSchGoSleepS+0x88>
 8005dec:	f247 40a0 	movw	r0, #29856	; 0x74a0
 8005df0:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005df4:	f7ff fb1c 	bl	8005430 <chSysHalt>
 8005df8:	f640 0308 	movw	r3, #2056	; 0x808
 8005dfc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005e00:	699b      	ldr	r3, [r3, #24]
 8005e02:	4618      	mov	r0, r3
 8005e04:	9903      	ldr	r1, [sp, #12]
 8005e06:	f7fa fa63 	bl	80002d0 <_port_switch>
}
 8005e0a:	b004      	add	sp, #16
 8005e0c:	bd10      	pop	{r4, pc}
 8005e0e:	bf00      	nop

08005e10 <wakeup.5158.4327>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8005e10:	b500      	push	{lr}
 8005e12:	b085      	sub	sp, #20
 8005e14:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8005e16:	9b01      	ldr	r3, [sp, #4]
 8005e18:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8005e1a:	f7ff ff11 	bl	8005c40 <chSysLockFromISR.5149.4356>
  switch (tp->p_state) {
 8005e1e:	9b03      	ldr	r3, [sp, #12]
 8005e20:	f893 3020 	ldrb.w	r3, [r3, #32]
 8005e24:	2b07      	cmp	r3, #7
 8005e26:	d823      	bhi.n	8005e70 <wakeup.5158.4327+0x60>
 8005e28:	a201      	add	r2, pc, #4	; (adr r2, 8005e30 <wakeup.5158.4327+0x20>)
 8005e2a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005e2e:	bf00      	nop
 8005e30:	08005e51 	.word	0x08005e51
 8005e34:	08005e71 	.word	0x08005e71
 8005e38:	08005e71 	.word	0x08005e71
 8005e3c:	08005e57 	.word	0x08005e57
 8005e40:	08005e6b 	.word	0x08005e6b
 8005e44:	08005e61 	.word	0x08005e61
 8005e48:	08005e71 	.word	0x08005e71
 8005e4c:	08005e6b 	.word	0x08005e6b
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8005e50:	f7ff fefe 	bl	8005c50 <chSysUnlockFromISR.5151.4354>
 8005e54:	e015      	b.n	8005e82 <wakeup.5158.4327+0x72>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8005e56:	9b03      	ldr	r3, [sp, #12]
 8005e58:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005e5a:	2200      	movs	r2, #0
 8005e5c:	601a      	str	r2, [r3, #0]
 8005e5e:	e007      	b.n	8005e70 <wakeup.5158.4327+0x60>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8005e60:	9b03      	ldr	r3, [sp, #12]
 8005e62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005e64:	4618      	mov	r0, r3
 8005e66:	f7ff ff0b 	bl	8005c80 <chSemFastSignalI.5130.4338>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8005e6a:	9803      	ldr	r0, [sp, #12]
 8005e6c:	f7ff fec0 	bl	8005bf0 <queue_dequeue.5127.4360>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8005e70:	9b03      	ldr	r3, [sp, #12]
 8005e72:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005e76:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8005e78:	9803      	ldr	r0, [sp, #12]
 8005e7a:	f7ff ff31 	bl	8005ce0 <chSchReadyI>
  chSysUnlockFromISR();
 8005e7e:	f7ff fee7 	bl	8005c50 <chSysUnlockFromISR.5151.4354>
}
 8005e82:	b005      	add	sp, #20
 8005e84:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e88:	f3af 8000 	nop.w
 8005e8c:	f3af 8000 	nop.w

08005e90 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8005e90:	b500      	push	{lr}
 8005e92:	b089      	sub	sp, #36	; 0x24
 8005e94:	4603      	mov	r3, r0
 8005e96:	9100      	str	r1, [sp, #0]
 8005e98:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
 8005e9c:	f7ff fc48 	bl	8005730 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 8005ea0:	9b00      	ldr	r3, [sp, #0]
 8005ea2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8005ea6:	d01e      	beq.n	8005ee6 <chSchGoSleepTimeoutS+0x56>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8005ea8:	f640 0308 	movw	r3, #2056	; 0x808
 8005eac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005eb0:	699b      	ldr	r3, [r3, #24]
 8005eb2:	aa03      	add	r2, sp, #12
 8005eb4:	4610      	mov	r0, r2
 8005eb6:	9900      	ldr	r1, [sp, #0]
 8005eb8:	f645 6211 	movw	r2, #24081	; 0x5e11
 8005ebc:	f6c0 0200 	movt	r2, #2048	; 0x800
 8005ec0:	f7ff fd06 	bl	80058d0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8005ec4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005ec8:	4618      	mov	r0, r3
 8005eca:	f7ff ff51 	bl	8005d70 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8005ece:	ab03      	add	r3, sp, #12
 8005ed0:	4618      	mov	r0, r3
 8005ed2:	f7ff fec5 	bl	8005c60 <chVTIsArmedI.5134.4343>
 8005ed6:	4603      	mov	r3, r0
 8005ed8:	2b00      	cmp	r3, #0
 8005eda:	d009      	beq.n	8005ef0 <chSchGoSleepTimeoutS+0x60>
      chVTDoResetI(&vt);
 8005edc:	ab03      	add	r3, sp, #12
 8005ede:	4618      	mov	r0, r3
 8005ee0:	f7ff fd9e 	bl	8005a20 <chVTDoResetI>
 8005ee4:	e004      	b.n	8005ef0 <chSchGoSleepTimeoutS+0x60>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8005ee6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8005eea:	4618      	mov	r0, r3
 8005eec:	f7ff ff40 	bl	8005d70 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8005ef0:	f640 0308 	movw	r3, #2056	; 0x808
 8005ef4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005ef8:	699b      	ldr	r3, [r3, #24]
 8005efa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8005efc:	4618      	mov	r0, r3
 8005efe:	b009      	add	sp, #36	; 0x24
 8005f00:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f04:	f3af 8000 	nop.w
 8005f08:	f3af 8000 	nop.w
 8005f0c:	f3af 8000 	nop.w

08005f10 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8005f10:	b510      	push	{r4, lr}
 8005f12:	b084      	sub	sp, #16
 8005f14:	9001      	str	r0, [sp, #4]
 8005f16:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 8005f18:	f7ff fc0a 	bl	8005730 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005f1c:	f640 0308 	movw	r3, #2056	; 0x808
 8005f20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f24:	681a      	ldr	r2, [r3, #0]
 8005f26:	f640 0308 	movw	r3, #2056	; 0x808
 8005f2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f2e:	429a      	cmp	r2, r3
 8005f30:	d013      	beq.n	8005f5a <chSchWakeupS+0x4a>
 8005f32:	f640 0308 	movw	r3, #2056	; 0x808
 8005f36:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f3a:	699b      	ldr	r3, [r3, #24]
 8005f3c:	689a      	ldr	r2, [r3, #8]
 8005f3e:	f640 0308 	movw	r3, #2056	; 0x808
 8005f42:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f46:	681b      	ldr	r3, [r3, #0]
 8005f48:	689b      	ldr	r3, [r3, #8]
 8005f4a:	429a      	cmp	r2, r3
 8005f4c:	d205      	bcs.n	8005f5a <chSchWakeupS+0x4a>
 8005f4e:	f247 5070 	movw	r0, #30064	; 0x7570
 8005f52:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005f56:	f7ff fa6b 	bl	8005430 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8005f5a:	9b01      	ldr	r3, [sp, #4]
 8005f5c:	9a00      	ldr	r2, [sp, #0]
 8005f5e:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8005f60:	9b01      	ldr	r3, [sp, #4]
 8005f62:	689a      	ldr	r2, [r3, #8]
 8005f64:	f640 0308 	movw	r3, #2056	; 0x808
 8005f68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f6c:	699b      	ldr	r3, [r3, #24]
 8005f6e:	689b      	ldr	r3, [r3, #8]
 8005f70:	429a      	cmp	r2, r3
 8005f72:	d803      	bhi.n	8005f7c <chSchWakeupS+0x6c>
    (void) chSchReadyI(ntp);
 8005f74:	9801      	ldr	r0, [sp, #4]
 8005f76:	f7ff feb3 	bl	8005ce0 <chSchReadyI>
 8005f7a:	e02f      	b.n	8005fdc <chSchWakeupS+0xcc>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8005f7c:	f640 0308 	movw	r3, #2056	; 0x808
 8005f80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f84:	699b      	ldr	r3, [r3, #24]
 8005f86:	4618      	mov	r0, r3
 8005f88:	f7ff feaa 	bl	8005ce0 <chSchReadyI>
 8005f8c:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 8005f8e:	f640 0308 	movw	r3, #2056	; 0x808
 8005f92:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8005f96:	9a01      	ldr	r2, [sp, #4]
 8005f98:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8005f9a:	9b01      	ldr	r3, [sp, #4]
 8005f9c:	2201      	movs	r2, #1
 8005f9e:	f883 2020 	strb.w	r2, [r3, #32]
    chSysSwitch(ntp, otp);
 8005fa2:	9803      	ldr	r0, [sp, #12]
 8005fa4:	f7ff fbec 	bl	8005780 <_dbg_trace.4403>
 8005fa8:	9801      	ldr	r0, [sp, #4]
 8005faa:	9903      	ldr	r1, [sp, #12]
 8005fac:	f000 fca8 	bl	8006900 <_stats_ctxswc.4028>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8005fb0:	f3ef 8309 	mrs	r3, PSP
 8005fb4:	461c      	mov	r4, r3
  return(result);
 8005fb6:	4623      	mov	r3, r4
 8005fb8:	9302      	str	r3, [sp, #8]
 8005fba:	9b02      	ldr	r3, [sp, #8]
 8005fbc:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8005fc0:	9b03      	ldr	r3, [sp, #12]
 8005fc2:	69db      	ldr	r3, [r3, #28]
 8005fc4:	429a      	cmp	r2, r3
 8005fc6:	d205      	bcs.n	8005fd4 <chSchWakeupS+0xc4>
 8005fc8:	f247 40a0 	movw	r0, #29856	; 0x74a0
 8005fcc:	f6c0 0000 	movt	r0, #2048	; 0x800
 8005fd0:	f7ff fa2e 	bl	8005430 <chSysHalt>
 8005fd4:	9801      	ldr	r0, [sp, #4]
 8005fd6:	9903      	ldr	r1, [sp, #12]
 8005fd8:	f7fa f97a 	bl	80002d0 <_port_switch>
  }
}
 8005fdc:	b004      	add	sp, #16
 8005fde:	bd10      	pop	{r4, pc}

08005fe0 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8005fe0:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 8005fe2:	f7ff fba5 	bl	8005730 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 8005fe6:	f7ff fe13 	bl	8005c10 <chSchIsRescRequiredI.5147.4358>
 8005fea:	4603      	mov	r3, r0
 8005fec:	2b00      	cmp	r3, #0
 8005fee:	d001      	beq.n	8005ff4 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
 8005ff0:	f000 f826 	bl	8006040 <chSchDoRescheduleAhead.4311>
  }
}
 8005ff4:	bd08      	pop	{r3, pc}
 8005ff6:	bf00      	nop
 8005ff8:	f3af 8000 	nop.w
 8005ffc:	f3af 8000 	nop.w

08006000 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8006000:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8006002:	f640 0308 	movw	r3, #2056	; 0x808
 8006006:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800600a:	681b      	ldr	r3, [r3, #0]
 800600c:	689b      	ldr	r3, [r3, #8]
 800600e:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8006010:	f640 0308 	movw	r3, #2056	; 0x808
 8006014:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006018:	699b      	ldr	r3, [r3, #24]
 800601a:	689b      	ldr	r3, [r3, #8]
 800601c:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800601e:	9a01      	ldr	r2, [sp, #4]
 8006020:	9b00      	ldr	r3, [sp, #0]
 8006022:	429a      	cmp	r2, r3
 8006024:	bf94      	ite	ls
 8006026:	2300      	movls	r3, #0
 8006028:	2301      	movhi	r3, #1
 800602a:	b2db      	uxtb	r3, r3
#endif
}
 800602c:	4618      	mov	r0, r3
 800602e:	b002      	add	sp, #8
 8006030:	4770      	bx	lr
 8006032:	bf00      	nop
 8006034:	f3af 8000 	nop.w
 8006038:	f3af 8000 	nop.w
 800603c:	f3af 8000 	nop.w

08006040 <chSchDoRescheduleAhead.4311>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8006040:	b510      	push	{r4, lr}
 8006042:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
 8006044:	f640 0308 	movw	r3, #2056	; 0x808
 8006048:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800604c:	699b      	ldr	r3, [r3, #24]
 800604e:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8006050:	f640 0008 	movw	r0, #2056	; 0x808
 8006054:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8006058:	f7ff fdb2 	bl	8005bc0 <queue_fifo_remove.5124.4363>
 800605c:	4602      	mov	r2, r0
 800605e:	f640 0308 	movw	r3, #2056	; 0x808
 8006062:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006066:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8006068:	f640 0308 	movw	r3, #2056	; 0x808
 800606c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006070:	699b      	ldr	r3, [r3, #24]
 8006072:	2201      	movs	r2, #1
 8006074:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
 8006078:	9b02      	ldr	r3, [sp, #8]
 800607a:	2200      	movs	r2, #0
 800607c:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 8006080:	f640 0308 	movw	r3, #2056	; 0x808
 8006084:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006088:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800608a:	9b03      	ldr	r3, [sp, #12]
 800608c:	681b      	ldr	r3, [r3, #0]
 800608e:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
 8006090:	9b03      	ldr	r3, [sp, #12]
 8006092:	689a      	ldr	r2, [r3, #8]
 8006094:	9b02      	ldr	r3, [sp, #8]
 8006096:	689b      	ldr	r3, [r3, #8]
 8006098:	429a      	cmp	r2, r3
 800609a:	d8f6      	bhi.n	800608a <chSchDoRescheduleAhead.4311+0x4a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 800609c:	9b02      	ldr	r3, [sp, #8]
 800609e:	9a03      	ldr	r2, [sp, #12]
 80060a0:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 80060a2:	9b03      	ldr	r3, [sp, #12]
 80060a4:	685a      	ldr	r2, [r3, #4]
 80060a6:	9b02      	ldr	r3, [sp, #8]
 80060a8:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 80060aa:	9b02      	ldr	r3, [sp, #8]
 80060ac:	685b      	ldr	r3, [r3, #4]
 80060ae:	9a02      	ldr	r2, [sp, #8]
 80060b0:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 80060b2:	9b03      	ldr	r3, [sp, #12]
 80060b4:	9a02      	ldr	r2, [sp, #8]
 80060b6:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 80060b8:	9802      	ldr	r0, [sp, #8]
 80060ba:	f7ff fb61 	bl	8005780 <_dbg_trace.4403>
 80060be:	f640 0308 	movw	r3, #2056	; 0x808
 80060c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060c6:	699b      	ldr	r3, [r3, #24]
 80060c8:	4618      	mov	r0, r3
 80060ca:	9902      	ldr	r1, [sp, #8]
 80060cc:	f000 fc18 	bl	8006900 <_stats_ctxswc.4028>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80060d0:	f3ef 8309 	mrs	r3, PSP
 80060d4:	461c      	mov	r4, r3
  return(result);
 80060d6:	4623      	mov	r3, r4
 80060d8:	9301      	str	r3, [sp, #4]
 80060da:	9b01      	ldr	r3, [sp, #4]
 80060dc:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 80060e0:	9b02      	ldr	r3, [sp, #8]
 80060e2:	69db      	ldr	r3, [r3, #28]
 80060e4:	429a      	cmp	r2, r3
 80060e6:	d205      	bcs.n	80060f4 <chSchDoRescheduleAhead.4311+0xb4>
 80060e8:	f247 40a0 	movw	r0, #29856	; 0x74a0
 80060ec:	f6c0 0000 	movt	r0, #2048	; 0x800
 80060f0:	f7ff f99e 	bl	8005430 <chSysHalt>
 80060f4:	f640 0308 	movw	r3, #2056	; 0x808
 80060f8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80060fc:	699b      	ldr	r3, [r3, #24]
 80060fe:	4618      	mov	r0, r3
 8006100:	9902      	ldr	r1, [sp, #8]
 8006102:	f7fa f8e5 	bl	80002d0 <_port_switch>
}
 8006106:	b004      	add	sp, #16
 8006108:	bd10      	pop	{r4, pc}
 800610a:	bf00      	nop
 800610c:	f3af 8000 	nop.w

08006110 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8006110:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8006112:	f7ff ff95 	bl	8006040 <chSchDoRescheduleAhead.4311>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8006116:	bd08      	pop	{r3, pc}
 8006118:	f3af 8000 	nop.w
 800611c:	f3af 8000 	nop.w

08006120 <port_lock.5268.4306>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006120:	b082      	sub	sp, #8
 8006122:	2320      	movs	r3, #32
 8006124:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8006126:	9b01      	ldr	r3, [sp, #4]
 8006128:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800612c:	b002      	add	sp, #8
 800612e:	4770      	bx	lr

08006130 <port_unlock.5271.4304>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006130:	b082      	sub	sp, #8
 8006132:	2300      	movs	r3, #0
 8006134:	9301      	str	r3, [sp, #4]
 8006136:	9b01      	ldr	r3, [sp, #4]
 8006138:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800613c:	b002      	add	sp, #8
 800613e:	4770      	bx	lr

08006140 <list_init.5280.4297>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8006140:	b082      	sub	sp, #8
 8006142:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8006144:	9b01      	ldr	r3, [sp, #4]
 8006146:	9a01      	ldr	r2, [sp, #4]
 8006148:	601a      	str	r2, [r3, #0]
}
 800614a:	b002      	add	sp, #8
 800614c:	4770      	bx	lr
 800614e:	bf00      	nop

08006150 <list_notempty.5367.4294>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8006150:	b082      	sub	sp, #8
 8006152:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8006154:	9b01      	ldr	r3, [sp, #4]
 8006156:	681a      	ldr	r2, [r3, #0]
 8006158:	9b01      	ldr	r3, [sp, #4]
 800615a:	429a      	cmp	r2, r3
 800615c:	bf0c      	ite	eq
 800615e:	2300      	moveq	r3, #0
 8006160:	2301      	movne	r3, #1
 8006162:	b2db      	uxtb	r3, r3
}
 8006164:	4618      	mov	r0, r3
 8006166:	b002      	add	sp, #8
 8006168:	4770      	bx	lr
 800616a:	bf00      	nop
 800616c:	f3af 8000 	nop.w

08006170 <queue_init.5371.4291>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8006170:	b082      	sub	sp, #8
 8006172:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8006174:	9b01      	ldr	r3, [sp, #4]
 8006176:	9a01      	ldr	r2, [sp, #4]
 8006178:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800617a:	9b01      	ldr	r3, [sp, #4]
 800617c:	9a01      	ldr	r2, [sp, #4]
 800617e:	605a      	str	r2, [r3, #4]
}
 8006180:	b002      	add	sp, #8
 8006182:	4770      	bx	lr
 8006184:	f3af 8000 	nop.w
 8006188:	f3af 8000 	nop.w
 800618c:	f3af 8000 	nop.w

08006190 <queue_notempty.5374.4287>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8006190:	b082      	sub	sp, #8
 8006192:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8006194:	9b01      	ldr	r3, [sp, #4]
 8006196:	681a      	ldr	r2, [r3, #0]
 8006198:	9b01      	ldr	r3, [sp, #4]
 800619a:	429a      	cmp	r2, r3
 800619c:	bf0c      	ite	eq
 800619e:	2300      	moveq	r3, #0
 80061a0:	2301      	movne	r3, #1
 80061a2:	b2db      	uxtb	r3, r3
}
 80061a4:	4618      	mov	r0, r3
 80061a6:	b002      	add	sp, #8
 80061a8:	4770      	bx	lr
 80061aa:	bf00      	nop
 80061ac:	f3af 8000 	nop.w

080061b0 <list_remove.5381.4280>:

  tp->p_next = tlp->p_next;
  tlp->p_next = tp;
}

static inline thread_t *list_remove(threads_list_t *tlp) {
 80061b0:	b084      	sub	sp, #16
 80061b2:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 80061b4:	9b01      	ldr	r3, [sp, #4]
 80061b6:	681b      	ldr	r3, [r3, #0]
 80061b8:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 80061ba:	9b03      	ldr	r3, [sp, #12]
 80061bc:	681a      	ldr	r2, [r3, #0]
 80061be:	9b01      	ldr	r3, [sp, #4]
 80061c0:	601a      	str	r2, [r3, #0]

  return tp;
 80061c2:	9b03      	ldr	r3, [sp, #12]
}
 80061c4:	4618      	mov	r0, r3
 80061c6:	b004      	add	sp, #16
 80061c8:	4770      	bx	lr
 80061ca:	bf00      	nop
 80061cc:	f3af 8000 	nop.w

080061d0 <queue_insert.5384.4276>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 80061d0:	b082      	sub	sp, #8
 80061d2:	9001      	str	r0, [sp, #4]
 80061d4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 80061d6:	9b01      	ldr	r3, [sp, #4]
 80061d8:	9a00      	ldr	r2, [sp, #0]
 80061da:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 80061dc:	9b00      	ldr	r3, [sp, #0]
 80061de:	685a      	ldr	r2, [r3, #4]
 80061e0:	9b01      	ldr	r3, [sp, #4]
 80061e2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80061e4:	9b01      	ldr	r3, [sp, #4]
 80061e6:	685b      	ldr	r3, [r3, #4]
 80061e8:	9a01      	ldr	r2, [sp, #4]
 80061ea:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 80061ec:	9b00      	ldr	r3, [sp, #0]
 80061ee:	9a01      	ldr	r2, [sp, #4]
 80061f0:	605a      	str	r2, [r3, #4]
}
 80061f2:	b002      	add	sp, #8
 80061f4:	4770      	bx	lr
 80061f6:	bf00      	nop
 80061f8:	f3af 8000 	nop.w
 80061fc:	f3af 8000 	nop.w

08006200 <queue_fifo_remove.5388.4273>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8006200:	b084      	sub	sp, #16
 8006202:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8006204:	9b01      	ldr	r3, [sp, #4]
 8006206:	681b      	ldr	r3, [r3, #0]
 8006208:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800620a:	9b03      	ldr	r3, [sp, #12]
 800620c:	681a      	ldr	r2, [r3, #0]
 800620e:	9b01      	ldr	r3, [sp, #4]
 8006210:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8006212:	9b01      	ldr	r3, [sp, #4]
 8006214:	681b      	ldr	r3, [r3, #0]
 8006216:	9a01      	ldr	r2, [sp, #4]
 8006218:	605a      	str	r2, [r3, #4]

  return tp;
 800621a:	9b03      	ldr	r3, [sp, #12]
}
 800621c:	4618      	mov	r0, r3
 800621e:	b004      	add	sp, #16
 8006220:	4770      	bx	lr
 8006222:	bf00      	nop
 8006224:	f3af 8000 	nop.w
 8006228:	f3af 8000 	nop.w
 800622c:	f3af 8000 	nop.w

08006230 <chSysLock.5400.4267>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006230:	b508      	push	{r3, lr}

  port_lock();
 8006232:	f7ff ff75 	bl	8006120 <port_lock.5268.4306>
  _stats_start_measure_crit_thd();
 8006236:	f000 fb83 	bl	8006940 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800623a:	f7ff f991 	bl	8005560 <_dbg_check_lock>
}
 800623e:	bd08      	pop	{r3, pc}

08006240 <chSysUnlock.5402.4265>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8006240:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8006242:	f7ff f9ad 	bl	80055a0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8006246:	f000 fb83 	bl	8006950 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800624a:	f640 0308 	movw	r3, #2056	; 0x808
 800624e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006252:	681a      	ldr	r2, [r3, #0]
 8006254:	f640 0308 	movw	r3, #2056	; 0x808
 8006258:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800625c:	429a      	cmp	r2, r3
 800625e:	d013      	beq.n	8006288 <chSysUnlock.5402.4265+0x48>
 8006260:	f640 0308 	movw	r3, #2056	; 0x808
 8006264:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006268:	699b      	ldr	r3, [r3, #24]
 800626a:	689a      	ldr	r2, [r3, #8]
 800626c:	f640 0308 	movw	r3, #2056	; 0x808
 8006270:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006274:	681b      	ldr	r3, [r3, #0]
 8006276:	689b      	ldr	r3, [r3, #8]
 8006278:	429a      	cmp	r2, r3
 800627a:	d205      	bcs.n	8006288 <chSysUnlock.5402.4265+0x48>
 800627c:	f247 5090 	movw	r0, #30096	; 0x7590
 8006280:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006284:	f7ff f8d4 	bl	8005430 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8006288:	f7ff ff52 	bl	8006130 <port_unlock.5271.4304>
}
 800628c:	bd08      	pop	{r3, pc}
 800628e:	bf00      	nop

08006290 <chThdGetSelfX.5398.4255>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006290:	f640 0308 	movw	r3, #2056	; 0x808
 8006294:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006298:	699b      	ldr	r3, [r3, #24]
}
 800629a:	4618      	mov	r0, r3
 800629c:	4770      	bx	lr
 800629e:	bf00      	nop

080062a0 <chThdSleepS.5411.4249>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 80062a0:	b500      	push	{lr}
 80062a2:	b083      	sub	sp, #12
 80062a4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
 80062a6:	9b01      	ldr	r3, [sp, #4]
 80062a8:	2b00      	cmp	r3, #0
 80062aa:	d105      	bne.n	80062b8 <chThdSleepS.5411.4249+0x18>
 80062ac:	f247 50a0 	movw	r0, #30112	; 0x75a0
 80062b0:	f6c0 0000 	movt	r0, #2048	; 0x800
 80062b4:	f7ff f8bc 	bl	8005430 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80062b8:	2008      	movs	r0, #8
 80062ba:	9901      	ldr	r1, [sp, #4]
 80062bc:	f7ff fde8 	bl	8005e90 <chSchGoSleepTimeoutS>
}
 80062c0:	b003      	add	sp, #12
 80062c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80062c6:	bf00      	nop
 80062c8:	f3af 8000 	nop.w
 80062cc:	f3af 8000 	nop.w

080062d0 <chThdDoDequeueNextI.5407.4245>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80062d0:	b500      	push	{lr}
 80062d2:	b085      	sub	sp, #20
 80062d4:	9001      	str	r0, [sp, #4]
 80062d6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 80062d8:	9801      	ldr	r0, [sp, #4]
 80062da:	f7ff ff59 	bl	8006190 <queue_notempty.5374.4287>
 80062de:	4603      	mov	r3, r0
 80062e0:	f083 0301 	eor.w	r3, r3, #1
 80062e4:	b2db      	uxtb	r3, r3
 80062e6:	2b00      	cmp	r3, #0
 80062e8:	d005      	beq.n	80062f6 <chThdDoDequeueNextI.5407.4245+0x26>
 80062ea:	f247 50e0 	movw	r0, #30176	; 0x75e0
 80062ee:	f6c0 0000 	movt	r0, #2048	; 0x800
 80062f2:	f7ff f89d 	bl	8005430 <chSysHalt>

  tp = queue_fifo_remove(tqp);
 80062f6:	9801      	ldr	r0, [sp, #4]
 80062f8:	f7ff ff82 	bl	8006200 <queue_fifo_remove.5388.4273>
 80062fc:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 80062fe:	9b03      	ldr	r3, [sp, #12]
 8006300:	f893 3020 	ldrb.w	r3, [r3, #32]
 8006304:	2b04      	cmp	r3, #4
 8006306:	d005      	beq.n	8006314 <chThdDoDequeueNextI.5407.4245+0x44>
 8006308:	f247 50e0 	movw	r0, #30176	; 0x75e0
 800630c:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006310:	f7ff f88e 	bl	8005430 <chSysHalt>

  tp->p_u.rdymsg = msg;
 8006314:	9b03      	ldr	r3, [sp, #12]
 8006316:	9a00      	ldr	r2, [sp, #0]
 8006318:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800631a:	9803      	ldr	r0, [sp, #12]
 800631c:	f7ff fce0 	bl	8005ce0 <chSchReadyI>
}
 8006320:	b005      	add	sp, #20
 8006322:	f85d fb04 	ldr.w	pc, [sp], #4
 8006326:	bf00      	nop
 8006328:	f3af 8000 	nop.w
 800632c:	f3af 8000 	nop.w

08006330 <_thread_init.4241>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8006330:	b500      	push	{lr}
 8006332:	b083      	sub	sp, #12
 8006334:	9001      	str	r0, [sp, #4]
 8006336:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8006338:	9b01      	ldr	r3, [sp, #4]
 800633a:	9a00      	ldr	r2, [sp, #0]
 800633c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 800633e:	9b01      	ldr	r3, [sp, #4]
 8006340:	2202      	movs	r2, #2
 8006342:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8006346:	9b01      	ldr	r3, [sp, #4]
 8006348:	2200      	movs	r2, #0
 800634a:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800634e:	9b01      	ldr	r3, [sp, #4]
 8006350:	9a00      	ldr	r2, [sp, #0]
 8006352:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
 8006354:	9b01      	ldr	r3, [sp, #4]
 8006356:	2200      	movs	r2, #0
 8006358:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800635a:	9b01      	ldr	r3, [sp, #4]
 800635c:	2200      	movs	r2, #0
 800635e:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8006360:	9b01      	ldr	r3, [sp, #4]
 8006362:	2201      	movs	r2, #1
 8006364:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8006368:	9b01      	ldr	r3, [sp, #4]
 800636a:	2200      	movs	r2, #0
 800636c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800636e:	9a01      	ldr	r2, [sp, #4]
 8006370:	f640 0308 	movw	r3, #2056	; 0x808
 8006374:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006378:	6113      	str	r3, [r2, #16]
 800637a:	f640 0308 	movw	r3, #2056	; 0x808
 800637e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006382:	695a      	ldr	r2, [r3, #20]
 8006384:	9b01      	ldr	r3, [sp, #4]
 8006386:	615a      	str	r2, [r3, #20]
 8006388:	9b01      	ldr	r3, [sp, #4]
 800638a:	695b      	ldr	r3, [r3, #20]
 800638c:	9a01      	ldr	r2, [sp, #4]
 800638e:	611a      	str	r2, [r3, #16]
 8006390:	f640 0308 	movw	r3, #2056	; 0x808
 8006394:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006398:	9a01      	ldr	r2, [sp, #4]
 800639a:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800639c:	9b01      	ldr	r3, [sp, #4]
 800639e:	3328      	adds	r3, #40	; 0x28
 80063a0:	4618      	mov	r0, r3
 80063a2:	f7ff fecd 	bl	8006140 <list_init.5280.4297>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80063a6:	9b01      	ldr	r3, [sp, #4]
 80063a8:	332c      	adds	r3, #44	; 0x2c
 80063aa:	4618      	mov	r0, r3
 80063ac:	f7ff fee0 	bl	8006170 <queue_init.5371.4291>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 80063b0:	9b01      	ldr	r3, [sp, #4]
 80063b2:	f103 0260 	add.w	r2, r3, #96	; 0x60
 80063b6:	9b01      	ldr	r3, [sp, #4]
 80063b8:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->p_stats);
 80063ba:	9b01      	ldr	r3, [sp, #4]
 80063bc:	3348      	adds	r3, #72	; 0x48
 80063be:	4618      	mov	r0, r3
 80063c0:	f000 f9ee 	bl	80067a0 <chTMObjectInit.4144>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 80063c4:	9b01      	ldr	r3, [sp, #4]
}
 80063c6:	4618      	mov	r0, r3
 80063c8:	b003      	add	sp, #12
 80063ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80063ce:	bf00      	nop

080063d0 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 80063d0:	b084      	sub	sp, #16
 80063d2:	9003      	str	r0, [sp, #12]
 80063d4:	9102      	str	r1, [sp, #8]
 80063d6:	4613      	mov	r3, r2
 80063d8:	f88d 3007 	strb.w	r3, [sp, #7]
 80063dc:	e005      	b.n	80063ea <_thread_memfill+0x1a>

  while (startp < endp) {
    *startp++ = v;
 80063de:	9b03      	ldr	r3, [sp, #12]
 80063e0:	1c5a      	adds	r2, r3, #1
 80063e2:	9203      	str	r2, [sp, #12]
 80063e4:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80063e8:	701a      	strb	r2, [r3, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80063ea:	9a03      	ldr	r2, [sp, #12]
 80063ec:	9b02      	ldr	r3, [sp, #8]
 80063ee:	429a      	cmp	r2, r3
 80063f0:	d3f5      	bcc.n	80063de <_thread_memfill+0xe>
    *startp++ = v;
  }
}
 80063f2:	b004      	add	sp, #16
 80063f4:	4770      	bx	lr
 80063f6:	bf00      	nop
 80063f8:	f3af 8000 	nop.w
 80063fc:	f3af 8000 	nop.w

08006400 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8006400:	b500      	push	{lr}
 8006402:	b087      	sub	sp, #28
 8006404:	9003      	str	r0, [sp, #12]
 8006406:	9102      	str	r1, [sp, #8]
 8006408:	9201      	str	r2, [sp, #4]
 800640a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 800640c:	9b03      	ldr	r3, [sp, #12]
 800640e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8006410:	f7ff f976 	bl	8005700 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 8006414:	9b03      	ldr	r3, [sp, #12]
 8006416:	2b00      	cmp	r3, #0
 8006418:	d008      	beq.n	800642c <chThdCreateI+0x2c>
 800641a:	9b02      	ldr	r3, [sp, #8]
 800641c:	2be7      	cmp	r3, #231	; 0xe7
 800641e:	d905      	bls.n	800642c <chThdCreateI+0x2c>
 8006420:	9b01      	ldr	r3, [sp, #4]
 8006422:	2b7f      	cmp	r3, #127	; 0x7f
 8006424:	d802      	bhi.n	800642c <chThdCreateI+0x2c>
 8006426:	9b00      	ldr	r3, [sp, #0]
 8006428:	2b00      	cmp	r3, #0
 800642a:	d105      	bne.n	8006438 <chThdCreateI+0x38>
 800642c:	f247 5080 	movw	r0, #30080	; 0x7580
 8006430:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006434:	f7fe fffc 	bl	8005430 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8006438:	9b02      	ldr	r3, [sp, #8]
 800643a:	3b24      	subs	r3, #36	; 0x24
 800643c:	9a03      	ldr	r2, [sp, #12]
 800643e:	441a      	add	r2, r3
 8006440:	9b05      	ldr	r3, [sp, #20]
 8006442:	60da      	str	r2, [r3, #12]
 8006444:	9b05      	ldr	r3, [sp, #20]
 8006446:	68db      	ldr	r3, [r3, #12]
 8006448:	9a00      	ldr	r2, [sp, #0]
 800644a:	601a      	str	r2, [r3, #0]
 800644c:	9b05      	ldr	r3, [sp, #20]
 800644e:	68db      	ldr	r3, [r3, #12]
 8006450:	9a08      	ldr	r2, [sp, #32]
 8006452:	605a      	str	r2, [r3, #4]
 8006454:	9b05      	ldr	r3, [sp, #20]
 8006456:	68da      	ldr	r2, [r3, #12]
 8006458:	f240 23e1 	movw	r3, #737	; 0x2e1
 800645c:	f6c0 0300 	movt	r3, #2048	; 0x800
 8006460:	6213      	str	r3, [r2, #32]

  return _thread_init(tp, prio);
 8006462:	9805      	ldr	r0, [sp, #20]
 8006464:	9901      	ldr	r1, [sp, #4]
 8006466:	f7ff ff63 	bl	8006330 <_thread_init.4241>
 800646a:	4603      	mov	r3, r0
}
 800646c:	4618      	mov	r0, r3
 800646e:	b007      	add	sp, #28
 8006470:	f85d fb04 	ldr.w	pc, [sp], #4
 8006474:	f3af 8000 	nop.w
 8006478:	f3af 8000 	nop.w
 800647c:	f3af 8000 	nop.w

08006480 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8006480:	b500      	push	{lr}
 8006482:	b089      	sub	sp, #36	; 0x24
 8006484:	9005      	str	r0, [sp, #20]
 8006486:	9104      	str	r1, [sp, #16]
 8006488:	9203      	str	r2, [sp, #12]
 800648a:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 800648c:	9b05      	ldr	r3, [sp, #20]
 800648e:	3360      	adds	r3, #96	; 0x60
 8006490:	9805      	ldr	r0, [sp, #20]
 8006492:	4619      	mov	r1, r3
 8006494:	22ff      	movs	r2, #255	; 0xff
 8006496:	f7ff ff9b 	bl	80063d0 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800649a:	9b05      	ldr	r3, [sp, #20]
 800649c:	f103 0260 	add.w	r2, r3, #96	; 0x60
 80064a0:	9905      	ldr	r1, [sp, #20]
 80064a2:	9b04      	ldr	r3, [sp, #16]
 80064a4:	440b      	add	r3, r1
 80064a6:	4610      	mov	r0, r2
 80064a8:	4619      	mov	r1, r3
 80064aa:	2255      	movs	r2, #85	; 0x55
 80064ac:	f7ff ff90 	bl	80063d0 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80064b0:	f7ff febe 	bl	8006230 <chSysLock.5400.4267>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80064b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80064b6:	9300      	str	r3, [sp, #0]
 80064b8:	9805      	ldr	r0, [sp, #20]
 80064ba:	9904      	ldr	r1, [sp, #16]
 80064bc:	9a03      	ldr	r2, [sp, #12]
 80064be:	9b02      	ldr	r3, [sp, #8]
 80064c0:	f7ff ff9e 	bl	8006400 <chThdCreateI>
 80064c4:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 80064c6:	9807      	ldr	r0, [sp, #28]
 80064c8:	2100      	movs	r1, #0
 80064ca:	f7ff fd21 	bl	8005f10 <chSchWakeupS>
  chSysUnlock();
 80064ce:	f7ff feb7 	bl	8006240 <chSysUnlock.5402.4265>

  return tp;
 80064d2:	9b07      	ldr	r3, [sp, #28]
}
 80064d4:	4618      	mov	r0, r3
 80064d6:	b009      	add	sp, #36	; 0x24
 80064d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80064dc:	f3af 8000 	nop.w

080064e0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80064e0:	b500      	push	{lr}
 80064e2:	b083      	sub	sp, #12
 80064e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80064e6:	f7ff fea3 	bl	8006230 <chSysLock.5400.4267>
  chThdSleepS(time);
 80064ea:	9801      	ldr	r0, [sp, #4]
 80064ec:	f7ff fed8 	bl	80062a0 <chThdSleepS.5411.4249>
  chSysUnlock();
 80064f0:	f7ff fea6 	bl	8006240 <chSysUnlock.5402.4265>
}
 80064f4:	b003      	add	sp, #12
 80064f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80064fa:	bf00      	nop
 80064fc:	f3af 8000 	nop.w

08006500 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8006500:	b500      	push	{lr}
 8006502:	b083      	sub	sp, #12
 8006504:	9001      	str	r0, [sp, #4]

  chSysLock();
 8006506:	f7ff fe93 	bl	8006230 <chSysLock.5400.4267>
  chThdExitS(msg);
 800650a:	9801      	ldr	r0, [sp, #4]
 800650c:	f000 f808 	bl	8006520 <chThdExitS>
  /* The thread never returns here.*/
}
 8006510:	b003      	add	sp, #12
 8006512:	f85d fb04 	ldr.w	pc, [sp], #4
 8006516:	bf00      	nop
 8006518:	f3af 8000 	nop.w
 800651c:	f3af 8000 	nop.w

08006520 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8006520:	b500      	push	{lr}
 8006522:	b085      	sub	sp, #20
 8006524:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8006526:	f640 0308 	movw	r3, #2056	; 0x808
 800652a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800652e:	699b      	ldr	r3, [r3, #24]
 8006530:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 8006532:	9b03      	ldr	r3, [sp, #12]
 8006534:	9a01      	ldr	r2, [sp, #4]
 8006536:	625a      	str	r2, [r3, #36]	; 0x24
 8006538:	e008      	b.n	800654c <chThdExitS+0x2c>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 800653a:	9b03      	ldr	r3, [sp, #12]
 800653c:	3328      	adds	r3, #40	; 0x28
 800653e:	4618      	mov	r0, r3
 8006540:	f7ff fe36 	bl	80061b0 <list_remove.5381.4280>
 8006544:	4603      	mov	r3, r0
 8006546:	4618      	mov	r0, r3
 8006548:	f7ff fbca 	bl	8005ce0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800654c:	9b03      	ldr	r3, [sp, #12]
 800654e:	3328      	adds	r3, #40	; 0x28
 8006550:	4618      	mov	r0, r3
 8006552:	f7ff fdfd 	bl	8006150 <list_notempty.5367.4294>
 8006556:	4603      	mov	r3, r0
 8006558:	2b00      	cmp	r3, #0
 800655a:	d1ee      	bne.n	800653a <chThdExitS+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 800655c:	9b03      	ldr	r3, [sp, #12]
 800655e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8006562:	f003 0303 	and.w	r3, r3, #3
 8006566:	2b00      	cmp	r3, #0
 8006568:	d109      	bne.n	800657e <chThdExitS+0x5e>
    REG_REMOVE(tp);
 800656a:	9b03      	ldr	r3, [sp, #12]
 800656c:	695b      	ldr	r3, [r3, #20]
 800656e:	9a03      	ldr	r2, [sp, #12]
 8006570:	6912      	ldr	r2, [r2, #16]
 8006572:	611a      	str	r2, [r3, #16]
 8006574:	9b03      	ldr	r3, [sp, #12]
 8006576:	691b      	ldr	r3, [r3, #16]
 8006578:	9a03      	ldr	r2, [sp, #12]
 800657a:	6952      	ldr	r2, [r2, #20]
 800657c:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800657e:	200f      	movs	r0, #15
 8006580:	f7ff fbf6 	bl	8005d70 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8006584:	f247 50b0 	movw	r0, #30128	; 0x75b0
 8006588:	f6c0 0000 	movt	r0, #2048	; 0x800
 800658c:	f7fe ff50 	bl	8005430 <chSysHalt>
}
 8006590:	b005      	add	sp, #20
 8006592:	f85d fb04 	ldr.w	pc, [sp], #4
 8006596:	bf00      	nop
 8006598:	f3af 8000 	nop.w
 800659c:	f3af 8000 	nop.w

080065a0 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 80065a0:	b500      	push	{lr}
 80065a2:	b085      	sub	sp, #20
 80065a4:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 80065a6:	f7ff fe73 	bl	8006290 <chThdGetSelfX.5398.4255>
 80065aa:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 80065ac:	9b01      	ldr	r3, [sp, #4]
 80065ae:	681b      	ldr	r3, [r3, #0]
 80065b0:	2b00      	cmp	r3, #0
 80065b2:	d005      	beq.n	80065c0 <chThdSuspendS+0x20>
 80065b4:	f247 50c0 	movw	r0, #30144	; 0x75c0
 80065b8:	f6c0 0000 	movt	r0, #2048	; 0x800
 80065bc:	f7fe ff38 	bl	8005430 <chSysHalt>

  *trp = tp;
 80065c0:	9b01      	ldr	r3, [sp, #4]
 80065c2:	9a03      	ldr	r2, [sp, #12]
 80065c4:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 80065c6:	9b03      	ldr	r3, [sp, #12]
 80065c8:	9a01      	ldr	r2, [sp, #4]
 80065ca:	625a      	str	r2, [r3, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 80065cc:	2003      	movs	r0, #3
 80065ce:	f7ff fbcf 	bl	8005d70 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 80065d2:	f7ff fe5d 	bl	8006290 <chThdGetSelfX.5398.4255>
 80065d6:	4603      	mov	r3, r0
 80065d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80065da:	4618      	mov	r0, r3
 80065dc:	b005      	add	sp, #20
 80065de:	f85d fb04 	ldr.w	pc, [sp], #4
 80065e2:	bf00      	nop
 80065e4:	f3af 8000 	nop.w
 80065e8:	f3af 8000 	nop.w
 80065ec:	f3af 8000 	nop.w

080065f0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 80065f0:	b500      	push	{lr}
 80065f2:	b085      	sub	sp, #20
 80065f4:	9001      	str	r0, [sp, #4]
 80065f6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80065f8:	9b01      	ldr	r3, [sp, #4]
 80065fa:	681b      	ldr	r3, [r3, #0]
 80065fc:	2b00      	cmp	r3, #0
 80065fe:	d016      	beq.n	800662e <chThdResumeI+0x3e>
    thread_t *tp = *trp;
 8006600:	9b01      	ldr	r3, [sp, #4]
 8006602:	681b      	ldr	r3, [r3, #0]
 8006604:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
 8006606:	9b03      	ldr	r3, [sp, #12]
 8006608:	f893 3020 	ldrb.w	r3, [r3, #32]
 800660c:	2b03      	cmp	r3, #3
 800660e:	d005      	beq.n	800661c <chThdResumeI+0x2c>
 8006610:	f247 50d0 	movw	r0, #30160	; 0x75d0
 8006614:	f6c0 0000 	movt	r0, #2048	; 0x800
 8006618:	f7fe ff0a 	bl	8005430 <chSysHalt>
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 800661c:	9b01      	ldr	r3, [sp, #4]
 800661e:	2200      	movs	r2, #0
 8006620:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 8006622:	9b03      	ldr	r3, [sp, #12]
 8006624:	9a00      	ldr	r2, [sp, #0]
 8006626:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8006628:	9803      	ldr	r0, [sp, #12]
 800662a:	f7ff fb59 	bl	8005ce0 <chSchReadyI>
  }
}
 800662e:	b005      	add	sp, #20
 8006630:	f85d fb04 	ldr.w	pc, [sp], #4
 8006634:	f3af 8000 	nop.w
 8006638:	f3af 8000 	nop.w
 800663c:	f3af 8000 	nop.w

08006640 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8006640:	b500      	push	{lr}
 8006642:	b083      	sub	sp, #12
 8006644:	9001      	str	r0, [sp, #4]
 8006646:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8006648:	9b00      	ldr	r3, [sp, #0]
 800664a:	2b00      	cmp	r3, #0
 800664c:	d102      	bne.n	8006654 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 800664e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006652:	e00d      	b.n	8006670 <chThdEnqueueTimeoutS+0x30>
  }

  queue_insert(currp, tqp);
 8006654:	f640 0308 	movw	r3, #2056	; 0x808
 8006658:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800665c:	699b      	ldr	r3, [r3, #24]
 800665e:	4618      	mov	r0, r3
 8006660:	9901      	ldr	r1, [sp, #4]
 8006662:	f7ff fdb5 	bl	80061d0 <queue_insert.5384.4276>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8006666:	2004      	movs	r0, #4
 8006668:	9900      	ldr	r1, [sp, #0]
 800666a:	f7ff fc11 	bl	8005e90 <chSchGoSleepTimeoutS>
 800666e:	4603      	mov	r3, r0
}
 8006670:	4618      	mov	r0, r3
 8006672:	b003      	add	sp, #12
 8006674:	f85d fb04 	ldr.w	pc, [sp], #4
 8006678:	f3af 8000 	nop.w
 800667c:	f3af 8000 	nop.w

08006680 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8006680:	b500      	push	{lr}
 8006682:	b083      	sub	sp, #12
 8006684:	9001      	str	r0, [sp, #4]
 8006686:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8006688:	9801      	ldr	r0, [sp, #4]
 800668a:	f7ff fd81 	bl	8006190 <queue_notempty.5374.4287>
 800668e:	4603      	mov	r3, r0
 8006690:	2b00      	cmp	r3, #0
 8006692:	d003      	beq.n	800669c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8006694:	9801      	ldr	r0, [sp, #4]
 8006696:	9900      	ldr	r1, [sp, #0]
 8006698:	f7ff fe1a 	bl	80062d0 <chThdDoDequeueNextI.5407.4245>
  }
}
 800669c:	b003      	add	sp, #12
 800669e:	f85d fb04 	ldr.w	pc, [sp], #4
 80066a2:	bf00      	nop
 80066a4:	f3af 8000 	nop.w
 80066a8:	f3af 8000 	nop.w
 80066ac:	f3af 8000 	nop.w

080066b0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80066b0:	b500      	push	{lr}
 80066b2:	b083      	sub	sp, #12
 80066b4:	9001      	str	r0, [sp, #4]
 80066b6:	9100      	str	r1, [sp, #0]
 80066b8:	e003      	b.n	80066c2 <chThdDequeueAllI+0x12>

  while (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
 80066ba:	9801      	ldr	r0, [sp, #4]
 80066bc:	9900      	ldr	r1, [sp, #0]
 80066be:	f7ff fe07 	bl	80062d0 <chThdDoDequeueNextI.5407.4245>
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 80066c2:	9801      	ldr	r0, [sp, #4]
 80066c4:	f7ff fd64 	bl	8006190 <queue_notempty.5374.4287>
 80066c8:	4603      	mov	r3, r0
 80066ca:	2b00      	cmp	r3, #0
 80066cc:	d1f5      	bne.n	80066ba <chThdDequeueAllI+0xa>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 80066ce:	b003      	add	sp, #12
 80066d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80066d4:	f3af 8000 	nop.w
 80066d8:	f3af 8000 	nop.w
 80066dc:	f3af 8000 	nop.w

080066e0 <port_rt_get_counter_value.5636.4154>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80066e0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80066e4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80066e8:	685b      	ldr	r3, [r3, #4]
}
 80066ea:	4618      	mov	r0, r3
 80066ec:	4770      	bx	lr
 80066ee:	bf00      	nop

080066f0 <tm_stop.5642.4149>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 80066f0:	b084      	sub	sp, #16
 80066f2:	9003      	str	r0, [sp, #12]
 80066f4:	9102      	str	r1, [sp, #8]
 80066f6:	9201      	str	r2, [sp, #4]

  tmp->n++;
 80066f8:	9b03      	ldr	r3, [sp, #12]
 80066fa:	68db      	ldr	r3, [r3, #12]
 80066fc:	1c5a      	adds	r2, r3, #1
 80066fe:	9b03      	ldr	r3, [sp, #12]
 8006700:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8006702:	9b03      	ldr	r3, [sp, #12]
 8006704:	689b      	ldr	r3, [r3, #8]
 8006706:	9a02      	ldr	r2, [sp, #8]
 8006708:	1ad2      	subs	r2, r2, r3
 800670a:	9b01      	ldr	r3, [sp, #4]
 800670c:	1ad2      	subs	r2, r2, r3
 800670e:	9b03      	ldr	r3, [sp, #12]
 8006710:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8006712:	9b03      	ldr	r3, [sp, #12]
 8006714:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8006718:	9b03      	ldr	r3, [sp, #12]
 800671a:	689b      	ldr	r3, [r3, #8]
 800671c:	461a      	mov	r2, r3
 800671e:	f04f 0300 	mov.w	r3, #0
 8006722:	1812      	adds	r2, r2, r0
 8006724:	eb43 0301 	adc.w	r3, r3, r1
 8006728:	9903      	ldr	r1, [sp, #12]
 800672a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  if (tmp->last > tmp->worst) {
 800672e:	9b03      	ldr	r3, [sp, #12]
 8006730:	689a      	ldr	r2, [r3, #8]
 8006732:	9b03      	ldr	r3, [sp, #12]
 8006734:	685b      	ldr	r3, [r3, #4]
 8006736:	429a      	cmp	r2, r3
 8006738:	d903      	bls.n	8006742 <tm_stop.5642.4149+0x52>
    tmp->worst = tmp->last;
 800673a:	9b03      	ldr	r3, [sp, #12]
 800673c:	689a      	ldr	r2, [r3, #8]
 800673e:	9b03      	ldr	r3, [sp, #12]
 8006740:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8006742:	9b03      	ldr	r3, [sp, #12]
 8006744:	689a      	ldr	r2, [r3, #8]
 8006746:	9b03      	ldr	r3, [sp, #12]
 8006748:	681b      	ldr	r3, [r3, #0]
 800674a:	429a      	cmp	r2, r3
 800674c:	d203      	bcs.n	8006756 <tm_stop.5642.4149+0x66>
    tmp->best = tmp->last;
 800674e:	9b03      	ldr	r3, [sp, #12]
 8006750:	689a      	ldr	r2, [r3, #8]
 8006752:	9b03      	ldr	r3, [sp, #12]
 8006754:	601a      	str	r2, [r3, #0]
  }
}
 8006756:	b004      	add	sp, #16
 8006758:	4770      	bx	lr
 800675a:	bf00      	nop
 800675c:	f3af 8000 	nop.w

08006760 <_tm_init.4147>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8006760:	b500      	push	{lr}
 8006762:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8006764:	f640 0308 	movw	r3, #2056	; 0x808
 8006768:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800676c:	2200      	movs	r2, #0
 800676e:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
  chTMObjectInit(&tm);
 8006772:	466b      	mov	r3, sp
 8006774:	4618      	mov	r0, r3
 8006776:	f000 f813 	bl	80067a0 <chTMObjectInit.4144>
  chTMStartMeasurementX(&tm);
 800677a:	466b      	mov	r3, sp
 800677c:	4618      	mov	r0, r3
 800677e:	f000 f827 	bl	80067d0 <chTMStartMeasurementX.4141>
  chTMStopMeasurementX(&tm);
 8006782:	466b      	mov	r3, sp
 8006784:	4618      	mov	r0, r3
 8006786:	f000 f833 	bl	80067f0 <chTMStopMeasurementX.4138>
  ch.tm.offset = tm.last;
 800678a:	9a02      	ldr	r2, [sp, #8]
 800678c:	f640 0308 	movw	r3, #2056	; 0x808
 8006790:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006794:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
}
 8006798:	b007      	add	sp, #28
 800679a:	f85d fb04 	ldr.w	pc, [sp], #4
 800679e:	bf00      	nop

080067a0 <chTMObjectInit.4144>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 80067a0:	b082      	sub	sp, #8
 80067a2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 80067a4:	9b01      	ldr	r3, [sp, #4]
 80067a6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80067aa:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80067ac:	9b01      	ldr	r3, [sp, #4]
 80067ae:	2200      	movs	r2, #0
 80067b0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 80067b2:	9b01      	ldr	r3, [sp, #4]
 80067b4:	2200      	movs	r2, #0
 80067b6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 80067b8:	9b01      	ldr	r3, [sp, #4]
 80067ba:	2200      	movs	r2, #0
 80067bc:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 80067be:	9901      	ldr	r1, [sp, #4]
 80067c0:	f04f 0200 	mov.w	r2, #0
 80067c4:	f04f 0300 	mov.w	r3, #0
 80067c8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 80067cc:	b002      	add	sp, #8
 80067ce:	4770      	bx	lr

080067d0 <chTMStartMeasurementX.4141>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 80067d0:	b500      	push	{lr}
 80067d2:	b083      	sub	sp, #12
 80067d4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 80067d6:	f7ff ff83 	bl	80066e0 <port_rt_get_counter_value.5636.4154>
 80067da:	4602      	mov	r2, r0
 80067dc:	9b01      	ldr	r3, [sp, #4]
 80067de:	609a      	str	r2, [r3, #8]
}
 80067e0:	b003      	add	sp, #12
 80067e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80067e6:	bf00      	nop
 80067e8:	f3af 8000 	nop.w
 80067ec:	f3af 8000 	nop.w

080067f0 <chTMStopMeasurementX.4138>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80067f0:	b500      	push	{lr}
 80067f2:	b083      	sub	sp, #12
 80067f4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80067f6:	f7ff ff73 	bl	80066e0 <port_rt_get_counter_value.5636.4154>
 80067fa:	4602      	mov	r2, r0
 80067fc:	f640 0308 	movw	r3, #2056	; 0x808
 8006800:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006804:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 8006808:	9801      	ldr	r0, [sp, #4]
 800680a:	4611      	mov	r1, r2
 800680c:	461a      	mov	r2, r3
 800680e:	f7ff ff6f 	bl	80066f0 <tm_stop.5642.4149>
}
 8006812:	b003      	add	sp, #12
 8006814:	f85d fb04 	ldr.w	pc, [sp], #4
 8006818:	f3af 8000 	nop.w
 800681c:	f3af 8000 	nop.w

08006820 <chTMChainMeasurementToX.4133>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 8006820:	b500      	push	{lr}
 8006822:	b083      	sub	sp, #12
 8006824:	9001      	str	r0, [sp, #4]
 8006826:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 8006828:	f7ff ff5a 	bl	80066e0 <port_rt_get_counter_value.5636.4154>
 800682c:	4602      	mov	r2, r0
 800682e:	9b00      	ldr	r3, [sp, #0]
 8006830:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
 8006832:	9b00      	ldr	r3, [sp, #0]
 8006834:	689b      	ldr	r3, [r3, #8]
 8006836:	9801      	ldr	r0, [sp, #4]
 8006838:	4619      	mov	r1, r3
 800683a:	2200      	movs	r2, #0
 800683c:	f7ff ff58 	bl	80066f0 <tm_stop.5642.4149>
}
 8006840:	b003      	add	sp, #12
 8006842:	f85d fb04 	ldr.w	pc, [sp], #4
 8006846:	bf00      	nop
 8006848:	f3af 8000 	nop.w
 800684c:	f3af 8000 	nop.w

08006850 <port_lock.5830.4131>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006850:	b082      	sub	sp, #8
 8006852:	2320      	movs	r3, #32
 8006854:	9301      	str	r3, [sp, #4]
 8006856:	9b01      	ldr	r3, [sp, #4]
 8006858:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800685c:	b002      	add	sp, #8
 800685e:	4770      	bx	lr

08006860 <port_unlock.5833.4129>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006860:	b082      	sub	sp, #8
 8006862:	2300      	movs	r3, #0
 8006864:	9301      	str	r3, [sp, #4]
 8006866:	9b01      	ldr	r3, [sp, #4]
 8006868:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800686c:	b002      	add	sp, #8
 800686e:	4770      	bx	lr

08006870 <port_lock_from_isr.5835.4127>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8006870:	b508      	push	{r3, lr}

  port_lock();
 8006872:	f7ff ffed 	bl	8006850 <port_lock.5830.4131>
}
 8006876:	bd08      	pop	{r3, pc}
 8006878:	f3af 8000 	nop.w
 800687c:	f3af 8000 	nop.w

08006880 <port_unlock_from_isr.5837.4125>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8006880:	b508      	push	{r3, lr}

  port_unlock();
 8006882:	f7ff ffed 	bl	8006860 <port_unlock.5833.4129>
}
 8006886:	bd08      	pop	{r3, pc}
 8006888:	f3af 8000 	nop.w
 800688c:	f3af 8000 	nop.w

08006890 <_stats_init.4123>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
 8006890:	b508      	push	{r3, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
 8006892:	f640 0308 	movw	r3, #2056	; 0x808
 8006896:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800689a:	2200      	movs	r2, #0
 800689c:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
 80068a0:	f640 0308 	movw	r3, #2056	; 0x808
 80068a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068a8:	2200      	movs	r2, #0
 80068aa:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
 80068ae:	4803      	ldr	r0, [pc, #12]	; (80068bc <_stats_init.4123+0x2c>)
 80068b0:	f7ff ff76 	bl	80067a0 <chTMObjectInit.4144>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
 80068b4:	4802      	ldr	r0, [pc, #8]	; (80068c0 <_stats_init.4123+0x30>)
 80068b6:	f7ff ff73 	bl	80067a0 <chTMObjectInit.4144>
}
 80068ba:	bd08      	pop	{r3, pc}
 80068bc:	20000cb8 	.word	0x20000cb8
 80068c0:	20000cd0 	.word	0x20000cd0
 80068c4:	f3af 8000 	nop.w
 80068c8:	f3af 8000 	nop.w
 80068cc:	f3af 8000 	nop.w

080068d0 <_stats_increase_irq>:

/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {
 80068d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80068d2:	f7ff ffcd 	bl	8006870 <port_lock_from_isr.5835.4127>
  ch.kernel_stats.n_irq++;
 80068d6:	f640 0308 	movw	r3, #2056	; 0x808
 80068da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068de:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
 80068e2:	1c5a      	adds	r2, r3, #1
 80068e4:	f640 0308 	movw	r3, #2056	; 0x808
 80068e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80068ec:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  port_unlock_from_isr();
 80068f0:	f7ff ffc6 	bl	8006880 <port_unlock_from_isr.5837.4125>
}
 80068f4:	bd08      	pop	{r3, pc}
 80068f6:	bf00      	nop
 80068f8:	f3af 8000 	nop.w
 80068fc:	f3af 8000 	nop.w

08006900 <_stats_ctxswc.4028>:
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
 8006900:	b500      	push	{lr}
 8006902:	b083      	sub	sp, #12
 8006904:	9001      	str	r0, [sp, #4]
 8006906:	9100      	str	r1, [sp, #0]

  ch.kernel_stats.n_ctxswc++;
 8006908:	f640 0308 	movw	r3, #2056	; 0x808
 800690c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8006910:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 8006914:	1c5a      	adds	r2, r3, #1
 8006916:	f640 0308 	movw	r3, #2056	; 0x808
 800691a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800691e:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 8006922:	9b00      	ldr	r3, [sp, #0]
 8006924:	f103 0248 	add.w	r2, r3, #72	; 0x48
 8006928:	9b01      	ldr	r3, [sp, #4]
 800692a:	3348      	adds	r3, #72	; 0x48
 800692c:	4610      	mov	r0, r2
 800692e:	4619      	mov	r1, r3
 8006930:	f7ff ff76 	bl	8006820 <chTMChainMeasurementToX.4133>
}
 8006934:	b003      	add	sp, #12
 8006936:	f85d fb04 	ldr.w	pc, [sp], #4
 800693a:	bf00      	nop
 800693c:	f3af 8000 	nop.w

08006940 <_stats_start_measure_crit_thd>:

/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {
 8006940:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
 8006942:	4802      	ldr	r0, [pc, #8]	; (800694c <_stats_start_measure_crit_thd+0xc>)
 8006944:	f7ff ff44 	bl	80067d0 <chTMStartMeasurementX.4141>
}
 8006948:	bd08      	pop	{r3, pc}
 800694a:	bf00      	nop
 800694c:	20000cb8 	.word	0x20000cb8

08006950 <_stats_stop_measure_crit_thd>:

/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {
 8006950:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
 8006952:	4802      	ldr	r0, [pc, #8]	; (800695c <_stats_stop_measure_crit_thd+0xc>)
 8006954:	f7ff ff4c 	bl	80067f0 <chTMStopMeasurementX.4138>
}
 8006958:	bd08      	pop	{r3, pc}
 800695a:	bf00      	nop
 800695c:	20000cb8 	.word	0x20000cb8

08006960 <_stats_start_measure_crit_isr>:

/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {
 8006960:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
 8006962:	4802      	ldr	r0, [pc, #8]	; (800696c <_stats_start_measure_crit_isr+0xc>)
 8006964:	f7ff ff34 	bl	80067d0 <chTMStartMeasurementX.4141>
}
 8006968:	bd08      	pop	{r3, pc}
 800696a:	bf00      	nop
 800696c:	20000cd0 	.word	0x20000cd0

08006970 <_stats_stop_measure_crit_isr>:

/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {
 8006970:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
 8006972:	4802      	ldr	r0, [pc, #8]	; (800697c <_stats_stop_measure_crit_isr+0xc>)
 8006974:	f7ff ff3c 	bl	80067f0 <chTMStopMeasurementX.4138>
}
 8006978:	bd08      	pop	{r3, pc}
 800697a:	bf00      	nop
 800697c:	20000cd0 	.word	0x20000cd0

08006980 <memset>:
 8006980:	b4f0      	push	{r4, r5, r6, r7}
 8006982:	0784      	lsls	r4, r0, #30
 8006984:	d043      	beq.n	8006a0e <memset+0x8e>
 8006986:	1e54      	subs	r4, r2, #1
 8006988:	2a00      	cmp	r2, #0
 800698a:	d03e      	beq.n	8006a0a <memset+0x8a>
 800698c:	b2cd      	uxtb	r5, r1
 800698e:	4603      	mov	r3, r0
 8006990:	e003      	b.n	800699a <memset+0x1a>
 8006992:	1e62      	subs	r2, r4, #1
 8006994:	2c00      	cmp	r4, #0
 8006996:	d038      	beq.n	8006a0a <memset+0x8a>
 8006998:	4614      	mov	r4, r2
 800699a:	f803 5b01 	strb.w	r5, [r3], #1
 800699e:	079a      	lsls	r2, r3, #30
 80069a0:	d1f7      	bne.n	8006992 <memset+0x12>
 80069a2:	2c03      	cmp	r4, #3
 80069a4:	d92a      	bls.n	80069fc <memset+0x7c>
 80069a6:	b2cd      	uxtb	r5, r1
 80069a8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80069ac:	2c0f      	cmp	r4, #15
 80069ae:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80069b2:	d915      	bls.n	80069e0 <memset+0x60>
 80069b4:	f1a4 0710 	sub.w	r7, r4, #16
 80069b8:	093f      	lsrs	r7, r7, #4
 80069ba:	f103 0610 	add.w	r6, r3, #16
 80069be:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 80069c2:	461a      	mov	r2, r3
 80069c4:	6015      	str	r5, [r2, #0]
 80069c6:	6055      	str	r5, [r2, #4]
 80069c8:	6095      	str	r5, [r2, #8]
 80069ca:	60d5      	str	r5, [r2, #12]
 80069cc:	3210      	adds	r2, #16
 80069ce:	42b2      	cmp	r2, r6
 80069d0:	d1f8      	bne.n	80069c4 <memset+0x44>
 80069d2:	f004 040f 	and.w	r4, r4, #15
 80069d6:	3701      	adds	r7, #1
 80069d8:	2c03      	cmp	r4, #3
 80069da:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 80069de:	d90d      	bls.n	80069fc <memset+0x7c>
 80069e0:	461e      	mov	r6, r3
 80069e2:	4622      	mov	r2, r4
 80069e4:	3a04      	subs	r2, #4
 80069e6:	2a03      	cmp	r2, #3
 80069e8:	f846 5b04 	str.w	r5, [r6], #4
 80069ec:	d8fa      	bhi.n	80069e4 <memset+0x64>
 80069ee:	1f22      	subs	r2, r4, #4
 80069f0:	f022 0203 	bic.w	r2, r2, #3
 80069f4:	3204      	adds	r2, #4
 80069f6:	4413      	add	r3, r2
 80069f8:	f004 0403 	and.w	r4, r4, #3
 80069fc:	b12c      	cbz	r4, 8006a0a <memset+0x8a>
 80069fe:	b2c9      	uxtb	r1, r1
 8006a00:	441c      	add	r4, r3
 8006a02:	f803 1b01 	strb.w	r1, [r3], #1
 8006a06:	42a3      	cmp	r3, r4
 8006a08:	d1fb      	bne.n	8006a02 <memset+0x82>
 8006a0a:	bcf0      	pop	{r4, r5, r6, r7}
 8006a0c:	4770      	bx	lr
 8006a0e:	4614      	mov	r4, r2
 8006a10:	4603      	mov	r3, r0
 8006a12:	e7c6      	b.n	80069a2 <memset+0x22>
	...
 8006a20:	65726854 	.word	0x65726854
 8006a24:	2c736461 	.word	0x2c736461
 8006a28:	716e6520 	.word	0x716e6520
 8006a2c:	69756575 	.word	0x69756575
 8006a30:	7420676e 	.word	0x7420676e
 8006a34:	20747365 	.word	0x20747365
 8006a38:	00003123 	.word	0x00003123
 8006a3c:	65726854 	.word	0x65726854
 8006a40:	2c736461 	.word	0x2c736461
 8006a44:	716e6520 	.word	0x716e6520
 8006a48:	69756575 	.word	0x69756575
 8006a4c:	7420676e 	.word	0x7420676e
 8006a50:	20747365 	.word	0x20747365
 8006a54:	00003223 	.word	0x00003223
 8006a58:	65726854 	.word	0x65726854
 8006a5c:	2c736461 	.word	0x2c736461
 8006a60:	69727020 	.word	0x69727020
 8006a64:	7469726f 	.word	0x7469726f
 8006a68:	68632079 	.word	0x68632079
 8006a6c:	65676e61 	.word	0x65676e61
 8006a70:	00000000 	.word	0x00000000
 8006a74:	65726854 	.word	0x65726854
 8006a78:	2c736461 	.word	0x2c736461
 8006a7c:	6c656420 	.word	0x6c656420
 8006a80:	00737961 	.word	0x00737961
 8006a84:	616d6553 	.word	0x616d6553
 8006a88:	726f6870 	.word	0x726f6870
 8006a8c:	202c7365 	.word	0x202c7365
 8006a90:	75716e65 	.word	0x75716e65
 8006a94:	6e697565 	.word	0x6e697565
 8006a98:	00000067 	.word	0x00000067
 8006a9c:	616d6553 	.word	0x616d6553
 8006aa0:	726f6870 	.word	0x726f6870
 8006aa4:	202c7365 	.word	0x202c7365
 8006aa8:	656d6974 	.word	0x656d6974
 8006aac:	0074756f 	.word	0x0074756f
 8006ab0:	616d6553 	.word	0x616d6553
 8006ab4:	726f6870 	.word	0x726f6870
 8006ab8:	202c7365 	.word	0x202c7365
 8006abc:	6d6f7461 	.word	0x6d6f7461
 8006ac0:	73206369 	.word	0x73206369
 8006ac4:	616e6769 	.word	0x616e6769
 8006ac8:	61772d6c 	.word	0x61772d6c
 8006acc:	00007469 	.word	0x00007469
 8006ad0:	616e6942 	.word	0x616e6942
 8006ad4:	53207972 	.word	0x53207972
 8006ad8:	70616d65 	.word	0x70616d65
 8006adc:	65726f68 	.word	0x65726f68
 8006ae0:	66202c73 	.word	0x66202c73
 8006ae4:	74636e75 	.word	0x74636e75
 8006ae8:	616e6f69 	.word	0x616e6f69
 8006aec:	7974696c 	.word	0x7974696c
 8006af0:	00000000 	.word	0x00000000
 8006af4:	6574754d 	.word	0x6574754d
 8006af8:	2c736578 	.word	0x2c736578
 8006afc:	69727020 	.word	0x69727020
 8006b00:	7469726f 	.word	0x7469726f
 8006b04:	6e652079 	.word	0x6e652079
 8006b08:	75657571 	.word	0x75657571
 8006b0c:	20676e69 	.word	0x20676e69
 8006b10:	74736574 	.word	0x74736574
 8006b14:	00000000 	.word	0x00000000
 8006b18:	6574754d 	.word	0x6574754d
 8006b1c:	2c736578 	.word	0x2c736578
 8006b20:	69727020 	.word	0x69727020
 8006b24:	7469726f 	.word	0x7469726f
 8006b28:	65722079 	.word	0x65722079
 8006b2c:	6e727574 	.word	0x6e727574
 8006b30:	00000000 	.word	0x00000000
 8006b34:	6574754d 	.word	0x6574754d
 8006b38:	2c736578 	.word	0x2c736578
 8006b3c:	61747320 	.word	0x61747320
 8006b40:	00737574 	.word	0x00737574
 8006b44:	646e6f43 	.word	0x646e6f43
 8006b48:	2c726156 	.word	0x2c726156
 8006b4c:	67697320 	.word	0x67697320
 8006b50:	206c616e 	.word	0x206c616e
 8006b54:	74736574 	.word	0x74736574
 8006b58:	00000000 	.word	0x00000000
 8006b5c:	646e6f43 	.word	0x646e6f43
 8006b60:	2c726156 	.word	0x2c726156
 8006b64:	6f726220 	.word	0x6f726220
 8006b68:	61636461 	.word	0x61636461
 8006b6c:	74207473 	.word	0x74207473
 8006b70:	00747365 	.word	0x00747365
 8006b74:	646e6f43 	.word	0x646e6f43
 8006b78:	2c726156 	.word	0x2c726156
 8006b7c:	6f6f6220 	.word	0x6f6f6220
 8006b80:	74207473 	.word	0x74207473
 8006b84:	00747365 	.word	0x00747365
 8006b88:	7373654d 	.word	0x7373654d
 8006b8c:	73656761 	.word	0x73656761
 8006b90:	6f6c202c 	.word	0x6f6c202c
 8006b94:	0000706f 	.word	0x0000706f
 8006b98:	6c69614d 	.word	0x6c69614d
 8006b9c:	65786f62 	.word	0x65786f62
 8006ba0:	71202c73 	.word	0x71202c73
 8006ba4:	69756575 	.word	0x69756575
 8006ba8:	6120676e 	.word	0x6120676e
 8006bac:	7420646e 	.word	0x7420646e
 8006bb0:	6f656d69 	.word	0x6f656d69
 8006bb4:	00737475 	.word	0x00737475
 8006bb8:	6e657645 	.word	0x6e657645
 8006bbc:	202c7374 	.word	0x202c7374
 8006bc0:	69676572 	.word	0x69676572
 8006bc4:	61727473 	.word	0x61727473
 8006bc8:	6e6f6974 	.word	0x6e6f6974
 8006bcc:	646e6120 	.word	0x646e6120
 8006bd0:	73696420 	.word	0x73696420
 8006bd4:	63746170 	.word	0x63746170
 8006bd8:	00000068 	.word	0x00000068
 8006bdc:	6e657645 	.word	0x6e657645
 8006be0:	202c7374 	.word	0x202c7374
 8006be4:	74696177 	.word	0x74696177
 8006be8:	646e6120 	.word	0x646e6120
 8006bec:	6f726220 	.word	0x6f726220
 8006bf0:	61636461 	.word	0x61636461
 8006bf4:	00007473 	.word	0x00007473
 8006bf8:	6e657645 	.word	0x6e657645
 8006bfc:	202c7374 	.word	0x202c7374
 8006c00:	656d6974 	.word	0x656d6974
 8006c04:	7374756f 	.word	0x7374756f
 8006c08:	00000000 	.word	0x00000000
 8006c0c:	70616548 	.word	0x70616548
 8006c10:	6c61202c 	.word	0x6c61202c
 8006c14:	61636f6c 	.word	0x61636f6c
 8006c18:	6e6f6974 	.word	0x6e6f6974
 8006c1c:	646e6120 	.word	0x646e6120
 8006c20:	61726620 	.word	0x61726620
 8006c24:	6e656d67 	.word	0x6e656d67
 8006c28:	69746174 	.word	0x69746174
 8006c2c:	74206e6f 	.word	0x74206e6f
 8006c30:	00747365 	.word	0x00747365
 8006c34:	6f6d654d 	.word	0x6f6d654d
 8006c38:	50207972 	.word	0x50207972
 8006c3c:	736c6f6f 	.word	0x736c6f6f
 8006c40:	7571202c 	.word	0x7571202c
 8006c44:	2f657565 	.word	0x2f657565
 8006c48:	75716564 	.word	0x75716564
 8006c4c:	00657565 	.word	0x00657565
 8006c50:	616e7944 	.word	0x616e7944
 8006c54:	2063696d 	.word	0x2063696d
 8006c58:	73495041 	.word	0x73495041
 8006c5c:	6874202c 	.word	0x6874202c
 8006c60:	64616572 	.word	0x64616572
 8006c64:	72632073 	.word	0x72632073
 8006c68:	69746165 	.word	0x69746165
 8006c6c:	66206e6f 	.word	0x66206e6f
 8006c70:	206d6f72 	.word	0x206d6f72
 8006c74:	70616568 	.word	0x70616568
 8006c78:	00000000 	.word	0x00000000
 8006c7c:	616e7944 	.word	0x616e7944
 8006c80:	2063696d 	.word	0x2063696d
 8006c84:	73495041 	.word	0x73495041
 8006c88:	6874202c 	.word	0x6874202c
 8006c8c:	64616572 	.word	0x64616572
 8006c90:	72632073 	.word	0x72632073
 8006c94:	69746165 	.word	0x69746165
 8006c98:	66206e6f 	.word	0x66206e6f
 8006c9c:	206d6f72 	.word	0x206d6f72
 8006ca0:	6f6d656d 	.word	0x6f6d656d
 8006ca4:	70207972 	.word	0x70207972
 8006ca8:	006c6f6f 	.word	0x006c6f6f
 8006cac:	616e7944 	.word	0x616e7944
 8006cb0:	2063696d 	.word	0x2063696d
 8006cb4:	73495041 	.word	0x73495041
 8006cb8:	6572202c 	.word	0x6572202c
 8006cbc:	74736967 	.word	0x74736967
 8006cc0:	61207972 	.word	0x61207972
 8006cc4:	7220646e 	.word	0x7220646e
 8006cc8:	72656665 	.word	0x72656665
 8006ccc:	65636e65 	.word	0x65636e65
 8006cd0:	00000073 	.word	0x00000073
 8006cd4:	75657551 	.word	0x75657551
 8006cd8:	202c7365 	.word	0x202c7365
 8006cdc:	75706e69 	.word	0x75706e69
 8006ce0:	75712074 	.word	0x75712074
 8006ce4:	73657565 	.word	0x73657565
 8006ce8:	00000000 	.word	0x00000000
 8006cec:	75657551 	.word	0x75657551
 8006cf0:	202c7365 	.word	0x202c7365
 8006cf4:	7074756f 	.word	0x7074756f
 8006cf8:	71207475 	.word	0x71207475
 8006cfc:	65756575 	.word	0x65756575
 8006d00:	00000073 	.word	0x00000073
 8006d04:	74737953 	.word	0x74737953
 8006d08:	202c6d65 	.word	0x202c6d65
 8006d0c:	74697263 	.word	0x74697263
 8006d10:	6c616369 	.word	0x6c616369
 8006d14:	6e6f7a20 	.word	0x6e6f7a20
 8006d18:	00007365 	.word	0x00007365
 8006d1c:	74737953 	.word	0x74737953
 8006d20:	202c6d65 	.word	0x202c6d65
 8006d24:	65746e69 	.word	0x65746e69
 8006d28:	70757272 	.word	0x70757272
 8006d2c:	68207374 	.word	0x68207374
 8006d30:	6c646e61 	.word	0x6c646e61
 8006d34:	00676e69 	.word	0x00676e69
 8006d38:	74737953 	.word	0x74737953
 8006d3c:	202c6d65 	.word	0x202c6d65
 8006d40:	65746e69 	.word	0x65746e69
 8006d44:	74697267 	.word	0x74697267
 8006d48:	00000079 	.word	0x00000079
 8006d4c:	636e6542 	.word	0x636e6542
 8006d50:	72616d68 	.word	0x72616d68
 8006d54:	6d202c6b 	.word	0x6d202c6b
 8006d58:	61737365 	.word	0x61737365
 8006d5c:	20736567 	.word	0x20736567
 8006d60:	00003123 	.word	0x00003123
 8006d64:	636e6542 	.word	0x636e6542
 8006d68:	72616d68 	.word	0x72616d68
 8006d6c:	6d202c6b 	.word	0x6d202c6b
 8006d70:	61737365 	.word	0x61737365
 8006d74:	20736567 	.word	0x20736567
 8006d78:	00003223 	.word	0x00003223
 8006d7c:	636e6542 	.word	0x636e6542
 8006d80:	72616d68 	.word	0x72616d68
 8006d84:	6d202c6b 	.word	0x6d202c6b
 8006d88:	61737365 	.word	0x61737365
 8006d8c:	20736567 	.word	0x20736567
 8006d90:	00003323 	.word	0x00003323
 8006d94:	636e6542 	.word	0x636e6542
 8006d98:	72616d68 	.word	0x72616d68
 8006d9c:	63202c6b 	.word	0x63202c6b
 8006da0:	65746e6f 	.word	0x65746e6f
 8006da4:	73207478 	.word	0x73207478
 8006da8:	63746977 	.word	0x63746977
 8006dac:	00000068 	.word	0x00000068
 8006db0:	636e6542 	.word	0x636e6542
 8006db4:	72616d68 	.word	0x72616d68
 8006db8:	74202c6b 	.word	0x74202c6b
 8006dbc:	61657268 	.word	0x61657268
 8006dc0:	202c7364 	.word	0x202c7364
 8006dc4:	6c6c7566 	.word	0x6c6c7566
 8006dc8:	63796320 	.word	0x63796320
 8006dcc:	0000656c 	.word	0x0000656c
 8006dd0:	636e6542 	.word	0x636e6542
 8006dd4:	72616d68 	.word	0x72616d68
 8006dd8:	74202c6b 	.word	0x74202c6b
 8006ddc:	61657268 	.word	0x61657268
 8006de0:	202c7364 	.word	0x202c7364
 8006de4:	61657263 	.word	0x61657263
 8006de8:	6f206574 	.word	0x6f206574
 8006dec:	00796c6e 	.word	0x00796c6e
 8006df0:	636e6542 	.word	0x636e6542
 8006df4:	72616d68 	.word	0x72616d68
 8006df8:	6d202c6b 	.word	0x6d202c6b
 8006dfc:	20737361 	.word	0x20737361
 8006e00:	63736572 	.word	0x63736572
 8006e04:	75646568 	.word	0x75646568
 8006e08:	202c656c 	.word	0x202c656c
 8006e0c:	68742035 	.word	0x68742035
 8006e10:	64616572 	.word	0x64616572
 8006e14:	00000073 	.word	0x00000073
 8006e18:	202d2d2d 	.word	0x202d2d2d
 8006e1c:	726f6353 	.word	0x726f6353
 8006e20:	203a2065 	.word	0x203a2065
 8006e24:	00000000 	.word	0x00000000
 8006e28:	78746320 	.word	0x78746320
 8006e2c:	2f637773 	.word	0x2f637773
 8006e30:	00000053 	.word	0x00000053
 8006e34:	636e6542 	.word	0x636e6542
 8006e38:	72616d68 	.word	0x72616d68
 8006e3c:	72202c6b 	.word	0x72202c6b
 8006e40:	646e756f 	.word	0x646e756f
 8006e44:	626f7220 	.word	0x626f7220
 8006e48:	63206e69 	.word	0x63206e69
 8006e4c:	65746e6f 	.word	0x65746e6f
 8006e50:	73207478 	.word	0x73207478
 8006e54:	63746977 	.word	0x63746977
 8006e58:	676e6968 	.word	0x676e6968
 8006e5c:	00000000 	.word	0x00000000
 8006e60:	74796220 	.word	0x74796220
 8006e64:	532f7365 	.word	0x532f7365
 8006e68:	00000000 	.word	0x00000000
 8006e6c:	636e6542 	.word	0x636e6542
 8006e70:	72616d68 	.word	0x72616d68
 8006e74:	49202c6b 	.word	0x49202c6b
 8006e78:	51204f2f 	.word	0x51204f2f
 8006e7c:	65756575 	.word	0x65756575
 8006e80:	68742073 	.word	0x68742073
 8006e84:	67756f72 	.word	0x67756f72
 8006e88:	74757068 	.word	0x74757068
 8006e8c:	00000000 	.word	0x00000000
 8006e90:	6d697420 	.word	0x6d697420
 8006e94:	2f737265 	.word	0x2f737265
 8006e98:	00000053 	.word	0x00000053
 8006e9c:	636e6542 	.word	0x636e6542
 8006ea0:	72616d68 	.word	0x72616d68
 8006ea4:	76202c6b 	.word	0x76202c6b
 8006ea8:	75747269 	.word	0x75747269
 8006eac:	74206c61 	.word	0x74206c61
 8006eb0:	72656d69 	.word	0x72656d69
 8006eb4:	65732073 	.word	0x65732073
 8006eb8:	65722f74 	.word	0x65722f74
 8006ebc:	00746573 	.word	0x00746573
 8006ec0:	69617720 	.word	0x69617720
 8006ec4:	69732b74 	.word	0x69732b74
 8006ec8:	6c616e67 	.word	0x6c616e67
 8006ecc:	0000532f 	.word	0x0000532f
 8006ed0:	636e6542 	.word	0x636e6542
 8006ed4:	72616d68 	.word	0x72616d68
 8006ed8:	73202c6b 	.word	0x73202c6b
 8006edc:	70616d65 	.word	0x70616d65
 8006ee0:	65726f68 	.word	0x65726f68
 8006ee4:	61772073 	.word	0x61772073
 8006ee8:	732f7469 	.word	0x732f7469
 8006eec:	616e6769 	.word	0x616e6769
 8006ef0:	0000006c 	.word	0x0000006c
 8006ef4:	636f6c20 	.word	0x636f6c20
 8006ef8:	6e752b6b 	.word	0x6e752b6b
 8006efc:	6b636f6c 	.word	0x6b636f6c
 8006f00:	0000532f 	.word	0x0000532f
 8006f04:	636e6542 	.word	0x636e6542
 8006f08:	72616d68 	.word	0x72616d68
 8006f0c:	6d202c6b 	.word	0x6d202c6b
 8006f10:	78657475 	.word	0x78657475
 8006f14:	6c207365 	.word	0x6c207365
 8006f18:	2f6b636f 	.word	0x2f6b636f
 8006f1c:	6f6c6e75 	.word	0x6f6c6e75
 8006f20:	00006b63 	.word	0x00006b63
 8006f24:	202d2d2d 	.word	0x202d2d2d
 8006f28:	74737953 	.word	0x74737953
 8006f2c:	203a6d65 	.word	0x203a6d65
 8006f30:	00000000 	.word	0x00000000
 8006f34:	74796220 	.word	0x74796220
 8006f38:	00007365 	.word	0x00007365
 8006f3c:	202d2d2d 	.word	0x202d2d2d
 8006f40:	65726854 	.word	0x65726854
 8006f44:	203a6461 	.word	0x203a6461
 8006f48:	00000000 	.word	0x00000000
 8006f4c:	202d2d2d 	.word	0x202d2d2d
 8006f50:	656d6954 	.word	0x656d6954
 8006f54:	203a2072 	.word	0x203a2072
 8006f58:	00000000 	.word	0x00000000
 8006f5c:	202d2d2d 	.word	0x202d2d2d
 8006f60:	616d6553 	.word	0x616d6553
 8006f64:	203a6870 	.word	0x203a6870
 8006f68:	00000000 	.word	0x00000000
 8006f6c:	202d2d2d 	.word	0x202d2d2d
 8006f70:	6e657645 	.word	0x6e657645
 8006f74:	203a5374 	.word	0x203a5374
 8006f78:	00000000 	.word	0x00000000
 8006f7c:	202d2d2d 	.word	0x202d2d2d
 8006f80:	6e657645 	.word	0x6e657645
 8006f84:	203a4c74 	.word	0x203a4c74
 8006f88:	00000000 	.word	0x00000000
 8006f8c:	202d2d2d 	.word	0x202d2d2d
 8006f90:	6574754d 	.word	0x6574754d
 8006f94:	203a2078 	.word	0x203a2078
 8006f98:	00000000 	.word	0x00000000
 8006f9c:	202d2d2d 	.word	0x202d2d2d
 8006fa0:	646e6f43 	.word	0x646e6f43
 8006fa4:	203a2e56 	.word	0x203a2e56
 8006fa8:	00000000 	.word	0x00000000
 8006fac:	202d2d2d 	.word	0x202d2d2d
 8006fb0:	75657551 	.word	0x75657551
 8006fb4:	203a2065 	.word	0x203a2065
 8006fb8:	00000000 	.word	0x00000000
 8006fbc:	202d2d2d 	.word	0x202d2d2d
 8006fc0:	6c69614d 	.word	0x6c69614d
 8006fc4:	203a2e42 	.word	0x203a2e42
 8006fc8:	00000000 	.word	0x00000000
 8006fcc:	636e6542 	.word	0x636e6542
 8006fd0:	72616d68 	.word	0x72616d68
 8006fd4:	52202c6b 	.word	0x52202c6b
 8006fd8:	66204d41 	.word	0x66204d41
 8006fdc:	70746f6f 	.word	0x70746f6f
 8006fe0:	746e6972 	.word	0x746e6972
 8006fe4:	00000000 	.word	0x00000000
 8006fe8:	67617355 	.word	0x67617355
 8006fec:	25203a65 	.word	0x25203a65
 8006ff0:	000a0d73 	.word	0x000a0d73
 8006ff4:	00207325 	.word	0x00207325
 8006ff8:	6f666e69 	.word	0x6f666e69
 8006ffc:	00000000 	.word	0x00000000
 8007000:	6e72654b 	.word	0x6e72654b
 8007004:	203a6c65 	.word	0x203a6c65
 8007008:	20202020 	.word	0x20202020
 800700c:	73252020 	.word	0x73252020
 8007010:	00000a0d 	.word	0x00000a0d
 8007014:	2e312e33 	.word	0x2e312e33
 8007018:	00000033 	.word	0x00000033
 800701c:	706d6f43 	.word	0x706d6f43
 8007020:	72656c69 	.word	0x72656c69
 8007024:	2020203a 	.word	0x2020203a
 8007028:	73252020 	.word	0x73252020
 800702c:	00000a0d 	.word	0x00000a0d
 8007030:	20434347 	.word	0x20434347
 8007034:	2e382e34 	.word	0x2e382e34
 8007038:	00000032 	.word	0x00000032
 800703c:	68637241 	.word	0x68637241
 8007040:	63657469 	.word	0x63657469
 8007044:	65727574 	.word	0x65727574
 8007048:	7325203a 	.word	0x7325203a
 800704c:	00000a0d 	.word	0x00000a0d
 8007050:	764d5241 	.word	0x764d5241
 8007054:	4d2d4537 	.word	0x4d2d4537
 8007058:	00000000 	.word	0x00000000
 800705c:	65726f43 	.word	0x65726f43
 8007060:	72615620 	.word	0x72615620
 8007064:	746e6169 	.word	0x746e6169
 8007068:	7325203a 	.word	0x7325203a
 800706c:	00000a0d 	.word	0x00000a0d
 8007070:	74726f43 	.word	0x74726f43
 8007074:	4d2d7865 	.word	0x4d2d7865
 8007078:	00000034 	.word	0x00000034
 800707c:	74726f50 	.word	0x74726f50
 8007080:	666e4920 	.word	0x666e4920
 8007084:	20203a6f 	.word	0x20203a6f
 8007088:	73252020 	.word	0x73252020
 800708c:	00000a0d 	.word	0x00000a0d
 8007090:	61766441 	.word	0x61766441
 8007094:	6465636e 	.word	0x6465636e
 8007098:	72656b20 	.word	0x72656b20
 800709c:	206c656e 	.word	0x206c656e
 80070a0:	65646f6d 	.word	0x65646f6d
 80070a4:	00000000 	.word	0x00000000
 80070a8:	74616c50 	.word	0x74616c50
 80070ac:	6d726f66 	.word	0x6d726f66
 80070b0:	2020203a 	.word	0x2020203a
 80070b4:	73252020 	.word	0x73252020
 80070b8:	00000a0d 	.word	0x00000a0d
 80070bc:	334d5453 	.word	0x334d5453
 80070c0:	30344632 	.word	0x30344632
 80070c4:	69482037 	.word	0x69482037
 80070c8:	50206867 	.word	0x50206867
 80070cc:	6f667265 	.word	0x6f667265
 80070d0:	6e616d72 	.word	0x6e616d72
 80070d4:	77206563 	.word	0x77206563
 80070d8:	20687469 	.word	0x20687469
 80070dc:	20505344 	.word	0x20505344
 80070e0:	20646e61 	.word	0x20646e61
 80070e4:	00555046 	.word	0x00555046
 80070e8:	72616f42 	.word	0x72616f42
 80070ec:	20203a64 	.word	0x20203a64
 80070f0:	20202020 	.word	0x20202020
 80070f4:	73252020 	.word	0x73252020
 80070f8:	00000a0d 	.word	0x00000a0d
 80070fc:	694d5453 	.word	0x694d5453
 8007100:	656f7263 	.word	0x656f7263
 8007104:	7463656c 	.word	0x7463656c
 8007108:	696e6f72 	.word	0x696e6f72
 800710c:	53207363 	.word	0x53207363
 8007110:	32334d54 	.word	0x32334d54
 8007114:	442d3446 	.word	0x442d3446
 8007118:	6f637369 	.word	0x6f637369
 800711c:	79726576 	.word	0x79726576
 8007120:	00000000 	.word	0x00000000
 8007124:	6c697542 	.word	0x6c697542
 8007128:	69742064 	.word	0x69742064
 800712c:	203a656d 	.word	0x203a656d
 8007130:	73252020 	.word	0x73252020
 8007134:	73257325 	.word	0x73257325
 8007138:	00000a0d 	.word	0x00000a0d
 800713c:	2072614d 	.word	0x2072614d
 8007140:	32203033 	.word	0x32203033
 8007144:	00363130 	.word	0x00363130
 8007148:	00202d20 	.word	0x00202d20
 800714c:	313a3331 	.word	0x313a3331
 8007150:	34333a37 	.word	0x34333a37
 8007154:	00000000 	.word	0x00000000
 8007158:	74737973 	.word	0x74737973
 800715c:	00656d69 	.word	0x00656d69
 8007160:	0d756c25 	.word	0x0d756c25
 8007164:	0000000a 	.word	0x0000000a
 8007168:	6c656873 	.word	0x6c656873
 800716c:	0000006c 	.word	0x0000006c
 8007170:	68430a0d 	.word	0x68430a0d
 8007174:	4f696269 	.word	0x4f696269
 8007178:	54522f53 	.word	0x54522f53
 800717c:	65685320 	.word	0x65685320
 8007180:	0a0d6c6c 	.word	0x0a0d6c6c
 8007184:	00000000 	.word	0x00000000
 8007188:	203e6863 	.word	0x203e6863
 800718c:	00000000 	.word	0x00000000
 8007190:	6f6c0a0d 	.word	0x6f6c0a0d
 8007194:	74756f67 	.word	0x74756f67
 8007198:	00000000 	.word	0x00000000
 800719c:	00000920 	.word	0x00000920
 80071a0:	206f6f74 	.word	0x206f6f74
 80071a4:	796e616d 	.word	0x796e616d
 80071a8:	67726120 	.word	0x67726120
 80071ac:	6e656d75 	.word	0x6e656d75
 80071b0:	0a0d7374 	.word	0x0a0d7374
 80071b4:	00000000 	.word	0x00000000
 80071b8:	74697865 	.word	0x74697865
 80071bc:	00000000 	.word	0x00000000
 80071c0:	706c6568 	.word	0x706c6568
 80071c4:	00000000 	.word	0x00000000
 80071c8:	6d6d6f43 	.word	0x6d6d6f43
 80071cc:	73646e61 	.word	0x73646e61
 80071d0:	6568203a 	.word	0x6568203a
 80071d4:	6520706c 	.word	0x6520706c
 80071d8:	20746978 	.word	0x20746978
 80071dc:	00000000 	.word	0x00000000
 80071e0:	00000a0d 	.word	0x00000a0d
 80071e4:	00007325 	.word	0x00007325
 80071e8:	0a0d3f20 	.word	0x0a0d3f20
 80071ec:	00000000 	.word	0x00000000
 80071f0:	0000445e 	.word	0x0000445e
 80071f4:	6c756e28 	.word	0x6c756e28
 80071f8:	0000296c 	.word	0x0000296c
 80071fc:	636c6557 	.word	0x636c6557
 8007200:	20656d6f 	.word	0x20656d6f
 8007204:	73206f74 	.word	0x73206f74
 8007208:	0d216d74 	.word	0x0d216d74
 800720c:	0000000a 	.word	0x0000000a
 8007210:	00006325 	.word	0x00006325
	...
 8007220:	5f627375 	.word	0x5f627375
 8007224:	5f646c6c 	.word	0x5f646c6c
 8007228:	706d7570 	.word	0x706d7570
 800722c:	00000000 	.word	0x00000000
 8007230:	00000a0d 	.word	0x00000a0d
 8007234:	00000000 	.word	0x00000000
 8007238:	202a2a2a 	.word	0x202a2a2a
 800723c:	62696843 	.word	0x62696843
 8007240:	2f534f69 	.word	0x2f534f69
 8007244:	74205452 	.word	0x74205452
 8007248:	20747365 	.word	0x20747365
 800724c:	74697573 	.word	0x74697573
 8007250:	00000065 	.word	0x00000065
 8007254:	002a2a2a 	.word	0x002a2a2a
 8007258:	202a2a2a 	.word	0x202a2a2a
 800725c:	6e72654b 	.word	0x6e72654b
 8007260:	203a6c65 	.word	0x203a6c65
 8007264:	20202020 	.word	0x20202020
 8007268:	00002020 	.word	0x00002020
 800726c:	2e312e33 	.word	0x2e312e33
 8007270:	00000033 	.word	0x00000033
 8007274:	202a2a2a 	.word	0x202a2a2a
 8007278:	706d6f43 	.word	0x706d6f43
 800727c:	64656c69 	.word	0x64656c69
 8007280:	2020203a 	.word	0x2020203a
 8007284:	00002020 	.word	0x00002020
 8007288:	2072614d 	.word	0x2072614d
 800728c:	32203033 	.word	0x32203033
 8007290:	20363130 	.word	0x20363130
 8007294:	3331202d 	.word	0x3331202d
 8007298:	3a37313a 	.word	0x3a37313a
 800729c:	00003233 	.word	0x00003233
 80072a0:	202a2a2a 	.word	0x202a2a2a
 80072a4:	706d6f43 	.word	0x706d6f43
 80072a8:	72656c69 	.word	0x72656c69
 80072ac:	2020203a 	.word	0x2020203a
 80072b0:	00002020 	.word	0x00002020
 80072b4:	20434347 	.word	0x20434347
 80072b8:	2e382e34 	.word	0x2e382e34
 80072bc:	00000032 	.word	0x00000032
 80072c0:	202a2a2a 	.word	0x202a2a2a
 80072c4:	68637241 	.word	0x68637241
 80072c8:	63657469 	.word	0x63657469
 80072cc:	65727574 	.word	0x65727574
 80072d0:	0000203a 	.word	0x0000203a
 80072d4:	764d5241 	.word	0x764d5241
 80072d8:	4d2d4537 	.word	0x4d2d4537
 80072dc:	00000000 	.word	0x00000000
 80072e0:	202a2a2a 	.word	0x202a2a2a
 80072e4:	65726f43 	.word	0x65726f43
 80072e8:	72615620 	.word	0x72615620
 80072ec:	746e6169 	.word	0x746e6169
 80072f0:	0000203a 	.word	0x0000203a
 80072f4:	74726f43 	.word	0x74726f43
 80072f8:	4d2d7865 	.word	0x4d2d7865
 80072fc:	00000034 	.word	0x00000034
 8007300:	202a2a2a 	.word	0x202a2a2a
 8007304:	74726f50 	.word	0x74726f50
 8007308:	666e4920 	.word	0x666e4920
 800730c:	20203a6f 	.word	0x20203a6f
 8007310:	00002020 	.word	0x00002020
 8007314:	61766441 	.word	0x61766441
 8007318:	6465636e 	.word	0x6465636e
 800731c:	72656b20 	.word	0x72656b20
 8007320:	206c656e 	.word	0x206c656e
 8007324:	65646f6d 	.word	0x65646f6d
 8007328:	00000000 	.word	0x00000000
 800732c:	202a2a2a 	.word	0x202a2a2a
 8007330:	74616c50 	.word	0x74616c50
 8007334:	6d726f66 	.word	0x6d726f66
 8007338:	2020203a 	.word	0x2020203a
 800733c:	00002020 	.word	0x00002020
 8007340:	334d5453 	.word	0x334d5453
 8007344:	30344632 	.word	0x30344632
 8007348:	69482037 	.word	0x69482037
 800734c:	50206867 	.word	0x50206867
 8007350:	6f667265 	.word	0x6f667265
 8007354:	6e616d72 	.word	0x6e616d72
 8007358:	77206563 	.word	0x77206563
 800735c:	20687469 	.word	0x20687469
 8007360:	20505344 	.word	0x20505344
 8007364:	20646e61 	.word	0x20646e61
 8007368:	00555046 	.word	0x00555046
 800736c:	202a2a2a 	.word	0x202a2a2a
 8007370:	74736554 	.word	0x74736554
 8007374:	616f4220 	.word	0x616f4220
 8007378:	203a6472 	.word	0x203a6472
 800737c:	00002020 	.word	0x00002020
 8007380:	694d5453 	.word	0x694d5453
 8007384:	656f7263 	.word	0x656f7263
 8007388:	7463656c 	.word	0x7463656c
 800738c:	696e6f72 	.word	0x696e6f72
 8007390:	53207363 	.word	0x53207363
 8007394:	32334d54 	.word	0x32334d54
 8007398:	442d3446 	.word	0x442d3446
 800739c:	6f637369 	.word	0x6f637369
 80073a0:	79726576 	.word	0x79726576
 80073a4:	00000000 	.word	0x00000000
 80073a8:	202d2d2d 	.word	0x202d2d2d
 80073ac:	74736554 	.word	0x74736554
 80073b0:	73614320 	.word	0x73614320
 80073b4:	00002065 	.word	0x00002065
 80073b8:	0000002e 	.word	0x0000002e
 80073bc:	00002820 	.word	0x00002820
 80073c0:	00000029 	.word	0x00000029
 80073c4:	202d2d2d 	.word	0x202d2d2d
 80073c8:	75736552 	.word	0x75736552
 80073cc:	203a746c 	.word	0x203a746c
 80073d0:	4c494146 	.word	0x4c494146
 80073d4:	20455255 	.word	0x20455255
 80073d8:	00002328 	.word	0x00002328
 80073dc:	00005b20 	.word	0x00005b20
 80073e0:	0000295d 	.word	0x0000295d
 80073e4:	202d2d2d 	.word	0x202d2d2d
 80073e8:	75736552 	.word	0x75736552
 80073ec:	203a746c 	.word	0x203a746c
 80073f0:	43435553 	.word	0x43435553
 80073f4:	00535345 	.word	0x00535345
 80073f8:	616e6946 	.word	0x616e6946
 80073fc:	6572206c 	.word	0x6572206c
 8007400:	746c7573 	.word	0x746c7573
 8007404:	0000203a 	.word	0x0000203a
 8007408:	4c494146 	.word	0x4c494146
 800740c:	00455255 	.word	0x00455255
 8007410:	43435553 	.word	0x43435553
 8007414:	00535345 	.word	0x00535345
 8007418:	00000045 	.word	0x00000045
 800741c:	00000044 	.word	0x00000044
 8007420:	00000043 	.word	0x00000043
 8007424:	00000042 	.word	0x00000042
 8007428:	00000041 	.word	0x00000041
 800742c:	44434241 	.word	0x44434241
 8007430:	00000045 	.word	0x00000045
	...
 8007440:	656c6469 	.word	0x656c6469
 8007444:	00000000 	.word	0x00000000
 8007448:	31235653 	.word	0x31235653
 800744c:	00000000 	.word	0x00000000
 8007450:	32235653 	.word	0x32235653
 8007454:	00000000 	.word	0x00000000
 8007458:	33235653 	.word	0x33235653
 800745c:	00000000 	.word	0x00000000
 8007460:	34235653 	.word	0x34235653
 8007464:	00000000 	.word	0x00000000
 8007468:	35235653 	.word	0x35235653
 800746c:	00000000 	.word	0x00000000
 8007470:	36235653 	.word	0x36235653
 8007474:	00000000 	.word	0x00000000
 8007478:	37235653 	.word	0x37235653
 800747c:	00000000 	.word	0x00000000
 8007480:	38235653 	.word	0x38235653
 8007484:	00000000 	.word	0x00000000
 8007488:	39235653 	.word	0x39235653
 800748c:	00000000 	.word	0x00000000
 8007490:	31235653 	.word	0x31235653
 8007494:	00000030 	.word	0x00000030
 8007498:	31235653 	.word	0x31235653
 800749c:	00000031 	.word	0x00000031
 80074a0:	63617473 	.word	0x63617473
 80074a4:	766f206b 	.word	0x766f206b
 80074a8:	6c667265 	.word	0x6c667265
 80074ac:	0000776f 	.word	0x0000776f

080074b0 <ram_areas.4021>:
 80074b0:	08007c20 200016a8 200016a8 200016a8      |..... ... ... 
 80074c0:	08007c20 20000000 20000000 20000000      |..... ... ... 
 80074d0:	08007c20 2001c000 2001c000 2001c000      |..... ... ... 
 80074e0:	08007c20 00000000 00000000 00000000      |..............
 80074f0:	08007c20 10000000 10000000 10000000      |..............
 8007500:	08007c20 40024000 40024000 40024000      |...@.@.@.@.@.@
 8007510:	08007c20 00000000 00000000 00000000      |..............
 8007520:	08007c20 00000000 00000000 00000000      |..............

08007530 <__func__.6004.4488>:
 8007530:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

08007540 <__func__.6621.4997>:
 8007540:	54566863 65536f44 00004974 00000000     chVTDoSetI......

08007550 <__func__.6629.4998>:
 8007550:	54566863 65526f44 49746573 00000000     chVTDoResetI....

08007560 <__func__.6618.5244>:
 8007560:	63536863 61655268 00497964 00000000     chSchReadyI.....

08007570 <__func__.6646.5245>:
 8007570:	63536863 6b615768 53707565 00000000     chSchWakeupS....

08007580 <__func__.6630.5582>:
 8007580:	68546863 65724364 49657461 00000000     chThdCreateI....

08007590 <__func__.5915.5578>:
 8007590:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080075a0 <__func__.6089.5581>:
 80075a0:	68546863 656c5364 00537065 00000000     chThdSleepS.....

080075b0 <__func__.6674.5584>:
 80075b0:	68546863 69784564 00005374 00000000     chThdExitS......

080075c0 <__func__.6684.5586>:
 80075c0:	68546863 73755364 646e6570 00000053     chThdSuspendS...

080075d0 <__func__.6696.5588>:
 80075d0:	68546863 73655264 49656d75 00000000     chThdResumeI....

080075e0 <__func__.6101.5580>:
 80075e0:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
 80075f0:	00497478 00000000 00000000 00000000     xtI.............

08007600 <ch_debug>:
 8007600:	6e69616d 18431600 08600404 1814100c     main..C...`.....
 8007610:	2221201c 00000000 00000000 00000000     . !"............

08007620 <__func__.6613.6880>:
 8007620:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

08007630 <__func__.6638.7378>:
 8007630:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
 8007640:	49736761 00000000 00000000 00000000     agsI............

08007650 <__func__.6655.7377>:
 8007650:	76456863 67695374 496c616e 00000000     chEvtSignalI....

08007660 <__func__.5915.8280>:
 8007660:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08007670 <__func__.7427.8762>:
 8007670:	74537473 41747261 6d72616c 00000000     stStartAlarm....

08007680 <__func__.7434.8763>:
 8007680:	65537473 616c4174 00006d72 00000000     stSetAlarm......

08007690 <__func__.7761.9101>:
 8007690:	4f716269 63656a62 696e4974 00000074     ibqObjectInit...

080076a0 <__func__.7772.9102>:
 80076a0:	50716269 4674736f 426c6c75 65666675     ibqPostFullBuffe
 80076b0:	00004972 00000000 00000000 00000000     rI..............

080076c0 <__func__.6247.9100>:
 80076c0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080076d0 <__func__.7786.9103>:
 80076d0:	47716269 75467465 75426c6c 72656666     ibqGetFullBuffer
 80076e0:	656d6954 5374756f 00000000 00000000     TimeoutS........

080076f0 <__func__.7793.9104>:
 80076f0:	52716269 61656c65 6d456573 42797470     ibqReleaseEmptyB
 8007700:	65666675 00005372 00000000 00000000     ufferS..........

08007710 <__func__.7819.9105>:
 8007710:	4f71626f 63656a62 696e4974 00000074     obqObjectInit...

08007720 <__func__.7830.9106>:
 8007720:	5271626f 61656c65 6d456573 42797470     obqReleaseEmptyB
 8007730:	65666675 00004972 00000000 00000000     ufferI..........

08007740 <__func__.7844.9107>:
 8007740:	4771626f 6d457465 42797470 65666675     obqGetEmptyBuffe
 8007750:	6d695472 74756f65 00000053 00000000     rTimeoutS.......

08007760 <__func__.7853.9108>:
 8007760:	5071626f 4674736f 426c6c75 65666675     obqPostFullBuffe
 8007770:	00005372 00000000 00000000 00000000     rS..............

08007780 <vmt.9713>:
 8007780:	08002df1 08002e31 08002e71 08002eb1     .-..1...q.......
 8007790:	08002ef1 08002f31 08002f71 08002fb1     ....1/..q/.../..

080077a0 <__func__.7483.9714>:
 80077a0:	53756473 74726174 00000000 00000000     sduStart........

080077b0 <__func__.5915.9712>:
 80077b0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

080077c0 <__func__.7496.9716>:
 80077c0:	43756473 69666e6f 65727567 6b6f6f48     sduConfigureHook
 80077d0:	00000049 00000000 00000000 00000000     I...............

080077e0 <__func__.7509.9724>:
 80077e0:	53756473 6f48464f 00496b6f 00000000     sduSOFHookI.....

080077f0 <zero_status.10187>:
	...

08007800 <active_status.10189>:
	...

08007810 <halted_status.10188>:
 8007810:	00000001 00000000 00000000 00000000     ................

08007820 <__func__.7808.10190>:
 8007820:	53627375 74726174 00000000 00000000     usbStart........

08007830 <__func__.6247.10186>:
 8007830:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08007840 <__func__.7825.10192>:
 8007840:	49627375 4574696e 6f70646e 49746e69     usbInitEndpointI
	...

08007860 <__func__.7841.10194>:
 8007860:	53627375 74726174 65636552 49657669     usbStartReceiveI
	...

08007880 <__func__.7849.10195>:
 8007880:	53627375 74726174 6e617254 74696d73     usbStartTransmit
 8007890:	00000049 00000000 00000000 00000000     I...............

080078a0 <__func__.7889.10198>:
 80078a0:	6273755f 3070655f 00006e69 00000000     _usb_ep0in......

080078b0 <__func__.7903.10199>:
 80078b0:	6273755f 3070655f 0074756f 00000000     _usb_ep0out.....

080078c0 <ep0config.11060>:
 80078c0:	00000000 08003e51 08001871 08001981     ....Q>..q.......
 80078d0:	00400040 200011d8 200011d8 00000001     @.@.... ... ....
 80078e0:	200011e8 00000000 00000000 00000000     ... ............

080078f0 <fsparams.11057>:
 80078f0:	00000080 00000140 00000003 00000000     ....@...........

08007900 <hsparams.11059>:
 8007900:	00000100 00000400 00000005 00000000     ................

08007910 <__func__.7804.11054>:
 8007910:	5f67746f 5f6d6172 6f6c6c61 00000063     otg_ram_alloc...

08007920 <__func__.7810.11055>:
 8007920:	5f67746f 6f666966 6972775f 665f6574     otg_fifo_write_f
 8007930:	5f6d6f72 66667562 00007265 00000000     rom_buffer......

08007940 <__func__.6417.11052>:
 8007940:	68546863 61745364 00497472 00000000     chThdStartI.....

08007950 <__func__.6247.11053>:
 8007950:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

08007960 <pal_default_config>:
 8007960:	2aa0aa00 00000000 ffffabff 40010054     ...*........T..@
 8007970:	0000ffff 55560000 000aaa00 00082080     ......VU..... ..
 8007980:	00000240 ffffffff 55514515 0000ffff     @........EQU....
 8007990:	04000000 00000040 02208001 00000000     ....@..... .....
 80079a0:	ffffffff 54451554 0000ffff 60000000     ....T.ET.......`
 80079b0:	00060600 55000100 00000000 ffffffff     .......U........
 80079c0:	00555055 00000fff 00000000 00000000     UPU.............
 80079d0:	00000040 00000000 ffffffff 00000000     @...............
 80079e0:	0000ffff 00000000 00000000 00000000     ................
 80079f0:	00000000 ffffffff 00000000 0000ffff     ................
	...
 8007a10:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8007a2c:	ffffffff 00000000 0000ffff 00000000     ................
	...
 8007a48:	ffffffff 00000000 0000ffff 00000000     ................
	...

08007a60 <vcom_device_descriptor_data.15042.5075>:
 8007a60:	01100112 40000002 57400483 02010200     .......@..@W....
 8007a70:	00000103 00000000 00000000 00000000     ................

08007a80 <vcom_device_descriptor.15041.5074>:
 8007a80:	00000012 08007a60 00000000 00000000     ....`z..........

08007a90 <vcom_configuration_descriptor_data.15044.5077>:
 8007a90:	00430209 c0000102 00040932 02020100     ..C.....2.......
 8007aa0:	24050001 05011000 01000124 02022404     ...$....$....$..
 8007ab0:	00062405 82050701 ff000803 00010409     .$..............
 8007ac0:	00000a02 01050700 00004002 02810507     .........@......
 8007ad0:	00000040 00000000 00000000 00000000     @...............

08007ae0 <vcom_configuration_descriptor.15043.5076>:
 8007ae0:	00000043 08007a90 00000000 00000000     C....z..........

08007af0 <vcom_string0.15046.5079>:
 8007af0:	04090304 00000000 00000000 00000000     ................

08007b00 <vcom_string1.15047.5080>:
 8007b00:	00530326 004d0054 00630069 006f0072     &.S.T.M.i.c.r.o.
 8007b10:	006c0065 00630065 00720074 006e006f     e.l.e.c.t.r.o.n.
 8007b20:	00630069 00000073 00000000 00000000     i.c.s...........

08007b30 <vcom_string2.15048.5081>:
 8007b30:	00430338 00690068 00690062 0053004f     8.C.h.i.b.i.O.S.
 8007b40:	0052002f 00200054 00690056 00740072     /.R.T. .V.i.r.t.
 8007b50:	00610075 0020006c 004f0043 0020004d     u.a.l. .C.O.M. .
 8007b60:	006f0050 00740072 00000000 00000000     P.o.r.t.........

08007b70 <vcom_string3.15049.5082>:
 8007b70:	00330308 00330031 00000000 00000000     ..3.1.3.........

08007b80 <vcom_strings.15045.5078>:
 8007b80:	00000004 08007af0 00000026 08007b00     .....z..&....{..
 8007b90:	00000038 08007b30 00000008 08007b70     8...0{......p{..

08007ba0 <ep1config.15050.5069>:
 8007ba0:	00000002 00000000 080033f1 080034d1     .........3...4..
 8007bb0:	00400040 20001678 20001688 00000002     @.@.x.. ... ....
	...

08007bd0 <ep2config.15053.5072>:
 8007bd0:	00000003 00000000 08003571 00000000     ........q5......
 8007be0:	00000010 20001698 00000000 00000001     ....... ........
	...

08007c00 <usbcfg.5068>:
 8007c00:	08000a71 08000a11 080032d1 08000b01     q........2......

08007c10 <serusbcfg.5066>:
 8007c10:	20000e08 00020101                       ... ....
